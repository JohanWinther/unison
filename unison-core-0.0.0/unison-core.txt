-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-core
@version 0.0.0

module U.Codebase.HashTags
newtype BranchHash
BranchHash :: Hash -> BranchHash
[unBranchHash] :: BranchHash -> Hash

-- | Represents a hash of a causal containing values of the provided type.
newtype CausalHash
CausalHash :: Hash -> CausalHash
[unCausalHash] :: CausalHash -> Hash
newtype PatchHash
PatchHash :: Hash -> PatchHash
[unPatchHash] :: PatchHash -> Hash
instance GHC.Classes.Ord U.Codebase.HashTags.BranchHash
instance GHC.Classes.Eq U.Codebase.HashTags.BranchHash
instance GHC.Classes.Ord U.Codebase.HashTags.CausalHash
instance GHC.Classes.Eq U.Codebase.HashTags.CausalHash
instance GHC.Classes.Ord U.Codebase.HashTags.PatchHash
instance GHC.Classes.Eq U.Codebase.HashTags.PatchHash
instance GHC.Show.Show U.Codebase.HashTags.PatchHash
instance GHC.Show.Show U.Codebase.HashTags.CausalHash
instance GHC.Show.Show U.Codebase.HashTags.BranchHash

module U.Core.ABT.Var

-- | A class for avoiding accidental variable capture
--   
--   <ul>
--   <li>`Set.notMember (freshIn vs v) vs`: <a>freshIn</a> returns a
--   variable not used in the <a>Set</a></li>
--   </ul>
class (Ord v) => Var v
freshIn :: Var v => Set v -> v -> v

module U.Core.ABT
data ABT f v r
Var :: v -> ABT f v r
Cycle :: r -> ABT f v r
Abs :: v -> r -> ABT f v r
Tm :: f r -> ABT f v r

-- | At each level in the tree, we store the set of free variables and a
--   value of type <tt>a</tt>. Variables are of type <tt>v</tt>.
data Term f v a
Term :: Set v -> a -> ABT f v (Term f v a) -> Term f v a
[freeVars] :: Term f v a -> Set v
[annotation] :: Term f v a -> a
[out] :: Term f v a -> ABT f v (Term f v a)
amap :: Functor f => (a -> a') -> Term f v a -> Term f v a'
vmap :: (Functor f, Foldable f, Ord v') => (v -> v') -> Term f v a -> Term f v' a
cata :: Functor f => (a -> ABT f v x -> x) -> Term f v a -> x
para :: Functor f => (a -> ABT f v (Term f v a, x) -> x) -> Term f v a -> x
transform :: (Ord v, Foldable g, Functor g) => (forall a. f a -> g a) -> Term f v a -> Term g v a
transformM :: (Ord v, Monad m, Traversable g) => (forall a. f a -> m (g a)) -> Term f v a -> m (Term g v a)
abs :: Ord v => a -> v -> Term f v a -> Term f v a
var :: a -> v -> Term f v a
cycle :: a -> Term f v a -> Term f v a
tm :: (Foldable f, Ord v) => a -> f (Term f v a) -> Term f v a

-- | `visit f t` applies an effectful function to each subtree of
--   <tt>t</tt> and sequences the results. When <tt>f</tt> returns
--   <a>Nothing</a>, <a>visit</a> descends into the children of the current
--   subtree. When <tt>f</tt> returns `Just t2`, <a>visit</a> replaces the
--   current subtree with <tt>t2</tt>. Thus: `visit (const Nothing) t ==
--   pure t` and `visit (const (Just (pure t2))) t == pure t2`
visit :: (Traversable f, Applicative g, Ord v) => (Term f v a -> Maybe (g (Term f v a))) -> Term f v a -> g (Term f v a)

-- | Apply an effectful function to an ABT tree top down, sequencing the
--   results.
visit' :: (Traversable f, Monad g, Ord v) => (f (Term f v a) -> g (f (Term f v a))) -> Term f v a -> g (Term f v a)

-- | Apply an effectful function to an ABT tree top down, sequencing the
--   results.
visit_ :: (Traversable f, Applicative g, Ord v) => (f (Term f v a) -> g ()) -> Term f v a -> g (Term f v a)

-- | <a>visit</a> specialized to the <a>Identity</a> effect.
visitPure :: (Traversable f, Ord v) => (Term f v a -> Maybe (Term f v a)) -> Term f v a -> Term f v a
foreachSubterm :: (Traversable f, Applicative g) => (Term f v a -> g b) -> Term f v a -> g [b]
subterms :: (Ord v, Traversable f) => Term f v a -> [Term f v a]
pattern Var' :: v -> Term f v a
pattern Cycle' :: [v] -> Term f v a -> Term f v a
pattern AbsN' :: [v] -> Term f v a -> Term f v a
pattern Tm' :: f (Term f v a) -> Term f v a
unabs :: Term f v a -> ([v], Term f v a)

-- | Produce a variable which is free in both terms
freshInBoth :: Var v => Term f v a -> Term f v a -> v -> v
substsInheritAnnotation :: (Foldable f, Functor f, Var v) => [(v, Term f v b)] -> Term f v a -> Term f v a
substInheritAnnotation :: (Foldable f, Functor f, Var v) => v -> Term f v b -> Term f v a -> Term f v a
subst' :: (Foldable f, Functor f, Var v) => (a -> Term f v a) -> v -> Set v -> Term f v a -> Term f v a

-- | renames <tt>old</tt> to <tt>new</tt> in the given term, ignoring
--   subtrees that bind <tt>old</tt>
rename :: (Foldable f, Functor f, Var v) => v -> v -> Term f v a -> Term f v a
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (U.Core.ABT.ABT f v)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (U.Core.ABT.ABT f v)
instance GHC.Base.Functor f => GHC.Base.Functor (U.Core.ABT.ABT f v)
instance (GHC.Show.Show v, GHC.Show.Show r, GHC.Show.Show (f r)) => GHC.Show.Show (U.Core.ABT.ABT f v r)
instance (GHC.Classes.Eq v, GHC.Classes.Eq r, GHC.Classes.Eq (f r)) => GHC.Classes.Eq (U.Core.ABT.ABT f v r)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (U.Core.ABT.Term f v)
instance GHC.Generics.Generic (U.Core.ABT.Term f v a)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (U.Core.ABT.Term f v)
instance GHC.Base.Functor f => GHC.Base.Functor (U.Core.ABT.Term f v)
instance (Data.Foldable.Foldable f, GHC.Base.Functor f, forall a1. GHC.Classes.Eq a1 => GHC.Classes.Eq (f a1), U.Core.ABT.Var.Var v) => GHC.Classes.Eq (U.Core.ABT.Term f v a)
instance (forall a1. GHC.Classes.Eq a1 => GHC.Classes.Eq (f a1), Data.Foldable.Foldable f, GHC.Base.Functor f, forall a1. GHC.Classes.Ord a1 => GHC.Classes.Ord (f a1), U.Core.ABT.Var.Var v) => GHC.Classes.Ord (U.Core.ABT.Term f v a)
instance (forall a1. GHC.Show.Show a1 => GHC.Show.Show (f a1), GHC.Show.Show v) => GHC.Show.Show (U.Core.ABT.Term f v a)


-- | Project-related types.
--   
--   A larger API, including orphan instances for parsing from <a>Text</a>,
--   is available in <a>Unison.Project</a>. Here, we just define the types,
--   which are shared among the low-level database layer (which assumes
--   without verifying that project names and such are syntactically valid)
--   and the higher-level project manipulation exposed by UCM.
module Unison.Core.Project

-- | The name of a project.
newtype ProjectName
UnsafeProjectName :: Text -> ProjectName

-- | The name of a branch of a project.
newtype ProjectBranchName
UnsafeProjectBranchName :: Text -> ProjectBranchName

-- | A generic data structure that contains information about a project and
--   a branch in that project.
data ProjectAndBranch a b
ProjectAndBranch :: a -> b -> ProjectAndBranch a b
[project] :: ProjectAndBranch a b -> a
[branch] :: ProjectAndBranch a b -> b
instance GHC.Show.Show Unison.Core.Project.ProjectName
instance GHC.Classes.Ord Unison.Core.Project.ProjectName
instance GHC.Classes.Eq Unison.Core.Project.ProjectName
instance GHC.Show.Show Unison.Core.Project.ProjectBranchName
instance GHC.Classes.Ord Unison.Core.Project.ProjectBranchName
instance GHC.Classes.Eq Unison.Core.Project.ProjectBranchName
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Unison.Core.Project.ProjectAndBranch a b)
instance GHC.Generics.Generic (Unison.Core.Project.ProjectAndBranch a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Unison.Core.Project.ProjectAndBranch a b)

module Unison.Util.Alphabetical
class (Eq n) => Alphabetical n
compareAlphabetical :: Alphabetical n => n -> n -> Ordering
sortAlphabetically :: Alphabetical a => [a] -> [a]
sortAlphabeticallyOn :: Alphabetical a => (b -> a) -> [b] -> [b]
newtype OrderAlphabetically a
OrderAlphabetically :: a -> OrderAlphabetically a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Util.Alphabetical.OrderAlphabetically a)
instance Data.Foldable.Foldable Unison.Util.Alphabetical.OrderAlphabetically
instance Data.Traversable.Traversable Unison.Util.Alphabetical.OrderAlphabetically
instance GHC.Base.Functor Unison.Util.Alphabetical.OrderAlphabetically
instance (GHC.Classes.Eq a, Unison.Util.Alphabetical.Alphabetical a) => GHC.Classes.Ord (Unison.Util.Alphabetical.OrderAlphabetically a)
instance Unison.Util.Alphabetical.Alphabetical a => Unison.Util.Alphabetical.Alphabetical [a]
instance Unison.Util.Alphabetical.Alphabetical a => Unison.Util.Alphabetical.Alphabetical (GHC.Base.NonEmpty a)
instance Unison.Util.Alphabetical.Alphabetical a => Unison.Util.Alphabetical.Alphabetical (GHC.Maybe.Maybe a)
instance Unison.Util.Alphabetical.Alphabetical Data.Text.Internal.Text

module Unison.NameSegment
newtype NameSegment
NameSegment :: Text -> NameSegment
[toText] :: NameSegment -> Text
segments' :: Text -> [Text]
reverseSegments' :: Text -> [Text]
isEmpty :: NameSegment -> Bool
isPrefixOf :: NameSegment -> NameSegment -> Bool
toString :: NameSegment -> String
toTextBuilder :: NameSegment -> Builder
instance GHC.Show.Show Unison.NameSegment.NameSegment
instance GHC.Generics.Generic Unison.NameSegment.NameSegment
instance GHC.Classes.Ord Unison.NameSegment.NameSegment
instance GHC.Classes.Eq Unison.NameSegment.NameSegment
instance Unison.Util.Alphabetical.Alphabetical Unison.NameSegment.NameSegment
instance Data.String.IsString Unison.NameSegment.NameSegment

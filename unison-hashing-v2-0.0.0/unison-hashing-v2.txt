-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-hashing-v2
@version 0.0.0

module Unison.Hashing.V2.Tokenizable

-- | Tokenizable converts a value into a set of hashing tokens which will
--   later be accumulated into a Hash. Be very careful when adding or
--   altering instances of this typeclass, changing the hash of a value is
--   a major breaking change and requires a complete codebase migration.
--   
--   If you simply want to provide a convenience instance for a type which
--   wraps some Hashable type, write an instance of <tt>Hashable</tt> which
--   calls through to the inner instance instead.
--   
--   E.g. If I want to be able to hash a <tt>TaggedBranch</tt> using its
--   Branch0 hashable instance:
--   
--   @@ data TaggedBranch = TaggedBranch String Branch
--   
--   instance Hashable TaggedBranch where hash (TaggedBranch _ b) = hash b
--   @@
class Tokenizable t
tokens :: (Tokenizable t, Accumulate h) => t -> [Token h]
class Accumulate h
accumulate :: Accumulate h => [Token h] -> h
fromBytes :: Accumulate h => ByteString -> h
toBytes :: Accumulate h => h -> ByteString
class Hashable1 f

-- | Produce a hash for an `f a`, given a hashing function for <tt>a</tt>.
--   If there is a notion of order-independence in some aspect of a subterm
--   of <tt>f</tt>, then the first argument (`hashUnordered :: [a] -&gt;
--   ([h], a -&gt; h)`) should be used to impose an order, and then apply
--   that order in further hashing. Otherwise the second argument (`hash ::
--   a -&gt; h`) should be used.
--   
--   Example 1: A simple functor with no unordered components. Hashable1
--   instance just uses <tt>hash</tt>:
--   
--   data T a = One a | Two a a deriving Functor
--   
--   instance Hashable1 T where hash1 _ hash t = case t of One a -&gt;
--   accumulate [Tag 0, Hashed (hash a)] Two a a2 -&gt; accumulate [Tag 1,
--   Hashed (hash a), Hashed (hash a2)]
--   
--   Example 2: A functor with unordered components. For hashing, we need
--   to pick a canonical ordering of the unordered components, so we use
--   <tt>hashUnordered</tt>:
--   
--   data U a = U { unordered :: [a], uno :: a, dos :: a } deriving Functor
--   
--   instance Hashable1 U where hash1 hashUnordered _ (U unordered uno dos)
--   = let (hs, hash) = hashUnordered unordered in accumulate $ map Hashed
--   hs ++ [Hashed (hash uno), Hashed (hash dos)]
hash1 :: (Hashable1 f, Ord h, Accumulate h) => ([a] -> ([h], a -> h)) -> (a -> h) -> f a -> h
data Token h
Tag :: !Word8 -> Token h
Bytes :: !ByteString -> Token h
Int :: !Int64 -> Token h
Text :: !Text -> Token h
Double :: !Double -> Token h
Hashed :: !h -> Token h
Nat :: !Word64 -> Token h

-- | Tokenize then accumulate a type into a Hash.
hashTokenizable :: (Tokenizable t, Accumulate h) => t -> h
accumulateToken :: (Accumulate h, Tokenizable t) => t -> Token h
instance Unison.Hashing.V2.Tokenizable.Tokenizable a => Unison.Hashing.V2.Tokenizable.Tokenizable [a]
instance (Unison.Hashing.V2.Tokenizable.Tokenizable a, Unison.Hashing.V2.Tokenizable.Tokenizable b) => Unison.Hashing.V2.Tokenizable.Tokenizable (a, b)
instance Unison.Hashing.V2.Tokenizable.Tokenizable a => Unison.Hashing.V2.Tokenizable.Tokenizable (Data.Set.Internal.Set a)
instance (Unison.Hashing.V2.Tokenizable.Tokenizable k, Unison.Hashing.V2.Tokenizable.Tokenizable v) => Unison.Hashing.V2.Tokenizable.Tokenizable (Data.Map.Internal.Map k v)
instance (Unison.Hashing.V2.Tokenizable.Tokenizable a, Unison.Hashing.V2.Tokenizable.Tokenizable b) => Unison.Hashing.V2.Tokenizable.Tokenizable (Unison.Util.Relation.Relation a b)
instance (Unison.Hashing.V2.Tokenizable.Tokenizable d1, Unison.Hashing.V2.Tokenizable.Tokenizable d2, Unison.Hashing.V2.Tokenizable.Tokenizable d3) => Unison.Hashing.V2.Tokenizable.Tokenizable (Unison.Util.Relation3.Relation3 d1 d2 d3)
instance (Unison.Hashing.V2.Tokenizable.Tokenizable d1, Unison.Hashing.V2.Tokenizable.Tokenizable d2, Unison.Hashing.V2.Tokenizable.Tokenizable d3, Unison.Hashing.V2.Tokenizable.Tokenizable d4) => Unison.Hashing.V2.Tokenizable.Tokenizable (Unison.Util.Relation4.Relation4 d1 d2 d3 d4)
instance Unison.Hashing.V2.Tokenizable.Tokenizable ()
instance Unison.Hashing.V2.Tokenizable.Tokenizable GHC.Types.Double
instance Unison.Hashing.V2.Tokenizable.Tokenizable Data.Text.Internal.Text
instance Unison.Hashing.V2.Tokenizable.Tokenizable GHC.Types.Char
instance Unison.Hashing.V2.Tokenizable.Tokenizable Data.ByteString.Internal.ByteString
instance Unison.Hashing.V2.Tokenizable.Tokenizable GHC.Word.Word64
instance Unison.Hashing.V2.Tokenizable.Tokenizable GHC.Int.Int64
instance Unison.Hashing.V2.Tokenizable.Tokenizable GHC.Types.Bool
instance Unison.Hashing.V2.Tokenizable.Tokenizable U.Util.Hash.Hash
instance Unison.Hashing.V2.Tokenizable.Accumulate U.Util.Hash.Hash

module Unison.Hashing.V2.Reference

-- | Either a builtin or a user defined (hashed) top-level declaration.
--   
--   Used for both terms and types. Doesn't distinguish between them.
--   
--   Other used defined things like local variables don't get
--   <tt>Reference</tt>s.
data Reference
pattern Builtin :: () => Text -> Reference
pattern Derived :: Hash -> Pos -> Reference
pattern DerivedId :: () => Id -> Reference

-- | <tt>Pos</tt> is a position into a cycle of size <tt>Size</tt>, as
--   cycles are hashed together.
data Id
Id :: Hash -> Pos -> Id
components :: [(Hash, [k])] -> [(k, Id)]
instance GHC.Classes.Ord Unison.Hashing.V2.Reference.Id
instance GHC.Classes.Eq Unison.Hashing.V2.Reference.Id
instance GHC.Classes.Ord Unison.Hashing.V2.Reference.Reference
instance GHC.Classes.Eq Unison.Hashing.V2.Reference.Reference
instance GHC.Show.Show Unison.Hashing.V2.Reference.Id
instance GHC.Show.Show Unison.Hashing.V2.Reference.Reference
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.Reference.Reference

module Unison.Hashing.V2.Referent
data Referent
pattern Ref :: () => Reference -> Referent
pattern Con :: () => Reference -> ConstructorId -> Referent
type ConstructorId = Word64
instance GHC.Classes.Eq Unison.Hashing.V2.Referent.Referent
instance GHC.Classes.Ord Unison.Hashing.V2.Referent.Referent
instance GHC.Show.Show Unison.Hashing.V2.Referent.Referent
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.Referent.Referent

module Unison.Hashing.V2.TermEdit
data TermEdit
Replace :: Referent -> TermEdit
Deprecate :: TermEdit
instance GHC.Show.Show Unison.Hashing.V2.TermEdit.TermEdit
instance GHC.Classes.Ord Unison.Hashing.V2.TermEdit.TermEdit
instance GHC.Classes.Eq Unison.Hashing.V2.TermEdit.TermEdit
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.TermEdit.TermEdit

module Unison.Hashing.V2.Kind
data Kind
Star :: Kind
Arrow :: Kind -> Kind -> Kind
instance GHC.Generics.Generic Unison.Hashing.V2.Kind.Kind
instance GHC.Show.Show Unison.Hashing.V2.Kind.Kind
instance GHC.Read.Read Unison.Hashing.V2.Kind.Kind
instance GHC.Classes.Ord Unison.Hashing.V2.Kind.Kind
instance GHC.Classes.Eq Unison.Hashing.V2.Kind.Kind
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.Kind.Kind

module Unison.Hashing.V2.Hashable

-- | This typeclass provides a mechanism for obtaining a content-based hash
--   for Unison types &amp; terms. Be wary that Unison requires that these
--   hashes be deterministic, any change to a Hashable instance requires a
--   full codebase migration and should not be taken lightly.
class Hashable t
hash :: Hashable t => t -> Hash
hashFor :: Hashable t => t -> HashFor t

-- | A hash tagged with the type it's a hash of, useful for maintaining
--   type safety guarantees.
newtype HashFor t
HashFor :: Hash -> HashFor t
[genericHash] :: HashFor t -> Hash
instance Unison.Hashing.V2.Tokenizable.Tokenizable a => Unison.Hashing.V2.Hashable.Hashable [a]
instance Unison.Hashing.V2.Tokenizable.Tokenizable a => Unison.Hashing.V2.Hashable.Hashable (Data.Set.Internal.Set a)
instance Unison.Hashing.V2.Hashable.Hashable GHC.Int.Int64

module Unison.Hashing.V2.Causal
data Causal
Causal :: Hash -> Set Hash -> Causal
[branchHash] :: Causal -> Hash
[parents] :: Causal -> Set Hash
hashCausal :: Causal -> Hash
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.Causal.Causal

module Unison.Hashing.V2.Branch
newtype NameSegment
NameSegment :: Text -> NameSegment
data Raw
Raw :: Map NameSegment (Map Referent MdValues) -> Map NameSegment (Map Reference MdValues) -> Map NameSegment Hash -> Map NameSegment Hash -> Raw
[terms] :: Raw -> Map NameSegment (Map Referent MdValues)
[types] :: Raw -> Map NameSegment (Map Reference MdValues)
[patches] :: Raw -> Map NameSegment Hash
[children] :: Raw -> Map NameSegment Hash
newtype MdValues
MdValues :: Set MetadataValue -> MdValues
hashBranch :: Raw -> Hash
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.Branch.MdValues
instance GHC.Show.Show Unison.Hashing.V2.Branch.MdValues
instance GHC.Classes.Ord Unison.Hashing.V2.Branch.MdValues
instance GHC.Classes.Eq Unison.Hashing.V2.Branch.MdValues
instance GHC.Show.Show Unison.Hashing.V2.Branch.NameSegment
instance GHC.Classes.Ord Unison.Hashing.V2.Branch.NameSegment
instance GHC.Classes.Eq Unison.Hashing.V2.Branch.NameSegment
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.Branch.Raw
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.Branch.NameSegment

module Unison.Hashing.V2.ABT

-- | At each level in the tree, we store the set of free variables and a
--   value of type <tt>a</tt>. Variables are of type <tt>v</tt>.
data Term (f :: Type -> Type) v a

-- | We ignore annotations in the <a>Term</a>, as these should never affect
--   the meaning of the term.
hash :: forall f v a h. (Functor f, Hashable1 f, Eq v, Show v, Ord h, Accumulate h) => Term f v a -> h
hashComponents :: (Functor f, Hashable1 f, Foldable f, Eq v, Show v, Var v, Ord h, Accumulate h) => (h -> Word64 -> Term f v ()) -> Map v (Term f v a) -> [(h, [(v, Term f v a)])]

module Unison.Hashing.V2.Reference.Util
hashComponents :: (Functor f, Hashable1 f, Foldable f, Eq v, Show v, Var v) => (Id -> Term f v ()) -> Map v (Term f v a) -> Map v (Id, Term f v a)

module Unison.Hashing.V2.Type

-- | Types are represented as ABTs over the base functor F, with variables
--   in <tt>v</tt>
type Type v a = Term F v a

-- | Base functor for types in the Unison language
data F a
Ref :: Reference -> F a
Arrow :: a -> a -> F a
Ann :: a -> Kind -> F a
App :: a -> a -> F a
Effect :: a -> a -> F a
Effects :: [a] -> F a
Forall :: a -> F a
IntroOuter :: a -> F a
bindExternal :: Var v => [(v, Reference)] -> Type v a -> Type v a
bindReferences :: Var v => (v -> Name) -> Set v -> Map Name Reference -> Type v a -> ResolutionResult v a (Type v a)
toReference :: (Ord v, Show v) => Type v a -> Reference
toReferenceMentions :: (Ord v, Show v) => Type v a -> Set Reference
booleanRef :: Reference
charRef :: Reference
effectRef :: Reference
floatRef :: Reference
intRef :: Reference
listRef :: Reference
natRef :: Reference
textRef :: Reference
instance Data.Traversable.Traversable Unison.Hashing.V2.Type.F
instance GHC.Base.Functor Unison.Hashing.V2.Type.F
instance Data.Foldable.Foldable Unison.Hashing.V2.Type.F
instance Unison.Hashing.V2.Tokenizable.Hashable1 Unison.Hashing.V2.Type.F

module Unison.Hashing.V2.Pattern
data Pattern loc
Unbound :: loc -> Pattern loc
Var :: loc -> Pattern loc
Boolean :: loc -> !Bool -> Pattern loc
Int :: loc -> !Int64 -> Pattern loc
Nat :: loc -> !Word64 -> Pattern loc
Float :: loc -> !Double -> Pattern loc
Text :: loc -> !Text -> Pattern loc
Char :: loc -> !Char -> Pattern loc
Constructor :: loc -> !Reference -> !ConstructorId -> [Pattern loc] -> Pattern loc
As :: loc -> Pattern loc -> Pattern loc
EffectPure :: loc -> Pattern loc -> Pattern loc
EffectBind :: loc -> !Reference -> !ConstructorId -> [Pattern loc] -> Pattern loc -> Pattern loc
SequenceLiteral :: loc -> [Pattern loc] -> Pattern loc
SequenceOp :: loc -> Pattern loc -> !SeqOp -> Pattern loc -> Pattern loc
data SeqOp
Cons :: SeqOp
Snoc :: SeqOp
Concat :: SeqOp
application :: Pattern loc -> Bool
loc :: Pattern loc -> loc
setLoc :: Pattern loc -> loc -> Pattern loc
foldMap' :: Monoid m => (Pattern loc -> m) -> Pattern loc -> m
generalizedDependencies :: Ord r => (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> Pattern loc -> Set r
instance GHC.Generics.Generic Unison.Hashing.V2.Pattern.SeqOp
instance GHC.Classes.Ord Unison.Hashing.V2.Pattern.SeqOp
instance GHC.Show.Show Unison.Hashing.V2.Pattern.SeqOp
instance GHC.Classes.Eq Unison.Hashing.V2.Pattern.SeqOp
instance Data.Traversable.Traversable Unison.Hashing.V2.Pattern.Pattern
instance Data.Foldable.Foldable Unison.Hashing.V2.Pattern.Pattern
instance GHC.Base.Functor Unison.Hashing.V2.Pattern.Pattern
instance GHC.Generics.Generic (Unison.Hashing.V2.Pattern.Pattern loc)
instance GHC.Classes.Ord loc => GHC.Classes.Ord (Unison.Hashing.V2.Pattern.Pattern loc)
instance GHC.Show.Show (Unison.Hashing.V2.Pattern.Pattern loc)
instance Unison.Hashing.V2.Tokenizable.Tokenizable (Unison.Hashing.V2.Pattern.Pattern p)
instance GHC.Classes.Eq (Unison.Hashing.V2.Pattern.Pattern loc)
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.Pattern.SeqOp

module Unison.Hashing.V2.Term

-- | Like `Term v`, but with an annotation of type <tt>a</tt> at every
--   level in the tree
type Term v a = Term2 v a a v a

-- | Base functor for terms in the Unison language We need <tt>typeVar</tt>
--   because the term and type variables may differ.
data F typeVar typeAnn patternAnn a
Int :: Int64 -> F typeVar typeAnn patternAnn a
Nat :: Word64 -> F typeVar typeAnn patternAnn a
Float :: Double -> F typeVar typeAnn patternAnn a
Boolean :: Bool -> F typeVar typeAnn patternAnn a
Text :: Text -> F typeVar typeAnn patternAnn a
Char :: Char -> F typeVar typeAnn patternAnn a
Blank :: Blank typeAnn -> F typeVar typeAnn patternAnn a
Ref :: Reference -> F typeVar typeAnn patternAnn a
Constructor :: Reference -> ConstructorId -> F typeVar typeAnn patternAnn a
Request :: Reference -> ConstructorId -> F typeVar typeAnn patternAnn a
Handle :: a -> a -> F typeVar typeAnn patternAnn a
App :: a -> a -> F typeVar typeAnn patternAnn a
Ann :: a -> Type typeVar typeAnn -> F typeVar typeAnn patternAnn a
List :: Seq a -> F typeVar typeAnn patternAnn a
If :: a -> a -> a -> F typeVar typeAnn patternAnn a
And :: a -> a -> F typeVar typeAnn patternAnn a
Or :: a -> a -> F typeVar typeAnn patternAnn a
Lam :: a -> F typeVar typeAnn patternAnn a
LetRec :: [a] -> a -> F typeVar typeAnn patternAnn a
Let :: a -> a -> F typeVar typeAnn patternAnn a
Match :: a -> [MatchCase patternAnn a] -> F typeVar typeAnn patternAnn a
TermLink :: Referent -> F typeVar typeAnn patternAnn a
TypeLink :: Reference -> F typeVar typeAnn patternAnn a
data MatchCase loc a
MatchCase :: Pattern loc -> Maybe a -> a -> MatchCase loc a
hashClosedTerm :: Var v => Term v a -> Id
hashComponents :: forall v a. Var v => Map v (Term v a, Type v a) -> Map v (Id, Term v a, Type v a)
hashComponentsWithoutTypes :: Var v => Map v (Term v a) -> Map v (Id, Term v a)
instance Data.Traversable.Traversable (Unison.Hashing.V2.Term.MatchCase loc)
instance GHC.Generics.Generic1 (Unison.Hashing.V2.Term.MatchCase loc)
instance GHC.Generics.Generic (Unison.Hashing.V2.Term.MatchCase loc a)
instance GHC.Base.Functor (Unison.Hashing.V2.Term.MatchCase loc)
instance Data.Foldable.Foldable (Unison.Hashing.V2.Term.MatchCase loc)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Hashing.V2.Term.MatchCase loc a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Hashing.V2.Term.MatchCase loc a)
instance Data.Traversable.Traversable (Unison.Hashing.V2.Term.F typeVar typeAnn patternAnn)
instance GHC.Generics.Generic1 (Unison.Hashing.V2.Term.F typeVar typeAnn patternAnn)
instance GHC.Generics.Generic (Unison.Hashing.V2.Term.F typeVar typeAnn patternAnn a)
instance GHC.Base.Functor (Unison.Hashing.V2.Term.F typeVar typeAnn patternAnn)
instance Data.Foldable.Foldable (Unison.Hashing.V2.Term.F typeVar typeAnn patternAnn)
instance Unison.Var.Var v => Unison.Hashing.V2.Tokenizable.Hashable1 (Unison.Hashing.V2.Term.F v a p)

module Unison.Hashing.V2.DataDeclaration
data DataDeclaration v a
DataDeclaration :: Modifier -> a -> [v] -> [(a, v, Type v a)] -> DataDeclaration v a
[modifier] :: DataDeclaration v a -> Modifier
[annotation] :: DataDeclaration v a -> a
[bound] :: DataDeclaration v a -> [v]
[constructors'] :: DataDeclaration v a -> [(a, v, Type v a)]
newtype EffectDeclaration v a
EffectDeclaration :: DataDeclaration v a -> EffectDeclaration v a
[toDataDecl] :: EffectDeclaration v a -> DataDeclaration v a
type Decl v a = Either (EffectDeclaration v a) (DataDeclaration v a)
data Modifier
Structural :: Modifier
Unique :: Text -> Modifier

-- | compute the hashes of these user defined types and update any free
--   vars corresponding to these decls with the resulting hashes
--   
--   data List a = Nil | Cons a (List a) becomes something like (List,
--   #xyz, [forall a. #xyz a, forall a. a -&gt; (#xyz a) -&gt; (#xyz a)])
--   
--   NOTE: technical limitation, this implementation gives diff results if
--   ctors have the same FQN as one of the types. TODO: assert this and
--   bomb if not satisfied, or else do local mangling and unmangling to
--   ensure this doesn't affect the hash.
hashDecls :: (Eq v, Var v, Show v) => (v -> Name) -> Map v (DataDeclaration v a) -> ResolutionResult v a [(v, Id, DataDeclaration v a)]
instance GHC.Show.Show Unison.Hashing.V2.DataDeclaration.Modifier
instance GHC.Classes.Ord Unison.Hashing.V2.DataDeclaration.Modifier
instance GHC.Classes.Eq Unison.Hashing.V2.DataDeclaration.Modifier
instance GHC.Base.Functor (Unison.Hashing.V2.DataDeclaration.DataDeclaration v)
instance GHC.Base.Functor (Unison.Hashing.V2.DataDeclaration.EffectDeclaration v)
instance Data.Foldable.Foldable Unison.Hashing.V2.DataDeclaration.F
instance GHC.Base.Functor Unison.Hashing.V2.DataDeclaration.F
instance Unison.Hashing.V2.Tokenizable.Hashable1 Unison.Hashing.V2.DataDeclaration.F
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.DataDeclaration.Modifier

module Unison.Hashing.V2.TypeEdit
data TypeEdit
Replace :: Reference -> TypeEdit
Deprecate :: TypeEdit
instance GHC.Show.Show Unison.Hashing.V2.TypeEdit.TypeEdit
instance GHC.Classes.Ord Unison.Hashing.V2.TypeEdit.TypeEdit
instance GHC.Classes.Eq Unison.Hashing.V2.TypeEdit.TypeEdit
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.TypeEdit.TypeEdit

module Unison.Hashing.V2.Patch
data Patch
Patch :: Map Referent (Set TermEdit) -> Map Reference (Set TypeEdit) -> Patch
[termEdits] :: Patch -> Map Referent (Set TermEdit)
[typeEdits] :: Patch -> Map Reference (Set TypeEdit)
hashPatch :: Patch -> Hash
instance Unison.Hashing.V2.Tokenizable.Tokenizable Unison.Hashing.V2.Patch.Patch

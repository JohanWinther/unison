-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-parser-typechecker
@version 0.0.0

module U.Codebase.Branch.Diff

-- | A tree of local diffs. Each node of the tree contains the definition
--   diffs at that path.
newtype TreeDiff
TreeDiff :: Cofree (Map NameSegment) DefinitionDiffs -> TreeDiff
[$sel:unTreeDiff:TreeDiff] :: TreeDiff -> Cofree (Map NameSegment) DefinitionDiffs

-- | A summary of a <a>TreeDiff</a>, containing all names added and
--   removed. Note that there isn't a clear notion of a name "changing"
--   since conflicts might muddy the notion by having multiple copies of
--   both the from and to names, so we just talk about adds and removals
--   instead.
data NameChanges
NameChanges :: [(Name, Referent)] -> [(Name, Referent)] -> [(Name, Reference)] -> [(Name, Reference)] -> NameChanges
[$sel:termNameAdds:NameChanges] :: NameChanges -> [(Name, Referent)]
[$sel:termNameRemovals:NameChanges] :: NameChanges -> [(Name, Referent)]
[$sel:typeNameAdds:NameChanges] :: NameChanges -> [(Name, Reference)]
[$sel:typeNameRemovals:NameChanges] :: NameChanges -> [(Name, Reference)]

-- | Represents the changes to definitions at a given path, not including
--   child paths.
--   
--   Note: doesn't yet include any info on metadata or patch diffs. Feel
--   free to add it.
data DefinitionDiffs
DefinitionDiffs :: Map NameSegment (Diff Referent) -> Map NameSegment (Diff Reference) -> DefinitionDiffs
[$sel:termDiffs:DefinitionDiffs] :: DefinitionDiffs -> Map NameSegment (Diff Referent)
[$sel:typeDiffs:DefinitionDiffs] :: DefinitionDiffs -> Map NameSegment (Diff Reference)
data Diff a
Diff :: Set a -> Set a -> Diff a
[$sel:adds:Diff] :: Diff a -> Set a
[$sel:removals:Diff] :: Diff a -> Set a

-- | A name-based diff for namespaces <tt>N1</tt> and <tt>N2</tt> is (for
--   both terms and types) a relation between references, where `a R b` if:
--   
--   <ol>
--   <li><tt>a</tt> has name <tt>n</tt> in <tt>N1</tt>, and <tt>b</tt> has
--   the same name <tt>n</tt> in <tt>N2</tt></li>
--   <li><tt>a</tt> != <tt>b</tt></li>
--   </ol>
data NameBasedDiff
NameBasedDiff :: Relation Reference Reference -> Relation Reference Reference -> NameBasedDiff
[$sel:terms:NameBasedDiff] :: NameBasedDiff -> Relation Reference Reference
[$sel:types:NameBasedDiff] :: NameBasedDiff -> Relation Reference Reference

-- | Diff two Branches, returning a tree containing all of the changes
diffBranches :: forall m. Monad m => Branch m -> Branch m -> m TreeDiff

-- | Get a summary of all of the name adds and removals from a tree diff.
--   
--   The provided name will be prepended to all names in the output diff,
--   and can be useful if diffing branches at a specific sub-tree, but you
--   can pass <a>Nothing</a> if you're diffing from the root.
nameChanges :: Maybe Name -> TreeDiff -> NameChanges

-- | Get a <a>NameBasedDiff</a> from a <a>TreeDiff</a>.
nameBasedDiff :: TreeDiff -> NameBasedDiff
instance GHC.Classes.Ord a => GHC.Classes.Ord (U.Codebase.Branch.Diff.Diff a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (U.Codebase.Branch.Diff.Diff a)
instance GHC.Show.Show a => GHC.Show.Show (U.Codebase.Branch.Diff.Diff a)
instance GHC.Classes.Ord U.Codebase.Branch.Diff.DefinitionDiffs
instance GHC.Classes.Eq U.Codebase.Branch.Diff.DefinitionDiffs
instance GHC.Show.Show U.Codebase.Branch.Diff.DefinitionDiffs
instance GHC.Classes.Ord U.Codebase.Branch.Diff.TreeDiff
instance GHC.Classes.Eq U.Codebase.Branch.Diff.TreeDiff
instance GHC.Show.Show U.Codebase.Branch.Diff.TreeDiff
instance GHC.Show.Show U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Generics.Generic U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Base.Monoid U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Base.Semigroup U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Base.Semigroup U.Codebase.Branch.Diff.NameChanges
instance GHC.Base.Monoid U.Codebase.Branch.Diff.NameChanges
instance GHC.Base.Semigroup U.Codebase.Branch.Diff.TreeDiff
instance GHC.Base.Monoid U.Codebase.Branch.Diff.TreeDiff
instance Control.Lens.Empty.AsEmpty U.Codebase.Branch.Diff.TreeDiff
instance GHC.Base.Semigroup U.Codebase.Branch.Diff.DefinitionDiffs
instance GHC.Base.Monoid U.Codebase.Branch.Diff.DefinitionDiffs

module Unison.Codebase.BuiltinAnnotation
class BuiltinAnnotation a
builtinAnnotation :: BuiltinAnnotation a => a
instance Unison.Codebase.BuiltinAnnotation.BuiltinAnnotation Unison.Parser.Ann.Ann

module Unison.Codebase.Causal.Type
data Causal m e
UnsafeOne :: CausalHash -> HashFor e -> e -> Causal m e
[$sel:currentHash:UnsafeOne] :: Causal m e -> CausalHash
[$sel:valueHash:UnsafeOne] :: Causal m e -> HashFor e
[$sel:head:UnsafeOne] :: Causal m e -> e
UnsafeCons :: CausalHash -> HashFor e -> e -> (CausalHash, m (Causal m e)) -> Causal m e
[$sel:currentHash:UnsafeOne] :: Causal m e -> CausalHash
[$sel:valueHash:UnsafeOne] :: Causal m e -> HashFor e
[$sel:head:UnsafeOne] :: Causal m e -> e
[$sel:tail:UnsafeOne] :: Causal m e -> (CausalHash, m (Causal m e))
UnsafeMerge :: CausalHash -> HashFor e -> e -> Map CausalHash (m (Causal m e)) -> Causal m e
[$sel:currentHash:UnsafeOne] :: Causal m e -> CausalHash
[$sel:valueHash:UnsafeOne] :: Causal m e -> HashFor e
[$sel:head:UnsafeOne] :: Causal m e -> e
[$sel:tails:UnsafeOne] :: Causal m e -> Map CausalHash (m (Causal m e))
pattern One :: CausalHash -> HashFor e -> e -> Causal m e
pattern Cons :: CausalHash -> HashFor e -> e -> (CausalHash, m (Causal m e)) -> Causal m e
pattern Merge :: CausalHash -> HashFor e -> e -> Map CausalHash (m (Causal m e)) -> Causal m e
before :: Monad m => Causal m e -> Causal m e -> m Bool
predecessors :: Causal m e -> Seq (m (Causal m e))
lca :: Monad m => Causal m e -> Causal m e -> m (Maybe (Causal m e))
instance GHC.Show.Show e => GHC.Show.Show (Unison.Codebase.Causal.Type.Causal m e)
instance GHC.Classes.Eq (Unison.Codebase.Causal.Type.Causal m a)
instance GHC.Classes.Ord (Unison.Codebase.Causal.Type.Causal m a)

module Unison.Codebase.CodeLookup
data CodeLookup v m a
CodeLookup :: (Id -> m (Maybe (Term v a))) -> (Id -> m (Maybe (Decl v a))) -> CodeLookup v m a
[$sel:getTerm:CodeLookup] :: CodeLookup v m a -> Id -> m (Maybe (Term v a))
[$sel:getTypeDeclaration:CodeLookup] :: CodeLookup v m a -> Id -> m (Maybe (Decl v a))
transitiveDependencies :: (Monad m, Var v) => CodeLookup v m a -> Set Id -> Id -> m (Set Id)
instance Control.Monad.Morph.MFunctor (Unison.Codebase.CodeLookup.CodeLookup v)
instance (GHC.Classes.Ord v, GHC.Base.Functor m) => GHC.Base.Functor (Unison.Codebase.CodeLookup.CodeLookup v m)
instance GHC.Base.Monad m => GHC.Base.Semigroup (Unison.Codebase.CodeLookup.CodeLookup v m a)
instance GHC.Base.Monad m => GHC.Base.Monoid (Unison.Codebase.CodeLookup.CodeLookup v m a)

module Unison.Codebase.Editor.DisplayObject
data DisplayObject b a
BuiltinObject :: b -> DisplayObject b a
MissingObject :: ShortHash -> DisplayObject b a
UserObject :: a -> DisplayObject b a
toMaybe :: DisplayObject b a -> Maybe a
instance GHC.Generics.Generic (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance GHC.Base.Functor (Unison.Codebase.Editor.DisplayObject.DisplayObject b)
instance (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance (GHC.Classes.Ord b, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance (GHC.Classes.Eq b, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance Data.Bifunctor.Bifunctor Unison.Codebase.Editor.DisplayObject.DisplayObject

module Unison.Codebase.Init.CreateCodebaseError
data CreateCodebaseError
CreateCodebaseAlreadyExists :: CreateCodebaseError
type Pretty = Pretty ColorText
instance GHC.Show.Show Unison.Codebase.Init.CreateCodebaseError.CreateCodebaseError


-- | Open codebase error type.
module Unison.Codebase.Init.OpenCodebaseError

-- | An error that can occur when attempting to open a codebase.
data OpenCodebaseError

-- | The codebase doesn't exist.
OpenCodebaseDoesntExist :: OpenCodebaseError

-- | The codebase exists, but its schema version is unknown to this
--   application.
OpenCodebaseUnknownSchemaVersion :: SchemaVersion -> OpenCodebaseError
OpenCodebaseFileLockFailed :: OpenCodebaseError

-- | The codebase exists, but requires a migration before it can be used.
OpenCodebaseRequiresMigration :: SchemaVersion -> SchemaVersion -> OpenCodebaseError
instance GHC.Exception.Type.Exception Unison.Codebase.Init.OpenCodebaseError.OpenCodebaseError
instance GHC.Classes.Eq Unison.Codebase.Init.OpenCodebaseError.OpenCodebaseError
instance GHC.Show.Show Unison.Codebase.Init.OpenCodebaseError.OpenCodebaseError

module Unison.Codebase.Path
newtype Path
Path :: Seq NameSegment -> Path
[$sel:toSeq:Path] :: Path -> Seq NameSegment
newtype Path'
Path' :: Either Absolute Relative -> Path'
[$sel:unPath':Path'] :: Path' -> Either Absolute Relative
newtype Absolute
Absolute :: Path -> Absolute
[$sel:unabsolute:Absolute] :: Absolute -> Path
pattern AbsolutePath' :: Absolute -> Path'
newtype Relative
Relative :: Path -> Relative
[$sel:unrelative:Relative] :: Relative -> Path
pattern RelativePath' :: Relative -> Path'
class Resolve l r o
resolve :: Resolve l r o => l -> r -> o
pattern Empty :: Path
pattern (:<) :: Cons b b a a => a -> b -> b
infixr 5 :<
pattern (:>) :: Snoc a a b b => a -> b -> a
infixl 5 :>
singleton :: NameSegment -> Path
uncons :: Path -> Maybe (NameSegment, Path)
empty :: Path
isAbsolute :: Path' -> Bool
isRelative :: Path' -> Bool
absoluteEmpty :: Absolute
absoluteEmpty' :: Path'
relativeEmpty :: Relative
relativeEmpty' :: Path'
currentPath :: Path'
prefix :: Absolute -> Path' -> Path

-- | examples: unprefix .foo.bar .blah == .blah (absolute paths left alone)
--   unprefix .foo.bar id == id (relative paths starting w/ nonmatching
--   prefix left alone) unprefix .foo.bar foo.bar.baz == baz (relative
--   paths w/ common prefix get stripped)
unprefix :: Absolute -> Path' -> Path
prefixName :: Absolute -> Name -> Name

-- | what is this? —AI
unprefixName :: Absolute -> Name -> Maybe Name
type HQSplit = (Path, HQSegment)
type Split = (Path, NameSegment)
type Split' = (Path', NameSegment)
type HQSplit' = (Path', HQSegment)
ancestors :: Absolute -> Seq Absolute

-- | Finds the longest shared path prefix of two paths. Returns (shared
--   prefix, path to first location from shared prefix, path to second
--   location from shared prefix)
--   
--   <pre>
--   &gt;&gt;&gt; longestPathPrefix ("a" :&lt; "b" :&lt; "x" :&lt; Empty) ("a" :&lt; "b" :&lt; "c" :&lt; Empty)
--   (a.b,x,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; longestPathPrefix Empty ("a" :&lt; "b" :&lt; "c" :&lt; Empty)
--   (,,a.b.c)
--   </pre>
longestPathPrefix :: Path -> Path -> (Path, Path, Path)
isCurrentPath :: Path' -> Bool
isRoot :: Absolute -> Bool
isRoot' :: Path' -> Bool
absoluteToPath' :: Absolute -> Path'
fromList :: [NameSegment] -> Path
fromName :: Name -> Path
fromName' :: Name -> Path'
fromPath' :: Path' -> Path
fromText :: Text -> Path

-- | Construct a Path' from a text
--   
--   <pre>
--   &gt;&gt;&gt; fromText' "a.b.c"
--   a.b.c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromText' ".a.b.c"
--   .a.b.c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; show $ fromText' ""
--   ""
--   </pre>
fromText' :: Text -> Path'
toAbsoluteSplit :: Absolute -> (Path', a) -> (Absolute, a)
toSplit' :: Path' -> Maybe (Path', NameSegment)
toList :: Path -> [NameSegment]
toName :: Path -> Maybe Name

-- | Convert a Path' to a Name
toName' :: Path' -> Maybe Name
unsafeToName :: Path -> Name

-- | Convert a Path' to a Name
unsafeToName' :: Path' -> Name

-- | Mitchell: this function is bogus, because an empty name segment is
--   bogus
toPath' :: Path -> Path'

-- | Note: This treats the path as relative.
toText :: Path -> Text
toText' :: Path' -> Text
unsplit :: Split -> Path
unsplit' :: Split' -> Path'
unsplitAbsolute :: (Absolute, NameSegment) -> Absolute
unsplitHQ :: HQSplit -> HashQualified Path
unsplitHQ' :: HQSplit' -> HashQualified Path'

-- | <pre>
--   &gt;&gt;&gt; splitFromName "a.b.c"
--   (a.b,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitFromName "foo"
--   (,foo)
--   </pre>
splitFromName :: Name -> Split
hqSplitFromName' :: Name -> Maybe HQSplit'
cons :: NameSegment -> Path -> Path
snoc :: Path -> NameSegment -> Path
unsnoc :: Path -> Maybe (Path, NameSegment)
class Convert a b
convert :: Convert a b => a -> b
instance GHC.Base.Monoid Unison.Codebase.Path.Path
instance GHC.Base.Semigroup Unison.Codebase.Path.Path
instance GHC.Classes.Ord Unison.Codebase.Path.Path
instance GHC.Classes.Eq Unison.Codebase.Path.Path
instance GHC.Classes.Ord Unison.Codebase.Path.Absolute
instance GHC.Classes.Eq Unison.Codebase.Path.Absolute
instance GHC.Classes.Ord Unison.Codebase.Path.Relative
instance GHC.Classes.Eq Unison.Codebase.Path.Relative
instance GHC.Classes.Ord Unison.Codebase.Path.Path'
instance GHC.Classes.Eq Unison.Codebase.Path.Path'
instance Control.Lens.Empty.AsEmpty Unison.Codebase.Path.Path
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.Codebase.Path.Path
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.Relative Unison.Codebase.Path.Absolute
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Path' Unison.Codebase.Path.Path'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Split' Unison.Codebase.Path.Path'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Split' Unison.Codebase.Path.Split'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.HQSplit Unison.Codebase.Path.HQSplitAbsolute
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.Path' Unison.Codebase.Path.Absolute
instance Unison.Name.Convert Unison.Codebase.Path.HQSplit' (Unison.HashQualified'.HashQualified Unison.Codebase.Path.Path')
instance Unison.Name.Parse Unison.Name.Internal.Name Unison.Codebase.Path.HQSplit'
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Split' Unison.Codebase.Path.Split' Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.HQSplit (Unison.HashQualified'.HashQualified Unison.Codebase.Path.Path)
instance Unison.Name.Convert Unison.Name.Internal.Name Unison.Codebase.Path.Split
instance GHC.Show.Show Unison.Codebase.Path.Path'
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Path' Unison.Codebase.Path.Path' Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Path' Unison.Codebase.Path.Path' Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.Absolute Unison.Codebase.Path.Path'
instance GHC.Show.Show Unison.Codebase.Path.Relative
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.Relative Data.Text.Internal.Text
instance Unison.Name.Convert Unison.Codebase.Path.Relative GHC.Base.String
instance GHC.Show.Show Unison.Codebase.Path.Absolute
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Absolute Unison.Codebase.Path.Absolute Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Absolute Unison.Codebase.Path.Absolute Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.Absolute Unison.Codebase.Path.Path
instance Unison.Name.Convert Unison.Codebase.Path.Absolute Data.Text.Internal.Text
instance Unison.Name.Convert Unison.Codebase.Path.Absolute GHC.Base.String
instance GHC.Exts.IsList Unison.Codebase.Path.Path
instance GHC.Show.Show Unison.Codebase.Path.Path
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Unison.Name.Convert [Unison.NameSegment.NameSegment] Unison.Codebase.Path.Path
instance Unison.Name.Convert Unison.Codebase.Path.Path [Unison.NameSegment.NameSegment]
instance Unison.Name.Convert (path, Unison.NameSegment.NameSegment) (path, Unison.HashQualified'.HQSegment)
instance Unison.Name.Convert path0 path1 => Unison.Name.Convert (path0, name) (path1, name)

module U.Codebase.Projects
libSegment :: NameSegment

-- | Infers path to use for loading names. Currently this means finding the
--   closest parent with a "lib" child.
inferNamesRoot :: Path -> Branch Transaction -> Transaction (Maybe Path)

module Unison.Codebase.Path.Parse
parsePath' :: String -> Either String Path'
parsePathImpl' :: String -> Either String (Path', String)
parseSplit' :: (String -> Either String NameSegment) -> String -> Either String Split'
definitionNameSegment :: String -> Either String NameSegment
parseHQSplit :: String -> Either String HQSplit
parseHQSplit' :: String -> Either String HQSplit'
parseShortHashOrHQSplit' :: String -> Either String (Either ShortHash HQSplit')
wordyNameSegment :: String -> Either String NameSegment


-- | This module defines the <a>PushBehavior</a> type.
module Unison.Codebase.PushBehavior

-- | How a <tt>push</tt> behaves.
data PushBehavior
ForcePush :: PushBehavior

-- | The namespace being pushed to is required to be empty.
RequireEmpty :: PushBehavior

-- | The namespace being pushed to is required to be non-empty
RequireNonEmpty :: PushBehavior
instance GHC.Show.Show Unison.Codebase.PushBehavior.PushBehavior
instance GHC.Classes.Eq Unison.Codebase.PushBehavior.PushBehavior

module Unison.Codebase.Serialization
type Get a = forall m. MonadGet m => m a
type Put a = forall m. MonadPut m => a -> m ()
data Format a
Format :: Get a -> Put a -> Format a
[$sel:get:Format] :: Format a -> Get a
[$sel:put:Format] :: Format a -> Put a
getFromBytes :: Get a -> ByteString -> Maybe a
getFromFile :: MonadIO m => Get a -> FilePath -> m (Maybe a)
getFromFile' :: MonadIO m => Get a -> FilePath -> m (Either String a)
putBytes :: Put a -> a -> ByteString
putWithParentDirs :: MonadIO m => Put a -> FilePath -> a -> m ()

module Unison.Codebase.ShortCausalHash
toString :: ShortCausalHash -> String
toHash :: Coercible Hash h => ShortCausalHash -> Maybe h
fromHash :: Coercible h Hash => Int -> h -> ShortCausalHash
fromText :: Text -> Maybe ShortCausalHash

-- | Causal Hash Prefix
newtype ShortCausalHash
ShortCausalHash :: Text -> ShortCausalHash
[$sel:toText:ShortCausalHash] :: ShortCausalHash -> Text
instance GHC.Generics.Generic Unison.Codebase.ShortCausalHash.ShortCausalHash
instance GHC.Classes.Ord Unison.Codebase.ShortCausalHash.ShortCausalHash
instance GHC.Classes.Eq Unison.Codebase.ShortCausalHash.ShortCausalHash
instance GHC.Show.Show Unison.Codebase.ShortCausalHash.ShortCausalHash

module Unison.Codebase.SqliteCodebase.Migrations.Helpers
abortMigration :: String -> Transaction a

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.DbHelpers
dbBranchHash :: DbBranch -> Transaction BranchHash
dbPatchHash :: Patch -> Transaction PatchHash
syncCausalHash :: SyncCausalFormat -> Transaction CausalHash


-- | There are many invariants we expect to hold in our sqlite database and
--   on codebase objects which we can't maintain using database checks.
--   This module performs checks for some of these invariants, which can be
--   useful to run after performing potentially dangerous operations like
--   migrations.
module Unison.Codebase.IntegrityCheck

-- | Performs all available integrity checks.
integrityCheckFullCodebase :: Transaction IntegrityResult

-- | Performs a bevy of checks on branch objects and their relation to
--   causals.
integrityCheckAllBranches :: Transaction IntegrityResult

-- | Performs a bevy of checks on causals.
integrityCheckAllCausals :: Transaction IntegrityResult
prettyPrintIntegrityErrors :: Foldable f => f IntegrityError -> Pretty ColorText
data IntegrityResult
IntegrityErrorDetected :: NESet IntegrityError -> IntegrityResult
NoIntegrityErrors :: IntegrityResult
instance GHC.Classes.Ord Unison.Codebase.IntegrityCheck.BranchError
instance GHC.Classes.Eq Unison.Codebase.IntegrityCheck.BranchError
instance GHC.Show.Show Unison.Codebase.IntegrityCheck.BranchError
instance GHC.Classes.Ord Unison.Codebase.IntegrityCheck.IntegrityError
instance GHC.Classes.Eq Unison.Codebase.IntegrityCheck.IntegrityError
instance GHC.Show.Show Unison.Codebase.IntegrityCheck.IntegrityError
instance GHC.Classes.Ord Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Classes.Eq Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Show.Show Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Base.Semigroup Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Base.Monoid Unison.Codebase.IntegrityCheck.IntegrityResult

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema2To3

-- | The 1 to 2 migration kept around hash objects of hash version 1,
--   unfortunately this caused an issue:
--   
--   The migration would detect causals whose value hash did not have a
--   corresponding branch object, this was caused by a race-condition in
--   sync which could end up in a partial sync. When a branch object was
--   determined to be missing, the migration would replace it with the
--   empty branch. This worked well, but led to a situation where related
--   parent or successors of that causal would have their hash objects
--   mapped to the new v2 object which contained the empty branch in place
--   of missing branches. This is fine, but, if a different codebase
--   migrated the same branch and wasn't missing the branch in question it
--   would migrate successfully and each database now have the same v1 hash
--   object mapped to two distinct v2 objects, which rightfully causes a
--   crash when syncing.
--   
--   This migration drops all the v1 hash objects to avoid this issue,
--   since these hash objects weren't being used for anything anyways.
migrateSchema2To3 :: Transaction ()

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema3To4

-- | There was a bug in previous versions of UCM which incorrectly used
--   causal hashes as branch hashes. This remained undetected because there
--   was never a need for this hash to be verifiable, and the hashes were
--   still unique because the namespace hash was PART of the causal hash.
--   It did however result in many identical branches being stored multiple
--   times under different <tt>primary_hash_id</tt>s.
--   
--   However, with the advent of Share and Sync, we now need to correctly
--   verify these namespace hashes.
--   
--   This migration fixes the issue by re-hashing namespace objects where
--   the value_hash_id of a causal matches the self_hash_id. Luckily this
--   doesn't change any causal hashes.
--   
--   However, due to the possibility of multiple identical objects stored
--   under different <tt>primary_hash_id</tt>s, we may now have multiple
--   objects with the same <tt>primary_hash_id</tt>, which our DB schema
--   doesn't allow.
--   
--   To address this, we keep exactly one <tt>canonical</tt> object for
--   each hash, then remap all references to old objects into this
--   canonical object instead. Unfortunately this requires mapping over
--   every branch object and traversing the child references.
--   
--   It was also discovered that some developers had many branches which
--   referenced objects which weren't in their codebase. We're not yet sure
--   how this happened, but it's unlikely to be the case for most end
--   users, and it turned out that these references were in causals and
--   branches which were unreachable from the root namespace. As a fix,
--   this migration also tracks every causal and branch which is reachable
--   from the root namespace and deletes all causals and namespaces which
--   are unreachable. Note that this may orphan some definitions, patches,
--   etc. which were previously referenced in an <tt>unreachable</tt>
--   branch, but they were already floating around in an unreachable state.
migrateSchema3To4 :: Transaction ()
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema3To4.MigrationState

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema4To5

-- | The 4 to 5 migration adds initial support for out-of-order sync i.e.
--   Unison Share
migrateSchema4To5 :: Transaction ()

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema6To7

-- | Adds a table for tracking namespace statistics Adds stats for all
--   existing namespaces, even though missing stats are computed on-demand
--   if missing.
migrateSchema6To7 :: Transaction ()

module Unison.Codebase.SqliteCodebase.SyncEphemeral
data Dependencies
Dependencies :: Set Hash -> Set Hash -> Dependencies
[$sel:definitions:Dependencies] :: Dependencies -> Set Hash
[$sel:branches:Dependencies] :: Dependencies -> Set Hash
data Error
Sync22Error :: Error -> Error
SrcWrongSchema :: SchemaVersion -> Error
DestWrongSchema :: SchemaVersion -> Error
DisappearingBranch :: CausalHash -> Error
instance GHC.Exception.Type.Exception Unison.Codebase.SqliteCodebase.SyncEphemeral.Error
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.SyncEphemeral.Error

module Unison.Codebase.SyncMode
data SyncMode
ShortCircuit :: SyncMode
Complete :: SyncMode
instance GHC.Show.Show Unison.Codebase.SyncMode.SyncMode
instance GHC.Classes.Eq Unison.Codebase.SyncMode.SyncMode

module Unison.Codebase.TermEdit
data TermEdit
Replace :: Reference -> Typing -> TermEdit
Deprecate :: TermEdit
references :: TermEdit -> [Reference]
data Typing
Same :: Typing
Subtype :: Typing
Different :: Typing
toReference :: TermEdit -> Maybe Reference
isTypePreserving :: TermEdit -> Bool
isSame :: TermEdit -> Bool
instance GHC.Show.Show Unison.Codebase.TermEdit.Typing
instance GHC.Classes.Ord Unison.Codebase.TermEdit.Typing
instance GHC.Classes.Eq Unison.Codebase.TermEdit.Typing
instance GHC.Show.Show Unison.Codebase.TermEdit.TermEdit
instance GHC.Classes.Ord Unison.Codebase.TermEdit.TermEdit
instance GHC.Classes.Eq Unison.Codebase.TermEdit.TermEdit

module Unison.Codebase.TypeEdit
data TypeEdit
Replace :: Reference -> TypeEdit
Deprecate :: TypeEdit
references :: TypeEdit -> [Reference]
toReference :: TypeEdit -> Maybe Reference
instance GHC.Show.Show Unison.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Ord Unison.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Eq Unison.Codebase.TypeEdit.TypeEdit

module Unison.Codebase.Patch
data Patch
Patch :: Relation Reference TermEdit -> Relation Reference TypeEdit -> Patch
[$sel:_termEdits:Patch] :: Patch -> Relation Reference TermEdit
[$sel:_typeEdits:Patch] :: Patch -> Relation Reference TypeEdit
data PatchDiff
PatchDiff :: Relation Reference TermEdit -> Relation Reference TypeEdit -> Relation Reference TermEdit -> Relation Reference TypeEdit -> PatchDiff
[$sel:_addedTermEdits:PatchDiff] :: PatchDiff -> Relation Reference TermEdit
[$sel:_addedTypeEdits:PatchDiff] :: PatchDiff -> Relation Reference TypeEdit
[$sel:_removedTermEdits:PatchDiff] :: PatchDiff -> Relation Reference TermEdit
[$sel:_removedTypeEdits:PatchDiff] :: PatchDiff -> Relation Reference TypeEdit
typeEdits :: Lens' Patch (Relation Reference TypeEdit)
termEdits :: Lens' Patch (Relation Reference TermEdit)
removedTypeEdits :: Lens' PatchDiff (Relation Reference TypeEdit)
removedTermEdits :: Lens' PatchDiff (Relation Reference TermEdit)
addedTypeEdits :: Lens' PatchDiff (Relation Reference TypeEdit)
addedTermEdits :: Lens' PatchDiff (Relation Reference TermEdit)
diff :: Patch -> Patch -> PatchDiff
labeledDependencies :: Patch -> Set LabeledDependency
empty :: Patch
isEmpty :: Patch -> Bool
allReferences :: Patch -> Set Reference

-- | Returns the set of references which are the target of an arrow in the
--   patch
allReferenceTargets :: Patch -> Set Reference
updateTerm :: (Reference -> Reference -> Typing) -> Reference -> TermEdit -> Patch -> Patch
updateType :: Reference -> TypeEdit -> Patch -> Patch
conflicts :: Patch -> Patch
instance GHC.Base.Semigroup Unison.Codebase.Patch.Patch
instance GHC.Base.Monoid Unison.Codebase.Patch.Patch
instance GHC.Base.Semigroup Unison.Codebase.Patch.PatchDiff
instance GHC.Base.Monoid Unison.Codebase.Patch.PatchDiff
instance GHC.Show.Show Unison.Codebase.Patch.Patch
instance GHC.Classes.Ord Unison.Codebase.Patch.Patch
instance GHC.Classes.Eq Unison.Codebase.Patch.Patch
instance GHC.Show.Show Unison.Codebase.Patch.PatchDiff
instance GHC.Classes.Ord Unison.Codebase.Patch.PatchDiff
instance GHC.Classes.Eq Unison.Codebase.Patch.PatchDiff

module Unison.Codebase.Verbosity
data Verbosity
Verbose :: Verbosity
Silent :: Verbosity
isSilent :: Verbosity -> Bool
instance GHC.Show.Show Unison.Codebase.Verbosity.Verbosity
instance GHC.Classes.Eq Unison.Codebase.Verbosity.Verbosity

module Unison.CodebasePath

-- | A directory that contains a codebase.
type CodebasePath = FilePath
getCodebaseDir :: MonadIO m => Maybe CodebasePath -> m CodebasePath

module Unison.PrettyPrintEnv
data PrettyPrintEnv
PrettyPrintEnv :: (Referent -> [(HashQualified Name, HashQualified Name)]) -> (Reference -> [(HashQualified Name, HashQualified Name)]) -> PrettyPrintEnv
[$sel:termNames:PrettyPrintEnv] :: PrettyPrintEnv -> Referent -> [(HashQualified Name, HashQualified Name)]
[$sel:typeNames:PrettyPrintEnv] :: PrettyPrintEnv -> Reference -> [(HashQualified Name, HashQualified Name)]
patterns :: PrettyPrintEnv -> ConstructorReference -> Maybe (HashQualified Name)
patternName :: PrettyPrintEnv -> ConstructorReference -> HashQualified Name
terms :: PrettyPrintEnv -> Referent -> Maybe (HashQualified Name)
types :: PrettyPrintEnv -> Reference -> Maybe (HashQualified Name)
allTermNames :: PrettyPrintEnv -> Referent -> [HashQualified Name]
allTypeNames :: PrettyPrintEnv -> Reference -> [HashQualified Name]
termName :: PrettyPrintEnv -> Referent -> HashQualified Name
typeName :: PrettyPrintEnv -> Reference -> HashQualified Name
termNameOrHashOnly :: PrettyPrintEnv -> Referent -> HashQualified Name
typeNameOrHashOnly :: PrettyPrintEnv -> Reference -> HashQualified Name

-- | Prefer names which share a common prefix with any provided target.
--   
--   Results are sorted according to the longest common prefix found
--   against ANY target.
biasTo :: [Name] -> PrettyPrintEnv -> PrettyPrintEnv

-- | Get a name for a LabeledDependency from the PPE.
labeledRefName :: PrettyPrintEnv -> LabeledDependency -> HashQualified Name
todoHashLength :: Int

-- | Attempts to find a name in primary ppe, falls back to backup ppe only
--   if no names are found. Typically one can use this to shadow global or
--   absolute names with names that are within the current path.
addFallback :: PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnv

-- | Finds names from both PPEs, if left unbiased the name from the left
--   ppe is preferred.
--   
--   This is distinct from <a>addFallback</a> with respect to biasing; A
--   bias applied to a union might select a name in the right half of the
--   union. Whereas, a bias applied to the result of <a>addFallback</a>
--   will bias within the available names inside the left PPE and will only
--   search in the fallback if there aren't ANY names in the primary ppe.
--   
--   If you don't know the difference, it's likely you want
--   <a>addFallback</a> where you add global names as a fallback for local
--   names.
union :: PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnv
empty :: PrettyPrintEnv
instance GHC.Show.Show Unison.PrettyPrintEnv.PrettyPrintEnv

module Unison.PrettyPrintEnv.FQN
type Imports = Map Name Suffix
type Prefix = [Text]
type Suffix = Text
elideFQN :: Imports -> HashQualified Name -> HashQualified Name

module Unison.PrettyPrintEnv.MonadPretty
type MonadPretty v m = (Var v, MonadReader (PrettyPrintEnv, Set v) m)
getPPE :: MonadPretty v m => m PrettyPrintEnv

-- | Run a computation with a modified PrettyPrintEnv, restoring the
--   original
withPPE :: MonadPretty v m => PrettyPrintEnv -> m a -> m a
applyPPE :: MonadPretty v m => (PrettyPrintEnv -> a) -> m a
applyPPE2 :: MonadPretty v m => (PrettyPrintEnv -> a -> b) -> a -> m b
applyPPE3 :: MonadPretty v m => (PrettyPrintEnv -> a -> b -> c) -> a -> b -> m c

-- | Run a computation with a modified PrettyPrintEnv, restoring the
--   original
modifyPPE :: MonadPretty v m => (PrettyPrintEnv -> PrettyPrintEnv) -> m a -> m a
modifyTypeVars :: MonadPretty v m => (Set v -> Set v) -> m a -> m a

-- | Add type variables to the set of variables that need to be avoided
addTypeVars :: MonadPretty v m => [v] -> m a -> m a

-- | Check if a list of type variables contains any variables that need to
--   be avoided
willCapture :: MonadPretty v m => [v] -> m Bool
runPretty :: Var v => PrettyPrintEnv -> Reader (PrettyPrintEnv, Set v) a -> a

module Unison.PrettyPrintEnv.Names
fromNames :: Int -> NamesWithHistory -> PrettyPrintEnv
fromSuffixNames :: Int -> NamesWithHistory -> PrettyPrintEnv

module Unison.PrettyPrintEnvDecl
data PrettyPrintEnvDecl
PrettyPrintEnvDecl :: PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnvDecl
[$sel:unsuffixifiedPPE:PrettyPrintEnvDecl] :: PrettyPrintEnvDecl -> PrettyPrintEnv
[$sel:suffixifiedPPE:PrettyPrintEnvDecl] :: PrettyPrintEnvDecl -> PrettyPrintEnv

-- | Lifts <a>biasTo</a> over a PrettyPrintEnvDecl
biasTo :: [Name] -> PrettyPrintEnvDecl -> PrettyPrintEnvDecl
empty :: PrettyPrintEnvDecl
addFallback :: PrettyPrintEnvDecl -> PrettyPrintEnvDecl -> PrettyPrintEnvDecl
instance GHC.Show.Show Unison.PrettyPrintEnvDecl.PrettyPrintEnvDecl

module Unison.PrettyPrintEnv.Util
declarationPPE :: PrettyPrintEnvDecl -> Reference -> PrettyPrintEnv
declarationPPEDecl :: PrettyPrintEnvDecl -> Reference -> PrettyPrintEnvDecl

module Unison.PrettyPrintEnvDecl.Names
fromNamesDecl :: Int -> NamesWithHistory -> PrettyPrintEnvDecl

module Unison.Runtime.Array

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length as a hint.
--   Its behaviour should be equivalent to <a>fromList</a>. The hint can be
--   used to construct the structure <tt>l</tt> more efficiently compared
--   to <a>fromList</a>. If the given hint does not equal to the input
--   list's length the behaviour of <a>fromListN</a> is not specified.
fromListN :: IsList l => Int -> [Item l] -> l
data ByteArray# :: TYPE 'UnliftedRep
data MutableByteArray# a :: TYPE 'UnliftedRep

-- | Mutable byte arrays associated with a primitive state token.
data MutableByteArray s
MutableByteArray :: MutableByteArray# s -> MutableByteArray s

-- | Mutable boxed arrays associated with a primitive state token.
data MutableArray s a
MutableArray :: MutableArray# s a -> MutableArray s a
[marray#] :: MutableArray s a -> MutableArray# s a

-- | Shrink a mutable byte array. The new size is given in bytes. It must
--   be smaller than the old size. The array will be resized in place.
shrinkMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m ()

-- | Byte arrays.
data ByteArray
ByteArray :: ByteArray# -> ByteArray

-- | The number of elements in an immutable array.
sizeofArray :: Array a -> Int

-- | The number of elements in a mutable array.
sizeofMutableArray :: MutableArray s a -> Int

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runPrimArray m = runST $ m &gt;&gt;= unsafeFreezePrimArray
--   </pre>
runPrimArray :: (forall s. () => ST s (MutablePrimArray s a)) -> PrimArray a

-- | Return a newly allocated mutable array with the specified subrange of
--   the provided mutable array. The provided mutable array should contain
--   the full subrange specified by the two Ints, but this is not checked.
cloneMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Return a newly allocated array with the specified subrange of the
--   provided array. The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
clonePrimArray :: Prim a => PrimArray a -> Int -> Int -> PrimArray a

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <tt>newPinnedByteArray</tt> or
--   <tt>newAlignedPinnedByteArray</tt>.
mutablePrimArrayContents :: MutablePrimArray s a -> Ptr a

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> prim arrays allocated by <tt>newPinnedByteArray</tt> or
--   <tt>newAlignedPinnedByteArray</tt>.
primArrayContents :: PrimArray a -> Ptr a

-- | Create a <i>pinned</i> primitive array of the specified size (in
--   elements) and with the alignment given by its <a>Prim</a> instance.
--   The garbage collector is guaranteed not to move it.
newAlignedPinnedPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Create a <i>pinned</i> primitive array of the specified size (in
--   elements). The garbage collector is guaranteed not to move it.
newPinnedPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Traverse the primitive array with the indices, discarding the results.
--   There is no <a>PrimMonad</a> variant of this function, since it would
--   not provide any performance benefit.
itraversePrimArray_ :: (Applicative f, Prim a) => (Int -> a -> f b) -> PrimArray a -> f ()

-- | Traverse the primitive array, discarding the results. There is no
--   <a>PrimMonad</a> variant of this function, since it would not provide
--   any performance benefit.
traversePrimArray_ :: (Applicative f, Prim a) => (a -> f b) -> PrimArray a -> f ()

-- | Execute the applicative action the given number of times and store the
--   results in a <a>PrimArray</a>.
replicatePrimArrayA :: (Applicative f, Prim a) => Int -> f a -> f (PrimArray a)

-- | Generate a primitive array by evaluating the applicative generator
--   function at each index.
generatePrimArrayA :: (Applicative f, Prim a) => Int -> (Int -> f a) -> f (PrimArray a)

-- | Create a primitive array by copying the element the given number of
--   times.
replicatePrimArray :: Prim a => Int -> a -> PrimArray a

-- | Generate a primitive array.
generatePrimArray :: Prim a => Int -> (Int -> a) -> PrimArray a

-- | Traverse a primitive array with the indices. The traversal forces the
--   resulting values and writes them to the new primitive array as it
--   performs the monadic effects.
itraversePrimArrayP :: (Prim a, Prim b, PrimMonad m) => (Int -> a -> m b) -> PrimArray a -> m (PrimArray b)

-- | Traverse a primitive array with the index of each element.
itraversePrimArray :: (Applicative f, Prim a, Prim b) => (Int -> a -> f b) -> PrimArray a -> f (PrimArray b)

-- | Traverse a primitive array. The traversal performs all of the
--   applicative effects <i>before</i> forcing the resulting values and
--   writing them to the new primitive array. Consequently:
--   
--   <pre>
--   &gt;&gt;&gt; traversePrimArray (\x -&gt; print x $&gt; bool x undefined (x == 2)) (fromList [1, 2, 3 :: Int])
--   1
--   2
--   3
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   The function <a>traversePrimArrayP</a> always outperforms this
--   function, but it requires a <a>PrimMonad</a> constraint, and it forces
--   the values as it performs the effects.
traversePrimArray :: (Applicative f, Prim a, Prim b) => (a -> f b) -> PrimArray a -> f (PrimArray b)

-- | Map over a primitive array, optionally discarding some elements. This
--   has the same behavior as <tt>Data.Maybe.mapMaybe</tt>.
mapMaybePrimArray :: (Prim a, Prim b) => (a -> Maybe b) -> PrimArray a -> PrimArray b

-- | Map over the primitive array, keeping the elements for which the
--   applicative predicate provides a <a>Just</a>.
mapMaybePrimArrayA :: (Applicative f, Prim a, Prim b) => (a -> f (Maybe b)) -> PrimArray a -> f (PrimArray b)

-- | Filter the primitive array, keeping the elements for which the monadic
--   predicate evaluates true.
filterPrimArrayA :: (Applicative f, Prim a) => (a -> f Bool) -> PrimArray a -> f (PrimArray a)

-- | Filter elements of a primitive array according to a predicate.
filterPrimArray :: Prim a => (a -> Bool) -> PrimArray a -> PrimArray a

-- | Indexed map over the elements of a primitive array.
imapPrimArray :: (Prim a, Prim b) => (Int -> a -> b) -> PrimArray a -> PrimArray b

-- | Map over the elements of a primitive array.
mapPrimArray :: (Prim a, Prim b) => (a -> b) -> PrimArray a -> PrimArray b

-- | Execute the monadic action the given number of times and store the
--   results in a primitive array.
replicatePrimArrayP :: (PrimMonad m, Prim a) => Int -> m a -> m (PrimArray a)

-- | Generate a primitive array by evaluating the monadic generator
--   function at each index.
generatePrimArrayP :: (PrimMonad m, Prim a) => Int -> (Int -> m a) -> m (PrimArray a)

-- | Map over the primitive array, keeping the elements for which the
--   monadic predicate provides a <a>Just</a>.
mapMaybePrimArrayP :: (PrimMonad m, Prim a, Prim b) => (a -> m (Maybe b)) -> PrimArray a -> m (PrimArray b)

-- | Filter the primitive array, keeping the elements for which the monadic
--   predicate evaluates to true.
filterPrimArrayP :: (PrimMonad m, Prim a) => (a -> m Bool) -> PrimArray a -> m (PrimArray a)

-- | Traverse a primitive array. The traversal forces the resulting values
--   and writes them to the new primitive array as it performs the monadic
--   effects. Consequently:
--   
--   <pre>
--   &gt;&gt;&gt; traversePrimArrayP (\x -&gt; print x $&gt; bool x undefined (x == 2)) (fromList [1, 2, 3 :: Int])
--   1
--   2
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   In many situations, <a>traversePrimArrayP</a> can replace
--   <a>traversePrimArray</a>, changing the strictness characteristics of
--   the traversal but typically improving the performance. Consider the
--   following short-circuiting traversal:
--   
--   <pre>
--   incrPositiveA :: PrimArray Int -&gt; Maybe (PrimArray Int)
--   incrPositiveA xs = traversePrimArray (\x -&gt; bool Nothing (Just (x + 1)) (x &gt; 0)) xs
--   </pre>
--   
--   This can be rewritten using <a>traversePrimArrayP</a>. To do this, we
--   must change the traversal context to <tt>MaybeT (ST s)</tt>, which has
--   a <a>PrimMonad</a> instance:
--   
--   <pre>
--   incrPositiveB :: PrimArray Int -&gt; Maybe (PrimArray Int)
--   incrPositiveB xs = runST $ runMaybeT $ traversePrimArrayP
--     (\x -&gt; bool (MaybeT (return Nothing)) (MaybeT (return (Just (x + 1)))) (x &gt; 0))
--     xs
--   </pre>
--   
--   Benchmarks demonstrate that the second implementation runs 150 times
--   faster than the first. It also results in fewer allocations.
traversePrimArrayP :: (PrimMonad m, Prim a, Prim b) => (a -> m b) -> PrimArray a -> m (PrimArray b)

-- | Strict left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArrayM' :: (Prim a, Monad m) => (b -> a -> m b) -> b -> PrimArray a -> m b

-- | Strict left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArray' :: Prim a => (b -> a -> b) -> b -> PrimArray a -> b

-- | Lazy left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArray :: Prim a => (b -> a -> b) -> b -> PrimArray a -> b

-- | Strict right-associated fold over the elements of a <a>PrimArray</a>.
foldrPrimArray' :: Prim a => (a -> b -> b) -> b -> PrimArray a -> b

-- | Lazy right-associated fold over the elements of a <a>PrimArray</a>.
foldrPrimArray :: Prim a => (a -> b -> b) -> b -> PrimArray a -> b

-- | Check whether or not the mutable primitive array is pinned. This
--   function is only available when compiling with GHC 8.2 or newer.
isMutablePrimArrayPinned :: MutablePrimArray s a -> Bool

-- | Check whether or not the primitive array is pinned. Pinned primitive
--   arrays cannot be moved by the garbage collector. It is safe to use
--   <a>primArrayContents</a> on such arrays. This function is only
--   available when compiling with GHC 8.2 or newer.
isPrimArrayPinned :: PrimArray a -> Bool

-- | Get the size, in elements, of the primitive array.
sizeofPrimArray :: Prim a => PrimArray a -> Int

-- | Convert an immutable array to a mutable one without copying. The
--   original array should not be used after the conversion.
unsafeThawPrimArray :: PrimMonad m => PrimArray a -> m (MutablePrimArray (PrimState m) a)

-- | Convert a mutable primitive array to an immutable one without copying.
--   The array should not be modified after the conversion.
unsafeFreezePrimArray :: PrimMonad m => MutablePrimArray (PrimState m) a -> m (PrimArray a)

-- | Create a mutable primitive array from a slice of an immutable
--   primitive array. The offset and length are given in elements.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawPrimArray :: (PrimMonad m, Prim a) => PrimArray a -> Int -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Create an immutable copy of a slice of a primitive array. The offset
--   and length are given in elements.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> Int -> m (PrimArray a)

-- | Check if the two arrays refer to the same memory block.
sameMutablePrimArray :: MutablePrimArray s a -> MutablePrimArray s a -> Bool

-- | Size of the mutable primitive array in elements. This function shall
--   not be used on primitive arrays that are an argument to or a result of
--   <a>resizeMutablePrimArray</a> or <a>shrinkMutablePrimArray</a>.
sizeofMutablePrimArray :: forall s a. Prim a => MutablePrimArray s a -> Int

-- | Get the size of a mutable primitive array in elements. Unlike
--   <a>sizeofMutablePrimArray</a>, this function ensures sequencing in the
--   presence of resizing.
getSizeofMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> m Int

-- | Fill a slice of a mutable primitive array with a value.
--   
--   <i>Note:</i> this function does not do bounds checking.
setPrimArray :: (Prim a, PrimMonad m) => MutablePrimArray (PrimState m) a -> Int -> Int -> a -> m ()

-- | Copy a slice of a mutable primitive array to a pointer. The offset and
--   length are given in elements of type <tt>a</tt>. This function assumes
--   that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutablePrimArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> MutablePrimArray (PrimState m) a -> Int -> Int -> m ()

-- | Copy a slice of an immutable primitive array to a pointer. The offset
--   and length are given in elements of type <tt>a</tt>. This function
--   assumes that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPrimArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> PrimArray a -> Int -> Int -> m ()

-- | Copy part of an array into another mutable array.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> PrimArray a -> Int -> Int -> m ()

-- | Copy part of a mutable array into another mutable array. In the case
--   that the destination and source arrays are the same, the regions may
--   overlap.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> MutablePrimArray (PrimState m) a -> Int -> Int -> m ()

-- | Shrink a mutable primitive array. The new size is given in elements.
--   It must be smaller than the old size. The array will be resized in
--   place.
shrinkMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> m ()

-- | Resize a mutable primitive array. The new size is given in elements.
--   
--   This will either resize the array in-place or, if not possible,
--   allocate the contents into a new, unpinned array and copy the original
--   array's contents.
--   
--   To avoid undefined behaviour, the original <a>MutablePrimArray</a>
--   shall not be accessed anymore after a <a>resizeMutablePrimArray</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutablePrimArray</a> in case a new <a>MutablePrimArray</a> had to
--   be allocated.
resizeMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Create a new mutable primitive array of the given length. The
--   underlying memory is left uninitialized.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | The empty <a>PrimArray</a>.
emptyPrimArray :: PrimArray a

-- | Convert a <a>PrimArray</a> to a list.
primArrayToList :: Prim a => PrimArray a -> [a]

-- | Create a <a>PrimArray</a> from a list of a known length. If the length
--   of the list does not match the given length, this throws an exception.
primArrayFromListN :: Prim a => Int -> [a] -> PrimArray a

-- | Create a <a>PrimArray</a> from a list.
--   
--   <pre>
--   primArrayFromList vs = <a>primArrayFromListN</a> (length vs) vs
--   </pre>
primArrayFromList :: Prim a => [a] -> PrimArray a

-- | Arrays of unboxed elements. This accepts types like <a>Double</a>,
--   <a>Char</a>, <a>Int</a> and <a>Word</a>, as well as their fixed-length
--   variants (<tt>Word8</tt>, <tt>Word16</tt>, etc.). Since the elements
--   are unboxed, a <a>PrimArray</a> is strict in its elements. This
--   differs from the behavior of <a>Array</a>, which is lazy in its
--   elements.
data PrimArray a
PrimArray :: ByteArray# -> PrimArray a

-- | Mutable primitive arrays associated with a primitive state token.
--   These can be written to and read from in a monadic context that
--   supports sequencing, such as <a>IO</a> or <a>ST</a>. Typically, a
--   mutable primitive array will be built and then converted to an
--   immutable primitive array using <a>unsafeFreezePrimArray</a>. However,
--   it is also acceptable to simply discard a mutable primitive array
--   since it lives in managed memory and will be garbage collected when no
--   longer referenced.
data MutablePrimArray s a
MutablePrimArray :: MutableByteArray# s -> MutablePrimArray s a

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runByteArray m = runST $ m &gt;&gt;= unsafeFreezeByteArray
--   </pre>
runByteArray :: (forall s. () => ST s (MutableByteArray s)) -> ByteArray

-- | Return a newly allocated mutable array with the specified subrange of
--   the provided mutable array. The provided mutable array should contain
--   the full subrange specified by the two Ints, but this is not checked.
cloneMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> m (MutableByteArray (PrimState m))

-- | Return a newly allocated array with the specified subrange of the
--   provided array. The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
cloneByteArray :: ByteArray -> Int -> Int -> ByteArray

-- | The empty <a>ByteArray</a>.
emptyByteArray :: ByteArray

-- | Lexicographic comparison of equal-length slices into two byte arrays.
--   This wraps the <tt>compareByteArrays#</tt> primop, which wraps
--   <tt>memcmp</tt>.
compareByteArrays :: ByteArray -> Int -> ByteArray -> Int -> Int -> Ordering

-- | Fill a slice of a mutable byte array with a byte.
--   
--   <i>Note:</i> this function does not do bounds checking.
fillByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> Word8 -> m ()

-- | Fill a slice of a mutable byte array with a value. The offset and
--   length are given in elements of type <tt>a</tt> rather than in bytes.
--   
--   <i>Note:</i> this function does not do bounds checking.
setByteArray :: (Prim a, PrimMonad m) => MutableByteArray (PrimState m) -> Int -> Int -> a -> m ()

-- | Copy a slice of a mutable byte array to an unmanaged address. These
--   must not overlap.
--   
--   Note: This function is just <a>copyMutableByteArrayToPtr</a> where
--   <tt>a</tt> is <a>Word8</a>.
copyMutableByteArrayToAddr :: PrimMonad m => Ptr Word8 -> MutableByteArray (PrimState m) -> Int -> Int -> m ()

-- | Copy a slice of a byte array to an unmanaged address. These must not
--   overlap.
--   
--   Note: This function is just <a>copyByteArrayToPtr</a> where <tt>a</tt>
--   is <a>Word8</a>.
copyByteArrayToAddr :: PrimMonad m => Ptr Word8 -> ByteArray -> Int -> Int -> m ()

-- | Copy a slice of a mutable byte array to an unmanaged pointer address.
--   These must not overlap. The offset and length are given in elements,
--   not in bytes.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutableByteArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> MutableByteArray (PrimState m) -> Int -> Int -> m ()

-- | Copy a slice of a byte array to an unmanaged pointer address. These
--   must not overlap. The offset and length are given in elements, not in
--   bytes.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyByteArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> ByteArray -> Int -> Int -> m ()

-- | Create a <a>ByteArray</a> from a list of a known length. If the length
--   of the list does not match the given length, this throws an exception.
byteArrayFromListN :: Prim a => Int -> [a] -> ByteArray

-- | Create a <a>ByteArray</a> from a list.
--   
--   <pre>
--   byteArrayFromList xs = <a>byteArrayFromListN</a> (length xs) xs
--   </pre>
byteArrayFromList :: Prim a => [a] -> ByteArray

-- | Right-fold over the elements of a <a>ByteArray</a>.
foldrByteArray :: Prim a => (a -> b -> b) -> b -> ByteArray -> b

-- | Check whether or not the mutable byte array is pinned. This function
--   is only available when compiling with GHC 8.2 or newer.
isMutableByteArrayPinned :: MutableByteArray s -> Bool

-- | Check whether or not the byte array is pinned. Pinned byte arrays
--   cannot be moved by the garbage collector. It is safe to use
--   <a>byteArrayContents</a> on such byte arrays. This function is only
--   available when compiling with GHC 8.2 or newer.
isByteArrayPinned :: ByteArray -> Bool

-- | Size of the mutable byte array in bytes. This function's behavior is
--   undefined if <a>resizeMutableByteArray</a> is ever called on the
--   mutable byte array given as the argument. Consequently, use of this
--   function is discouraged. Prefer <a>getSizeofMutableByteArray</a>,
--   which ensures correct sequencing in the presence of resizing.
sizeofMutableByteArray :: MutableByteArray s -> Int

-- | Size of the byte array in bytes.
sizeofByteArray :: ByteArray -> Int

-- | Convert an immutable byte array to a mutable one without copying. The
--   original array should not be used after the conversion.
unsafeThawByteArray :: PrimMonad m => ByteArray -> m (MutableByteArray (PrimState m))

-- | Convert a mutable byte array to an immutable one without copying. The
--   array should not be modified after the conversion.
unsafeFreezeByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> m ByteArray

-- | Create a mutable byte array from a slice of an immutable byte array.
--   The offset and length are given in bytes.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawByteArray :: PrimMonad m => ByteArray -> Int -> Int -> m (MutableByteArray (PrimState m))

-- | Create an immutable copy of a slice of a byte array. The offset and
--   length are given in bytes.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezeByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> m ByteArray

-- | Get the size of a byte array in bytes. Unlike
--   <a>sizeofMutableByteArray</a>, this function ensures sequencing in the
--   presence of resizing.
getSizeofMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> m Int

-- | Resize a mutable byte array. The new size is given in bytes.
--   
--   This will either resize the array in-place or, if not possible,
--   allocate the contents into a new, unpinned array and copy the original
--   array's contents.
--   
--   To avoid undefined behaviour, the original <a>MutableByteArray</a>
--   shall not be accessed anymore after a <a>resizeMutableByteArray</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutableByteArray</a> in case a new <a>MutableByteArray</a> had to
--   be allocated.
resizeMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m (MutableByteArray (PrimState m))

-- | Check if the two arrays refer to the same memory block.
sameMutableByteArray :: MutableByteArray s -> MutableByteArray s -> Bool

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <a>newPinnedByteArray</a> or
--   <a>newAlignedPinnedByteArray</a>.
mutableByteArrayContents :: MutableByteArray s -> Ptr Word8

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <a>newPinnedByteArray</a> or
--   <a>newAlignedPinnedByteArray</a>.
byteArrayContents :: ByteArray -> Ptr Word8

-- | Create a <i>pinned</i> byte array of the specified size in bytes and
--   with the given alignment. The garbage collector is guaranteed not to
--   move it.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newAlignedPinnedByteArray :: PrimMonad m => Int -> Int -> m (MutableByteArray (PrimState m))

-- | Create a <i>pinned</i> byte array of the specified size in bytes. The
--   garbage collector is guaranteed not to move it.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newPinnedByteArray :: PrimMonad m => Int -> m (MutableByteArray (PrimState m))

-- | Create a new mutable byte array of the specified size in bytes.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newByteArray :: PrimMonad m => Int -> m (MutableByteArray (PrimState m))

-- | Create an array from a list.
arrayFromList :: [a] -> Array a

-- | Create an array from a list of a known length. If the length of the
--   list does not match the given length, this throws an exception.
arrayFromListN :: Int -> [a] -> Array a

-- | Strict map over the elements of the array.
mapArray' :: (a -> b) -> Array a -> Array b

-- | This is the fastest, most straightforward way to traverse an array,
--   but it only works correctly with a sufficiently "affine"
--   <a>PrimMonad</a> instance. In particular, it must only produce
--   <i>one</i> result array. <a>ListT</a>-transformed monads, for example,
--   will not work right at all.
traverseArrayP :: PrimMonad m => (a -> m b) -> Array a -> m (Array b)

-- | Create an array of the given size with a default value, apply the
--   monadic function and freeze the result. If the size is 0, return
--   <a>emptyArray</a> (rather than a new copy thereof).
--   
--   <pre>
--   createArray 0 _ _ = emptyArray
--   createArray n x f = runArray $ do
--     mary &lt;- newArray n x
--     f mary
--     pure mary
--   </pre>
createArray :: Int -> a -> (forall s. () => MutableArray s a -> ST s ()) -> Array a

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runArray m = runST $ m &gt;&gt;= unsafeFreezeArray
--   </pre>
runArray :: (forall s. () => ST s (MutableArray s a)) -> Array a

-- | The empty <a>Array</a>.
emptyArray :: Array a

-- | Return a newly allocated <a>Array</a> with the specified subrange of
--   the provided <a>Array</a>.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
cloneArray :: Array a -> Int -> Int -> Array a

-- | Check whether the two arrays refer to the same memory block.
sameMutableArray :: MutableArray s a -> MutableArray s a -> Bool

-- | Convert an immutable array to an mutable one without copying. The
--   immutable array should not be used after the conversion.
unsafeThawArray :: PrimMonad m => Array a -> m (MutableArray (PrimState m) a)

-- | Create a mutable array from a slice of an immutable array.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawArray :: PrimMonad m => Array a -> Int -> Int -> m (MutableArray (PrimState m) a)

-- | Convert a mutable array to an immutable one without copying. The array
--   should not be modified after the conversion.
unsafeFreezeArray :: PrimMonad m => MutableArray (PrimState m) a -> m (Array a)

-- | Create an immutable copy of a slice of an array.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezeArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> Int -> m (Array a)

-- | Monadically read a value from the immutable array at the given index.
--   This allows us to be strict in the array while remaining lazy in the
--   read element which is very useful for collective operations. Suppose
--   we want to copy an array. We could do something like this:
--   
--   <pre>
--   copy marr arr ... = do ...
--                          writeArray marr i (indexArray arr i) ...
--                          ...
--   </pre>
--   
--   But since the arrays are lazy, the calls to <a>indexArray</a> will not
--   be evaluated. Rather, <tt>marr</tt> will be filled with thunks each of
--   which would retain a reference to <tt>arr</tt>. This is definitely not
--   what we want!
--   
--   With <a>indexArrayM</a>, we can instead write
--   
--   <pre>
--   copy marr arr ... = do ...
--                          x &lt;- indexArrayM arr i
--                          writeArray marr i x
--                          ...
--   </pre>
--   
--   Now, indexing is executed immediately although the returned element is
--   still not evaluated.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArrayM :: Monad m => Array a -> Int -> m a

-- | Read a value from the immutable array at the given index, returning
--   the result in an unboxed unary tuple. This is currently used to
--   implement folds.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArray## :: Array a -> Int -> (# a #)

-- | Read a value from the immutable array at the given index.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArray :: Array a -> Int -> a

-- | Create a new mutable array of the specified size and initialise all
--   elements with the given value.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newArray :: PrimMonad m => Int -> a -> m (MutableArray (PrimState m) a)

-- | Boxed arrays.
data Array a
Array :: Array# a -> Array a
[array#] :: Array a -> Array# a
readArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> m a
writeArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> a -> m ()
copyArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> Array a -> Int -> Int -> m ()
copyMutableArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> MutableArray (PrimState m) a -> Int -> Int -> m ()
cloneMutableArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> Int -> m (MutableArray (PrimState m) a)
readByteArray :: forall a m. CheckCtx => PrimMonad m => Prim a => MutableByteArray (PrimState m) -> Int -> m a
writeByteArray :: forall a m. CheckCtx => PrimMonad m => Prim a => MutableByteArray (PrimState m) -> Int -> a -> m ()
indexByteArray :: forall a. CheckCtx => Prim a => ByteArray -> Int -> a
copyByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> ByteArray -> Int -> Int -> m ()
copyMutableByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> MutableByteArray (PrimState m) -> Int -> Int -> m ()
moveByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> MutableByteArray (PrimState m) -> Int -> Int -> m ()
readPrimArray :: CheckCtx => PrimMonad m => Prim a => MutablePrimArray (PrimState m) a -> Int -> m a
writePrimArray :: CheckCtx => PrimMonad m => Prim a => MutablePrimArray (PrimState m) a -> Int -> a -> m ()
indexPrimArray :: CheckCtx => Prim a => PrimArray a -> Int -> a

module Unison.Runtime.SparseVector
data SparseVector bits a
SparseVector :: !bits -> !Vector a -> SparseVector bits a
[$sel:indices:SparseVector] :: SparseVector bits a -> !bits
[$sel:elements:SparseVector] :: SparseVector bits a -> !Vector a
map :: (Unbox a, Unbox b) => (a -> b) -> SparseVector bits a -> SparseVector bits b
mask :: forall a bits. (Unbox a, FiniteBits bits) => bits -> SparseVector bits a -> SparseVector bits a
zipWith :: (Unbox a, Unbox b, Unbox c, FiniteBits bits) => (a -> b -> c) -> SparseVector bits a -> SparseVector bits b -> SparseVector bits c
_1 :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> SparseVector bits a
_2 :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> SparseVector bits b
unzip :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> (SparseVector bits a, SparseVector bits b)
choose :: (FiniteBits bits, Unbox a) => bits -> SparseVector bits a -> SparseVector bits a -> SparseVector bits a
merge :: forall a bits. (FiniteBits bits, Unbox a) => SparseVector bits a -> SparseVector bits a -> SparseVector bits a
eq :: a -> a -> Bool

module Unison.Runtime.Vector
data Vec a
[Scalar] :: a -> Vec a
[Vec] :: Unbox a => Vector a -> Vec a
[Pair] :: Vec a -> Vec b -> Vec (a, b)
[Choose] :: Vec Bool -> Vec a -> Vec a -> Vec a
[Mux] :: Vec Nat -> Vec (Vec a) -> Vec a
type Nat = Word64
mu :: Vec a -> Nat -> Maybe a
bound :: Nat -> Vec a -> Nat
toList :: Vec a -> [a]


-- | Types related to Share and Codeservers.
module Unison.Share.Types

-- | This type is expanded out into all of its fields because we require
--   certain pieces which are optional in a URI, and also to make it more
--   typesafe to eventually convert into a BaseURL for servant clients.
data CodeserverURI
CodeserverURI :: Scheme -> String -> String -> Maybe Int -> [String] -> CodeserverURI
[$sel:codeserverScheme:CodeserverURI] :: CodeserverURI -> Scheme
[$sel:codeserverUserInfo:CodeserverURI] :: CodeserverURI -> String
[$sel:codeserverRegName:CodeserverURI] :: CodeserverURI -> String
[$sel:codeserverPort:CodeserverURI] :: CodeserverURI -> Maybe Int
[$sel:codeserverPath:CodeserverURI] :: CodeserverURI -> [String]

-- | This is distinct from the codeserver URI in that we store credentials
--   by a normalized ID, since it's much easier to look up that way than
--   from an arbitrary path. We may wish to use explicitly named
--   configurations in the future. This currently uses a stringified
--   uriAuthority.
newtype CodeserverId
CodeserverId :: Text -> CodeserverId
[$sel:codeserverId:CodeserverId] :: CodeserverId -> Text
data Scheme
Http :: Scheme
Https :: Scheme

-- | <pre>
--   &gt;&gt;&gt; import Data.Maybe (fromJust)
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "http://localhost:8080"
--   Just http://localhost:8080
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "http://localhost:80"
--   Just http://localhost:80
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "https://share.unison-lang.org/api"
--   Just https://share.unison-lang.org/api
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "http://share.unison-lang.org/api"
--   Just http://share.unison-lang.org/api
--   </pre>
codeserverFromURI :: URI -> Maybe CodeserverURI

-- | Gets the part of the CodeserverURI that we use for identifying that
--   codeserver in credentials files.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Maybe (fromJust)
--   
--   &gt;&gt;&gt; import Network.URI (parseURI)
--   
--   &gt;&gt;&gt; codeserverIdFromURI (fromJust $ parseURI "http://localhost:5424/api")
--   
--   &gt;&gt;&gt; codeserverIdFromURI (fromJust $ parseURI "https://share.unison-lang.org/api")
--   Right "localhost:5424"
--   Right "share.unison-lang.org"
--   </pre>
codeserverIdFromURI :: URI -> Either Text CodeserverId
codeserverToURI :: CodeserverURI -> URI

-- | Gets the CodeserverId for a given CodeserverURI
codeserverIdFromCodeserverURI :: CodeserverURI -> CodeserverId

-- | Builds a servant-compatible BaseUrl for a given CodeserverURI.
codeserverBaseURL :: CodeserverURI -> BaseUrl
instance GHC.Show.Show Unison.Share.Types.Scheme
instance GHC.Classes.Ord Unison.Share.Types.Scheme
instance GHC.Classes.Eq Unison.Share.Types.Scheme
instance GHC.Classes.Ord Unison.Share.Types.CodeserverURI
instance GHC.Classes.Eq Unison.Share.Types.CodeserverURI
instance Data.Aeson.Types.FromJSON.FromJSONKey Unison.Share.Types.CodeserverId
instance Data.Aeson.Types.ToJSON.ToJSONKey Unison.Share.Types.CodeserverId
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Share.Types.CodeserverId
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Share.Types.CodeserverId
instance GHC.Classes.Ord Unison.Share.Types.CodeserverId
instance GHC.Classes.Eq Unison.Share.Types.CodeserverId
instance GHC.Show.Show Unison.Share.Types.CodeserverId
instance GHC.Show.Show Unison.Share.Types.CodeserverURI

module Unison.Codebase.Editor.RemoteRepo
data ReadRepo
ReadRepoGit :: ReadGitRepo -> ReadRepo
ReadRepoShare :: ShareCodeserver -> ReadRepo
data ShareCodeserver
DefaultCodeserver :: ShareCodeserver
CustomCodeserver :: CodeserverURI -> ShareCodeserver
newtype ShareUserHandle
ShareUserHandle :: Text -> ShareUserHandle
[$sel:shareUserHandleToText:ShareUserHandle] :: ShareUserHandle -> Text

-- | <pre>
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; import Data.Maybe (fromJust)
--   
--   &gt;&gt;&gt; import Network.URI
--   
--   &gt;&gt;&gt; displayShareCodeserver DefaultCodeserver "share" ["base", "List"]
--   "share.base.List"
--   
--   &gt;&gt;&gt; displayShareCodeserver DefaultCodeserver "share" []
--   "share"
--   
--   &gt;&gt;&gt; displayShareCodeserver (CustomCodeserver . fromJust $ parseURI "https://share-next.unison-lang.org/api" &gt;&gt;= codeserverFromURI ) "unison" ["base", "List"]
--   "share(https://share-next.unison-lang.org:443/api).unison.base.List"
--   </pre>
displayShareCodeserver :: ShareCodeserver -> ShareUserHandle -> Path -> Text
data ReadGitRepo
ReadGitRepo :: Text -> Maybe Text -> ReadGitRepo
[$sel:url:ReadGitRepo] :: ReadGitRepo -> Text
[$sel:ref:ReadGitRepo] :: ReadGitRepo -> Maybe Text
data WriteRepo
WriteRepoGit :: WriteGitRepo -> WriteRepo
WriteRepoShare :: ShareCodeserver -> WriteRepo
data WriteGitRepo
WriteGitRepo :: Text -> Maybe Text -> WriteGitRepo
[$sel:url:WriteGitRepo] :: WriteGitRepo -> Text
[$sel:branch:WriteGitRepo] :: WriteGitRepo -> Maybe Text
writeToRead :: WriteRepo -> ReadRepo
writeToReadGit :: WriteGitRepo -> ReadGitRepo
writePathToRead :: WriteRemotePath -> ReadRemoteNamespace
printReadGitRepo :: ReadGitRepo -> Text
printWriteGitRepo :: WriteGitRepo -> Text

-- | print remote namespace
printNamespace :: ReadRemoteNamespace -> Text

-- | Render a <a>WriteRemotePath</a> as text.
printWriteRemotePath :: WriteRemotePath -> Text
maybePrintPath :: Path -> Text
data ReadRemoteNamespace
ReadRemoteNamespaceGit :: ReadGitRemoteNamespace -> ReadRemoteNamespace
ReadRemoteNamespaceShare :: ReadShareRemoteNamespace -> ReadRemoteNamespace
data ReadGitRemoteNamespace
ReadGitRemoteNamespace :: ReadGitRepo -> Maybe ShortCausalHash -> Path -> ReadGitRemoteNamespace
[$sel:repo:ReadGitRemoteNamespace] :: ReadGitRemoteNamespace -> ReadGitRepo
[$sel:sch:ReadGitRemoteNamespace] :: ReadGitRemoteNamespace -> Maybe ShortCausalHash
[$sel:path:ReadGitRemoteNamespace] :: ReadGitRemoteNamespace -> Path
data ReadShareRemoteNamespace
ReadShareRemoteNamespace :: ShareCodeserver -> ShareUserHandle -> Path -> ReadShareRemoteNamespace
[$sel:server:ReadShareRemoteNamespace] :: ReadShareRemoteNamespace -> ShareCodeserver
[$sel:repo:ReadShareRemoteNamespace] :: ReadShareRemoteNamespace -> ShareUserHandle
[$sel:path:ReadShareRemoteNamespace] :: ReadShareRemoteNamespace -> Path
isPublic :: ReadShareRemoteNamespace -> Bool
data WriteRemotePath
WriteRemotePathGit :: WriteGitRemotePath -> WriteRemotePath
WriteRemotePathShare :: WriteShareRemotePath -> WriteRemotePath

-- | A lens which focuses the path of a remote path.
remotePath_ :: Lens' WriteRemotePath Path
data WriteGitRemotePath
WriteGitRemotePath :: WriteGitRepo -> Path -> WriteGitRemotePath
[$sel:repo:WriteGitRemotePath] :: WriteGitRemotePath -> WriteGitRepo
[$sel:path:WriteGitRemotePath] :: WriteGitRemotePath -> Path
data WriteShareRemotePath
WriteShareRemotePath :: ShareCodeserver -> ShareUserHandle -> Path -> WriteShareRemotePath
[$sel:server:WriteShareRemotePath] :: WriteShareRemotePath -> ShareCodeserver
[$sel:repo:WriteShareRemotePath] :: WriteShareRemotePath -> ShareUserHandle
[$sel:path:WriteShareRemotePath] :: WriteShareRemotePath -> Path
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ShareCodeserver
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.ShareCodeserver
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ShareCodeserver
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ShareUserHandle
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.ShareUserHandle
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ShareUserHandle
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ReadGitRepo
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.ReadGitRepo
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ReadGitRepo
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ReadRepo
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.ReadRepo
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ReadRepo
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.WriteGitRepo
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.WriteGitRepo
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.WriteGitRepo
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.WriteRepo
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.WriteRepo
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.WriteRepo
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ReadGitRemoteNamespace
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ReadGitRemoteNamespace
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ReadShareRemoteNamespace
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ReadShareRemoteNamespace
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ReadRemoteNamespace
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ReadRemoteNamespace
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.WriteGitRemotePath
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.WriteGitRemotePath
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.WriteShareRemotePath
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.WriteShareRemotePath
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.WriteRemotePath
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.WriteRemotePath

module Unison.Codebase.SqliteCodebase.GitError
data GitSqliteCodebaseError
GitCouldntParseRootBranchHash :: ReadGitRepo -> String -> GitSqliteCodebaseError
CodebaseFileLockFailed :: GitSqliteCodebaseError
NoDatabaseFile :: ReadGitRepo -> CodebasePath -> GitSqliteCodebaseError
UnrecognizedSchemaVersion :: ReadGitRepo -> CodebasePath -> SchemaVersion -> GitSqliteCodebaseError
CodebaseRequiresMigration :: SchemaVersion -> SchemaVersion -> GitSqliteCodebaseError
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.GitError.GitSqliteCodebaseError

module Unison.Codebase.GitError
type CodebasePath = FilePath
data GitProtocolError
NoGit :: GitProtocolError
UnrecognizableCacheDir :: ReadGitRepo -> CodebasePath -> GitProtocolError
UnrecognizableCheckoutDir :: ReadGitRepo -> CodebasePath -> GitProtocolError
CopyException :: FilePath -> FilePath -> String -> GitProtocolError
CloneException :: ReadGitRepo -> String -> GitProtocolError
PushException :: WriteGitRepo -> String -> GitProtocolError
PushNoOp :: WriteGitRepo -> GitProtocolError
PushDestinationHasNewStuff :: WriteGitRepo -> GitProtocolError
CleanupError :: SomeException -> GitProtocolError
RemoteRefNotFound :: Text -> Text -> GitProtocolError
data GitCodebaseError h
NoRemoteNamespaceWithHash :: ReadGitRepo -> ShortCausalHash -> GitCodebaseError h
RemoteNamespaceHashAmbiguous :: ReadGitRepo -> ShortCausalHash -> Set h -> GitCodebaseError h
CouldntLoadRootBranch :: ReadGitRepo -> h -> GitCodebaseError h
CouldntParseRemoteBranch :: ReadGitRepo -> String -> GitCodebaseError h
CouldntLoadSyncedBranch :: ReadGitRemoteNamespace -> h -> GitCodebaseError h
CouldntFindRemoteBranch :: ReadGitRepo -> Path -> GitCodebaseError h
instance GHC.Exception.Type.Exception Unison.Codebase.GitError.GitProtocolError
instance GHC.Show.Show Unison.Codebase.GitError.GitProtocolError
instance GHC.Show.Show h => GHC.Show.Show (Unison.Codebase.GitError.GitCodebaseError h)

module Unison.Codebase.Editor.Git

-- | Run a git command in the repository at localPath
gitIn :: MonadIO m => GitRepo -> [Text] -> m ()

-- | Run a git command in the repository at localPath and capture stdout
gitTextIn :: MonadIO m => GitRepo -> [Text] -> m Text

-- | like <a>gitIn</a>, but silences all output from the command and
--   returns whether the command succeeded.
gitInCaptured :: MonadIO m => GitRepo -> [Text] -> m (Bool, Text, Text)

-- | Clone or fetch an updated copy of the provided repository and check
--   out the expected ref, then provide the action with a path to the
--   codebase in that repository. Note that the repository provided to the
--   action is temporary, it will be removed when the action completes or
--   fails.
withRepo :: forall m a. MonadUnliftIO m => ReadGitRepo -> GitBranchBehavior -> (GitRepo -> m a) -> m (Either GitProtocolError a)

-- | Perform an IO action, passing any IO exception to <tt>handler</tt>
withIOError :: MonadIO m => IO a -> (IOException -> m a) -> m a
withStatus :: MonadIO m => String -> m a -> m a

-- | Run an action on an isolated copy of the provided repo. The repo is
--   deleted when the action exits or fails. A branch or tag to check out
--   from the source repo may be specified.
withIsolatedRepo :: forall m r. MonadUnliftIO m => GitRepo -> Text -> Maybe Text -> (GitRepo -> m r) -> m (Either GitProtocolError r)
debugGit :: Bool
gitDirToPath :: GitRepo -> FilePath
gitVerbosity :: [Text]

-- | Define what to do if the repo we're pulling/pushing doesn't have the
--   specified branch.
data GitBranchBehavior
CreateBranchIfMissing :: GitBranchBehavior
RequireExistingBranch :: GitBranchBehavior

-- | A path to a git repository.
data GitRepo
Bare :: FilePath -> GitRepo
Worktree :: FilePath -> GitRepo
gitCacheDir :: MonadIO m => Text -> m FilePath
instance GHC.Show.Show Unison.Codebase.Editor.Git.GitRepo

module Unison.Syntax.NamePrinter
type SyntaxText = SyntaxText' Reference
prettyName :: IsString s => Name -> Pretty s
prettyHashQualified :: HashQualified Name -> Pretty SyntaxText
prettyHashQualified' :: HashQualified Name -> Pretty SyntaxText
prettyHashQualified0 :: IsString s => HashQualified Name -> Pretty s

-- | Pretty-print a reference as a name and the given number of characters
--   of its hash.
prettyNamedReference :: Int -> Name -> Reference -> Pretty SyntaxText

-- | Pretty-print a referent as a name and the given number of characters
--   of its hash.
prettyNamedReferent :: Int -> Name -> Referent -> Pretty SyntaxText

-- | Pretty-print a reference as the given number of characters of its
--   hash.
prettyReference :: Int -> Reference -> Pretty SyntaxText

-- | Pretty-print a referent as the given number of characters of its hash.
prettyReferent :: Int -> Referent -> Pretty SyntaxText
prettyLabeledDependency :: Int -> LabeledDependency -> Pretty SyntaxText
prettyShortHash :: IsString s => ShortHash -> Pretty s
styleHashQualified :: IsString s => (Pretty s -> Pretty s) -> HashQualified Name -> Pretty s
styleHashQualified' :: IsString s => (Pretty s -> Pretty s) -> (Pretty s -> Pretty s) -> HashQualified Name -> Pretty s
styleHashQualified'' :: (Pretty SyntaxText -> Pretty SyntaxText) -> HashQualified Name -> Pretty SyntaxText
fmt :: Element r -> Pretty (SyntaxText' r) -> Pretty (SyntaxText' r)

module Unison.Typechecker.Components

-- | Algorithm for minimizing cycles of a `let rec`. This can improve
--   generalization during typechecking and may also be more efficient for
--   execution.
--   
--   For instance:
--   
--   minimize (let rec id x = x; g = id 42; y = id "hi" in g) ==&gt; Just
--   (let id x = x; g = id 42; y = id "hi" in g)
--   
--   Gets rid of the let rec and replaces it with an ordinary `let`, such
--   that <a>id</a> is suitably generalized.
--   
--   Fails on the left if there are duplicate definitions.
minimize :: Var v => Term' vt v a -> Either (NonEmpty (v, [a])) (Maybe (Term' vt v a))
minimize' :: Var v => Term' vt v a -> Either (NonEmpty (v, [a])) (Term' vt v a)

module Unison.Typechecker.TypeLookup
data TypeLookup v a
TypeLookup :: Map Reference (Type v a) -> Map Reference (DataDeclaration v a) -> Map Reference (EffectDeclaration v a) -> TypeLookup v a
[$sel:typeOfTerms:TypeLookup] :: TypeLookup v a -> Map Reference (Type v a)
[$sel:dataDecls:TypeLookup] :: TypeLookup v a -> Map Reference (DataDeclaration v a)
[$sel:effectDecls:TypeLookup] :: TypeLookup v a -> Map Reference (EffectDeclaration v a)
typeOfReferent :: TypeLookup v a -> Referent -> Maybe (Type v a)
unsafeConstructorType :: TypeLookup v a -> Reference -> ConstructorType
constructorType :: TypeLookup v a -> Reference -> Maybe ConstructorType
typeOfDataConstructor :: TypeLookup v a -> ConstructorReference -> Maybe (Type v a)
typeOfEffectConstructor :: TypeLookup v a -> ConstructorReference -> Maybe (Type v a)
typeOfTerm :: TypeLookup v a -> Reference -> Maybe (Type v a)
typeOfTerm' :: TypeLookup v a -> Reference -> Either Reference (Type v a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Semigroup (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Monoid (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Functor (Unison.Typechecker.TypeLookup.TypeLookup v)

module Unison.Typechecker.TypeVar
data TypeVar b v
Universal :: v -> TypeVar b v
Existential :: b -> v -> TypeVar b v
underlying :: TypeVar b v -> v
liftType :: Ord v => Type v a -> Type (TypeVar b v) a
lowerType :: Ord v => Type (TypeVar b v) a -> Type v a
liftTerm :: Ord v => Term v a -> Term' (TypeVar b v) v a
lowerTerm :: Ord v => Term' (TypeVar b v) v a -> Term v a
instance GHC.Base.Functor (Unison.Typechecker.TypeVar.TypeVar b)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Typechecker.TypeVar.TypeVar b v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Typechecker.TypeVar.TypeVar b v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.TypeVar.TypeVar b v)
instance U.Core.ABT.Var.Var v => U.Core.ABT.Var.Var (Unison.Typechecker.TypeVar.TypeVar b v)
instance Unison.Var.Var v => Unison.Var.Var (Unison.Typechecker.TypeVar.TypeVar b v)

module Unison.UnisonFile.Env
data Env v a
Env :: Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> Names -> Env v a
[$sel:datasId:Env] :: Env v a -> Map v (Id, DataDeclaration v a)
[$sel:effectsId:Env] :: Env v a -> Map v (Id, EffectDeclaration v a)
[$sel:names:Env] :: Env v a -> Names
datas :: Env v a -> Map v (Reference, DataDeclaration v a)

module Unison.UnisonFile.Type
data UnisonFile v a
UnisonFileId :: Map v (TermReferenceId, DataDeclaration v a) -> Map v (TermReferenceId, EffectDeclaration v a) -> [(v, Term v a)] -> Map WatchKind [(v, Term v a)] -> UnisonFile v a
[$sel:dataDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TermReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TermReferenceId, EffectDeclaration v a)
[$sel:terms:UnisonFileId] :: UnisonFile v a -> [(v, Term v a)]
[$sel:watches:UnisonFileId] :: UnisonFile v a -> Map WatchKind [(v, Term v a)]
pattern UnisonFile :: Map v (TypeReference, DataDeclaration v a) -> Map v (TypeReference, EffectDeclaration v a) -> [(v, Term v a)] -> Map WatchKind [(v, Term v a)] -> UnisonFile v a

-- | A UnisonFile after typechecking. Terms are split into groups by cycle
--   and the type of each term is known.
data TypecheckedUnisonFile v a
TypecheckedUnisonFileId :: Map v (TypeReferenceId, DataDeclaration v a) -> Map v (TypeReferenceId, EffectDeclaration v a) -> [[(v, Term v a, Type v a)]] -> [(WatchKind, [(v, Term v a, Type v a)])] -> Map v (TermReferenceId, Maybe WatchKind, Term v a, Type v a) -> TypecheckedUnisonFile v a
[$sel:dataDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, EffectDeclaration v a)
[$sel:topLevelComponents':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [[(v, Term v a, Type v a)]]
[$sel:watchComponents:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [(WatchKind, [(v, Term v a, Type v a)])]
[$sel:hashTermsId:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TermReferenceId, Maybe WatchKind, Term v a, Type v a)
pattern TypecheckedUnisonFile :: Map v (TypeReference, DataDeclaration v a) -> Map v (TypeReference, EffectDeclaration v a) -> [[(v, Term v a, Type v a)]] -> [(WatchKind, [(v, Term v a, Type v a)])] -> Map v (TermReference, Maybe WatchKind, Term (F v a a) v a, Term F v a) -> TypecheckedUnisonFile v a
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.UnisonFile.Type.UnisonFile v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.UnisonFile.Type.TypecheckedUnisonFile v a)
instance GHC.Generics.Generic (Unison.UnisonFile.Type.TypecheckedUnisonFile v a)
instance GHC.Classes.Ord v => GHC.Base.Functor (Unison.UnisonFile.Type.TypecheckedUnisonFile v)

module Unison.Util.Convert
class Convert a b
convert :: Convert a b => a -> b
class Parse a b
parse :: Parse a b => a -> Maybe b
instance (Unison.Util.Convert.Parse a a2, Unison.Util.Convert.Parse b b2) => Unison.Util.Convert.Parse (a, b) (a2, b2)

module Unison.Util.CycleTable
data CycleTable k v
CycleTable :: BasicHashTable k v -> IOPRef Int -> CycleTable k v
[$sel:table:CycleTable] :: CycleTable k v -> BasicHashTable k v
[$sel:sizeRef:CycleTable] :: CycleTable k v -> IOPRef Int
new :: Int -> IO (CycleTable k v)
lookup :: (Hashable k, Eq k) => k -> CycleTable k v -> IO (Maybe v)
insert :: (Hashable k, Eq k) => k -> v -> CycleTable k v -> IO ()
size :: CycleTable k v -> IO Int
insertEnd :: (Hashable k, Eq k) => k -> CycleTable k Int -> IO ()

module Unison.Util.CyclicEq
class CyclicEq a
cyclicEq :: CyclicEq a => CycleTable Int Int -> CycleTable Int Int -> a -> a -> IO Bool
bothEq' :: (Eq a, CyclicEq b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Bool
bothEq :: (CyclicEq a, CyclicEq b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Bool
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq [a]
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq (Data.Sequence.Internal.Seq a)
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq (Data.Vector.Vector a)

module Unison.Util.CyclicOrd
class CyclicOrd a
cyclicOrd :: CyclicOrd a => CycleTable Int Int -> CycleTable Int Int -> a -> a -> IO Ordering
bothOrd' :: (Ord a, CyclicOrd b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Ordering
bothOrd :: (CyclicOrd a, CyclicOrd b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Ordering
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd [a]
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd (Data.Sequence.Internal.Seq a)
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd (Data.Vector.Vector a)

module Unison.Util.EnumContainers
data EnumMap k a
data EnumSet k
class EnumKey k
keyToInt :: EnumKey k => k -> Int
intToKey :: EnumKey k => Int -> k
mapFromList :: EnumKey k => [(k, a)] -> EnumMap k a
setFromList :: EnumKey k => [k] -> EnumSet k
setToList :: EnumKey k => EnumSet k -> [k]
mapSingleton :: EnumKey k => k -> a -> EnumMap k a
setSingleton :: EnumKey k => k -> EnumSet k
mapInsert :: EnumKey k => k -> a -> EnumMap k a -> EnumMap k a
unionWith :: EnumKey k => (a -> a -> a) -> EnumMap k a -> EnumMap k a -> EnumMap k a
intersectionWith :: (a -> b -> c) -> EnumMap k a -> EnumMap k b -> EnumMap k c
hasKey :: EnumKey k => k -> EnumMap k a -> Bool
keys :: EnumKey k => EnumMap k a -> [k]
keysSet :: EnumKey k => EnumMap k a -> EnumSet k
restrictKeys :: EnumKey k => EnumMap k a -> EnumSet k -> EnumMap k a
withoutKeys :: EnumKey k => EnumMap k a -> EnumSet k -> EnumMap k a
member :: EnumKey k => k -> EnumSet k -> Bool
lookup :: EnumKey k => k -> EnumMap k a -> Maybe a
lookupWithDefault :: EnumKey k => a -> k -> EnumMap k a -> a
mapWithKey :: EnumKey k => (k -> a -> b) -> EnumMap k a -> EnumMap k b
foldMapWithKey :: EnumKey k => Monoid m => (k -> a -> m) -> EnumMap k a -> m
mapToList :: EnumKey k => EnumMap k a -> [(k, a)]
(!) :: EnumKey k => EnumMap k a -> k -> a
findMin :: EnumKey k => EnumSet k -> k
interverse :: Applicative f => (a -> b -> f c) -> EnumMap k a -> EnumMap k b -> f (EnumMap k c)
traverseSet_ :: Applicative f => EnumKey k => (k -> f ()) -> EnumSet k -> f ()
traverseWithKey :: Applicative f => EnumKey k => (k -> a -> f b) -> EnumMap k a -> f (EnumMap k b)
setSize :: EnumSet k -> Int
instance GHC.Base.Semigroup (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Base.Monoid (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Util.EnumContainers.EnumMap k a)
instance Data.Traversable.Traversable (Unison.Util.EnumContainers.EnumMap k)
instance Data.Foldable.Foldable (Unison.Util.EnumContainers.EnumMap k)
instance GHC.Base.Functor (Unison.Util.EnumContainers.EnumMap k)
instance GHC.Base.Semigroup (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Base.Monoid (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Classes.Ord (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Classes.Eq (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Show.Show (Unison.Util.EnumContainers.EnumSet k)
instance Unison.Util.EnumContainers.EnumKey GHC.Word.Word64
instance Unison.Util.EnumContainers.EnumKey GHC.Word.Word16

module Unison.Util.Exception
tryAny :: MonadIO m => IO a -> m (Either SomeException a)
catchAny :: IO a -> (SomeException -> IO a) -> IO a


-- | Small logging library. Typical usage, import qualified:
--   
--   import qualified Unison.Util.Logger as L
--   
--   do logger &lt;- L.atomic . L.atInfo . L.scope "worker" . L.toHandle $
--   stderr L.warn logger "WARNING!!!" L.debug logger "Debug message, will
--   be ignored" let logger2 = L.atDebug logger L.debug logger2 "Debug
--   message, will be printed" logger' &lt;- L.at L.warnLevel
module Unison.Util.Logger
type Level = Int
type Scope = [String]
data Logger
Logger :: !Scope -> (String -> String) -> !Level -> (String -> IO ()) -> Logger
[$sel:getScope:Logger] :: Logger -> !Scope
[$sel:prefix:Logger] :: Logger -> String -> String
[$sel:getLevel:Logger] :: Logger -> !Level
[$sel:raw:Logger] :: Logger -> String -> IO ()

-- | Ensure at most one message is logged at the same time
atomic :: Logger -> IO Logger
toHandle :: Handle -> Logger
toStandardError :: Logger
toStandardOut :: Logger
logHandleAt :: Logger -> Level -> Handle -> IO ()
logAt' :: Logger -> Level -> IO String -> IO ()
logAt :: Logger -> Level -> String -> IO ()
scope :: String -> Logger -> Logger
scope' :: [String] -> Logger -> Logger
logger :: (String -> IO ()) -> Logger
error :: Logger -> String -> IO ()
warn :: Logger -> String -> IO ()
info :: Logger -> String -> IO ()
debug :: Logger -> String -> IO ()
trace :: Logger -> String -> IO ()
error' :: Logger -> IO String -> IO ()
warn' :: Logger -> IO String -> IO ()
info' :: Logger -> IO String -> IO ()
debug' :: Logger -> IO String -> IO ()
trace' :: Logger -> IO String -> IO ()
errorLevel :: Level
warnLevel :: Level
infoLevel :: Level
debugLevel :: Level
traceLevel :: Level
at :: Level -> Logger -> Logger
atError :: Logger -> Logger
atWarn :: Logger -> Logger
atInfo :: Logger -> Logger
atDebug :: Logger -> Logger
atTrace :: Logger -> Logger
increment :: Logger -> Logger
decrement :: Logger -> Logger


-- | A utility type for saving memory in the presence of many duplicate
--   ByteStrings, etc. If you have data that may be a redundant duplicate,
--   try pinning it to a pin board, and use the result of that operation
--   instead.
--   
--   Without a pin board:
--   
--   x ───── "38dce848c8c829c62" y ───── "38dce848c8c829c62" z ─────
--   "d2518f260535b927b"
--   
--   With a pin board:
--   
--   x ───── "38dce848c8c829c62" ┄┄┄┄┄┐ y ────────┘ board z ─────
--   "d2518f260535b927b" ┄┄┄┄┄┘
--   
--   ... and after x is garbage collected:
--   
--   "38dce848c8c829c62" ┄┄┄┄┄┐ y ────────┘ board z ─────
--   "d2518f260535b927b" ┄┄┄┄┄┘
--   
--   ... and after y is garbage collected:
--   
--   board z ───── "d2518f260535b927b" ┄┄┄┄┄┘
module Unison.Util.PinBoard

-- | A "pin board" is a place to pin values; semantically, it's a set, but
--   differs in a few ways:
--   
--   <ul>
--   <li>Pinned values aren't kept alive by the pin board, they might be
--   garbage collected at any time.</li>
--   <li>If you try to pin a value that's already pinned (per its Eq
--   instance), the pinned one will be returned instead.</li>
--   <li>It has a small API: just <a>new</a> and <a>pin</a>.</li>
--   </ul>
data PinBoard a
new :: MonadIO m => m (PinBoard a)
pin :: forall a m. (Eq a, Hashable a, MonadIO m) => PinBoard a -> a -> m a
debugDump :: MonadIO m => (a -> Text) -> PinBoard a -> m ()
debugSize :: PinBoard a -> IO Int

module Unison.Util.Pretty.MegaParsec
prettyPrintParseError :: String -> ParseErrorBundle Text Void -> Pretty ColorText
showErrorFancy :: ShowErrorComponent e => ErrorFancy e -> String
showErrorItem :: ErrorItem (Token Text) -> String

module Unison.Util.RefPromise

-- | When performing compare-and-swaps, the <i>ticket</i> encapsulates
--   proof that a thread observed a specific previous value of a mutable
--   variable. It is provided in lieu of the "old" value to
--   compare-and-swap.
--   
--   Design note: <a>Ticket</a>s exist to hide objects from the GHC
--   compiler, which can normally perform many optimizations that change
--   pointer equality. A Ticket, on the other hand, is a first-class object
--   that can be handled by the user, but will not have its pointer
--   identity changed by compiler optimizations (but will of course, change
--   addresses during garbage collection).
data Ticket a

-- | A ticket contains or can get the usable Haskell value. This function
--   does just that.
peekTicket :: Ticket a -> a

-- | Ordinary processor load instruction (non-atomic, not implying any
--   memory barriers).
--   
--   The difference between this function and <a>readIORef</a>, is that it
--   returns a <i>ticket</i>, for use in future compare-and-swap
--   operations.
readForCAS :: IORef a -> IO (Ticket a)

-- | Performs a machine-level compare and swap (CAS) operation on an
--   <a>IORef</a>. Returns a tuple containing a <a>Bool</a> which is
--   <a>True</a> when a swap is performed, along with the most
--   <tt>current</tt> value from the <a>IORef</a>. Note that this differs
--   from the more common CAS behavior, which is to return the <i>old</i>
--   value before the CAS occured.
--   
--   The reason for the difference is the ticket API. This function always
--   returns the ticket that you should use in your next CAS attempt. In
--   case of success, this ticket corresponds to the <tt>new</tt> value
--   which you yourself installed in the <a>IORef</a>, whereas in the case
--   of failure it represents the preexisting value currently in the IORef.
--   
--   Note "compare" here means pointer equality in the sense of
--   <a>reallyUnsafePtrEquality#</a>. However, the ticket API absolves the
--   user of this module from needing to worry about the pointer equality
--   of their values, which in general requires reasoning about the details
--   of the Haskell implementation (GHC).
--   
--   By convention this function is strict in the "new" value argument.
--   This isn't absolutely necesary, but we think it's a bad habit to use
--   unevaluated thunks in this context.
casIORef :: IORef a -> Ticket a -> a -> IO (Bool, Ticket a)
data Promise a
newPromise :: IO (Promise a)
readPromise :: Promise a -> IO a
tryReadPromise :: Promise a -> IO (Maybe a)
writePromise :: Promise a -> a -> IO Bool

module Unison.Util.Star3
data Star3 fact d1 d2 d3
Star3 :: Set fact -> Relation fact d1 -> Relation fact d2 -> Relation fact d3 -> Star3 fact d1 d2 d3
[$sel:fact:Star3] :: Star3 fact d1 d2 d3 -> Set fact
[$sel:d1:Star3] :: Star3 fact d1 d2 d3 -> Relation fact d1
[$sel:d2:Star3] :: Star3 fact d1 d2 d3 -> Relation fact d2
[$sel:d3:Star3] :: Star3 fact d1 d2 d3 -> Relation fact d3
toList :: (Ord fact, Ord d1, Ord d2, Ord d3) => Star3 fact d1 d2 d3 -> [(fact, d1, d2, d3)]
difference :: (Ord fact, Ord d1, Ord d2, Ord d3) => Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
d23s :: (Ord fact, Ord d2, Ord d3) => Star3 fact d1 d2 d3 -> [(fact, d2, d3)]
d23s' :: (Ord fact, Ord d2, Ord d3) => Star3 fact d1 d2 d3 -> [(d2, d3)]
d12s :: (Ord fact, Ord d1, Ord d2) => Star3 fact d1 d2 d3 -> [(fact, d1, d2)]
d13s :: (Ord fact, Ord d1, Ord d3) => Star3 fact d1 d2 d3 -> [(fact, d1, d3)]
mapD1 :: (Ord fact, Ord d1, Ord d1a) => (d1 -> d1a) -> Star3 fact d1 d2 d3 -> Star3 fact d1a d2 d3
mapD2 :: (Ord fact, Ord d2, Ord d2a) => (d2 -> d2a) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2a d3
mapD3 :: (Ord fact, Ord d3, Ord d3a) => (d3 -> d3a) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3a
fromList :: (Ord fact, Ord d1, Ord d2, Ord d3) => [(fact, d1, d2, d3)] -> Star3 fact d1 d2 d3
selectFact :: (Ord fact, Ord d1, Ord d2, Ord d3) => Set fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
select1D3 :: (Ord fact, Ord d1, Ord d2, Ord d3) => d3 -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
selectD3 :: (Ord fact, Ord d1, Ord d2, Ord d3) => Set d3 -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
deletePrimaryD1 :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d1) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
lookupD1 :: (Ord fact, Ord d1) => d1 -> Star3 fact d1 d2 d3 -> Set fact
insertD1 :: (Ord fact, Ord d1) => (fact, d1) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
memberD1 :: (Ord fact, Ord d1) => (fact, d1) -> Star3 fact d1 d2 d3 -> Bool
memberD2 :: (Ord fact, Ord d2) => (fact, d2) -> Star3 fact d1 d2 d3 -> Bool
memberD3 :: (Ord fact, Ord d3) => (fact, d3) -> Star3 fact d1 d2 d3 -> Bool
insert :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d1, d2, d3) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
insertD23 :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d2, d3) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
deleteD3 :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d3) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
deleteD2 :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d2) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3

-- | Given a possibly-invalid Star3, which may contain the given fact in
--   its fact set that are not related to any d1, d2, or d3, return a valid
--   Star3, with this fact possibly removed.
garbageCollect :: Ord fact => fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
deleteFact :: (Ord fact, Ord d1, Ord d2, Ord d3) => Set fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
replaceFacts :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact -> fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3) -> Map fact fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
replaceFact :: (Ord fact, Ord d1, Ord d2, Ord d3) => fact -> fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
instance (GHC.Show.Show fact, GHC.Show.Show d1, GHC.Show.Show d2, GHC.Show.Show d3) => GHC.Show.Show (Unison.Util.Star3.Star3 fact d1 d2 d3)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2, GHC.Classes.Ord d3) => GHC.Classes.Ord (Unison.Util.Star3.Star3 fact d1 d2 d3)
instance (GHC.Classes.Eq fact, GHC.Classes.Eq d1, GHC.Classes.Eq d2, GHC.Classes.Eq d3) => GHC.Classes.Eq (Unison.Util.Star3.Star3 fact d1 d2 d3)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2, GHC.Classes.Ord d3) => GHC.Base.Semigroup (Unison.Util.Star3.Star3 fact d1 d2 d3)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2, GHC.Classes.Ord d3) => GHC.Base.Monoid (Unison.Util.Star3.Star3 fact d1 d2 d3)

module Unison.Codebase.Metadata
type Type = Reference
type Value = Reference
type Metadata = Map Type (Set Value)
type Star a n = Star3 a n Type (Type, Value)
type R4 a n = Relation4 a n Type Value
starToR4 :: (Ord r, Ord n) => Star r n -> Relation4 r n Type Value

-- | Flattens a Metadata.Star into a 4-tuple.
starToR4List :: Ord r => Star r n -> [(r, n, Type, Value)]
hasMetadata :: Ord a => a -> Type -> Value -> Star a n -> Bool
hasMetadataWithType' :: Ord a => a -> Type -> R4 a n -> Bool
hasMetadataWithType :: Ord a => a -> Type -> Star a n -> Bool
inserts :: (Ord a, Ord n) => [(a, Type, Value)] -> Star a n -> Star a n
insertWithMetadata :: (Ord a, Ord n) => (a, Metadata) -> Star a n -> Star a n
insert :: (Ord a, Ord n) => (a, Type, Value) -> Star a n -> Star a n
delete :: (Ord a, Ord n) => (a, Type, Value) -> Star a n -> Star a n
merge :: Metadata -> Metadata -> Metadata
append :: Metadata -> Metadata -> Metadata
empty :: Metadata
singleton :: Type -> Value -> Metadata
toRelation :: Star3 a n x y -> Relation a n

module Unison.Codebase.Branch.Type

-- | A Hash for a namespace itself, it doesn't incorporate any history.
type NamespaceHash m = HashFor (Branch0 m)
head :: Branch m -> Branch0 m
headHash :: Branch m -> CausalHash
namespaceHash :: Branch m -> NamespaceHash m

-- | A node in the Unison namespace hierarchy along with its history.
newtype Branch m
Branch :: UnwrappedBranch m -> Branch m
[$sel:_history:Branch] :: Branch m -> UnwrappedBranch m

-- | A node in the Unison namespace hierarchy.
--   
--   <a>$sel:_terms:Branch0</a> and <a>$sel:_types:Branch0</a> are the
--   declarations at this level. <a>$sel:_children:Branch0</a> are the
--   nodes one level below us. <a>$sel:_edits:Branch0</a> are the
--   <a>Patch</a>s stored at this node in the code.
--   
--   The remaining fields are derived from the four above. Please don't set
--   them manually; use Branch.empty0 or Branch.branch0 to construct them.
data Branch0 m
Branch0 :: Star Referent NameSegment -> Star Reference NameSegment -> Map NameSegment (Branch m) -> Map NameSegment (PatchHash, m Patch) -> Bool -> Relation Referent Name -> Relation Reference Name -> R4 Referent Name -> R4 Reference Name -> Set Path -> Map Name PatchHash -> Branch0 m
[$sel:_terms:Branch0] :: Branch0 m -> Star Referent NameSegment
[$sel:_types:Branch0] :: Branch0 m -> Star Reference NameSegment

-- | Note the <a>Branch</a> here, not <a>Branch0</a>. Every level in the
--   tree has a history.
[$sel:_children:Branch0] :: Branch0 m -> Map NameSegment (Branch m)
[$sel:_edits:Branch0] :: Branch0 m -> Map NameSegment (PatchHash, m Patch)

-- | True if a branch and its children have no definitions or edits in
--   them. (Computed recursively, and small enough to justify storing here
--   to avoid computing more than once.)
[$sel:isEmpty0:Branch0] :: Branch0 m -> Bool
[$sel:deepTerms:Branch0] :: Branch0 m -> Relation Referent Name
[$sel:deepTypes:Branch0] :: Branch0 m -> Relation Reference Name
[$sel:deepTermMetadata:Branch0] :: Branch0 m -> R4 Referent Name
[$sel:deepTypeMetadata:Branch0] :: Branch0 m -> R4 Reference Name
[$sel:deepPaths:Branch0] :: Branch0 m -> Set Path
[$sel:deepEdits:Branch0] :: Branch0 m -> Map Name PatchHash
history :: Iso' (Branch m) (UnwrappedBranch m)
edits :: Lens' (Branch0 m) (Map NameSegment (PatchHash, m Patch))
type Star r n = Star r n
type UnwrappedBranch m = Causal m (Branch0 m)
instance GHC.Classes.Ord (Unison.Codebase.Branch.Type.Branch m)
instance GHC.Classes.Eq (Unison.Codebase.Branch.Type.Branch m)
instance GHC.Classes.Eq (Unison.Codebase.Branch.Type.Branch0 m)


module Unison.Hashing.V2.Convert
type ResolutionResult v a r = Either Seq ResolutionFailure v a r
hashBranch0 :: Branch0 m -> Hash
hashCausal :: ContentAddressable e => e -> Set CausalHash -> (CausalHash, HashFor e)
hashDataDecls :: Var v => Map v (DataDeclaration v a) -> ResolutionResult v a [(v, Id, DataDeclaration v a)]
hashDecls :: Var v => Map v (Decl v a) -> ResolutionResult v a [(v, Id, Decl v a)]
hashPatch :: Patch -> Hash
hashClosedTerm :: Var v => Term v a -> Id
hashTermComponents :: forall v a. Var v => Map v (Term v a, Type v a) -> Map v (Id, Term v a, Type v a)

-- | This shouldn't be used when storing terms in the codebase, as it
--   doesn't incorporate the type into the hash. this should only be used
--   in cases where you just need a way to identify some terms that you
--   have, but won't be saving them.
hashTermComponentsWithoutTypes :: forall v a. Var v => Map v (Term v a) -> Map v (Id, Term v a)
typeToReference :: Var v => Type v a -> Reference
typeToReferenceMentions :: Var v => Type v a -> Set Reference

module Unison.Codebase.Causal
data Causal m e
pattern One :: CausalHash -> HashFor e -> e -> Causal m e
pattern Cons :: CausalHash -> HashFor e -> e -> (CausalHash, m (Causal m e)) -> Causal m e
pattern Merge :: CausalHash -> HashFor e -> e -> Map CausalHash (m (Causal m e)) -> Causal m e

-- | Focus the current head, keeping the hash up to date.
head_ :: ContentAddressable e => Lens' (Causal m e) e
one :: ContentAddressable e => e -> Causal m e
cons :: (Applicative m, ContentAddressable e) => e -> Causal m e -> Causal m e
consDistinct :: (Applicative m, Eq e, ContentAddressable e) => e -> Causal m e -> Causal m e
uncons :: Applicative m => Causal m e -> m (Maybe (e, Causal m e))
predecessors :: Causal m e -> Seq (m (Causal m e))
threeWayMerge :: forall m e. (Monad m, ContentAddressable e) => (Maybe e -> e -> e -> m e) -> Causal m e -> Causal m e -> m (Causal m e)
threeWayMerge' :: forall m e. (Monad m, ContentAddressable e) => (Causal m e -> Causal m e -> m (Maybe (Causal m e))) -> (Maybe e -> e -> e -> m e) -> Causal m e -> Causal m e -> m (Causal m e)
squashMerge' :: forall m e. (Monad m, ContentAddressable e, Eq e) => (Causal m e -> Causal m e -> m (Maybe (Causal m e))) -> (e -> m e) -> (Maybe e -> e -> e -> m e) -> Causal m e -> Causal m e -> m (Causal m e)
lca :: Monad m => Causal m e -> Causal m e -> m (Maybe (Causal m e))
stepDistinct :: (Applicative m, Eq e, ContentAddressable e) => (e -> e) -> Causal m e -> Causal m e
stepDistinctM :: (Applicative m, Functor n, Eq e, ContentAddressable e) => (e -> n e) -> Causal m e -> n (Causal m e)
transform :: Functor m => (forall a. m a -> n a) -> Causal m e -> Causal n e
unsafeMapHashPreserving :: forall m e e2. Functor m => (e -> e2) -> Causal m e -> Causal m e2
before :: Monad m => Causal m e -> Causal m e -> m Bool
beforeHash :: forall m e. Monad m => Word -> CausalHash -> Causal m e -> m Bool
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.Causal.FoldHistoryResult a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Codebase.Causal.FoldHistoryResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.Causal.FoldHistoryResult a)

module Unison.Codebase.Causal.FoldHistory
data FoldHistoryResult a
Satisfied :: a -> FoldHistoryResult a
Unsatisfied :: a -> FoldHistoryResult a
foldHistoryUntil :: forall m e a. Monad m => (a -> e -> (a, Bool)) -> a -> Causal m e -> m (FoldHistoryResult a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.Causal.FoldHistory.FoldHistoryResult a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Codebase.Causal.FoldHistory.FoldHistoryResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.Causal.FoldHistory.FoldHistoryResult a)

module Unison.Builtin.Decls
lookupDeclRef :: Text -> Reference
lookupEffectRef :: Text -> Reference
unitRef :: Reference
pairRef :: Reference
optionalRef :: Reference
eitherRef :: Reference
testResultRef :: Reference
linkRef :: Reference
docRef :: Reference
ioErrorRef :: Reference
stdHandleRef :: Reference
failureRef :: Reference
ioFailureRef :: Reference
tlsFailureRef :: Reference
arrayFailureRef :: Reference
exceptionRef :: Reference
tlsSignedCertRef :: Reference
tlsPrivateKeyRef :: Reference
isPropagatedRef :: Reference
isTestRef :: Reference
runtimeFailureRef :: Reference
arithmeticFailureRef :: Reference
miscFailureRef :: Reference
stmFailureRef :: Reference
fileModeRef :: Reference
filePathRef :: Reference
bufferModeRef :: Reference
seekModeRef :: Reference
seqViewRef :: Reference
pairCtorRef :: Referent
unitCtorRef :: Referent
constructorId :: Reference -> Text -> Maybe ConstructorId
noneId :: ConstructorId
someId :: ConstructorId
okConstructorId :: ConstructorId
failConstructorId :: ConstructorId
docBlobId :: ConstructorId
docLinkId :: ConstructorId
docSignatureId :: ConstructorId
docSourceId :: ConstructorId
docEvaluateId :: ConstructorId
docJoinId :: ConstructorId
linkTermId :: ConstructorId
linkTypeId :: ConstructorId
eitherRightId :: ConstructorId
eitherLeftId :: ConstructorId
isPropagatedConstructorId :: ConstructorId
isTestConstructorId :: ConstructorId
bufferModeNoBufferingId :: ConstructorId
bufferModeLineBufferingId :: ConstructorId
bufferModeBlockBufferingId :: ConstructorId
bufferModeSizedBlockBufferingId :: ConstructorId
seqViewEmpty :: ConstructorId
seqViewElem :: ConstructorId
okConstructorReferent :: Referent
failConstructorReferent :: Referent

-- | parse some builtin data types, and resolve their free variables using
--   | builtinTypes' and those types defined herein
builtinDataDecls :: [(Symbol, Id, DataDeclaration Symbol ())]
builtinEffectDecls :: [(Symbol, Id, EffectDeclaration Symbol ())]
pattern UnitRef :: Reference
pattern PairRef :: Reference
pattern EitherRef :: Reference
pattern OptionalRef :: Reference
pattern OptionalNone' :: Term (F typeVar typeAnn patternAnn) v a
pattern OptionalSome' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern TupleType' :: Var v => [Type v a] -> Type v a
pattern TupleTerm' :: [Term2 vt at ap v a] -> Term2 vt at ap v a
pattern TuplePattern :: [Pattern loc] -> Pattern loc
pattern EitherLeft' :: Term2 vt at ap v a -> Term2 vt at ap v a
pattern EitherRight' :: Term2 vt at ap v a -> Term2 vt at ap v a
pattern EitherLeftId :: ConstructorId
pattern EitherRightId :: ConstructorId
unLeftTerm :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a)
unRightTerm :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a)
pattern DocRef :: Reference
pattern DocJoin :: Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term (F typeVar typeAnn patternAnn) v a
pattern DocBlob :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern DocLink :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocSignature :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocEvaluate :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc :: Term (F typeVar typeAnn patternAnn) v a
pattern DocSignatureId :: ConstructorId
pattern DocBlobId :: ConstructorId
pattern DocLinkId :: ConstructorId
pattern DocSourceId :: ConstructorId
pattern DocEvaluateId :: ConstructorId
pattern DocJoinId :: ConstructorId
pattern LinkTermId :: ConstructorId
pattern LinkTypeId :: ConstructorId
pattern LinkRef :: Reference
pattern LinkTerm :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern LinkType :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
unitType :: Ord v => a -> Type v a
pairType :: Ord v => a -> Type v a
optionalType :: Ord v => a -> Type v a
testResultType :: Ord v => a -> Type v a
eitherType :: Ord v => a -> Type v a
ioErrorType :: Ord v => a -> Type v a
fileModeType :: Ord v => a -> Type v a
filePathType :: Ord v => a -> Type v a
bufferModeType :: Ord v => a -> Type v a
seekModeType :: Ord v => a -> Type v a
stdHandleType :: Ord v => a -> Type v a
failureType :: Ord v => a -> Type v a
exceptionType :: Ord v => a -> Type v a
tlsSignedCertType :: Var v => a -> Type v a
unitTerm :: Var v => a -> Term v a
tupleConsTerm :: (Ord v, Semigroup a) => Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
tupleTerm :: (Var v, Monoid a) => [Term v a] -> Term v a
forceTerm :: Var v => a -> a -> Term v a -> Term v a
delayTerm :: Var v => a -> Term v a -> Term v a
unTupleTerm :: Term2 vt at ap v a -> Maybe [Term2 vt at ap v a]
unTupleType :: Var v => Type v a -> Maybe [Type v a]
unTuplePattern :: Pattern loc -> Maybe [Pattern loc]
unUnitRef :: Reference -> Bool
unPairRef :: Reference -> Bool
unOptionalRef :: Reference -> Bool

module Unison.UnisonFile
data UnisonFile v a
UnisonFileId :: Map v (TermReferenceId, DataDeclaration v a) -> Map v (TermReferenceId, EffectDeclaration v a) -> [(v, Term v a)] -> Map WatchKind [(v, Term v a)] -> UnisonFile v a
[$sel:dataDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TermReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TermReferenceId, EffectDeclaration v a)
[$sel:terms:UnisonFileId] :: UnisonFile v a -> [(v, Term v a)]
[$sel:watches:UnisonFileId] :: UnisonFile v a -> Map WatchKind [(v, Term v a)]
pattern UnisonFile :: Map v (TypeReference, DataDeclaration v a) -> Map v (TypeReference, EffectDeclaration v a) -> [(v, Term v a)] -> Map WatchKind [(v, Term v a)] -> UnisonFile v a
allWatches :: UnisonFile v a -> [(v, Term v a)]
dataDeclarations :: UnisonFile v a -> Map v (Reference, DataDeclaration v a)
declsToTypeLookup :: Var v => UnisonFile v a -> TypeLookup v a
dependencies :: (Monoid a, Var v) => UnisonFile v a -> Set Reference
effectDeclarations :: UnisonFile v a -> Map v (Reference, EffectDeclaration v a)
typecheckingTerm :: (Var v, Monoid a) => UnisonFile v a -> Term v a
watchesOfKind :: WatchKind -> UnisonFile v a -> [(v, Term v a)]

-- | A UnisonFile after typechecking. Terms are split into groups by cycle
--   and the type of each term is known.
data TypecheckedUnisonFile v a
TypecheckedUnisonFileId :: Map v (TypeReferenceId, DataDeclaration v a) -> Map v (TypeReferenceId, EffectDeclaration v a) -> [[(v, Term v a, Type v a)]] -> [(WatchKind, [(v, Term v a, Type v a)])] -> Map v (TermReferenceId, Maybe WatchKind, Term v a, Type v a) -> TypecheckedUnisonFile v a
[$sel:dataDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, EffectDeclaration v a)
[$sel:topLevelComponents':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [[(v, Term v a, Type v a)]]
[$sel:watchComponents:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [(WatchKind, [(v, Term v a, Type v a)])]
[$sel:hashTermsId:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TermReferenceId, Maybe WatchKind, Term v a, Type v a)

-- | A mapping of all terms in the file by their var name. The returned
--   terms refer to other definitions in the file by their var, not by
--   reference. Includes test watches.
allTerms :: Ord v => TypecheckedUnisonFile v a -> Map v (Term v a)
dataDeclarations' :: TypecheckedUnisonFile v a -> Map v (Reference, DataDeclaration v a)
discardTypes :: TypecheckedUnisonFile v a -> UnisonFile v a
effectDeclarations' :: TypecheckedUnisonFile v a -> Map v (Reference, EffectDeclaration v a)
hashConstructors :: forall v a. Ord v => TypecheckedUnisonFile v a -> Map v Id

-- | Returns the set of constructor names for decls whose names in the
--   given Set.
constructorsForDecls :: Ord v => Set v -> TypecheckedUnisonFile v a -> Set v
hashTerms :: TypecheckedUnisonFile v a -> Map v (Reference, Maybe WatchKind, Term v a, Type v a)
indexByReference :: TypecheckedUnisonFile v a -> (Map Id (Term v a, Type v a), Map Id (Decl v a))
lookupDecl :: Ord v => v -> TypecheckedUnisonFile v a -> Maybe (Id, Decl v a)
nonEmpty :: TypecheckedUnisonFile v a -> Bool
termSignatureExternalLabeledDependencies :: Ord v => TypecheckedUnisonFile v a -> Set LabeledDependency

-- | the top level components (no watches) plus test watches.
topLevelComponents :: TypecheckedUnisonFile v a -> [[(v, Term v a, Type v a)]]
typecheckedUnisonFile :: forall v a. Var v => Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> [[(v, Term v a, Type v a)]] -> [(WatchKind, [(v, Term v a, Type v a)])] -> TypecheckedUnisonFile v a

module Unison.UnisonFile.Names
toNames :: Var v => UnisonFile v a -> Names
typecheckedToNames :: Var v => TypecheckedUnisonFile v a -> Names
typecheckedUnisonFile0 :: Ord v => TypecheckedUnisonFile v a
bindNames :: Var v => Names -> UnisonFile v a -> ResolutionResult v a (UnisonFile v a)
environmentFor :: forall v a. Var v => Names -> Map v (DataDeclaration v a) -> Map v (EffectDeclaration v a) -> ResolutionResult v a (Either [Error v a] (Env v a))

module Unison.Codebase.CodeLookup.Util
fromTypecheckedUnisonFile :: forall m v a. (Var v, Monad m) => TypecheckedUnisonFile v a -> CodeLookup v m a

module Unison.Syntax.TypePrinter
pretty :: Var v => PrettyPrintEnv -> Type v a -> Pretty ColorText
pretty0 :: forall v a m. MonadPretty v m => Imports -> Int -> Type v a -> m (Pretty SyntaxText)
prettyRaw :: forall v a m. MonadPretty v m => Imports -> Int -> Type v a -> m (Pretty SyntaxText)
prettyStr :: Var v => Maybe Width -> PrettyPrintEnv -> Type v a -> String
prettySyntax :: Var v => PrettyPrintEnv -> Type v a -> Pretty SyntaxText
prettySignaturesST :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> [Pretty SyntaxText]
prettySignaturesCT :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> [Pretty ColorText]
prettySignaturesCTCollapsed :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> Pretty ColorText
prettySignaturesAlt :: Var v => PrettyPrintEnv -> [([HashQualified Name], Type v a)] -> Pretty ColorText
prettySignaturesAlt' :: Var v => PrettyPrintEnv -> [([HashQualified Name], Type v a)] -> [Pretty ColorText]
runPretty :: Var v => PrettyPrintEnv -> Reader (PrettyPrintEnv, Set v) a -> a

module Unison.Typechecker.Context

-- | public interface to the typechecker
synthesizeClosed :: (Var v, Ord loc) => [Type v loc] -> TypeLookup v loc -> Term v loc -> Result v loc (Type v loc)
data ErrorNote v loc
ErrorNote :: Cause v loc -> Seq (PathElement v loc) -> ErrorNote v loc
[$sel:cause:ErrorNote] :: ErrorNote v loc -> Cause v loc
[$sel:path:ErrorNote] :: ErrorNote v loc -> Seq (PathElement v loc)
data CompilerBug v loc
UnknownDecl :: Unknown -> Reference -> Map Reference (DataDeclaration v loc) -> CompilerBug v loc
UnknownConstructor :: Unknown -> ConstructorReference -> DataDeclaration v loc -> CompilerBug v loc
UndeclaredTermVariable :: v -> Context v loc -> CompilerBug v loc
RetractFailure :: Element v loc -> Context v loc -> CompilerBug v loc
EmptyLetRec :: Term v loc -> CompilerBug v loc
PatternMatchFailure :: CompilerBug v loc
EffectConstructorHadMultipleEffects :: Type v loc -> CompilerBug v loc
FreeVarsInTypeAnnotation :: Set (TypeVar v loc) -> CompilerBug v loc
UnannotatedReference :: Reference -> CompilerBug v loc
MalformedPattern :: Pattern loc -> CompilerBug v loc
UnknownTermReference :: Reference -> CompilerBug v loc
UnknownExistentialVariable :: v -> Context v loc -> CompilerBug v loc
IllegalContextExtension :: Context v loc -> Element v loc -> String -> CompilerBug v loc
OtherBug :: String -> CompilerBug v loc
data InfoNote v loc
SolvedBlank :: Recorded loc -> v -> Type v loc -> InfoNote v loc
Decision :: v -> loc -> Term v loc -> InfoNote v loc
TopLevelComponent :: [(v, Type v loc, RedundantTypeAnnotation)] -> InfoNote v loc
data Cause v loc
TypeMismatch :: Context v loc -> Cause v loc
IllFormedType :: Context v loc -> Cause v loc
UnknownSymbol :: loc -> v -> Cause v loc
UnknownTerm :: loc -> v -> [Suggestion v loc] -> Type v loc -> Cause v loc
AbilityCheckFailure :: [Type v loc] -> [Type v loc] -> Context v loc -> Cause v loc
AbilityEqFailure :: [Type v loc] -> [Type v loc] -> Context v loc -> Cause v loc
EffectConstructorWrongArgCount :: ExpectedArgCount -> ActualArgCount -> ConstructorReference -> Cause v loc
MalformedEffectBind :: Type v loc -> Type v loc -> [Type v loc] -> Cause v loc
PatternArityMismatch :: loc -> Type v loc -> Int -> Cause v loc
DuplicateDefinitions :: NonEmpty (v, [loc]) -> Cause v loc
UnguardedLetRecCycle :: [v] -> [(v, Term v loc)] -> Cause v loc
ConcatPatternWithoutConstantLength :: loc -> Type v loc -> Cause v loc
HandlerOfUnexpectedType :: loc -> Type v loc -> Cause v loc
DataEffectMismatch :: Unknown -> Reference -> DataDeclaration v loc -> Cause v loc
newtype Context v loc
Context :: [(Element v loc, Info v loc)] -> Context v loc
type ActualArgCount = Int
type ExpectedArgCount = Int
type ConstructorId = Word64

-- | Elements of an ordered algorithmic context
data Element v loc

-- | A variable declaration
Var :: TypeVar v loc -> Element v loc

-- | <tt>v</tt> is solved to some monotype
Solved :: Blank loc -> v -> Monotype v loc -> Element v loc

-- | <tt>v</tt> has type <tt>a</tt>, maybe quantified
Ann :: v -> Type v loc -> Element v loc

-- | used for scoping
Marker :: v -> Element v loc
data PathElement v loc
InSynthesize :: Term v loc -> PathElement v loc
InSubtype :: Type v loc -> Type v loc -> PathElement v loc
InEquate :: Type v loc -> Type v loc -> PathElement v loc
InCheck :: Term v loc -> Type v loc -> PathElement v loc
InInstantiateL :: v -> Type v loc -> PathElement v loc
InInstantiateR :: Type v loc -> v -> PathElement v loc
InSynthesizeApp :: Type v loc -> Term v loc -> Int -> PathElement v loc
InFunctionCall :: [v] -> Term v loc -> Type v loc -> [Term v loc] -> PathElement v loc
InAndApp :: PathElement v loc
InOrApp :: PathElement v loc
InIfCond :: PathElement v loc
InIfBody :: loc -> PathElement v loc
InVectorApp :: loc -> PathElement v loc
InMatch :: loc -> PathElement v loc
InMatchGuard :: PathElement v loc
InMatchBody :: PathElement v loc
type Term v loc = Term' (TypeVar v loc) v loc
type Type v loc = Type (TypeVar v loc) loc
type TypeVar v loc = TypeVar (Blank loc) v
data Result v loc a
Success :: !Seq (InfoNote v loc) -> !a -> Result v loc a
TypeError :: !NESeq (ErrorNote v loc) -> !Seq (InfoNote v loc) -> Result v loc a
CompilerBug :: !CompilerBug v loc -> !Seq (ErrorNote v loc) -> !Seq (InfoNote v loc) -> Result v loc a
errorTerms :: ErrorNote v loc -> [Term v loc]
innermostErrorTerm :: ErrorNote v loc -> Maybe (Term v loc)
lookupAnn :: Ord v => Context v loc -> v -> Maybe (Type v loc)
lookupSolved :: Ord v => Context v loc -> v -> Maybe (Monotype v loc)

-- | Replace any existentials with their solution in the context
apply :: (Var v, Ord loc) => Context v loc -> Type v loc -> Type v loc
isEqual :: (Var v, Ord loc) => Type v loc -> Type v loc -> Either (CompilerBug v loc) Bool
isSubtype :: (Var v, Ord loc) => Type v loc -> Type v loc -> Either (CompilerBug v loc) Bool
fitsScheme :: (Var v, Ord loc) => Type v loc -> Type v loc -> Either (CompilerBug v loc) Bool
isRedundant :: (Var v, Ord loc) => Type v loc -> Type v loc -> M v loc Bool
data Suggestion v loc
Suggestion :: Text -> Type v loc -> Either v Referent -> SuggestionMatch -> Suggestion v loc
[$sel:suggestionName:Suggestion] :: Suggestion v loc -> Text
[$sel:suggestionType:Suggestion] :: Suggestion v loc -> Type v loc
[$sel:suggestionReplacement:Suggestion] :: Suggestion v loc -> Either v Referent
[$sel:suggestionMatch:Suggestion] :: Suggestion v loc -> SuggestionMatch
data SuggestionMatch
Exact :: SuggestionMatch
WrongType :: SuggestionMatch
WrongName :: SuggestionMatch
isExact :: Suggestion v loc -> Bool
typeErrors :: Result v loc a -> Seq (ErrorNote v loc)
infoNotes :: Result v loc a -> Seq (InfoNote v loc)
data Unknown
Data :: Unknown
Effect :: Unknown
relax :: Var v => Ord loc => Type v loc -> Type v loc
generalizeAndUnTypeVar :: Var v => Type v a -> Type v a
instance GHC.Show.Show Unison.Typechecker.Context.Unknown
instance (GHC.Show.Show v, GHC.Show.Show loc) => GHC.Show.Show (Unison.Typechecker.Context.PathElement v loc)
instance GHC.Show.Show Unison.Typechecker.Context.SuggestionMatch
instance GHC.Classes.Eq Unison.Typechecker.Context.SuggestionMatch
instance GHC.Classes.Ord Unison.Typechecker.Context.SuggestionMatch
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.Context.Suggestion v loc)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Typechecker.Context.Suggestion v loc)
instance (GHC.Show.Show loc, GHC.Show.Show v) => GHC.Show.Show (Unison.Typechecker.Context.InfoNote v loc)
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.Cause v loc)
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.ErrorNote v loc)
instance (GHC.Show.Show loc, Unison.Var.Var v, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.CompilerBug v loc)
instance GHC.Base.Functor (Unison.Typechecker.Context.Result v loc)
instance GHC.Base.Functor f => GHC.Base.Functor (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => GHC.Base.Monad (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => Control.Monad.Fail.MonadFail (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => GHC.Base.Applicative (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => Control.Monad.State.Class.MonadState (Unison.Typechecker.Context.Env v loc) (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Applicative (Unison.Typechecker.Context.Result v loc)
instance GHC.Base.Monad (Unison.Typechecker.Context.Result v loc)
instance (GHC.Classes.Ord loc, Unison.Var.Var v) => GHC.Show.Show (Unison.Typechecker.Context.Context v loc)
instance (GHC.Classes.Ord loc, Unison.Var.Var v) => GHC.Classes.Eq (Unison.Typechecker.Context.Element v loc)
instance Unison.Var.Var v => GHC.Show.Show (Unison.Typechecker.Context.Element v loc)

module Unison.Typechecker.Extractor
type RedundantTypeAnnotation = Bool
type Extractor e a = MaybeT (Reader e) a
type ErrorExtractor v loc a = Extractor (ErrorNote v loc) a
type InfoExtractor v loc a = Extractor (InfoNote v loc) a
type PathExtractor v loc a = Extractor (PathElement v loc) a
type SubseqExtractor v loc a = SubseqExtractor' (ErrorNote v loc) a
extractor :: (e -> Maybe a) -> Extractor e a
extract :: Extractor e a -> e -> Maybe a
subseqExtractor :: (ErrorNote v loc -> [Ranged a]) -> SubseqExtractor v loc a
traceSubseq :: Show a => String -> SubseqExtractor' n a -> SubseqExtractor' n a
traceNote :: Show a => String -> ErrorExtractor v loc a -> ErrorExtractor v loc a
unique :: SubseqExtractor v loc a -> ErrorExtractor v loc a
data SubseqExtractor' n a
SubseqExtractor' :: (n -> [Ranged a]) -> SubseqExtractor' n a
[$sel:runSubseq:SubseqExtractor'] :: SubseqExtractor' n a -> n -> [Ranged a]
data Ranged a
Pure :: a -> Ranged a
Ranged :: a -> Int -> Int -> Ranged a
[$sel:get:Pure] :: Ranged a -> a
[$sel:start:Pure] :: Ranged a -> Int
[$sel:end:Pure] :: Ranged a -> Int

-- | collects the regions where <tt>xa</tt> doesn't match / aka invert a
--   set of intervals unused, but don't want to delete it yet - Aug 30,
--   2018
_no :: SubseqExtractor' n a -> SubseqExtractor' n ()
_any :: SubseqExtractor v loc ()
_any' :: (n -> Int) -> SubseqExtractor' n ()
data DistinctRanged a
DistinctRanged :: a -> Int -> Int -> DistinctRanged a
some :: forall n a. SubseqExtractor' n a -> SubseqExtractor' n [a]
pathStart :: SubseqExtractor' n ()
asPathExtractor :: (PathElement v loc -> Maybe a) -> SubseqExtractor v loc a
inSynthesize :: SubseqExtractor v loc (Term v loc)
inSubtype :: SubseqExtractor v loc (Type v loc, Type v loc)
inEquate :: SubseqExtractor v loc (Type v loc, Type v loc)
inCheck :: SubseqExtractor v loc (Term v loc, Type v loc)
inSynthesizeApp :: SubseqExtractor v loc (Type v loc, Term v loc, Int)
inFunctionCall :: SubseqExtractor v loc ([v], Term v loc, Type v loc, [Term v loc])
inAndApp :: SubseqExtractor v loc ()
inOrApp :: SubseqExtractor v loc ()
inIfCond :: SubseqExtractor v loc ()
inMatchGuard :: SubseqExtractor v loc ()
inMatchBody :: SubseqExtractor v loc ()
inMatch :: SubseqExtractor v loc loc
inVector :: SubseqExtractor v loc loc
inIfBody :: SubseqExtractor v loc loc
cause :: ErrorExtractor v loc (Cause v loc)
duplicateDefinitions :: ErrorExtractor v loc (NonEmpty (v, [loc]))
typeMismatch :: ErrorExtractor v loc (Context v loc)
illFormedType :: ErrorExtractor v loc (Context v loc)
unknownSymbol :: ErrorExtractor v loc (loc, v)
unknownTerm :: Var v => ErrorExtractor v loc (loc, v, [Suggestion v loc], Type v loc)
abilityCheckFailure :: ErrorExtractor v loc ([Type v loc], [Type v loc], Context v loc)
abilityEqFailure :: ErrorExtractor v loc ([Type v loc], [Type v loc], Context v loc)
effectConstructorWrongArgCount :: ErrorExtractor v loc (ExpectedArgCount, ActualArgCount, ConstructorReference)
malformedEffectBind :: ErrorExtractor v loc (Type v loc, Type v loc, [Type v loc])
solvedBlank :: InfoExtractor v loc (Recorded loc, v, Type v loc)
errorNote :: ErrorExtractor v loc (ErrorNote v loc)
infoNote :: InfoExtractor v loc (InfoNote v loc)
innermostTerm :: ErrorExtractor v loc (Term v loc)
path :: ErrorExtractor v loc [PathElement v loc]
topLevelComponent :: InfoExtractor v loc [(v, Type v loc, RedundantTypeAnnotation)]
instance GHC.Show.Show a => GHC.Show.Show (Unison.Typechecker.Extractor.Ranged a)
instance GHC.Base.Functor Unison.Typechecker.Extractor.Ranged
instance GHC.Classes.Eq (Unison.Typechecker.Extractor.DistinctRanged a)
instance GHC.Classes.Ord (Unison.Typechecker.Extractor.DistinctRanged a)
instance GHC.Base.Functor (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Applicative (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance Control.Monad.Fail.MonadFail (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Monad (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Alternative (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.MonadPlus (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Monoid (Unison.Typechecker.Extractor.SubseqExtractor' n a)
instance GHC.Base.Semigroup (Unison.Typechecker.Extractor.SubseqExtractor' n a)

module Unison.Typechecker.TypeError
data BooleanMismatch
CondMismatch :: BooleanMismatch
AndMismatch :: BooleanMismatch
OrMismatch :: BooleanMismatch
GuardMismatch :: BooleanMismatch
data ExistentialMismatch
IfBody :: ExistentialMismatch
ListBody :: ExistentialMismatch
CaseBody :: ExistentialMismatch
data TypeError v loc
Mismatch :: Type v loc -> Type v loc -> Type v loc -> Type v loc -> Term v loc -> ErrorNote v loc -> TypeError v loc
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:foundLeaf:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedLeaf:Mismatch] :: TypeError v loc -> Type v loc
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
BooleanMismatch :: BooleanMismatch -> Term v loc -> Type v loc -> ErrorNote v loc -> TypeError v loc
[$sel:getBooleanMismatch:Mismatch] :: TypeError v loc -> BooleanMismatch
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
ExistentialMismatch :: ExistentialMismatch -> Type v loc -> loc -> Type v loc -> Term v loc -> ErrorNote v loc -> TypeError v loc
[$sel:getExistentialMismatch:Mismatch] :: TypeError v loc -> ExistentialMismatch
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedLoc:Mismatch] :: TypeError v loc -> loc
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
FunctionApplication :: Term v loc -> Type v loc -> Term v loc -> Int -> Type v loc -> Type v loc -> Maybe (Type v loc, Type v loc) -> [(v, Type v loc)] -> ErrorNote v loc -> TypeError v loc
[$sel:f:Mismatch] :: TypeError v loc -> Term v loc
[$sel:ft:Mismatch] :: TypeError v loc -> Type v loc
[$sel:arg:Mismatch] :: TypeError v loc -> Term v loc
[$sel:argNum:Mismatch] :: TypeError v loc -> Int
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:leafs:Mismatch] :: TypeError v loc -> Maybe (Type v loc, Type v loc)
[$sel:solvedVars:Mismatch] :: TypeError v loc -> [(v, Type v loc)]
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
NotFunctionApplication :: Term v loc -> Type v loc -> ErrorNote v loc -> TypeError v loc
[$sel:f:Mismatch] :: TypeError v loc -> Term v loc
[$sel:ft:Mismatch] :: TypeError v loc -> Type v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
AbilityCheckFailure :: [Type v loc] -> [Type v loc] -> loc -> ErrorNote v loc -> TypeError v loc
[$sel:ambient:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:requested:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:abilityCheckFailureSite:Mismatch] :: TypeError v loc -> loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
AbilityEqFailure :: [Type v loc] -> [Type v loc] -> Type v loc -> Type v loc -> loc -> ErrorNote v loc -> TypeError v loc
[$sel:lhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:rhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:tlhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:trhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:abilityCheckFailureSite:Mismatch] :: TypeError v loc -> loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
AbilityEqFailureFromAp :: [Type v loc] -> [Type v loc] -> Type v loc -> Type v loc -> Term v loc -> Term v loc -> ErrorNote v loc -> TypeError v loc
[$sel:lhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:rhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:tlhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:trhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
UnguardedLetRecCycle :: [v] -> [loc] -> ErrorNote v loc -> TypeError v loc
[$sel:cycle:Mismatch] :: TypeError v loc -> [v]
[$sel:cycleLocs:Mismatch] :: TypeError v loc -> [loc]
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
UnknownType :: v -> loc -> ErrorNote v loc -> TypeError v loc
[$sel:unknownTypeV:Mismatch] :: TypeError v loc -> v
[$sel:typeSite:Mismatch] :: TypeError v loc -> loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
UnknownTerm :: v -> loc -> [Suggestion v loc] -> Type v loc -> ErrorNote v loc -> TypeError v loc
[$sel:unknownTermV:Mismatch] :: TypeError v loc -> v
[$sel:termSite:Mismatch] :: TypeError v loc -> loc
[$sel:suggestions:Mismatch] :: TypeError v loc -> [Suggestion v loc]
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
DuplicateDefinitions :: NonEmpty (v, [loc]) -> ErrorNote v loc -> TypeError v loc
[$sel:defns:Mismatch] :: TypeError v loc -> NonEmpty (v, [loc])
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
Other :: ErrorNote v loc -> TypeError v loc
type RedundantTypeAnnotation = Bool
data TypeInfo v loc
TopLevelComponent :: [(v, Type v loc, RedundantTypeAnnotation)] -> TypeInfo v loc
[$sel:definitions:TopLevelComponent] :: TypeInfo v loc -> [(v, Type v loc, RedundantTypeAnnotation)]
type TypeNote v loc = Either (TypeError v loc) (TypeInfo v loc)
typeErrorFromNote :: (Ord loc, Show loc, Var v) => ErrorNote v loc -> TypeError v loc
typeInfoFromNote :: (Ord loc, Show loc, Var v) => InfoNote v loc -> Maybe (TypeInfo v loc)
allErrors :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
topLevelComponent :: InfoExtractor v a (TypeInfo v a)
abilityCheckFailure :: ErrorExtractor v a (TypeError v a)
abilityEqFailure :: ErrorExtractor v a (TypeError v a)
duplicateDefinitions :: ErrorExtractor v a (TypeError v a)
unknownType :: ErrorExtractor v loc (TypeError v loc)
unknownTerm :: Var v => ErrorExtractor v loc (TypeError v loc)
generalMismatch :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
and :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
or :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
cond :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
matchGuard :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
unguardedCycle :: ErrorExtractor v loc (TypeError v loc)

-- | helper function to support <a>and</a> <i> <a>or</a> </i> <a>cond</a>
booleanMismatch0 :: (Var v, Ord loc) => BooleanMismatch -> SubseqExtractor v loc () -> ErrorExtractor v loc (TypeError v loc)
existentialMismatch0 :: (Var v, Ord loc) => ExistentialMismatch -> SubseqExtractor v loc loc -> ErrorExtractor v loc (TypeError v loc)
ifBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
listBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
matchBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
applyingNonFunction :: Var v => ErrorExtractor v loc (TypeError v loc)

-- | Want to collect this info: The <tt>n</tt>th argument to
--   <a>$sel:f:Mismatch</a> is <a>$sel:foundType:Mismatch</a>, but I was
--   expecting <a>$sel:expectedType:Mismatch</a>.
--   
--   30 | asdf asdf asdf
--   
--   If you're curious <a>$sel:f:Mismatch</a> has type <tt>blah</tt>, where
--   <tt>a</tt> was chosen as <tt>A</tt> <tt>b</tt> was chosen as
--   <tt>B</tt> <tt>c</tt> was chosen as <tt>C</tt> (many colors / groups)
applyingFunction :: forall v loc. Var v => ErrorExtractor v loc (TypeError v loc)
inSubtypes :: SubseqExtractor v loc (Type v loc, Type v loc, Maybe (Type v loc, Type v loc))
instance GHC.Show.Show Unison.Typechecker.TypeError.BooleanMismatch
instance GHC.Show.Show Unison.Typechecker.TypeError.ExistentialMismatch
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.TypeError.TypeError v loc)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.TypeError.TypeInfo v loc)

module Unison.Result
type Result notes = ResultT notes Identity
type ResultT notes f = MaybeT (WriterT notes f)
data Note v loc
Parsing :: Err v -> Note v loc
NameResolutionFailures :: [ResolutionFailure v loc] -> Note v loc
UnknownSymbol :: v -> loc -> Note v loc
TypeError :: ErrorNote v loc -> Note v loc
TypeInfo :: InfoNote v loc -> Note v loc
CompilerBug :: CompilerBug v loc -> Note v loc
data CompilerBug v loc
TopLevelComponentNotFound :: v -> Term v loc -> CompilerBug v loc
ResolvedNameNotFound :: v -> loc -> Name -> CompilerBug v loc
TypecheckerBug :: CompilerBug v loc -> CompilerBug v loc
result :: Result notes a -> Maybe a
pattern Result :: w -> Maybe a -> MaybeT (WriterT w Identity) a
isSuccess :: Functor f => ResultT note f a -> f Bool
isFailure :: Functor f => ResultT note f a -> f Bool
toMaybe :: Functor f => ResultT note f a -> f (Maybe a)
runResultT :: ResultT notes f a -> f (Maybe a, notes)
getResult :: Functor f => ResultT notes f a -> f (Result notes a)
toEither :: Functor f => ResultT notes f a -> ExceptT notes f a
tell1 :: Monad f => note -> ResultT (Seq note) f ()
fromParsing :: Monad f => Either (Err v) a -> ResultT (Seq (Note v loc)) f a
tellAndFail :: Monad f => note -> ResultT (Seq note) f a
compilerBug :: Monad f => CompilerBug v loc -> ResultT (Seq (Note v loc)) f a
hoist :: (Monad f, Monoid notes) => (forall a. f a -> g a) -> ResultT notes f b -> ResultT notes g b
instance (GHC.Show.Show loc, Unison.Var.Var v, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Result.CompilerBug v loc)
instance (GHC.Show.Show loc, Unison.Var.Var v, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Result.Note v loc)


-- | This module is the primary interface to the Unison typechecker module
--   Unison.Typechecker (admissibleTypeAt, check, check', checkAdmissible',
--   equals, locals, subtype, isSubtype, synthesize, synthesize', typeAt,
--   wellTyped) where
module Unison.Typechecker
type Name = Text
data Notes v loc
Notes :: Seq (CompilerBug v loc) -> Seq (ErrorNote v loc) -> Seq (InfoNote v loc) -> Notes v loc
[$sel:bugs:Notes] :: Notes v loc -> Seq (CompilerBug v loc)
[$sel:errors:Notes] :: Notes v loc -> Seq (ErrorNote v loc)
[$sel:infos:Notes] :: Notes v loc -> Seq (InfoNote v loc)
convertResult :: Result v loc a -> Result (Notes v loc) a
data NamedReference v loc
NamedReference :: Name -> Type v loc -> Either v Referent -> NamedReference v loc
[$sel:fqn:NamedReference] :: NamedReference v loc -> Name
[$sel:fqnType:NamedReference] :: NamedReference v loc -> Type v loc
[$sel:replacement:NamedReference] :: NamedReference v loc -> Either v Referent
data Env v loc
Env :: [Type v loc] -> TypeLookup v loc -> Map Name [NamedReference v loc] -> Env v loc
[$sel:_ambientAbilities:Env] :: Env v loc -> [Type v loc]
[$sel:_typeLookup:Env] :: Env v loc -> TypeLookup v loc
[$sel:_termsByShortname:Env] :: Env v loc -> Map Name [NamedReference v loc]
typeLookup :: forall v_a2VCq loc_a2VCr. Lens' (Env v_a2VCq loc_a2VCr) (TypeLookup v_a2VCq loc_a2VCr)
termsByShortname :: forall v_a2VCq loc_a2VCr. Lens' (Env v_a2VCq loc_a2VCr) (Map Name [NamedReference v_a2VCq loc_a2VCr])
ambientAbilities :: forall v_a2VCq loc_a2VCr. Lens' (Env v_a2VCq loc_a2VCr) [Type v_a2VCq loc_a2VCr]

-- | Infer the type of a <a>Term</a>, using a function to resolve the type
--   of <tt>Ref</tt> constructors contained in that term.
synthesize :: (Monad f, Var v, Ord loc) => Env v loc -> Term v loc -> ResultT (Notes v loc) f (Type v loc)
isSubtype :: Var v => Type v loc -> Type v loc -> Bool
handleCompilerBug :: Var v => Either (CompilerBug v ()) a -> a

-- | Similar to <a>isSubtype</a> but treats <tt>t2</tt> as a scheme where
--   the outermost variables are existential rather than universal.
--   
--   For example: <tt> let lhs = Unison.Type.ref ()
--   (Unison.Builtin.Decls.unitRef) rhs = Unison.Type.forall ()
--   (Unison.Var.named "x") (Unison.Type.var () (Unison.Var.named "x")) in
--   fitsScheme </tt>Symbol lhs rhs <tt> is </tt>True@ although the lhs is
--   not a subtype of the rhs.
--   
--   <a>fitsScheme</a> is used to check that runnable types are a subtype
--   of <tt> exists x. '{IO, Exception} x </tt>
fitsScheme :: Var v => Type v loc -> Type v loc -> Bool
isEqual :: Var v => Type v loc -> Type v loc -> Bool
type TDNR f v loc a = StateT (Term v loc) (ResultT (Notes v loc) f) a
data Resolution v loc
Resolution :: Text -> Type v loc -> loc -> [Suggestion v loc] -> Resolution v loc
[$sel:resolvedName:Resolution] :: Resolution v loc -> Text
[$sel:inferredType:Resolution] :: Resolution v loc -> Type v loc
[$sel:resolvedLoc:Resolution] :: Resolution v loc -> loc
[$sel:suggestions:Resolution] :: Resolution v loc -> [Suggestion v loc]

-- | Infer the type of a <a>Term</a>, using type-directed name resolution
--   to attempt to resolve unknown symbols.
synthesizeAndResolve :: (Monad f, Var v, Monoid loc, Ord loc) => Env v loc -> TDNR f v loc (Type v loc)
compilerBug :: CompilerBug v loc -> Result (Notes v loc) ()
typeError :: ErrorNote v loc -> Result (Notes v loc) ()
btw :: Monad f => InfoNote v loc -> ResultT (Notes v loc) f ()
liftResult :: Monad f => Result (Notes v loc) a -> TDNR f v loc a
typeDirectedNameResolution :: forall v loc f. (Monad f, Var v, Ord loc, Monoid loc) => Notes v loc -> Type v loc -> Env v loc -> TDNR f v loc (Type v loc)

-- | Check whether a term matches a type, using a function to resolve the
--   type of <tt>Ref</tt> constructors contained in the term. Returns
--   <tt>typ</tt> if successful, and a note about typechecking failure
--   otherwise.
check :: (Monad f, Var v, Ord loc) => Env v loc -> Term v loc -> Type v loc -> ResultT (Notes v loc) f (Type v loc)

-- | <tt>checkAdmissible</tt> e t` tests that `(f : t -&gt; r) e` is
--   well-typed. If <tt>t</tt> has quantifiers, these are moved outside, so
--   if `t : forall a . a`, this will check that `(f : forall a . a -&gt;
--   a) e` is well typed. checkAdmissible' :: Var v =&gt; Term v -&gt; Type
--   v -&gt; Either Note (Type v) checkAdmissible' term typ = synthesize'
--   (Term.blank() <a>ann_</a> tweak typ <a>app_</a> term) where tweak
--   (Type.ForallNamed' v body) = Type.forall() v (tweak body) tweak t =
--   Type.arrow() t t | Returns <a>True</a> if the expression is
--   well-typed, <a>False</a> otherwise
wellTyped :: (Monad f, Var v, Ord loc) => Env v loc -> Term v loc -> f Bool
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Notes v loc)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.NamedReference v loc)
instance GHC.Base.Semigroup (Unison.Typechecker.Notes v loc)
instance GHC.Base.Monoid (Unison.Typechecker.Notes v loc)

module Unison.Codebase.TermEdit.Typing
typing :: Var v => Type v loc -> Type v loc -> Typing

module Unison.Syntax.DeclPrinter
prettyDecl :: Var v => PrettyPrintEnvDecl -> Reference -> HashQualified Name -> Decl v a -> Pretty SyntaxText
prettyDeclHeader :: Var v => HashQualified Name -> Either (EffectDeclaration v a) (DataDeclaration v a) -> Pretty SyntaxText
prettyDeclOrBuiltinHeader :: Var v => HashQualified Name -> DeclOrBuiltin v a -> Pretty SyntaxText

module Unison.Syntax.TypeParser
type TypeP v = P v (Type v Ann)
valueType :: Var v => TypeP v
computationType :: Var v => TypeP v
valueTypeLeaf :: Var v => TypeP v
typeAtom :: Var v => TypeP v
type1 :: Var v => TypeP v
type2a :: Var v => TypeP v
delayed :: Var v => TypeP v
type2 :: Var v => TypeP v
effect :: Var v => TypeP v
effectList :: Var v => TypeP v
sequenceTyp :: Var v => TypeP v
tupleOrParenthesizedType :: Var v => TypeP v -> TypeP v
arrow :: Var v => TypeP v -> TypeP v
forall :: Var v => TypeP v -> TypeP v

module Unison.Syntax.TermPrinter
emptyAc :: AmbientContext
pretty :: Var v => PrettyPrintEnv -> Term v a -> Pretty ColorText
prettyBlock :: Var v => Bool -> PrettyPrintEnv -> Term v a -> Pretty ColorText
prettyBlock' :: Var v => Bool -> PrettyPrintEnv -> Term v a -> Pretty SyntaxText
pretty' :: Var v => Maybe Width -> PrettyPrintEnv -> Term v a -> ColorText

-- | Render a binding, producing output of the form
--   
--   foo : t -&gt; u foo a = ...
--   
--   The first line is only output if the term has a type annotation as the
--   outermost constructor.
--   
--   Binary functions with symbolic names are output infix, as follows:
--   
--   (+) : t -&gt; t -&gt; t a + b = ...
prettyBinding :: Var v => PrettyPrintEnv -> HashQualified Name -> Term2 v at ap v a -> Pretty SyntaxText
prettyBinding' :: Var v => PrettyPrintEnv -> Width -> HashQualified Name -> Term v a -> ColorText

-- | Like <a>prettyBinding</a>, but elides the type signature (if any).
prettyBindingWithoutTypeSignature :: Var v => PrettyPrintEnv -> HashQualified Name -> Term2 v at ap v a -> Pretty SyntaxText
pretty0 :: forall v m. MonadPretty v m => AmbientContext -> Term3 v PrintAnnotation -> m (Pretty SyntaxText)
runPretty :: Var v => PrettyPrintEnv -> Reader (PrettyPrintEnv, Set v) a -> a
instance GHC.Show.Show Unison.Syntax.TermPrinter.BlockContext
instance GHC.Classes.Eq Unison.Syntax.TermPrinter.BlockContext
instance GHC.Show.Show Unison.Syntax.TermPrinter.InfixContext
instance GHC.Classes.Eq Unison.Syntax.TermPrinter.InfixContext
instance GHC.Show.Show Unison.Syntax.TermPrinter.DocLiteralContext
instance GHC.Classes.Eq Unison.Syntax.TermPrinter.DocLiteralContext
instance GHC.Show.Show Unison.Syntax.TermPrinter.PrintAnnotation
instance GHC.Base.Semigroup Unison.Syntax.TermPrinter.PrintAnnotation
instance GHC.Base.Monoid Unison.Syntax.TermPrinter.PrintAnnotation

module Unison.Syntax.TermParser
watch :: Show a => String -> a -> a
type TermP v = P v (Term v Ann)
term :: Var v => TermP v
term2 :: Var v => TermP v
term3 :: Var v => TermP v
keywordBlock :: Var v => TermP v
typeLink' :: Var v => P v (Token Reference)
termLink' :: Var v => P v (Token Referent)
link' :: Var v => P v (Either (Token Reference) (Token Referent))
link :: Var v => TermP v
blockTerm :: Var v => TermP v
match :: Var v => TermP v
matchCases1 :: Var v => Token () -> P v (NonEmpty (Int, MatchCase Ann (Term v Ann)))
matchCase :: Var v => P v (Int, [MatchCase Ann (Term v Ann)])
parsePattern :: forall v. Var v => P v (Pattern Ann, [(Ann, v)])
lam :: Var v => TermP v -> TermP v
letBlock :: Var v => TermP v
handle :: Var v => TermP v
ifthen :: Var v => TermP v
checkCasesArities :: (Ord v, Annotated a) => NonEmpty (Int, a) -> P v (Int, NonEmpty a)
lamCase :: Var v => TermP v
text :: Var v => TermP v
char :: Var v => TermP v
boolean :: Var v => TermP v
list :: Var v => TermP v -> TermP v
hashQualifiedPrefixTerm :: Var v => TermP v
hashQualifiedInfixTerm :: Var v => TermP v
quasikeyword :: Ord v => String -> P v (Token ())
resolveHashQualified :: Var v => Token (HashQualified Name) -> TermP v
termLeaf :: forall v. Var v => TermP v
doc2Block :: forall v. Var v => TermP v
docBlock :: Var v => TermP v
data UnbreakCase
LineEnds :: UnbreakCase
StartsIndented :: UnbreakCase
StartsUnindented :: UnbreakCase
docNormalize :: (Ord v, Show v) => Term v a -> Term v a
delayQuote :: Var v => TermP v
delayBlock :: Var v => TermP v
bang :: Var v => TermP v
var :: Var v => Token v -> Term v Ann
seqOp :: Ord v => P v SeqOp
term4 :: Var v => TermP v
infixAppOrBooleanOp :: Var v => TermP v
typedecl :: Var v => P v (Token v, Type v Ann)
verifyRelativeVarName :: Var v => P v (Token v) -> P v (Token v)
verifyRelativeName :: Ord v => P v (Token Name) -> P v (Token Name)
verifyRelativeName' :: Ord v => Token Name -> P v ()
destructuringBind :: forall v. Var v => P v (Ann, Term v Ann -> Term v Ann)

-- | Rules for the annotation of the resulting binding is as follows: * If
--   the binding has a type signature, the top level scope of the
--   annotation for the type Ann node will contain the _entire_ binding,
--   including the type signature. * The body expression of the binding
--   contains the entire lhs (including the name of the binding) and the
--   entire body. * If the binding is a lambda, the lambda node includes
--   the entire LHS of the binding, including the name as well.
binding :: forall v. Var v => P v ((Ann, v), Term v Ann)
customFailure :: MonadParsec e s m => e -> m a
block :: forall v. Var v => String -> TermP v
importp :: Ord v => P v [(Name, Name)]
data BlockElement v
Binding :: ((Ann, v), Term v Ann) -> BlockElement v
DestructuringBind :: (Ann, Term v Ann -> Term v Ann) -> BlockElement v
Action :: Term v Ann -> BlockElement v
imports :: Var v => P v (NamesWithHistory, [(v, v)])
substImports :: Var v => NamesWithHistory -> [(v, v)] -> Term v Ann -> Term v Ann
block' :: Var v => IsTop -> String -> P v (Token ()) -> P v (Token ()) -> TermP v
block'' :: forall v b. Var v => IsTop -> Bool -> String -> P v (Token ()) -> P v b -> TermP v
number :: Var v => TermP v
bytes :: Var v => TermP v
number' :: Ord v => (Token Int64 -> a) -> (Token Word64 -> a) -> (Token Double -> a) -> P v a
tupleOrParenthesizedTerm :: Var v => TermP v
instance GHC.Show.Show Unison.Syntax.TermParser.UnbreakCase
instance GHC.Classes.Eq Unison.Syntax.TermParser.UnbreakCase
instance GHC.Show.Show v => GHC.Show.Show (Unison.Syntax.TermParser.BlockElement v)

module Unison.Syntax.FileParser
resolutionFailures :: Ord v => [ResolutionFailure v Ann] -> P v x
file :: forall v. Var v => P v (UnisonFile v Ann)

-- | Final validations and sanity checks to perform before finishing
--   parsing.
validateUnisonFile :: forall v. Var v => UnisonFile v Ann -> P v ()

-- | Because types and abilities can introduce their own constructors and
--   fields it's difficult to detect all duplicate terms during parsing
--   itself. Here we collect all terms and constructors and verify that no
--   duplicates exist in the file, triggering an error if needed.
checkForDuplicateTermsAndConstructors :: forall v. Ord v => UnisonFile v Ann -> P v ()
data Stanza v term
WatchBinding :: WatchKind -> Ann -> ((Ann, v), term) -> Stanza v term
WatchExpression :: WatchKind -> Text -> Ann -> term -> Stanza v term
Binding :: ((Ann, v), term) -> Stanza v term
Bindings :: [((Ann, v), term)] -> Stanza v term
getVars :: Var v => Stanza v term -> [v]
stanza :: Var v => P v (Stanza v (Term v Ann))
watched :: Var v => P v (WatchKind, Text, Ann)
type Accessors v = [(Token v, [(Token v, Type v Ann)])]
declarations :: Var v => P v (Map v (DataDeclaration v Ann), Map v (EffectDeclaration v Ann), Accessors v)
modifier :: Var v => P v (Maybe (Token Modifier))
declaration :: Var v => P v (Either (v, DataDeclaration v Ann, Accessors v) (v, EffectDeclaration v Ann))
dataDeclaration :: forall v. Var v => Maybe (Token Modifier) -> P v (v, DataDeclaration v Ann, Accessors v)
effectDeclaration :: Var v => Maybe (Token Modifier) -> P v (v, EffectDeclaration v Ann)
instance GHC.Base.Functor (Unison.Syntax.FileParser.Stanza v)
instance Data.Traversable.Traversable (Unison.Syntax.FileParser.Stanza v)
instance Data.Foldable.Foldable (Unison.Syntax.FileParser.Stanza v)

module Unison.PrintError
type Env = PrettyPrintEnv
pattern Code :: Color
pattern Type1 :: Color
pattern Type2 :: Color
pattern ErrorSite :: Color
pattern TypeKeyword :: Color
pattern AbilityKeyword :: Color
pattern Identifier :: Color
defaultWidth :: Width
structuralVsUniqueDocsLink :: IsString a => Pretty a
fromOverHere' :: Ord a => String -> [Maybe (Range, a)] -> [Maybe (Range, a)] -> Pretty (AnnotatedText a)
fromOverHere :: Ord a => String -> [(Range, a)] -> [(Range, a)] -> Pretty (AnnotatedText a)
showTypeWithProvenance :: (Var v, Annotated a, Ord style) => Env -> String -> style -> Type v a -> Pretty (AnnotatedText style)
styleAnnotated :: Annotated a => sty -> a -> Maybe (Range, sty)
style :: s -> String -> Pretty (AnnotatedText s)
stylePretty :: Color -> Pretty ColorText -> Pretty ColorText
describeStyle :: Color -> Pretty ColorText
renderTypeInfo :: forall v loc sty. (Var v, Annotated loc, Ord loc, Show loc) => TypeInfo v loc -> Env -> Pretty (AnnotatedText sty)
renderTypeError :: forall v loc. (Var v, Annotated loc, Ord loc, Show loc) => TypeError v loc -> Env -> String -> Absolute -> Pretty ColorText
renderCompilerBug :: (Var v, Annotated loc, Ord loc, Show loc) => Env -> String -> CompilerBug v loc -> Pretty ColorText
renderContext :: (Var v, Ord loc) => Env -> Context v loc -> Pretty (AnnotatedText a)
renderTerm :: (IsString s, Var v) => Env -> Term v loc -> s

-- | renders a type with no special styling
renderType' :: (IsString s, Var v) => Env -> Type v loc -> s

-- | <a>$sel:f:Mismatch</a> may do some styling based on <tt>loc</tt>. |
--   You can pass `(const id)` if no styling is needed, or call
--   <a>renderType</a>`.
renderType :: Var v => Env -> (loc -> Pretty (AnnotatedText a) -> Pretty (AnnotatedText a)) -> Type v loc -> Pretty (AnnotatedText a)
renderSuggestion :: (IsString s, Semigroup s, Var v) => Env -> Suggestion v loc -> s
spaces :: (IsString a, Monoid a) => (b -> a) -> [b] -> a
arrows :: (IsString a, Monoid a) => (b -> a) -> [b] -> a
commas :: (IsString a, Monoid a) => (b -> a) -> [b] -> a
renderVar :: (IsString a, Var v) => v -> a
renderVar' :: (Var v, Annotated a) => Env -> Context v a -> v -> String
prettyVar :: Var v => v -> Pretty ColorText
renderKind :: Kind -> Pretty (AnnotatedText a)
showTermRef :: IsString s => Env -> Referent -> s
showTypeRef :: IsString s => Env -> Reference -> s
showConstructor :: IsString s => Env -> ConstructorReference -> s
styleInOverallType :: (Var v, Annotated a, Eq a) => Env -> Type v a -> Type v a -> Color -> Pretty ColorText
_posToEnglish :: IsString s => Pos -> s
rangeForToken :: Token a -> Range
rangeToEnglish :: IsString s => Range -> s
annotatedToEnglish :: (Annotated a, IsString s) => a -> s
rangeForAnnotated :: Annotated a => a -> Maybe Range
showLexerOutput :: Bool
renderNoteAsANSI :: (Var v, Annotated a, Show a, Ord a) => Width -> Env -> String -> Absolute -> Note v a -> String
renderParseErrorAsANSI :: Var v => Width -> String -> Err v -> String
printNoteWithSource :: (Var v, Annotated a, Show a, Ord a) => Env -> String -> Absolute -> Note v a -> Pretty ColorText
_printPosRange :: String -> Pos -> Pos -> String
_printArrowsAtPos :: String -> Int -> Int -> String
pattern LexerError :: [Token Lexeme] -> Err -> Maybe (ErrorItem (Token Lexeme))
firstLexerError :: Foldable t => t (Token Lexeme) -> Maybe ([Token Lexeme], Err)
prettyParseError :: forall v. Var v => String -> Err v -> Pretty ColorText
renderParseErrors :: forall v. Var v => String -> Err v -> [(Pretty ColorText, [Range])]
annotatedAsErrorSite :: Annotated a => String -> a -> Pretty ColorText
annotatedAsStyle :: (Ord style, Annotated a) => style -> String -> a -> Pretty (AnnotatedText style)
annotatedsAsErrorSite :: Annotated a => String -> [a] -> Pretty ColorText
annotatedsAsStyle :: Annotated a => Color -> String -> [a] -> Pretty ColorText
annotatedsStartingLineAsStyle :: Annotated a => Color -> String -> [a] -> Pretty ColorText
tokenAsErrorSite :: String -> Token a -> Pretty ColorText
tokensAsErrorSite :: String -> [Token a] -> Pretty ColorText
showSourceMaybes :: Ord a => String -> [Maybe (Range, a)] -> Pretty (AnnotatedText a)
showSource :: Ord a => String -> [(Range, a)] -> Pretty (AnnotatedText a)
showSource1 :: Ord a => String -> (Range, a) -> Pretty (AnnotatedText a)
findTerm :: Seq (PathElement v loc) -> Maybe loc
prettyTypecheckError :: (Var v, Ord loc, Show loc, Annotated loc) => ErrorNote v loc -> Env -> String -> Absolute -> Pretty ColorText
prettyTypeInfo :: (Var v, Ord loc, Show loc, Annotated loc) => InfoNote v loc -> Env -> Pretty ColorText
intLiteralSyntaxTip :: Term v loc -> Type v loc -> Pretty ColorText

-- | Pretty prints resolution failure annotations, including a table of
--   disambiguation suggestions.
prettyResolutionFailures :: forall v a. (Annotated a, Var v, Ord a) => String -> [ResolutionFailure v a] -> Pretty ColorText
useExamples :: Pretty ColorText
prettyPath' :: Path' -> Pretty ColorText

module Unison.Codebase.Runtime
type Error = Pretty ColorText
type Term v = Term v ()
data Runtime v
Runtime :: IO () -> (CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error (Term v))) -> (CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)) -> Type v Ann -> Type v Ann -> Runtime v
[$sel:terminate:Runtime] :: Runtime v -> IO ()
[$sel:evaluate:Runtime] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error (Term v))
[$sel:compileTo:Runtime] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)
[$sel:mainType:Runtime] :: Runtime v -> Type v Ann
[$sel:ioTestType:Runtime] :: Runtime v -> Type v Ann
type IsCacheHit = Bool
noCache :: Id -> IO (Maybe (Term v))
type WatchResults v a = (Either Error ([(v, Term v)], Map v (a, WatchKind, Id, Term v, Term v, IsCacheHit)))
evaluateWatches :: forall v a. Var v => CodeLookup v IO a -> PrettyPrintEnv -> (Id -> IO (Maybe (Term v))) -> Runtime v -> TypecheckedUnisonFile v a -> IO (WatchResults v a)
evaluateTerm' :: (Var v, Monoid a) => CodeLookup v IO a -> (Id -> IO (Maybe (Term v))) -> PrettyPrintEnv -> Runtime v -> Term v a -> IO (Either Error (Term v))
evaluateTerm :: (Var v, Monoid a) => CodeLookup v IO a -> PrettyPrintEnv -> Runtime v -> Term v a -> IO (Either Error (Term v))


-- | Find a computation of type '{IO} () in the codebase.
module Unison.Codebase.MainTerm
data MainTerm v
NotAFunctionName :: String -> MainTerm v
NotFound :: String -> MainTerm v
BadType :: String -> Maybe (Type v Ann) -> MainTerm v
Success :: HashQualified Name -> Term v Ann -> Type v Ann -> MainTerm v
getMainTerm :: (Monad m, Var v) => (Reference -> m (Maybe (Type v Ann))) -> Names -> String -> Type v Ann -> m (MainTerm v)
builtinMain :: Var v => a -> Type v a
builtinMainWithResultType :: Var v => a -> Type v a -> Type v a
resultArr :: Ord v => a -> Type v a
builtinResultArr :: Ord v => a -> Type v a
builtinTest :: Ord v => a -> Type v a

module Unison.Builtin.Terms
builtinTermsRef :: Map Symbol Id
builtinTermsSrc :: a -> [(Symbol, Term Symbol a, Type Symbol a)]

module Unison.Builtin
codeLookup :: Applicative m => CodeLookup Symbol m Ann
constructorType :: Reference -> Maybe ConstructorType
names :: NamesWithHistory
names0 :: Names
builtinDataDecls :: [(Symbol, (Id, DataDeclaration))]
builtinEffectDecls :: [(Symbol, (Id, EffectDeclaration))]
builtinConstructorType :: Map Reference ConstructorType
builtinTypeDependents :: Reference -> Set Reference
builtinTypeDependentsOfComponent :: Hash -> Set Reference
builtinTypes :: [(Name, Reference)]
builtinTermsByType :: Relation Reference Referent
builtinTermsByTypeMention :: Relation Reference Referent
intrinsicTermReferences :: Set Reference
intrinsicTypeReferences :: Set Reference
isBuiltinType :: Reference -> Bool
typeOf :: a -> (Type -> a) -> Reference -> a
typeLookup :: TypeLookup Symbol Ann
termRefTypes :: Map Reference Type
instance GHC.Show.Show Unison.Builtin.BuiltinDSL

module Unison.Parsers
unsafeGetRightFrom :: (Var v, Show v) => String -> Either (Err v) a -> a
parse :: Var v => P v a -> String -> ParsingEnv -> Either (Err v) a
parseTerm :: Var v => String -> ParsingEnv -> Either (Err v) (Term v Ann)
parseType :: Var v => String -> ParsingEnv -> Either (Err v) (Type v Ann)
parseFile :: Var v => FilePath -> String -> ParsingEnv -> Either (Err v) (UnisonFile v Ann)
readAndParseFile :: Var v => ParsingEnv -> FilePath -> IO (Either (Err v) (UnisonFile v Ann))
unsafeParseTerm :: Var v => String -> ParsingEnv -> Term v Ann
unsafeReadAndParseFile :: ParsingEnv -> FilePath -> IO (UnisonFile Symbol Ann)
unsafeParseFileBuiltinsOnly :: FilePath -> IO (UnisonFile Symbol Ann)
unsafeParseFile :: String -> ParsingEnv -> UnisonFile Symbol Ann

module Unison.FileParsers
type Term v = Term v Ann
type Type v = Type v Ann
type UnisonFile v = UnisonFile v Ann
type Result' v = Result (Seq (Note v Ann))
debug :: Bool
convertNotes :: Ord v => Notes v ann -> Seq (Note v ann)
parseAndSynthesizeFile :: (Var v, Monad m) => [Type v] -> (Set Reference -> m (TypeLookup v Ann)) -> ParsingEnv -> FilePath -> Text -> ResultT (Seq (Note v Ann)) m (Either (UnisonFile v Ann) (TypecheckedUnisonFile v Ann))
type TDNRMap v = Map Name [NamedReference v Ann]
resolveNames :: (Var v, Monad m) => (Set Reference -> m (TypeLookup v Ann)) -> Names -> UnisonFile v -> ResultT (Seq (Note v Ann)) m (Term v, TDNRMap v, TypeLookup v Ann)
synthesizeFile' :: forall v. Var v => [Type v] -> TypeLookup v Ann -> UnisonFile v -> Result (Seq (Note v Ann)) (TypecheckedUnisonFile v Ann)
synthesizeFile :: forall v. Var v => [Type v] -> TypeLookup v Ann -> TDNRMap v -> UnisonFile v -> Term v -> Result (Seq (Note v Ann)) (TypecheckedUnisonFile v Ann)

module Unison.Runtime.IOSource
debug :: Bool
typecheckedFile :: TypecheckedUnisonFile Symbol Ann
typecheckedFile' :: TypecheckedUnisonFile Symbol Ann
typecheckedFileTerms :: Map Symbol Reference
termNamed :: String -> Reference
codeLookup :: CodeLookup Symbol Identity Ann
codeLookupM :: Applicative m => CodeLookup Symbol m Ann
typeNamedId :: String -> Id
typeNamed :: String -> Reference
abilityNamedId :: String -> Id
eitherReference :: Reference
optionReference :: Reference
isTestReference :: Reference
isPropagatedReference :: Reference
isTest :: (Reference, Reference)
isIOTest :: (Reference, Reference)
isPropagatedValue :: Reference
eitherLeftId :: ConstructorId
eitherRightId :: ConstructorId
someId :: ConstructorId
noneId :: ConstructorId
authorRef :: Reference
guidRef :: Reference
copyrightHolderRef :: Reference
doc2Ref :: Reference
doc2SpecialFormRef :: Reference
doc2TermRef :: Reference
prettyRef :: Reference
prettyAnnotatedRef :: Reference
ansiColorRef :: Reference
consoleTextRef :: Reference
pattern Doc2Ref :: Reference
doc2WordId :: ConstructorId
doc2CodeId :: ConstructorId
doc2CodeBlockId :: ConstructorId
doc2BoldId :: ConstructorId
doc2ItalicId :: ConstructorId
doc2StrikethroughId :: ConstructorId
doc2StyleId :: ConstructorId
doc2AnchorId :: ConstructorId
doc2BlockquoteId :: ConstructorId
doc2BlanklineId :: ConstructorId
doc2LinebreakId :: ConstructorId
doc2SectionBreakId :: ConstructorId
doc2TooltipId :: ConstructorId
doc2AsideId :: ConstructorId
doc2CalloutId :: ConstructorId
doc2TableId :: ConstructorId
doc2FoldedId :: ConstructorId
doc2ParagraphId :: ConstructorId
doc2BulletedListId :: ConstructorId
doc2NumberedListId :: ConstructorId
doc2SectionId :: ConstructorId
doc2NamedLinkId :: ConstructorId
doc2ImageId :: ConstructorId
doc2SpecialId :: ConstructorId
doc2JoinId :: ConstructorId
doc2UntitledSectionId :: ConstructorId
doc2ColumnId :: ConstructorId
doc2GroupId :: ConstructorId
doc2MediaSourceRef :: Reference
pattern Doc2MediaSourceRef :: Reference
doc2VideoRef :: Reference
pattern Doc2VideoRef :: Reference
doc2FrontMatterRef :: Reference
pattern Doc2FrontMatterRef :: Reference
doc2LaTeXInlineRef :: Reference
pattern Doc2LaTeXInlineRef :: Reference
doc2SvgRef :: Reference
pattern Doc2SvgRef :: Reference
pattern Doc2Word :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Code :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2CodeBlock :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Bold :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Italic :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Strikethrough :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Style :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Anchor :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Blockquote :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Blankline :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Linebreak :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SectionBreak :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Tooltip :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Aside :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Callout :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Table :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Folded :: Bool -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Paragraph :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2BulletedList :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2NumberedList :: Word64 -> [Term (F typeVar typeAnn patternAnn) v a] -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Section :: Term2 typeVar typeAnn patternAnn v a -> [Term (F typeVar typeAnn patternAnn) v a] -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2NamedLink :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Image :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Special :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Join :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2UntitledSection :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Column :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Group :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormRef :: Reference
doc2SpecialFormSourceId :: ConstructorId
doc2SpecialFormFoldedSourceId :: ConstructorId
doc2SpecialFormExampleId :: ConstructorId
doc2SpecialFormExampleBlockId :: ConstructorId
doc2SpecialFormLinkId :: ConstructorId
doc2SpecialFormSignatureId :: ConstructorId
doc2SpecialFormSignatureInlineId :: ConstructorId
doc2SpecialFormEvalId :: ConstructorId
doc2SpecialFormEvalInlineId :: ConstructorId
doc2SpecialFormEmbedId :: ConstructorId
doc2SpecialFormEmbedInlineId :: ConstructorId
pattern Doc2SpecialFormSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormFoldedSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormExample :: Word64 -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormExampleBlock :: Word64 -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormLink :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormSignature :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormSignatureInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEval :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEvalInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbed :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2MediaSource :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormEmbedVideo :: [Term (F typeVar typeAnn patternAnn) v a] -> [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedFrontMatter :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedLaTeXInline :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedSvg :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Example :: forall vt at ap v a. [v] -> Term2 vt at ap v a -> Term (F vt at ap) v a
pattern Doc2Term :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2TermRef :: Reference
pattern PrettyAnnotatedRef :: Reference
prettyEmptyId :: ConstructorId
prettyGroupId :: ConstructorId
prettyLitId :: ConstructorId
prettyWrapId :: ConstructorId
prettyOrElseId :: ConstructorId
prettyIndentId :: ConstructorId
prettyAppendId :: ConstructorId
prettyTableId :: ConstructorId
pattern PrettyEmpty :: Term (F typeVar typeAnn patternAnn) v a
pattern PrettyGroup :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyLit :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyWrap :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyIndent :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyOrElse :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyTable :: Term2 typeVar typeAnn patternAnn v a -> Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyAppend :: Term2 typeVar typeAnn patternAnn v a -> Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyRef :: Reference
prettyGetRef :: Reference
doc2FormatConsoleRef :: Reference
pattern AnsiColorRef :: Reference
ansiColorBlackId :: ConstructorId
pattern AnsiColorBlack :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorRed :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorGreen :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorYellow :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBlue :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorMagenta :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorCyan :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorWhite :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightBlack :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightRed :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightGreen :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightYellow :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightBlue :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightMagenta :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightCyan :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightWhite :: Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextRef :: Reference
consoleTextPlainId :: ConstructorId
consoleTextForegroundId :: ConstructorId
consoleTextBackgroundId :: ConstructorId
consoleTextBoldId :: ConstructorId
consoleTextUnderlineId :: ConstructorId
consoleTextInvertId :: ConstructorId
pattern ConsoleTextPlain :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextForeground :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern ConsoleTextBackground :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern ConsoleTextBold :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextUnderline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextInvert :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
constructorNamed :: Reference -> Text -> ConstructorId
constructorName :: Reference -> ConstructorId -> Text
source :: Text

module Unison.Codebase.SqliteCodebase.Branch.Dependencies
type Branches m = [(CausalHash, m (Branch m))]
data Dependencies
Dependencies :: Set PatchHash -> Set Hash -> Set Hash -> Dependencies
[$sel:patches:Dependencies] :: Dependencies -> Set PatchHash
[$sel:terms:Dependencies] :: Dependencies -> Set Hash
[$sel:decls:Dependencies] :: Dependencies -> Set Hash
data Dependencies'
Dependencies' :: [PatchHash] -> [Hash] -> [Hash] -> Dependencies'
[$sel:patches':Dependencies'] :: Dependencies' -> [PatchHash]
[$sel:terms':Dependencies'] :: Dependencies' -> [Hash]
[$sel:decls':Dependencies'] :: Dependencies' -> [Hash]
to' :: Dependencies -> Dependencies'
fromBranch :: Applicative m => Branch m -> (Branches m, Dependencies)
fromBranch0 :: Applicative m => Branch0 m -> (Branches m, Dependencies)
instance GHC.Base.Monoid Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Base.Semigroup Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Base.Monoid Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Base.Semigroup Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Classes.Eq Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'

module Unison.Codebase.RootBranchCache
data RootBranchCache
newEmptyRootBranchCache :: STM RootBranchCache
newEmptyRootBranchCacheIO :: MonadIO m => m RootBranchCache
fetchRootBranch :: forall m. MonadUnliftIO m => RootBranchCache -> m (Branch Transaction) -> m (Branch Transaction)

-- | Take a cache lock so that no other thread can read or write to the
--   cache, perform an action with the cached value, then restore the cache
--   to Empty or Full
withLock :: forall m r. MonadUnliftIO m => RootBranchCache -> ((forall x. m x -> m x) -> Maybe (Branch Transaction) -> m r) -> (r -> Maybe (Branch Transaction)) -> m r

module Unison.Codebase.Branch.Raw
type Star r n = Star r n
type EditHash = Hash
data Raw
Raw :: Star Referent NameSegment -> Star Reference NameSegment -> Map NameSegment Hash -> Map NameSegment EditHash -> Raw
[$sel:_termsR:Raw] :: Raw -> Star Referent NameSegment
[$sel:_typesR:Raw] :: Raw -> Star Reference NameSegment
[$sel:_childrenR:Raw] :: Raw -> Map NameSegment Hash
[$sel:_editsR:Raw] :: Raw -> Map NameSegment EditHash

module Unison.Codebase.Branch.BranchDiff
type Star r n = Star r n
data BranchDiff
BranchDiff :: Star Referent NameSegment -> Star Referent NameSegment -> Star Reference NameSegment -> Star Reference NameSegment -> Map NameSegment PatchDiff -> BranchDiff
[$sel:addedTerms:BranchDiff] :: BranchDiff -> Star Referent NameSegment
[$sel:removedTerms:BranchDiff] :: BranchDiff -> Star Referent NameSegment
[$sel:addedTypes:BranchDiff] :: BranchDiff -> Star Reference NameSegment
[$sel:removedTypes:BranchDiff] :: BranchDiff -> Star Reference NameSegment
[$sel:changedPatches:BranchDiff] :: BranchDiff -> Map NameSegment PatchDiff
diff0 :: Monad m => Branch0 m -> Branch0 m -> m BranchDiff
instance GHC.Show.Show Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Classes.Ord Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Classes.Eq Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Base.Semigroup Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Base.Monoid Unison.Codebase.Branch.BranchDiff.BranchDiff

module Unison.Codebase.Branch

-- | A node in the Unison namespace hierarchy along with its history.
newtype Branch m
Branch :: UnwrappedBranch m -> Branch m
[$sel:_history:Branch] :: Branch m -> UnwrappedBranch m
type UnwrappedBranch m = Causal m (Branch0 m)

-- | A node in the Unison namespace hierarchy.
--   
--   <a>$sel:_terms:Branch0</a> and <a>$sel:_types:Branch0</a> are the
--   declarations at this level. <a>$sel:_children:Branch0</a> are the
--   nodes one level below us. <a>$sel:_edits:Branch0</a> are the
--   <a>Patch</a>s stored at this node in the code.
--   
--   The remaining fields are derived from the four above. Please don't set
--   them manually; use Branch.empty0 or Branch.branch0 to construct them.
data Branch0 m
Branch0 :: Star Referent NameSegment -> Star Reference NameSegment -> Map NameSegment (Branch m) -> Map NameSegment (PatchHash, m Patch) -> Bool -> Relation Referent Name -> Relation Reference Name -> R4 Referent Name -> R4 Reference Name -> Set Path -> Map Name PatchHash -> Branch0 m
[$sel:_terms:Branch0] :: Branch0 m -> Star Referent NameSegment
[$sel:_types:Branch0] :: Branch0 m -> Star Reference NameSegment

-- | Note the <a>Branch</a> here, not <a>Branch0</a>. Every level in the
--   tree has a history.
[$sel:_children:Branch0] :: Branch0 m -> Map NameSegment (Branch m)
[$sel:_edits:Branch0] :: Branch0 m -> Map NameSegment (PatchHash, m Patch)

-- | True if a branch and its children have no definitions or edits in
--   them. (Computed recursively, and small enough to justify storing here
--   to avoid computing more than once.)
[$sel:isEmpty0:Branch0] :: Branch0 m -> Bool
[$sel:deepTerms:Branch0] :: Branch0 m -> Relation Referent Name
[$sel:deepTypes:Branch0] :: Branch0 m -> Relation Reference Name
[$sel:deepTermMetadata:Branch0] :: Branch0 m -> R4 Referent Name
[$sel:deepTypeMetadata:Branch0] :: Branch0 m -> R4 Reference Name
[$sel:deepPaths:Branch0] :: Branch0 m -> Set Path
[$sel:deepEdits:Branch0] :: Branch0 m -> Map Name PatchHash
data Raw
type Star r n = Star r n

-- | A Hash for a namespace itself, it doesn't incorporate any history.
type NamespaceHash m = HashFor (Branch0 m)
branch0 :: forall m. Star Referent NameSegment -> Star TypeReference NameSegment -> Map NameSegment (Branch m) -> Map NameSegment (PatchHash, m Patch) -> Branch0 m
one :: Branch0 m -> Branch m
cons :: Applicative m => Branch0 m -> Branch m -> Branch m
uncons :: Applicative m => Branch m -> m (Maybe (Branch0 m, Branch m))
empty :: Branch m
empty0 :: Branch0 m

-- | Discards the history of a Branch and its children, recursively
discardHistory :: Applicative m => Branch m -> Branch m

-- | Discards the history of a Branch0's children, recursively
discardHistory0 :: Applicative m => Branch0 m -> Branch0 m
transform :: Functor m => (forall a. m a -> n a) -> Branch m -> Branch n

-- | Checks whether a branch is empty AND has no history.
isEmpty :: Branch m -> Bool
isOne :: Branch m -> Bool
before :: Monad m => Branch m -> Branch m -> m Bool
lca :: Monad m => Branch m -> Branch m -> m (Maybe (Branch m))
history :: Iso' (Branch m) (UnwrappedBranch m)
head :: Branch m -> Branch0 m
headHash :: Branch m -> CausalHash
children :: Lens' (Branch0 m) (Map NameSegment (Branch m))
nonEmptyChildren :: Branch0 m -> Map NameSegment (Branch m)

-- | a version of <a>$sel:deepEdits:Branch0</a> that returns the `m Patch`
--   as well.
deepEdits' :: Branch0 m -> Map Name (PatchHash, m Patch)

-- | what does this do? —AI
toList0 :: Branch0 m -> [(Path, Branch0 m)]
namespaceStats :: Branch0 m -> NamespaceStats

-- | Perform an update over the current branch and create a new causal
--   step.
step :: Applicative m => (Branch0 m -> Branch0 m) -> Branch m -> Branch m

-- | Run a series of updates at specific locations, aggregating all changes
--   into a single causal step. History is managed according to
--   <a>UpdateStrategy</a>.
stepManyAt :: forall m f. (Monad m, Foldable f) => f (Path, Branch0 m -> Branch0 m) -> Branch m -> Branch m

-- | Run a series of updates at specific locations. History is managed
--   according to the <a>UpdateStrategy</a>
stepManyAtM :: (Monad m, Monad n, Foldable f) => f (Path, Branch0 m -> n (Branch0 m)) -> Branch m -> n (Branch m)
stepEverywhere :: Applicative m => (Branch0 m -> Branch0 m) -> Branch0 m -> Branch0 m

-- | Perform updates over many locations within a branch by batching up
--   operations on sub-branches as much as possible without affecting
--   semantics. This operation does not create any causal conses, the
--   operations are performed directly on the current head of the provided
--   branch and child branches. It's the caller's responsibility to apply
--   updates in history however they choose.
batchUpdates :: forall f m. (Monad m, Foldable f) => f (Path, Branch0 m -> Branch0 m) -> Branch0 m -> Branch0 m

-- | Batch many updates. This allows us to apply the updates while
--   minimizing redundant traversals. Semantics of operations are preserved
--   by ensuring that all updates will always see changes by updates before
--   them in the list.
--   
--   This method does not <a>step</a> any branches on its own, all causal
--   changes must be performed in the updates themselves, or this batch
--   update must be provided to 'stepManyAt(M)'.
batchUpdatesM :: forall m n f. (Monad m, Monad n, Foldable f) => f (Path, Branch0 m -> n (Branch0 m)) -> Branch0 m -> n (Branch0 m)
data UpdateStrategy

-- | Compress all changes into a single causal cons. The resulting branch
--   will have at most one new causal cons at each branch.
--   
--   Note that this does NOT allow updates to add histories at children.
--   E.g. if the root.editme branch has history: A -&gt; B -&gt; C and you
--   use <tt>makeSetBranch</tt> to update it to a new branch with history X
--   -&gt; Y -&gt; Z, CompressHistory will result in a history for
--   root.editme of: A -&gt; B -&gt; C -&gt; Z. A <tt>snapshot</tt> of the
--   most recent state of the updated branch is appended to the existing
--   history, if the new state is equal to the existing state, no new
--   history nodes are appended.
CompressHistory :: UpdateStrategy

-- | Preserves any history changes made within the update.
--   
--   Note that this allows you to clobber the history child branches if you
--   want. E.g. if the root.editme branch has history: A -&gt; B -&gt; C
--   and you use <tt>makeSetBranch</tt> to update it to a new branch with
--   history X -&gt; Y -&gt; Z, AllowRewritingHistory will result in a
--   history for root.editme of: X -&gt; Y -&gt; Z. The history of the
--   updated branch is replaced entirely.
AllowRewritingHistory :: UpdateStrategy
addTermName :: Referent -> NameSegment -> Metadata -> Branch0 m -> Branch0 m
addTypeName :: TypeReference -> NameSegment -> Metadata -> Branch0 m -> Branch0 m
deleteTermName :: Referent -> NameSegment -> Branch0 m -> Branch0 m
deleteTypeName :: TypeReference -> NameSegment -> Branch0 m -> Branch0 m
setChildBranch :: NameSegment -> Branch m -> Branch0 m -> Branch0 m
replacePatch :: Applicative m => NameSegment -> Patch -> Branch0 m -> Branch0 m
deletePatch :: NameSegment -> Branch0 m -> Branch0 m
getMaybePatch :: Applicative m => NameSegment -> Branch0 m -> m (Maybe Patch)
getPatch :: Applicative m => NameSegment -> Branch0 m -> m Patch
modifyPatches :: Monad m => NameSegment -> (Patch -> Patch) -> Branch0 m -> m (Branch0 m)
getAt :: Path -> Branch m -> Maybe (Branch m)
getAt' :: Path -> Branch m -> Branch m
getAt0 :: Path -> Branch0 m -> Branch0 m
modifyAt :: Applicative m => Path -> (Branch m -> Branch m) -> Branch m -> Branch m
modifyAtM :: forall n m. Functor n => Applicative m => Path -> (Branch m -> n (Branch m)) -> Branch m -> n (Branch m)

-- | Traverse the head branch of all direct children. The index of the
--   traversal is the name of that child branch according to the parent.
children0 :: IndexedTraversal' NameSegment (Branch0 m) (Branch0 m)
terms :: Lens' (Branch0 m) (Star Referent NameSegment)
types :: Lens' (Branch0 m) (Star TypeReference NameSegment)
edits :: Lens' (Branch0 m) (Map NameSegment (PatchHash, m Patch))
deepReferents :: Branch0 m -> Set Referent
deepTypeReferences :: Branch0 m -> Set TypeReference

-- | <tt>head <a>consBranchSnapshot</a> base</tt> Cons's the current state
--   of <tt>head</tt> onto <tt>base</tt> as-is. Consider whether you really
--   want this behaviour or the behaviour of <a>squashMerge</a> That is, it
--   does not perform any common ancestor detection, or change
--   reconciliation, it sets the current state of the base branch to the
--   new state as a new causal step (or returns the existing base if there
--   are no)
consBranchSnapshot :: forall m. Monad m => Branch m -> Branch m -> Branch m
instance GHC.Classes.Eq Unison.Codebase.Branch.ActionLocation
instance Control.Lens.Empty.AsEmpty (Unison.Codebase.Branch.Type.Branch m)
instance Unison.Hashing.ContentAddressable.ContentAddressable (Unison.Codebase.Branch.Type.Branch0 m)

module Unison.Codebase.Type

-- | Abstract interface to a user's codebase.
data Codebase m v a
Codebase :: (Id -> Transaction (Maybe (Term v a))) -> (Id -> Transaction (Maybe (Type v a))) -> (Id -> Transaction (Maybe (Decl v a))) -> (Reference -> m ConstructorType) -> (Id -> Term v a -> Type v a -> Transaction ()) -> (Hash -> [(Term v a, Type v a)] -> Transaction ()) -> (Id -> Decl v a -> Transaction ()) -> (Hash -> [Decl v a] -> Transaction ()) -> (Hash -> Transaction (Maybe [(Term v a, Type v a)])) -> m (Branch m) -> (Text -> Branch m -> m ()) -> (CausalHash -> m (Maybe (Branch m))) -> (Branch m -> m ()) -> (CodebasePath -> SyncMode -> Branch m -> m ()) -> (CodebasePath -> SyncMode -> Branch m -> m ()) -> (forall r. ReadGitRemoteNamespace -> GitBranchBehavior -> ((Branch m, CodebasePath) -> m r) -> m (Either GitError r)) -> (forall e. WriteGitRepo -> PushGitBranchOpts -> (Branch m -> m (Either e (Branch m))) -> m (Either GitError (Either e (Branch m)))) -> (WatchKind -> Id -> Transaction (Maybe (Term v a))) -> (Reference -> Transaction (Set Id)) -> (Reference -> Transaction (Set Id)) -> (ShortHash -> Transaction (Set Id)) -> (Path -> Maybe BranchHash -> BranchHash -> Transaction ()) -> (forall x. (Connection -> m x) -> m x) -> (forall x. (Connection -> IO x) -> IO x) -> Codebase m v a

-- | Get a user-defined term from the codebase.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>$sel:getTerm:Codebase</a>, and receive <tt>Nothing</tt>, per the
--   semantics of <a>$sel:putTerm:Codebase</a>.
[$sel:getTerm:Codebase] :: Codebase m v a -> Id -> Transaction (Maybe (Term v a))

-- | Get the type of a user-defined term.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>$sel:getTypeOfTermImpl:Codebase</a>, and receive <tt>Nothing</tt>,
--   per the semantics of <a>$sel:putTerm:Codebase</a>.
[$sel:getTypeOfTermImpl:Codebase] :: Codebase m v a -> Id -> Transaction (Maybe (Type v a))

-- | Get a type declaration.
--   
--   Note that it is possible to call
--   <a>$sel:putTypeDeclaration:Codebase</a>, then
--   <a>$sel:getTypeDeclaration:Codebase</a>, and receive <tt>Nothing</tt>,
--   per the semantics of <a>$sel:putTypeDeclaration:Codebase</a>.
[$sel:getTypeDeclaration:Codebase] :: Codebase m v a -> Id -> Transaction (Maybe (Decl v a))

-- | Get the type of a given decl.
[$sel:getDeclType:Codebase] :: Codebase m v a -> Reference -> m ConstructorType

-- | Enqueue the put of a user-defined term (with its type) into the
--   codebase, if it doesn't already exist. The implementation may choose
--   to delay the put until all of the term's (and its type's) references
--   are stored as well.
[$sel:putTerm:Codebase] :: Codebase m v a -> Id -> Term v a -> Type v a -> Transaction ()
[$sel:putTermComponent:Codebase] :: Codebase m v a -> Hash -> [(Term v a, Type v a)] -> Transaction ()

-- | Enqueue the put of a type declaration into the codebase, if it doesn't
--   already exist. The implementation may choose to delay the put until
--   all of the type declaration's references are stored as well.
[$sel:putTypeDeclaration:Codebase] :: Codebase m v a -> Id -> Decl v a -> Transaction ()
[$sel:putTypeDeclarationComponent:Codebase] :: Codebase m v a -> Hash -> [Decl v a] -> Transaction ()
[$sel:getTermComponentWithTypes:Codebase] :: Codebase m v a -> Hash -> Transaction (Maybe [(Term v a, Type v a)])

-- | Get the root branch.
[$sel:getRootBranch:Codebase] :: Codebase m v a -> m (Branch m)

-- | Like <a>$sel:putBranch:Codebase</a>, but also adjusts the root branch
--   pointer afterwards.
[$sel:putRootBranch:Codebase] :: Codebase m v a -> Text -> Branch m -> m ()
[$sel:getBranchForHashImpl:Codebase] :: Codebase m v a -> CausalHash -> m (Maybe (Branch m))

-- | Put a branch into the codebase, which includes its children, its
--   patches, and the branch itself, if they don't already exist.
--   
--   The terms and type declarations that a branch references must already
--   exist in the codebase.
[$sel:putBranch:Codebase] :: Codebase m v a -> Branch m -> m ()

-- | Copy a branch and all of its dependencies from the given codebase into
--   this one.
[$sel:syncFromDirectory:Codebase] :: Codebase m v a -> CodebasePath -> SyncMode -> Branch m -> m ()

-- | Copy a branch and all of its dependencies from this codebase into the
--   given codebase.
[$sel:syncToDirectory:Codebase] :: Codebase m v a -> CodebasePath -> SyncMode -> Branch m -> m ()
[$sel:viewRemoteBranch':Codebase] :: Codebase m v a -> forall r. ReadGitRemoteNamespace -> GitBranchBehavior -> ((Branch m, CodebasePath) -> m r) -> m (Either GitError r)

-- | Push the given branch to the given repo, and optionally set it as the
--   root branch.
[$sel:pushGitBranch:Codebase] :: Codebase m v a -> forall e. WriteGitRepo -> PushGitBranchOpts -> (Branch m -> m (Either e (Branch m))) -> m (Either GitError (Either e (Branch m)))

-- | <tt>getWatch k r</tt> returns watch result <tt>t</tt> that was
--   previously put by <tt>putWatch k r t</tt>.
[$sel:getWatch:Codebase] :: Codebase m v a -> WatchKind -> Id -> Transaction (Maybe (Term v a))

-- | Get the set of user-defined terms-or-constructors that have the given
--   type.
[$sel:termsOfTypeImpl:Codebase] :: Codebase m v a -> Reference -> Transaction (Set Id)

-- | Get the set of user-defined terms-or-constructors mention the given
--   type anywhere in their signature.
[$sel:termsMentioningTypeImpl:Codebase] :: Codebase m v a -> Reference -> Transaction (Set Id)

-- | Get the set of user-defined terms-or-constructors whose hash matches
--   the given prefix.
[$sel:termReferentsByPrefix:Codebase] :: Codebase m v a -> ShortHash -> Transaction (Set Id)
[$sel:updateNameLookup:Codebase] :: Codebase m v a -> Path -> Maybe BranchHash -> BranchHash -> Transaction ()

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
[$sel:withConnection:Codebase] :: Codebase m v a -> forall x. (Connection -> m x) -> m x

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
[$sel:withConnectionIO:Codebase] :: Codebase m v a -> forall x. (Connection -> IO x) -> IO x

-- | A directory that contains a codebase.
type CodebasePath = FilePath
data PushGitBranchOpts
PushGitBranchOpts :: GitPushBehavior -> SyncMode -> PushGitBranchOpts
[$sel:behavior:PushGitBranchOpts] :: PushGitBranchOpts -> GitPushBehavior
[$sel:syncMode:PushGitBranchOpts] :: PushGitBranchOpts -> SyncMode
data GitPushBehavior

-- | Don't set root, just sync entities.
GitPushBehaviorGist :: GitPushBehavior

-- | After syncing entities, do a fast-forward check, then set the root.
GitPushBehaviorFf :: GitPushBehavior

-- | After syncing entities, just set the root (force-pushy).
GitPushBehaviorForce :: GitPushBehavior
data GitError
GitProtocolError :: GitProtocolError -> GitError
GitCodebaseError :: GitCodebaseError CausalHash -> GitError
GitSqliteCodebaseError :: GitSqliteCodebaseError -> GitError
type SyncToDir m = CodebasePath -> SyncMode -> Branch m -> m ()

-- | Whether a codebase is local or remote.
data LocalOrRemote
Local :: LocalOrRemote
Remote :: LocalOrRemote
gitErrorFromOpenCodebaseError :: CodebasePath -> ReadGitRepo -> OpenCodebaseError -> GitSqliteCodebaseError
instance GHC.Classes.Ord Unison.Codebase.Type.LocalOrRemote
instance GHC.Classes.Eq Unison.Codebase.Type.LocalOrRemote
instance GHC.Show.Show Unison.Codebase.Type.LocalOrRemote
instance GHC.Show.Show Unison.Codebase.Type.GitError
instance GHC.Exception.Type.Exception Unison.Codebase.Type.GitError

module Unison.Codebase.SqliteCodebase.Branch.Cache

-- | A cache of <a>Branch</a> by <a>CausalHash</a>es.
data BranchCache m
BranchCache :: (CausalHash -> m (Maybe (Branch m))) -> (CausalHash -> Branch m -> m ()) -> BranchCache m
[$sel:lookupCachedBranch:BranchCache] :: BranchCache m -> CausalHash -> m (Maybe (Branch m))
[$sel:insertCachedBranch:BranchCache] :: BranchCache m -> CausalHash -> Branch m -> m ()

-- | Creates a <a>BranchCache</a> which uses weak references to only keep
--   branches in the cache for as long as they're reachable by something
--   else in the app.
--   
--   This means you don't need to worry about a Branch not being GC'd
--   because it's in the cache.
newBranchCache :: forall m. MonadIO m => m (BranchCache Transaction)

module Unison.Codebase.SqliteCodebase.Conversions
sch1to2 :: ShortCausalHash -> ShortCausalHash
decltype2to1 :: DeclType -> ConstructorType
decltype1to2 :: ConstructorType -> DeclType
watchKind1to2 :: WatchKind -> WatchKind
watchKind2to1 :: WatchKind -> WatchKind
term1to2 :: Hash -> Term Symbol Ann -> Term Symbol
term2to1 :: forall m. Monad m => Hash -> (Reference -> m ConstructorType) -> Term Symbol -> m (Term Symbol Ann)
termComponent1to2 :: Hash -> [(Term Symbol Ann, Type Symbol a)] -> [(Term Symbol, TypeT Symbol)]
decl2to1 :: Hash -> Decl Symbol -> Decl Symbol Ann
decl1to2 :: Hash -> Decl Symbol a -> Decl Symbol
symbol2to1 :: Symbol -> Symbol
symbol1to2 :: Symbol -> Symbol
shortHashSuffix1to2 :: Text -> Pos
rreference2to1 :: Hash -> Reference' Text (Maybe Hash) -> Reference
rreference1to2 :: Hash -> Reference -> Reference' Text (Maybe Hash)
rreferenceid2to1 :: Hash -> Id' (Maybe Hash) -> Id
rreferenceid1to2 :: Hash -> Id -> Id' (Maybe Hash)
branchHash1to2 :: NamespaceHash m -> BranchHash
branchHash2to1 :: forall m. BranchHash -> NamespaceHash m
reference2to1 :: Reference -> Reference
reference1to2 :: Reference -> Reference
referenceid1to2 :: Id -> Id
referenceid2to1 :: Id -> Id
rreferent2to1 :: Applicative m => Hash -> (Reference -> m ConstructorType) -> ReferentH -> m Referent
rreferent1to2 :: Hash -> Referent -> ReferentH
referent2to1 :: Applicative m => (Reference -> m ConstructorType) -> Referent -> m Referent
referent1to2 :: Referent -> Referent
referentid2to1 :: Applicative m => (Reference -> m ConstructorType) -> Id -> m Id
constructorType1to2 :: ConstructorType -> ConstructorType
constructorType2to1 :: ConstructorType -> ConstructorType
ttype2to1 :: Type Symbol -> Type Symbol Ann
dtype2to1 :: Hash -> Type Symbol -> Type Symbol Ann
type2to1' :: (r -> Reference) -> TypeR r Symbol -> Type Symbol Ann
dtype1to2 :: Hash -> Type Symbol a -> TypeD Symbol
ttype1to2 :: Type Symbol a -> TypeT Symbol
type1to2' :: (Reference -> r) -> Type Symbol a -> TypeR r Symbol

-- | forces loading v1 branches even if they may not exist
causalbranch2to1 :: Monad m => BranchCache m -> (Reference -> m ConstructorType) -> CausalBranch m -> m (Branch m)
causalbranch2to1' :: Monad m => BranchCache m -> (Reference -> m ConstructorType) -> CausalBranch m -> m (UnwrappedBranch m)
causalbranch1to2 :: forall m. Monad m => Branch m -> CausalBranch m
patch2to1 :: Patch -> Patch
patch1to2 :: Patch -> Patch
branch2to1 :: Monad m => BranchCache m -> (Reference -> m ConstructorType) -> Branch m -> m (Branch0 m)

-- | Generates a v1 short hash from a v2 referent. Also shortens the hash
--   to the provided length. If <a>Nothing</a>, it will include the full
--   length hash.
referent2toshorthash1 :: Maybe Int -> Referent -> ShortHash

-- | Generates a v1 short hash from a v2 reference. Also shortens the hash
--   to the provided length. If <a>Nothing</a>, it will include the full
--   length hash.
reference2toshorthash1 :: Maybe Int -> Reference -> ShortHash

module Unison.Codebase.BranchUtil

-- | Creates a branch containing all of the given names, with a single
--   history node.
fromNames :: Monad m => Names -> Branch m
getBranch :: Split -> Branch0 m -> Maybe (Branch m)
getTerm :: HQSplit -> Branch0 m -> Set Referent
getType :: HQSplit -> Branch0 m -> Set Reference
getTermMetadataAt :: (Path, a) -> Referent -> Branch0 m -> Metadata
getTypeMetadataAt :: (Path, a) -> Reference -> Branch0 m -> Metadata
getTermMetadataHQNamed :: (Path, HQSegment) -> Branch0 m -> R4 Referent NameSegment
getTypeMetadataHQNamed :: (Path, HQSegment) -> Branch0 m -> R4 Reference NameSegment
makeSetBranch :: Split -> Branch m -> (Path, Branch0 m -> Branch0 m)
makeAddTypeName :: Split -> Reference -> Metadata -> (Path, Branch0 m -> Branch0 m)
makeDeleteTypeName :: Split -> Reference -> (Path, Branch0 m -> Branch0 m)
makeAddTermName :: Split -> Referent -> Metadata -> (Path, Branch0 m -> Branch0 m)
makeDeleteTermName :: Split -> Referent -> (Path, Branch0 m -> Branch0 m)
makeDeletePatch :: Split -> (Path, Branch0 m -> Branch0 m)
makeReplacePatch :: Applicative m => Split -> Patch -> (Path, Branch0 m -> Branch0 m)

module Unison.Codebase.BranchDiff
data DiffType a
Create :: a -> DiffType a
Delete :: a -> DiffType a
Modify :: a -> DiffType a
data NamespaceSlice r
NamespaceSlice :: Relation r Name -> Relation3 r Name Value -> NamespaceSlice r
[$sel:names:NamespaceSlice] :: NamespaceSlice r -> Relation r Name
[$sel:metadata:NamespaceSlice] :: NamespaceSlice r -> Relation3 r Name Value
data DiffSlice r
DiffSlice :: Map Name (Set r, Set r) -> Relation r Name -> Relation r Name -> Map r (Set Name, Set Name) -> Relation3 r Name Value -> Relation3 r Name Value -> DiffSlice r
[$sel:tallnamespaceUpdates:DiffSlice] :: DiffSlice r -> Map Name (Set r, Set r)
[$sel:talladds:DiffSlice] :: DiffSlice r -> Relation r Name
[$sel:tallremoves:DiffSlice] :: DiffSlice r -> Relation r Name
[$sel:trenames:DiffSlice] :: DiffSlice r -> Map r (Set Name, Set Name)
[$sel:taddedMetadata:DiffSlice] :: DiffSlice r -> Relation3 r Name Value
[$sel:tremovedMetadata:DiffSlice] :: DiffSlice r -> Relation3 r Name Value
data BranchDiff
BranchDiff :: DiffSlice Referent -> DiffSlice Reference -> Map Name (DiffType PatchDiff) -> BranchDiff
[$sel:termsDiff:BranchDiff] :: BranchDiff -> DiffSlice Referent
[$sel:typesDiff:BranchDiff] :: BranchDiff -> DiffSlice Reference
[$sel:patchesDiff:BranchDiff] :: BranchDiff -> Map Name (DiffType PatchDiff)
diff0 :: forall m. Monad m => Branch0 m -> Branch0 m -> m BranchDiff
patchDiff :: forall m. Monad m => Branch0 m -> Branch0 m -> m (Map Name (DiffType PatchDiff))
deepr4ToSlice :: Ord r => Relation r Name -> R4 r Name -> NamespaceSlice r
computeSlices :: NamespaceSlice Referent -> NamespaceSlice Referent -> NamespaceSlice Reference -> NamespaceSlice Reference -> (DiffSlice Referent, DiffSlice Reference)
namespaceUpdates :: Ord r => DiffSlice r -> Map Name (Set r, Set r)
propagatedUpdates :: Ord r => DiffSlice r -> Map Name (Set r)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.BranchDiff.DiffType a)
instance GHC.Show.Show r => GHC.Show.Show (Unison.Codebase.BranchDiff.NamespaceSlice r)
instance GHC.Show.Show r => GHC.Show.Show (Unison.Codebase.BranchDiff.DiffSlice r)
instance GHC.Generics.Generic (Unison.Codebase.BranchDiff.DiffSlice r)
instance GHC.Show.Show Unison.Codebase.BranchDiff.BranchDiff
instance GHC.Generics.Generic Unison.Codebase.BranchDiff.BranchDiff

module Unison.Codebase.Branch.Names
findHistoricalHQs :: Monad m => Set (HashQualified Name) -> Branch m -> m (Set (HashQualified Name), Names)
findHistoricalRefs :: Monad m => Set LabeledDependency -> Branch m -> m (Set LabeledDependency, Names)
findHistoricalRefs' :: Monad m => Set Reference -> Branch m -> m (Set Reference, Names)
namesDiff :: Branch m -> Branch m -> Diff
toNames :: Branch0 m -> Names


-- | This module contains sqlite-specific operations on high-level
--   "parser-typechecker" types all in the Transaction monad.
--   
--   The Codebase record-of-functions wraps this functionality, and runs
--   each transaction to IO, so that the operations' are unified with
--   non-sqlite operations in the Codebase interface, like
--   <tt>appendReflog</tt>.
module Unison.Codebase.SqliteCodebase.Operations
data BufferEntry a
BufferEntry :: Maybe Word64 -> Map Pos a -> Set Hash -> Set Hash -> BufferEntry a
[$sel:beComponentTargetSize:BufferEntry] :: BufferEntry a -> Maybe Word64
[$sel:beComponent:BufferEntry] :: BufferEntry a -> Map Pos a
[$sel:beMissingDependencies:BufferEntry] :: BufferEntry a -> Set Hash
[$sel:beWaitingDependents:BufferEntry] :: BufferEntry a -> Set Hash
prettyBufferEntry :: Show a => Hash -> BufferEntry a -> String
type TermBufferEntry = BufferEntry (Term Symbol Ann, Type Symbol Ann)
type DeclBufferEntry = BufferEntry (Decl Symbol Ann)
getBuffer :: TVar (Map Hash (BufferEntry a)) -> Hash -> IO (BufferEntry a)
putBuffer :: TVar (Map Hash (BufferEntry a)) -> Hash -> BufferEntry a -> IO ()
removeBuffer :: TVar (Map Hash (BufferEntry a)) -> Hash -> IO ()
addBufferDependent :: Hash -> TVar (Map Hash (BufferEntry a)) -> Hash -> IO ()
tryFlushBuffer :: forall a. Show a => TVar (Map Hash (BufferEntry a)) -> (Hash -> [a] -> Transaction ()) -> (Hash -> Transaction ()) -> Hash -> Transaction ()
getTerm :: (Reference -> Transaction ConstructorType) -> Id -> Transaction (Maybe (Term Symbol Ann))
getDeclType :: Reference -> Transaction ConstructorType
expectDeclTypeById :: Id -> Transaction ConstructorType
getTypeOfTermImpl :: Id -> Transaction (Maybe (Type Symbol Ann))
getTermComponentWithTypes :: (Reference -> Transaction ConstructorType) -> Hash -> Transaction (Maybe [(Term Symbol Ann, Type Symbol Ann)])
getTypeDeclaration :: Id -> Transaction (Maybe (Decl Symbol Ann))
getDeclComponent :: Hash -> Transaction (Maybe [Decl Symbol Ann])
putTermComponent :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Hash -> [(Term Symbol Ann, Type Symbol Ann)] -> Transaction ()
putTerm :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Id -> Term Symbol Ann -> Type Symbol Ann -> Transaction ()
putTerm_ :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Id -> Term Symbol Ann -> Type Symbol Ann -> Transaction ()
tryFlushTermBuffer :: TVar (Map Hash TermBufferEntry) -> Hash -> Transaction ()
addDeclComponentTypeIndex :: ObjectId -> [[Type Symbol Ann]] -> Transaction ()
putTypeDeclarationComponent :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Hash -> [Decl Symbol Ann] -> Transaction ()
putTypeDeclaration :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Id -> Decl Symbol Ann -> Transaction ()
putTypeDeclaration_ :: TVar (Map Hash DeclBufferEntry) -> Id -> Decl Symbol Ann -> Transaction ()
tryFlushDeclBuffer :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Hash -> Transaction ()
uncachedLoadRootBranch :: BranchCache Transaction -> (Reference -> Transaction ConstructorType) -> Transaction (Branch Transaction)

-- | Get whether the root branch exists.
getRootBranchExists :: Transaction Bool
putRootBranch :: Branch Transaction -> Transaction ()
getBranchForHash :: BranchCache Transaction -> (Reference -> Transaction ConstructorType) -> CausalHash -> Transaction (Maybe (Branch Transaction))
putBranch :: Branch Transaction -> Transaction ()

-- | Check whether the given branch exists in the codebase.
branchExists :: CausalHash -> Transaction Bool
getPatch :: PatchHash -> Transaction (Maybe Patch)

-- | Put a patch into the codebase.
--   
--   Note that <a>putBranch</a> may also put patches.
putPatch :: PatchHash -> Patch -> Transaction ()

-- | Check whether the given patch exists in the codebase.
patchExists :: PatchHash -> Transaction Bool
dependentsImpl :: DependentsSelector -> Reference -> Transaction (Set Id)
dependentsOfComponentImpl :: Hash -> Transaction (Set Id)

-- | <tt>watches k</tt> returns all of the references <tt>r</tt> that were
--   previously put by a <tt>putWatch k r t</tt>. <tt>t</tt> can be
--   retrieved by <tt>getWatch k r</tt>.
watches :: WatchKind -> Transaction [Id]
getWatch :: (Reference -> Transaction ConstructorType) -> WatchKind -> Id -> Transaction (Maybe (Term Symbol Ann))

-- | <tt>putWatch k r t</tt> puts a watch of kind <tt>k</tt>, with
--   hash-of-expression <tt>r</tt> and decompiled result <tt>t</tt> into
--   the codebase.
--   
--   For example, in the watch expression below, <tt>k</tt> is
--   <a>Regular</a>, <tt>r</tt> is the hash of <tt>x</tt>, and <tt>t</tt>
--   is <tt>7</tt>.
--   
--   <pre>
--   &gt; x = 3 + 4
--     ⧩
--     7
--   </pre>
putWatch :: WatchKind -> Id -> Term Symbol Ann -> Transaction ()
standardWatchKinds :: [WatchKind]
termsOfTypeImpl :: (Reference -> Transaction ConstructorType) -> Reference -> Transaction (Set Id)
termsMentioningTypeImpl :: (Reference -> Transaction ConstructorType) -> Reference -> Transaction (Set Id)

-- | The number of base32 characters needed to distinguish any two
--   references in the codebase.
hashLength :: Transaction Int

-- | The number of base32 characters needed to distinguish any two branch
--   in the codebase.
branchHashLength :: Transaction Int
defnReferencesByPrefix :: ObjectType -> ShortHash -> Transaction (Set Id)
termReferencesByPrefix :: ShortHash -> Transaction (Set Id)

-- | Get the set of type declarations whose hash matches the given prefix.
typeReferencesByPrefix :: ShortHash -> Transaction (Set Id)
referentsByPrefix :: (Reference -> Transaction ConstructorType) -> ShortHash -> Transaction (Set Id)

-- | Get the set of branches whose hash matches the given prefix.
causalHashesByPrefix :: ShortCausalHash -> Transaction (Set CausalHash)
termExists :: Hash -> Transaction Bool
declExists :: Hash -> Transaction Bool
before :: CausalHash -> CausalHash -> Transaction Bool

-- | Construct a <a>ScopedNames</a> which can produce names which are
--   relative to the provided Path.
--   
--   NOTE: this method requires an up-to-date name lookup index, which is
--   currently not kept up-to-date automatically (because it's slow to do
--   so).
namesAtPath :: Path -> Path -> Transaction ScopedNames

-- | Update the root namespace names index which is used by the share
--   server for serving api requests.
updateNameLookupIndex :: (Reference -> Transaction ConstructorType) -> Path -> Maybe BranchHash -> BranchHash -> Transaction ()

-- | Compute the root namespace names index which is used by the share
--   server for serving api requests. Using <a>updateNameLookupIndex</a> is
--   preferred whenever possible, since it's considerably faster. This can
--   be used to reset the index if it ever gets out of sync due to a bug.
--   
--   This version can be used if you've already got the root Branch
--   pre-loaded, otherwise it's faster to use
--   <a>initializeNameLookupIndexFromV2Root</a>
initializeNameLookupIndexFromV1Branch :: Branch Transaction -> Transaction ()

-- | Compute the root namespace names index which is used by the share
--   server for serving api requests. Using <a>updateNameLookupIndex</a> is
--   preferred whenever possible, since it's considerably faster. This can
--   be used to reset the index if it ever gets out of sync due to a bug.
--   
--   This version should be used if you don't already have the root Branch
--   pre-loaded, If you do, use
--   <a>initializeNameLookupIndexFromV1Branch</a> instead.
initializeNameLookupIndexFromV2Root :: (Reference -> Transaction ConstructorType) -> Transaction ()

-- | Given a transaction, return a transaction that first checks a
--   semispace cache of the given size.
--   
--   The transaction should probably be read-only, as we (of course) don't
--   hit SQLite on a cache hit.
makeCachedTransaction :: (Ord a, MonadIO m) => Word -> (a -> Transaction b) -> m (a -> Transaction b)

-- | Like <a>makeCachedTransaction</a>, but for when the transaction
--   returns a Maybe; only cache the Justs.
makeMaybeCachedTransaction :: (Ord a, MonadIO m) => Word -> (a -> Transaction (Maybe b)) -> m (a -> Transaction (Maybe b))
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.SqliteCodebase.Operations.BufferEntry a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.SqliteCodebase.Operations.BufferEntry a)

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2
migrateSchema1To2 :: (Reference -> Transaction ConstructorType) -> TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Transaction ()
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.Entity
instance GHC.Classes.Ord Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.Entity
instance GHC.Classes.Eq Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.Entity
instance Data.Traversable.Traversable Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference
instance Data.Foldable.Foldable Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference
instance GHC.Show.Show ref => GHC.Show.Show (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Classes.Ord ref => GHC.Classes.Ord (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Generics.Generic (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Base.Functor Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference
instance GHC.Classes.Eq ref => GHC.Classes.Eq (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.MigrationState

module Unison.Codebase.Branch.Merge
data MergeMode
RegularMerge :: MergeMode
SquashMerge :: MergeMode
merge'' :: forall m. Monad m => (Branch m -> Branch m -> m (Maybe (Branch m))) -> MergeMode -> Branch m -> Branch m -> m (Branch m)
instance GHC.Show.Show Unison.Codebase.Branch.Merge.MergeMode
instance GHC.Classes.Ord Unison.Codebase.Branch.Merge.MergeMode
instance GHC.Classes.Eq Unison.Codebase.Branch.Merge.MergeMode

module Unison.Codebase

-- | Abstract interface to a user's codebase.
data Codebase m v a

-- | Get a user-defined term from the codebase.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>$sel:getTerm:Codebase</a>, and receive <tt>Nothing</tt>, per the
--   semantics of <a>$sel:putTerm:Codebase</a>.
($sel:getTerm:Codebase) :: Codebase m v a -> Id -> Transaction (Maybe (Term v a))

-- | Like <a>$sel:getTerm:Codebase</a>, for when the term is known to exist
--   in the codebase.
unsafeGetTerm :: HasCallStack => Codebase m v a -> Id -> Transaction (Term v a)

-- | Like <a>unsafeGetTerm</a>, but returns the type of the term, too.
unsafeGetTermWithType :: HasCallStack => Codebase m v a -> Id -> Transaction (Term v a, Type v a)
($sel:getTermComponentWithTypes:Codebase) :: Codebase m v a -> Hash -> Transaction (Maybe [(Term v a, Type v a)])

-- | Like <a>$sel:getTermComponentWithTypes:Codebase</a>, for when the term
--   component is known to exist in the codebase.
unsafeGetTermComponent :: HasCallStack => Codebase m v a -> Hash -> Transaction [(Term v a, Type v a)]

-- | Get the type of a term.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>getTypeOfTerm</a>, and receive <tt>Nothing</tt>, per the semantics
--   of <a>$sel:putTerm:Codebase</a>.
getTypeOfTerm :: BuiltinAnnotation a => Codebase m Symbol a -> Reference -> Transaction (Maybe (Type Symbol a))

-- | Get the type of a given decl.
($sel:getDeclType:Codebase) :: Codebase m v a -> Reference -> m ConstructorType

-- | Like <a>getTypeOfTerm</a>, but for when the term is known to exist in
--   the codebase.
unsafeGetTypeOfTermById :: HasCallStack => Codebase m v a -> Id -> Transaction (Type v a)

-- | Check whether a reference is a term.
isTerm :: BuiltinAnnotation a => Codebase m Symbol a -> Reference -> Transaction Bool

-- | Enqueue the put of a user-defined term (with its type) into the
--   codebase, if it doesn't already exist. The implementation may choose
--   to delay the put until all of the term's (and its type's) references
--   are stored as well.
($sel:putTerm:Codebase) :: Codebase m v a -> Id -> Term v a -> Type v a -> Transaction ()
($sel:putTermComponent:Codebase) :: Codebase m v a -> Hash -> [(Term v a, Type v a)] -> Transaction ()

-- | Get the metadata attached to the term at a given path and name
--   relative to the given branch.
termMetadata :: Maybe (Branch Transaction) -> Split -> Maybe Referent -> Transaction [Map MetadataValue MetadataType]

-- | Get the type of a referent.
getTypeOfReferent :: BuiltinAnnotation a => Codebase m Symbol a -> Referent -> Transaction (Maybe (Type Symbol a))

-- | Get the set of terms-or-constructors that have the given type.
termsOfType :: Var v => Codebase m v a -> Type v a -> Transaction (Set Referent)

-- | Get the set of terms-or-constructors mention the given type anywhere
--   in their signature.
termsMentioningType :: Var v => Codebase m v a -> Type v a -> Transaction (Set Referent)
termReferencesByPrefix :: ShortHash -> Transaction (Set Id)

-- | Get the set of user-defined terms-or-constructors whose hash matches
--   the given prefix.
($sel:termReferentsByPrefix:Codebase) :: Codebase m v a -> ShortHash -> Transaction (Set Id)

-- | Get a type declaration.
--   
--   Note that it is possible to call
--   <a>$sel:putTypeDeclaration:Codebase</a>, then
--   <a>$sel:getTypeDeclaration:Codebase</a>, and receive <tt>Nothing</tt>,
--   per the semantics of <a>$sel:putTypeDeclaration:Codebase</a>.
($sel:getTypeDeclaration:Codebase) :: Codebase m v a -> Id -> Transaction (Maybe (Decl v a))

-- | Like <a>$sel:getTypeDeclaration:Codebase</a>, for when the type
--   declaration is known to exist in the codebase.
unsafeGetTypeDeclaration :: HasCallStack => Codebase m v a -> Id -> Transaction (Decl v a)
getDeclComponent :: Hash -> Transaction (Maybe [Decl Symbol Ann])

-- | Enqueue the put of a type declaration into the codebase, if it doesn't
--   already exist. The implementation may choose to delay the put until
--   all of the type declaration's references are stored as well.
($sel:putTypeDeclaration:Codebase) :: Codebase m v a -> Id -> Decl v a -> Transaction ()
($sel:putTypeDeclarationComponent:Codebase) :: Codebase m v a -> Hash -> [Decl v a] -> Transaction ()

-- | Get the set of type declarations whose hash matches the given prefix.
typeReferencesByPrefix :: ShortHash -> Transaction (Set Id)
isType :: Codebase m v a -> Reference -> Transaction Bool

-- | Check whether the given branch exists in the codebase.
branchExists :: CausalHash -> Transaction Bool

-- | Get a branch from the codebase.
getBranchForHash :: Monad m => Codebase m v a -> CausalHash -> m (Maybe (Branch m))

-- | Put a branch into the codebase, which includes its children, its
--   patches, and the branch itself, if they don't already exist.
--   
--   The terms and type declarations that a branch references must already
--   exist in the codebase.
($sel:putBranch:Codebase) :: Codebase m v a -> Branch m -> m ()

-- | Get the set of branches whose hash matches the given prefix.
causalHashesByPrefix :: ShortCausalHash -> Transaction (Set CausalHash)

-- | Get the lowest common ancestor of two branches, i.e. the most recent
--   branch that is an ancestor of both branches.
lca :: MonadIO m => Codebase m v a -> Branch m -> Branch m -> m (Maybe (Branch m))
before :: CausalHash -> CausalHash -> Transaction Bool

-- | Recursively descend into causals following the given path, Use the
--   root causal if none is provided.
getShallowBranchAtPath :: Path -> Maybe (Branch Transaction) -> Transaction (Branch Transaction)

-- | Recursively descend into causals following the given path, Use the
--   root causal if none is provided.
getShallowCausalAtPath :: Path -> Maybe (CausalBranch Transaction) -> Transaction (CausalBranch Transaction)
expectCausalBranchByCausalHash :: CausalHash -> Transaction (CausalBranch Transaction)
getShallowCausalFromRoot :: Maybe CausalHash -> Path -> Transaction (CausalBranch Transaction)

-- | Get the shallow representation of the root branches without loading
--   the children or history.
getShallowRootBranch :: Transaction (Branch Transaction)

-- | Get the shallow representation of the root branches without loading
--   the children or history.
getShallowRootCausal :: Transaction (CausalBranch Transaction)

-- | Get the root branch.
($sel:getRootBranch:Codebase) :: Codebase m v a -> m (Branch m)

-- | Get whether the root branch exists.
getRootBranchExists :: Transaction Bool
expectRootCausalHash :: Transaction CausalHash

-- | Like <a>$sel:putBranch:Codebase</a>, but also adjusts the root branch
--   pointer afterwards.
($sel:putRootBranch:Codebase) :: Codebase m v a -> Text -> Branch m -> m ()

-- | Construct a <a>ScopedNames</a> which can produce names which are
--   relative to the provided Path.
--   
--   NOTE: this method requires an up-to-date name lookup index, which is
--   currently not kept up-to-date automatically (because it's slow to do
--   so).
namesAtPath :: Path -> Path -> Transaction ScopedNames

-- | Check whether the given patch exists in the codebase.
patchExists :: PatchHash -> Transaction Bool
getPatch :: PatchHash -> Transaction (Maybe Patch)

-- | Put a patch into the codebase.
--   
--   Note that <a>putBranch</a> may also put patches.
putPatch :: PatchHash -> Patch -> Transaction ()

-- | <tt>getWatch k r</tt> returns watch result <tt>t</tt> that was
--   previously put by <tt>putWatch k r t</tt>.
($sel:getWatch:Codebase) :: Codebase m v a -> WatchKind -> Id -> Transaction (Maybe (Term v a))

-- | Like <a>$sel:getWatch:Codebase</a>, but first looks up the given
--   reference as a regular watch, then as a test watch.
--   
--   <pre>
--   lookupWatchCache codebase ref =
--     runMaybeT do
--       MaybeT (getWatch codebase RegularWatch ref)
--         <a>|</a> MaybeT (getWatch codebase TestWatch ref))
--   </pre>
lookupWatchCache :: Codebase m v a -> Id -> Transaction (Maybe (Term v a))

-- | <tt>watches k</tt> returns all of the references <tt>r</tt> that were
--   previously put by a <tt>putWatch k r t</tt>. <tt>t</tt> can be
--   retrieved by <tt>getWatch k r</tt>.
watches :: WatchKind -> Transaction [Id]

-- | <tt>putWatch k r t</tt> puts a watch of kind <tt>k</tt>, with
--   hash-of-expression <tt>r</tt> and decompiled result <tt>t</tt> into
--   the codebase.
--   
--   For example, in the watch expression below, <tt>k</tt> is
--   <a>Regular</a>, <tt>r</tt> is the hash of <tt>x</tt>, and <tt>t</tt>
--   is <tt>7</tt>.
--   
--   <pre>
--   &gt; x = 3 + 4
--     ⧩
--     7
--   </pre>
putWatch :: WatchKind -> Id -> Term Symbol Ann -> Transaction ()

-- | Delete all watches that were put by <tt>putWatch</tt>.
clearWatches :: Transaction ()

-- | Gets the specified number of reflog entries in chronological order,
--   most recent first.
getReflog :: Int -> Transaction [Entry CausalHash Text]

-- | The number of base32 characters needed to distinguish any two
--   references in the codebase.
hashLength :: Transaction Int

-- | The number of base32 characters needed to distinguish any two branch
--   in the codebase.
branchHashLength :: Transaction Int

-- | Get the set of terms, type declarations, and builtin types that depend
--   on the given term, type declaration, or builtin type.
dependents :: DependentsSelector -> Reference -> Transaction (Set Reference)
dependentsOfComponent :: Hash -> Transaction (Set Reference)

-- | Copy a branch and all of its dependencies from the given codebase into
--   this one.
($sel:syncFromDirectory:Codebase) :: Codebase m v a -> CodebasePath -> SyncMode -> Branch m -> m ()

-- | Copy a branch and all of its dependencies from this codebase into the
--   given codebase.
($sel:syncToDirectory:Codebase) :: Codebase m v a -> CodebasePath -> SyncMode -> Branch m -> m ()

-- | Pull a git branch and view it from the cache, without syncing into the
--   local codebase.
viewRemoteBranch :: MonadIO m => Codebase m v a -> ReadGitRemoteNamespace -> GitBranchBehavior -> (Branch m -> m r) -> m (Either GitError r)

-- | Sync elements as needed from a remote git codebase into the local one.
--   If <tt>sch</tt> is supplied, we try to load the specified branch hash;
--   otherwise we try to load the root branch.
importRemoteBranch :: forall m v a. MonadUnliftIO m => Codebase m v a -> ReadGitRemoteNamespace -> SyncMode -> Preprocessing m -> m (Either GitError (Branch m))

-- | An optional preprocessing step to run on branches before they're
--   imported into the local codebase.
data Preprocessing m
Unmodified :: Preprocessing m
Preprocessed :: (Branch m -> m (Branch m)) -> Preprocessing m

-- | Push the given branch to the given repo, and optionally set it as the
--   root branch.
($sel:pushGitBranch:Codebase) :: Codebase m v a -> forall e. WriteGitRepo -> PushGitBranchOpts -> (Branch m -> m (Either e (Branch m))) -> m (Either GitError (Either e (Branch m)))
data PushGitBranchOpts
PushGitBranchOpts :: GitPushBehavior -> SyncMode -> PushGitBranchOpts
[$sel:behavior:PushGitBranchOpts] :: PushGitBranchOpts -> GitPushBehavior
[$sel:syncMode:PushGitBranchOpts] :: PushGitBranchOpts -> SyncMode
getCodebaseDir :: MonadIO m => Maybe CodebasePath -> m CodebasePath

-- | A directory that contains a codebase.
type CodebasePath = FilePath
type SyncToDir m = CodebasePath -> SyncMode -> Branch m -> m ()

-- | Run a transaction on a codebase.
runTransaction :: MonadIO m => Codebase m v a -> Transaction b -> m b

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
($sel:withConnection:Codebase) :: Codebase m v a -> forall x. (Connection -> m x) -> m x

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
($sel:withConnectionIO:Codebase) :: Codebase m v a -> forall x. (Connection -> IO x) -> IO x
addDefsToCodebase :: forall m v a. (Var v, Show a) => Codebase m v a -> TypecheckedUnisonFile v a -> Transaction ()
componentReferencesForReference :: Reference -> Transaction (Set Reference)

-- | Write all of UCM's dependencies (builtins types and an empty
--   namespace) into the codebase
installUcmDependencies :: Codebase m Symbol Ann -> Transaction ()
toCodeLookup :: MonadIO m => Codebase m Symbol Ann -> CodeLookup Symbol m Ann
typeLookupForDependencies :: BuiltinAnnotation a => Codebase m Symbol a -> Set Reference -> Transaction (TypeLookup Symbol a)
unsafeGetComponentLength :: HasCallStack => Hash -> Transaction CycleSize

module Unison.Codebase.SqliteCodebase.Paths

-- | Prefer makeCodebasePath or makeCodebaseDirPath when possible.
codebasePath :: FilePath

-- | Makes a path to a sqlite database from a codebase path.
makeCodebasePath :: CodebasePath -> FilePath

-- | Makes a path to the location where sqlite files are stored within a
--   codebase path.
makeCodebaseDirPath :: CodebasePath -> FilePath

-- | Makes a path to store a backup of a sqlite database given the current
--   time.
backupCodebasePath :: NominalDiffTime -> FilePath
lockfilePath :: CodebasePath -> FilePath

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema5To6

-- | The 5 to 6 migration adds the reflog as a table in the DB
migrateSchema5To6 :: CodebasePath -> Transaction ()

module Unison.Codebase.SqliteCodebase.Migrations

-- | Mapping from schema version to the migration required to get there.
--   Each migration may only be run on a schema of its immediate
--   predecessor, E.g. The migration at index 2 must be run on a codebase
--   at version 1.
migrations :: (Reference -> Transaction ConstructorType) -> TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> CodebasePath -> Map SchemaVersion (Transaction ())
data CodebaseVersionStatus
CodebaseUpToDate :: CodebaseVersionStatus
CodebaseUnknownSchemaVersion :: SchemaVersion -> CodebaseVersionStatus
CodebaseRequiresMigration :: SchemaVersion -> SchemaVersion -> CodebaseVersionStatus
checkCodebaseIsUpToDate :: Transaction CodebaseVersionStatus

-- | Migrates a codebase up to the most recent version known to ucm. This
--   is a No-op if it's up to date Returns an error if the schema version
--   is newer than this ucm knows about.
ensureCodebaseIsUpToDate :: MonadIO m => LocalOrRemote -> CodebasePath -> (Reference -> Transaction ConstructorType) -> TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Bool -> Connection -> m (Either OpenCodebaseError ())

-- | Copy the sqlite database to a new file with a unique name based on
--   current time.
backupCodebase :: CodebasePath -> Bool -> IO ()
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Migrations.CodebaseVersionStatus
instance GHC.Classes.Ord Unison.Codebase.SqliteCodebase.Migrations.CodebaseVersionStatus
instance GHC.Classes.Eq Unison.Codebase.SqliteCodebase.Migrations.CodebaseVersionStatus

module Unison.Codebase.Init.Type
data Init m v a
Init :: (DebugName -> CodebasePath -> m (Either Pretty (m (), Codebase m v a))) -> (DebugName -> CodebasePath -> m (Either CreateCodebaseError (m (), Codebase m v a))) -> (CodebasePath -> CodebasePath) -> Init m v a

-- | open an existing codebase
[$sel:openCodebase:Init] :: Init m v a -> DebugName -> CodebasePath -> m (Either Pretty (m (), Codebase m v a))

-- | create a new codebase
[$sel:createCodebase':Init] :: Init m v a -> DebugName -> CodebasePath -> m (Either CreateCodebaseError (m (), Codebase m v a))

-- | given a codebase root, and given that the codebase root may have other
--   junk in it, give the path to the "actual" files; e.g. what a forked
--   transcript should clone.
[$sel:codebasePath:Init] :: Init m v a -> CodebasePath -> CodebasePath

module Unison.Codebase.FileCodebase
codebaseExists :: MonadIO m => CodebasePath -> m Bool

module Unison.Codebase.Init
data Init m v a
Init :: (forall r. DebugName -> CodebasePath -> CodebaseLockOption -> MigrationStrategy -> (Codebase m v a -> m r) -> m (Either OpenCodebaseError r)) -> (forall r. DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m v a -> m r) -> m (Either CreateCodebaseError r)) -> (CodebasePath -> CodebasePath) -> Init m v a

-- | open an existing codebase
[$sel:withOpenCodebase:Init] :: Init m v a -> forall r. DebugName -> CodebasePath -> CodebaseLockOption -> MigrationStrategy -> (Codebase m v a -> m r) -> m (Either OpenCodebaseError r)

-- | create a new codebase
[$sel:withCreatedCodebase:Init] :: Init m v a -> forall r. DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m v a -> m r) -> m (Either CreateCodebaseError r)

-- | given a codebase root, and given that the codebase root may have other
--   junk in it, give the path to the "actual" files; e.g. what a forked
--   transcript should clone.
[$sel:codebasePath:Init] :: Init m v a -> CodebasePath -> CodebasePath
type DebugName = String

-- | An error that occurred while initializing a codebase.
data InitError
FoundV1Codebase :: InitError
InitErrorOpen :: OpenCodebaseError -> InitError
CouldntCreateCodebase :: Pretty -> InitError
data CodebaseInitOptions
Home :: CodebasePath -> CodebaseInitOptions
Specified :: SpecifiedCodebase -> CodebaseInitOptions
data CodebaseLockOption
DoLock :: CodebaseLockOption
DontLock :: CodebaseLockOption
data InitResult
OpenedCodebase :: InitResult
CreatedCodebase :: InitResult
data SpecifiedCodebase
CreateWhenMissing :: CodebasePath -> SpecifiedCodebase
DontCreateWhenMissing :: CodebasePath -> SpecifiedCodebase
data MigrationStrategy

-- | Perform a migration immediately if one is required.
MigrateAutomatically :: MigrationStrategy

-- | Prompt the user that a migration is about to occur, continue after
--   acknownledgment
MigrateAfterPrompt :: MigrationStrategy

-- | Triggers an <a>OpenCodebaseRequiresMigration</a> error instead of
--   migrating
DontMigrate :: MigrationStrategy
type Pretty = Pretty ColorText
createCodebase :: MonadIO m => Init m v a -> DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m v a -> m r) -> m (Either Pretty r)

-- | try to init a codebase where none exists and then exit regardless
--   (i.e. `ucm --codebase dir init`)
initCodebaseAndExit :: MonadIO m => Init m Symbol Ann -> DebugName -> Maybe CodebasePath -> CodebaseLockOption -> m ()
withOpenOrCreateCodebase :: MonadIO m => Init m v a -> DebugName -> CodebaseInitOptions -> CodebaseLockOption -> MigrationStrategy -> ((InitResult, CodebasePath, Codebase m v a) -> m r) -> m (Either (CodebasePath, InitError) r)
withNewUcmCodebaseOrExit :: MonadIO m => Init m Symbol Ann -> DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m Symbol Ann -> m r) -> m r
withTemporaryUcmCodebase :: MonadUnliftIO m => Init m Symbol Ann -> DebugName -> CodebaseLockOption -> ((CodebasePath, Codebase m Symbol Ann) -> m r) -> m r
instance GHC.Classes.Ord Unison.Codebase.Init.MigrationStrategy
instance GHC.Classes.Eq Unison.Codebase.Init.MigrationStrategy
instance GHC.Show.Show Unison.Codebase.Init.MigrationStrategy
instance GHC.Classes.Eq Unison.Codebase.Init.InitError
instance GHC.Show.Show Unison.Codebase.Init.InitError
instance GHC.Classes.Eq Unison.Codebase.Init.InitResult
instance GHC.Show.Show Unison.Codebase.Init.InitResult

module Unison.Codebase.SqliteCodebase
init :: HasCallStack => MonadUnliftIO m => Init m Symbol Ann
data MigrationStrategy

-- | Perform a migration immediately if one is required.
MigrateAutomatically :: MigrationStrategy

-- | Prompt the user that a migration is about to occur, continue after
--   acknownledgment
MigrateAfterPrompt :: MigrationStrategy

-- | Triggers an <a>OpenCodebaseRequiresMigration</a> error instead of
--   migrating
DontMigrate :: MigrationStrategy
data CodebaseLockOption
DoLock :: CodebaseLockOption
DontLock :: CodebaseLockOption
instance GHC.Classes.Eq Unison.Codebase.SqliteCodebase.CodebaseStatus
instance GHC.Show.Show (Unison.Codebase.SqliteCodebase.Entity m)


-- | Execute a computation of type '{IO} () that has been previously added
--   to the codebase, without setting up an interactive environment.
--   
--   This allows one to run standalone applications implemented in the
--   Unison language.
module Unison.Codebase.Execute
execute :: Codebase IO Symbol Ann -> Runtime Symbol -> String -> IO (Either Error ())

module Unison.Util.TQueue
data TQueue a
TQueue :: TVar (Seq a) -> TVar Word64 -> TQueue a
newIO :: MonadIO m => m (TQueue a)
size :: TQueue a -> STM Int
awaitSize :: Int -> TQueue a -> STM ()
peek :: TQueue a -> STM a
dequeue :: TQueue a -> STM a
undequeue :: TQueue a -> a -> STM ()
tryDequeue :: TQueue a -> STM (Maybe a)
dequeueN :: TQueue a -> Int -> STM [a]
enqueueCount :: TQueue a -> STM Word64
flush :: TQueue a -> STM [a]
enqueue :: TQueue a -> a -> STM ()
raceIO :: MonadIO m => STM a -> STM b -> m (Either a b)
tryPeekWhile :: (a -> Bool) -> TQueue a -> STM [a]
takeWhile :: (a -> Bool) -> TQueue a -> STM [a]
peekWhile :: (a -> Bool) -> TQueue a -> STM [a]

module Unison.Codebase.Watch
untilJust :: Monad m => m (Maybe a) -> m a
watchDirectory' :: forall m. MonadIO m => FilePath -> m (IO (), IO (FilePath, UTCTime))
collectUntilPause :: forall a. TQueue a -> Int -> IO [a]
watchDirectory :: forall m. MonadIO m => FilePath -> (FilePath -> Bool) -> m (IO (), IO (FilePath, Text))

module Unison.Util.Text
newtype Text
Text :: Rope Chunk -> Text
data Chunk
Chunk :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Text -> Chunk
empty :: Text
one :: Char -> Text
singleton :: Char -> Text
appendUnbalanced :: Text -> Text -> Text
threshold :: Int
replicate :: Int -> Text -> Text
chunkToText :: Chunk -> Text
chunk :: Text -> Chunk
take :: Int -> Text -> Text
drop :: Int -> Text -> Text
uncons :: Text -> Maybe (Char, Text)
unsnoc :: Text -> Maybe (Text, Char)
unconsChunk :: Text -> Maybe (Chunk, Text)
unsnocChunk :: Text -> Maybe (Text, Chunk)
at :: Int -> Text -> Maybe Char
size :: Text -> Int
reverse :: Text -> Text
toUppercase :: Text -> Text
toLowercase :: Text -> Text
fromUtf8 :: Bytes -> Either String Text
toUtf8 :: Text -> Bytes
fromText :: Text -> Text
pack :: String -> Text
toString :: Text -> String
unpack :: Text -> String
toText :: Text -> Text
dropTextWhileMax :: (Char -> Bool) -> Int -> Text -> (Int, Text)
dropWhileMax :: (Char -> Bool) -> Int -> Text -> (Int, Text)
instance GHC.Base.Monoid Unison.Util.Text.Text
instance GHC.Base.Semigroup Unison.Util.Text.Text
instance GHC.Classes.Ord Unison.Util.Text.Text
instance GHC.Classes.Eq Unison.Util.Text.Text
instance Unison.Util.Rope.Sized Unison.Util.Text.Text
instance GHC.Show.Show Unison.Util.Text.Text
instance Data.String.IsString Unison.Util.Text.Text
instance GHC.Classes.Eq Unison.Util.Text.Chunk
instance GHC.Classes.Ord Unison.Util.Text.Chunk
instance GHC.Base.Semigroup Unison.Util.Text.Chunk
instance GHC.Base.Monoid Unison.Util.Text.Chunk
instance Unison.Util.Rope.Sized Unison.Util.Text.Chunk
instance Unison.Util.Rope.Drop Unison.Util.Text.Chunk
instance Unison.Util.Rope.Take Unison.Util.Text.Chunk
instance Unison.Util.Rope.Index Unison.Util.Text.Chunk GHC.Types.Char
instance Unison.Util.Rope.Reverse Unison.Util.Text.Chunk

module Unison.Runtime.ANF
minimizeCyclesOrCrash :: Var v => Term v a -> Term v a
pattern TVar :: Var v => v -> Term ANormalF v
pattern TLit :: Var v => Lit -> Term ANormalF v
pattern TApp :: Var v => Func v -> [v] -> Term ANormalF v
pattern TApv :: Var v => v -> [v] -> Term ANormalF v
pattern TCom :: Var v => Reference -> [v] -> Term ANormalF v
pattern TCon :: Var v => Reference -> CTag -> [v] -> Term ANormalF v
pattern TKon :: Var v => v -> [v] -> Term ANormalF v
pattern TReq :: Var v => Reference -> CTag -> [v] -> Term ANormalF v
pattern TPrm :: Var v => POp -> [v] -> Term ANormalF v
pattern TFOp :: Var v => FOp -> [v] -> Term ANormalF v
pattern THnd :: Var v => [Reference] -> v -> Term ANormalF v -> Term ANormalF v
pattern TLet :: Var v => Direction Word16 -> v -> Mem -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TLetD :: Var v => v -> Mem -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TFrc :: Var v => v -> Term ANormalF v
pattern TLets :: Var v => Direction Word16 -> [v] -> [Mem] -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TName :: Var v => v -> Either Reference v -> [v] -> Term ANormalF v -> Term ANormalF v
pattern TBind :: Var v => Cte v -> ANormal v -> ANormal v
pattern TBinds :: Var v => [Cte v] -> ANormal v -> ANormal v
pattern TShift :: Var v => Reference -> v -> Term ANormalF v -> Term ANormalF v
pattern TMatch :: Var v => v -> Branched (Term ANormalF v) -> Term ANormalF v
data CompileExn
CE :: CallStack -> Pretty ColorText -> CompileExn
internalBug :: HasCallStack => String -> a
data Mem
UN :: Mem
BX :: Mem
data Lit
I :: Int64 -> Lit
N :: Word64 -> Lit
F :: Double -> Lit
T :: Text -> Lit
C :: Char -> Lit
LM :: Referent -> Lit
LY :: Reference -> Lit
data Direction a
Indirect :: a -> Direction a
Direct :: Direction a
data SuperNormal v
Lambda :: [Mem] -> ANormal v -> SuperNormal v
[$sel:conventions:Lambda] :: SuperNormal v -> [Mem]
[$sel:bound:Lambda] :: SuperNormal v -> ANormal v
data SuperGroup v
Rec :: [(v, SuperNormal v)] -> SuperNormal v -> SuperGroup v
[$sel:group:Rec] :: SuperGroup v -> [(v, SuperNormal v)]
[$sel:entry:Rec] :: SuperGroup v -> SuperNormal v
data POp
ADDI :: POp
SUBI :: POp
MULI :: POp
DIVI :: POp
SGNI :: POp
NEGI :: POp
MODI :: POp
POWI :: POp
SHLI :: POp
SHRI :: POp
INCI :: POp
DECI :: POp
LEQI :: POp
EQLI :: POp
ADDN :: POp
SUBN :: POp
MULN :: POp
DIVN :: POp
MODN :: POp
TZRO :: POp
LZRO :: POp
POPC :: POp
POWN :: POp
SHLN :: POp
SHRN :: POp
ANDN :: POp
IORN :: POp
XORN :: POp
COMN :: POp
INCN :: POp
DECN :: POp
LEQN :: POp
EQLN :: POp
ADDF :: POp
SUBF :: POp
MULF :: POp
DIVF :: POp
MINF :: POp
MAXF :: POp
LEQF :: POp
EQLF :: POp
POWF :: POp
EXPF :: POp
SQRT :: POp
LOGF :: POp
LOGB :: POp
ABSF :: POp
CEIL :: POp
FLOR :: POp
TRNF :: POp
RNDF :: POp
COSF :: POp
ACOS :: POp
COSH :: POp
ACSH :: POp
SINF :: POp
ASIN :: POp
SINH :: POp
ASNH :: POp
TANF :: POp
ATAN :: POp
TANH :: POp
ATNH :: POp
ATN2 :: POp
CATT :: POp
TAKT :: POp
DRPT :: POp
SIZT :: POp
UCNS :: POp
USNC :: POp
EQLT :: POp
LEQT :: POp
PAKT :: POp
UPKT :: POp
CATS :: POp
TAKS :: POp
DRPS :: POp
SIZS :: POp
CONS :: POp
SNOC :: POp
IDXS :: POp
BLDS :: POp
VWLS :: POp
VWRS :: POp
SPLL :: POp
SPLR :: POp
PAKB :: POp
UPKB :: POp
TAKB :: POp
DRPB :: POp
IDXB :: POp
SIZB :: POp
FLTB :: POp
CATB :: POp
ITOF :: POp
NTOF :: POp
ITOT :: POp
NTOT :: POp
TTOI :: POp
TTON :: POp
TTOF :: POp
FTOT :: POp
FORK :: POp
EQLU :: POp
CMPU :: POp
EROR :: POp
MISS :: POp
CACH :: POp
LKUP :: POp
LOAD :: POp
CVLD :: POp
SDBX :: POp
VALU :: POp
TLTT :: POp
PRNT :: POp
INFO :: POp
TRCE :: POp
DBTX :: POp
ATOM :: POp
TFRC :: POp
type FOp = Word64
close :: (Var v, Monoid a) => Set v -> Term v a -> Term v a
saturate :: (Var v, Monoid a) => Map ConstructorReference Int -> Term v a -> Term v a
float :: Var v => Monoid a => Term v a -> (Term v a, [(Reference, Term v a)], [(Reference, Term v a)])
lamLift :: Var v => Monoid a => Term v a -> (Term v a, [(Reference, Term v a)], [(Reference, Term v a)])
inlineAlias :: Var v => Monoid a => Term v a -> Term v a
addDefaultCases :: Var v => Monoid a => String -> Term v a -> Term v a
data ANormalF v e
ALet :: Direction Word16 -> [Mem] -> e -> e -> ANormalF v e
AName :: Either Reference v -> [v] -> e -> ANormalF v e
ALit :: Lit -> ANormalF v e
AMatch :: v -> Branched e -> ANormalF v e
AShift :: Reference -> e -> ANormalF v e
AHnd :: [Reference] -> v -> e -> ANormalF v e
AApp :: Func v -> [v] -> ANormalF v e
AFrc :: v -> ANormalF v e
AVar :: v -> ANormalF v e
pattern AApv :: v -> [v] -> ANormalF v e
pattern ACom :: Reference -> [v] -> ANormalF v e
pattern ACon :: Reference -> CTag -> [v] -> ANormalF v e
pattern AKon :: v -> [v] -> ANormalF v e
pattern AReq :: Reference -> CTag -> [v] -> ANormalF v e
pattern APrm :: POp -> [v] -> ANormalF v e
pattern AFOp :: FOp -> [v] -> ANormalF v e
type ANormal = Term ANormalF
data RTag
data CTag
class Tag t
rawTag :: Tag t => t -> Word64
data GroupRef
GR :: Reference -> Word64 -> GroupRef
data Value
Partial :: GroupRef -> [Word64] -> [Value] -> Value
Data :: Reference -> Word64 -> [Word64] -> [Value] -> Value
Cont :: [Word64] -> [Value] -> Cont -> Value
BLit :: BLit -> Value
data Cont
KE :: Cont
Mark :: Word64 -> Word64 -> [Reference] -> Map Reference Value -> Cont -> Cont
Push :: Word64 -> Word64 -> Word64 -> Word64 -> GroupRef -> Cont -> Cont
data BLit
Text :: Text -> BLit
List :: Seq Value -> BLit
TmLink :: Referent -> BLit
TyLink :: Reference -> BLit
Bytes :: Bytes -> BLit
Quote :: Value -> BLit
Code :: SuperGroup Symbol -> BLit
BArr :: ByteArray -> BLit
packTags :: RTag -> CTag -> Word64
unpackTags :: Word64 -> (RTag, CTag)
maskTags :: Word64 -> Word64
type ANFM v = ReaderT (Set v) (State (Word64, Word16, [(v, SuperNormal v)]))
data Branched e
MatchIntegral :: EnumMap Word64 e -> Maybe e -> Branched e
MatchText :: Map Text e -> Maybe e -> Branched e
MatchRequest :: Map Reference (EnumMap CTag ([Mem], e)) -> e -> Branched e
MatchEmpty :: Branched e
MatchData :: Reference -> EnumMap CTag ([Mem], e) -> Maybe e -> Branched e
MatchSum :: EnumMap Word64 ([Mem], e) -> Branched e
pattern MatchDataCover :: Reference -> EnumMap CTag ([Mem], e) -> Branched e
data Func v
FVar :: v -> Func v
FComb :: !Reference -> Func v
FCont :: v -> Func v
FCon :: !Reference -> !CTag -> Func v
FReq :: !Reference -> !CTag -> Func v
FPrim :: Either POp FOp -> Func v
data SGEqv v
NumDefns :: SuperGroup v -> SuperGroup v -> SGEqv v
DefnConventions :: SuperNormal v -> SuperNormal v -> SGEqv v
Subterms :: ANormal v -> ANormal v -> SGEqv v
equivocate :: Var v => SuperGroup v -> SuperGroup v -> Either (SGEqv v) ()
superNormalize :: Var v => Term v a -> SuperGroup v
anfTerm :: Var v => Term v a -> ANFM v (DNormal v)
valueTermLinks :: Value -> [Reference]
valueLinks :: Monoid a => (Bool -> Reference -> a) -> Value -> a
groupTermLinks :: SuperGroup v -> [Reference]
groupLinks :: Monoid a => (Bool -> Reference -> a) -> SuperGroup v -> a
normalLinks :: Monoid a => (Bool -> Reference -> a) -> SuperNormal v -> a
prettyGroup :: Var v => String -> SuperGroup v -> ShowS
prettySuperNormal :: Var v => Int -> SuperNormal v -> ShowS
prettyANF :: Var v => Bool -> Int -> ANormal v -> ShowS
instance GHC.Show.Show Unison.Runtime.ANF.CompileExn
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.Prefix v x)
instance GHC.Enum.Enum Unison.Runtime.ANF.Mem
instance GHC.Show.Show Unison.Runtime.ANF.Mem
instance GHC.Classes.Ord Unison.Runtime.ANF.Mem
instance GHC.Classes.Eq Unison.Runtime.ANF.Mem
instance Unison.Util.EnumContainers.EnumKey Unison.Runtime.ANF.RTag
instance GHC.Read.Read Unison.Runtime.ANF.RTag
instance GHC.Show.Show Unison.Runtime.ANF.RTag
instance GHC.Classes.Ord Unison.Runtime.ANF.RTag
instance GHC.Classes.Eq Unison.Runtime.ANF.RTag
instance Unison.Util.EnumContainers.EnumKey Unison.Runtime.ANF.CTag
instance GHC.Read.Read Unison.Runtime.ANF.CTag
instance GHC.Show.Show Unison.Runtime.ANF.CTag
instance GHC.Classes.Ord Unison.Runtime.ANF.CTag
instance GHC.Classes.Eq Unison.Runtime.ANF.CTag
instance GHC.Show.Show Unison.Runtime.ANF.SeqEnd
instance GHC.Enum.Enum Unison.Runtime.ANF.SeqEnd
instance GHC.Classes.Ord Unison.Runtime.ANF.SeqEnd
instance GHC.Classes.Eq Unison.Runtime.ANF.SeqEnd
instance Data.Traversable.Traversable Unison.Runtime.ANF.Branched
instance Data.Foldable.Foldable Unison.Runtime.ANF.Branched
instance GHC.Base.Functor Unison.Runtime.ANF.Branched
instance GHC.Classes.Eq e => GHC.Classes.Eq (Unison.Runtime.ANF.Branched e)
instance GHC.Show.Show e => GHC.Show.Show (Unison.Runtime.ANF.Branched e)
instance GHC.Classes.Eq Unison.Runtime.ANF.Lit
instance GHC.Show.Show Unison.Runtime.ANF.Lit
instance GHC.Enum.Bounded Unison.Runtime.ANF.POp
instance GHC.Enum.Enum Unison.Runtime.ANF.POp
instance GHC.Classes.Ord Unison.Runtime.ANF.POp
instance GHC.Classes.Eq Unison.Runtime.ANF.POp
instance GHC.Show.Show Unison.Runtime.ANF.POp
instance Data.Traversable.Traversable Unison.Runtime.ANF.Func
instance Data.Foldable.Foldable Unison.Runtime.ANF.Func
instance GHC.Base.Functor Unison.Runtime.ANF.Func
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Runtime.ANF.Func v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.Func v)
instance Data.Traversable.Traversable Unison.Runtime.ANF.Direction
instance Data.Foldable.Foldable Unison.Runtime.ANF.Direction
instance GHC.Base.Functor Unison.Runtime.ANF.Direction
instance GHC.Show.Show a => GHC.Show.Show (Unison.Runtime.ANF.Direction a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Runtime.ANF.Direction a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Runtime.ANF.Direction a)
instance (GHC.Classes.Eq e, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.Runtime.ANF.ANormalF v e)
instance (GHC.Show.Show e, GHC.Show.Show v) => GHC.Show.Show (Unison.Runtime.ANF.ANormalF v e)
instance (GHC.Show.Show v, GHC.Show.Show s) => GHC.Show.Show (Unison.Runtime.ANF.CTE v s)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Runtime.ANF.SuperNormal v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.SuperNormal v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.SuperGroup v)
instance GHC.Show.Show Unison.Runtime.ANF.GroupRef
instance GHC.Show.Show Unison.Runtime.ANF.Cont
instance GHC.Show.Show Unison.Runtime.ANF.Value
instance GHC.Show.Show Unison.Runtime.ANF.BLit
instance Unison.Var.Var v => GHC.Classes.Eq (Unison.Runtime.ANF.SuperGroup v)
instance GHC.Base.Semigroup (Unison.Runtime.ANF.BranchAccum v)
instance GHC.Base.Monoid (Unison.Runtime.ANF.BranchAccum e)
instance GHC.Base.Functor (Unison.Runtime.ANF.ANormalF v)
instance Data.Bifunctor.Bifunctor Unison.Runtime.ANF.ANormalF
instance Data.Bifoldable.Bifoldable Unison.Runtime.ANF.ANormalF
instance Unison.ABT.Normalized.Align Unison.Runtime.ANF.ANormalF
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Unison.Runtime.ANF.Direction a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Unison.Runtime.ANF.Direction a)
instance Unison.Runtime.ANF.Tag Unison.Runtime.ANF.RTag
instance Unison.Runtime.ANF.Tag Unison.Runtime.ANF.CTag
instance GHC.Enum.Enum Unison.Runtime.ANF.CTag
instance GHC.Num.Num Unison.Runtime.ANF.CTag
instance GHC.Enum.Enum Unison.Runtime.ANF.RTag
instance GHC.Num.Num Unison.Runtime.ANF.RTag
instance GHC.Base.Functor (Unison.Runtime.ANF.Prefix v)
instance GHC.Classes.Ord v => GHC.Base.Applicative (Unison.Runtime.ANF.Prefix v)
instance GHC.Exception.Type.Exception Unison.Runtime.ANF.CompileExn

module Unison.Runtime.Pattern
type DataSpec = Map Reference (Either Cons Cons)
splitPatterns :: Var v => DataSpec -> Term v -> Term v
builtinDataSpec :: DataSpec
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.Pattern.PatternRow v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.Pattern.PatternMatrix v)
instance GHC.Show.Show Unison.Runtime.Pattern.SeqMatch
instance GHC.Classes.Ord Unison.Runtime.Pattern.SeqMatch
instance GHC.Classes.Eq Unison.Runtime.Pattern.SeqMatch
instance GHC.Base.Semigroup Unison.Runtime.Pattern.PType
instance GHC.Base.Monoid Unison.Runtime.Pattern.PType

module Unison.Runtime.MCode
data Args'
Arg1 :: !Int -> Args'
Arg2 :: !Int -> !Int -> Args'
ArgN :: {-# UNPACK #-} !PrimArray Int -> Args'
ArgR :: !Int -> !Int -> Args'
data Args
ZArgs :: Args
UArg1 :: !Int -> Args
UArg2 :: !Int -> !Int -> Args
BArg1 :: !Int -> Args
BArg2 :: !Int -> !Int -> Args
DArg2 :: !Int -> !Int -> Args
UArgR :: !Int -> !Int -> Args
BArgR :: !Int -> !Int -> Args
DArgR :: !Int -> !Int -> !Int -> !Int -> Args
BArgN :: !PrimArray Int -> Args
UArgN :: !PrimArray Int -> Args
DArgN :: !PrimArray Int -> !PrimArray Int -> Args
DArgV :: !Int -> !Int -> Args
data RefNums
RN :: (Reference -> Word64) -> (Reference -> Word64) -> RefNums
[$sel:dnum:RN] :: RefNums -> Reference -> Word64
[$sel:cnum:RN] :: RefNums -> Reference -> Word64
data MLit
MI :: !Int -> MLit
MD :: !Double -> MLit
MT :: !Text -> MLit
MM :: !Referent -> MLit
MY :: !Reference -> MLit
data Instr
UPrim1 :: !UPrim1 -> !Int -> Instr
UPrim2 :: !UPrim2 -> !Int -> !Int -> Instr
BPrim1 :: !BPrim1 -> !Int -> Instr
BPrim2 :: !BPrim2 -> !Int -> !Int -> Instr
ForeignCall :: !Bool -> !Word64 -> !Args -> Instr
SetDyn :: !Word64 -> !Int -> Instr
Capture :: !Word64 -> Instr
Name :: !Ref -> !Args -> Instr
Info :: !String -> Instr
Pack :: !Reference -> !Word64 -> !Args -> Instr
Unpack :: !Maybe Reference -> !Int -> Instr
Lit :: !MLit -> Instr
Print :: !Int -> Instr
Reset :: !EnumSet Word64 -> Instr
Fork :: !Int -> Instr
Atomically :: !Int -> Instr
Seq :: !Args -> Instr
TryForce :: !Int -> Instr
data Section
App :: !Bool -> !Ref -> !Args -> Section
Call :: !Bool -> !Word64 -> !Args -> Section
Jump :: !Int -> !Args -> Section
Match :: !Int -> !Branch -> Section
Yield :: !Args -> Section
Ins :: !Instr -> !Section -> Section
Let :: !Section -> !CombIx -> Section
Die :: String -> Section
Exit :: Section
pattern MatchT :: Int -> Section -> Map Text Section -> Section
pattern MatchW :: Int -> Section -> EnumMap Word64 Section -> Section
data Comb
Lam :: !Int -> !Int -> !Int -> !Int -> !Section -> Comb
type Combs = EnumMap Word64 Comb
data CombIx
CIx :: !Reference -> !Word64 -> !Word64 -> CombIx
data Ref
Stk :: !Int -> Ref
Env :: !Word64 -> !Word64 -> Ref
Dyn :: !Word64 -> Ref
data UPrim1
DECI :: UPrim1
INCI :: UPrim1
NEGI :: UPrim1
SGNI :: UPrim1
LZRO :: UPrim1
TZRO :: UPrim1
COMN :: UPrim1
POPC :: UPrim1
ABSF :: UPrim1
EXPF :: UPrim1
LOGF :: UPrim1
SQRT :: UPrim1
COSF :: UPrim1
ACOS :: UPrim1
COSH :: UPrim1
ACSH :: UPrim1
SINF :: UPrim1
ASIN :: UPrim1
SINH :: UPrim1
ASNH :: UPrim1
TANF :: UPrim1
ATAN :: UPrim1
TANH :: UPrim1
ATNH :: UPrim1
ITOF :: UPrim1
NTOF :: UPrim1
CEIL :: UPrim1
FLOR :: UPrim1
TRNF :: UPrim1
RNDF :: UPrim1
data UPrim2
ADDI :: UPrim2
SUBI :: UPrim2
MULI :: UPrim2
DIVI :: UPrim2
MODI :: UPrim2
DIVN :: UPrim2
MODN :: UPrim2
SHLI :: UPrim2
SHRI :: UPrim2
SHRN :: UPrim2
POWI :: UPrim2
EQLI :: UPrim2
LEQI :: UPrim2
LEQN :: UPrim2
ANDN :: UPrim2
IORN :: UPrim2
XORN :: UPrim2
EQLF :: UPrim2
LEQF :: UPrim2
ADDF :: UPrim2
SUBF :: UPrim2
MULF :: UPrim2
DIVF :: UPrim2
ATN2 :: UPrim2
POWF :: UPrim2
LOGB :: UPrim2
MAXF :: UPrim2
MINF :: UPrim2
data BPrim1
SIZT :: BPrim1
USNC :: BPrim1
UCNS :: BPrim1
ITOT :: BPrim1
NTOT :: BPrim1
FTOT :: BPrim1
TTOI :: BPrim1
TTON :: BPrim1
TTOF :: BPrim1
PAKT :: BPrim1
UPKT :: BPrim1
VWLS :: BPrim1
VWRS :: BPrim1
SIZS :: BPrim1
PAKB :: BPrim1
UPKB :: BPrim1
SIZB :: BPrim1
FLTB :: BPrim1
MISS :: BPrim1
CACH :: BPrim1
LKUP :: BPrim1
LOAD :: BPrim1
CVLD :: BPrim1
VALU :: BPrim1
TLTT :: BPrim1
DBTX :: BPrim1
data BPrim2
EQLU :: BPrim2
CMPU :: BPrim2
DRPT :: BPrim2
CATT :: BPrim2
TAKT :: BPrim2
EQLT :: BPrim2
LEQT :: BPrim2
LEST :: BPrim2
DRPS :: BPrim2
CATS :: BPrim2
TAKS :: BPrim2
CONS :: BPrim2
SNOC :: BPrim2
IDXS :: BPrim2
SPLL :: BPrim2
SPLR :: BPrim2
TAKB :: BPrim2
DRPB :: BPrim2
IDXB :: BPrim2
CATB :: BPrim2
THRO :: BPrim2
TRCE :: BPrim2
SDBX :: BPrim2
data Branch
Test1 :: !Word64 -> !Section -> !Section -> Branch
Test2 :: !Word64 -> !Section -> !Word64 -> !Section -> !Section -> Branch
TestW :: !Section -> !EnumMap Word64 Section -> Branch
TestT :: !Section -> !Map Text Section -> Branch
bcount :: Args -> Int
ucount :: Args -> Int
emitCombs :: Var v => RefNums -> Reference -> Word64 -> SuperGroup v -> EnumMap Word64 Comb
emitComb :: Var v => RefNums -> Reference -> Word64 -> RCtx v -> (Word64, SuperNormal v) -> EnumMap Word64 Comb
emptyRNs :: RefNums
argsToLists :: Args -> ([Int], [Int])
combRef :: CombIx -> Reference
combDeps :: Comb -> [Word64]
combTypes :: Comb -> [Word64]
prettyCombs :: Word64 -> EnumMap Word64 Comb -> ShowS
prettyComb :: Word64 -> Word64 -> Comb -> ShowS
instance GHC.Show.Show Unison.Runtime.MCode.Args'
instance GHC.Classes.Ord Unison.Runtime.MCode.Args
instance GHC.Classes.Eq Unison.Runtime.MCode.Args
instance GHC.Show.Show Unison.Runtime.MCode.Args
instance GHC.Classes.Ord Unison.Runtime.MCode.UPrim1
instance GHC.Classes.Eq Unison.Runtime.MCode.UPrim1
instance GHC.Show.Show Unison.Runtime.MCode.UPrim1
instance GHC.Classes.Ord Unison.Runtime.MCode.UPrim2
instance GHC.Classes.Eq Unison.Runtime.MCode.UPrim2
instance GHC.Show.Show Unison.Runtime.MCode.UPrim2
instance GHC.Classes.Ord Unison.Runtime.MCode.BPrim1
instance GHC.Classes.Eq Unison.Runtime.MCode.BPrim1
instance GHC.Show.Show Unison.Runtime.MCode.BPrim1
instance GHC.Classes.Ord Unison.Runtime.MCode.BPrim2
instance GHC.Classes.Eq Unison.Runtime.MCode.BPrim2
instance GHC.Show.Show Unison.Runtime.MCode.BPrim2
instance GHC.Classes.Ord Unison.Runtime.MCode.MLit
instance GHC.Classes.Eq Unison.Runtime.MCode.MLit
instance GHC.Show.Show Unison.Runtime.MCode.MLit
instance GHC.Show.Show Unison.Runtime.MCode.CombIx
instance GHC.Classes.Ord Unison.Runtime.MCode.CombIx
instance GHC.Classes.Eq Unison.Runtime.MCode.CombIx
instance GHC.Classes.Ord Unison.Runtime.MCode.Ref
instance GHC.Classes.Eq Unison.Runtime.MCode.Ref
instance GHC.Show.Show Unison.Runtime.MCode.Ref
instance GHC.Classes.Ord Unison.Runtime.MCode.Instr
instance GHC.Classes.Eq Unison.Runtime.MCode.Instr
instance GHC.Show.Show Unison.Runtime.MCode.Instr
instance GHC.Classes.Ord Unison.Runtime.MCode.Section
instance GHC.Classes.Eq Unison.Runtime.MCode.Section
instance GHC.Show.Show Unison.Runtime.MCode.Section
instance GHC.Classes.Ord Unison.Runtime.MCode.Branch
instance GHC.Classes.Eq Unison.Runtime.MCode.Branch
instance GHC.Show.Show Unison.Runtime.MCode.Branch
instance GHC.Classes.Ord Unison.Runtime.MCode.Comb
instance GHC.Classes.Eq Unison.Runtime.MCode.Comb
instance GHC.Show.Show Unison.Runtime.MCode.Comb
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.MCode.Ctx v)
instance GHC.Base.Functor Unison.Runtime.MCode.Counted
instance GHC.Base.Functor Unison.Runtime.MCode.Emit
instance GHC.Base.Applicative Unison.Runtime.MCode.Emit
instance GHC.Base.Applicative Unison.Runtime.MCode.Counted

module Unison.Runtime.Debug
traceComb :: Bool -> Word64 -> Comb -> Bool
traceCombs :: Word64 -> Bool -> EnumMap Word64 Comb -> EnumMap Word64 Comb
tracePretty :: Var v => PrettyPrintEnv -> Bool -> Term v -> Term v
tracePrettyGroup :: Var v => Word64 -> Bool -> SuperGroup v -> SuperGroup v

module Unison.Util.Text.Pattern
data Pattern
Join :: [Pattern] -> Pattern
Or :: Pattern -> Pattern -> Pattern
Capture :: Pattern -> Pattern
Many :: Pattern -> Pattern
Replicate :: Int -> Int -> Pattern -> Pattern
AnyChar :: Pattern
Eof :: Pattern
Literal :: Text -> Pattern
CharRange :: Char -> Char -> Pattern
CharIn :: [Char] -> Pattern
NotCharIn :: [Char] -> Pattern
NotCharRange :: Char -> Char -> Pattern
Digit :: Pattern
Letter :: Pattern
Space :: Pattern
Punctuation :: Pattern
data CPattern
CP :: Pattern -> (Text -> Maybe ([Text], Text)) -> CPattern
cpattern :: Pattern -> CPattern
run :: Pattern -> Text -> Maybe ([Text], Text)
data Stack
Empty :: !Captures -> Stack
Mark :: !Captures -> !Text -> !Stack -> Stack
type Captures = [Text] -> [Text]
stackCaptures :: Stack -> Captures
pushCaptures :: Captures -> Stack -> Stack
pushCapture :: Text -> Stack -> Stack
appendCaptures :: Captures -> Captures -> Captures
emptyCaptures :: Captures
capturesToList :: Captures -> [Text]
type Compiled r = (Stack -> Text -> r) -> (Stack -> Text -> r) -> Stack -> Text -> r
compile :: Pattern -> Compiled r
charInPred :: [Char] -> Char -> Bool
charNotInPred :: [Char] -> Char -> Bool
try :: String -> Compiled r -> Compiled r
instance GHC.Classes.Ord Unison.Util.Text.Pattern.Pattern
instance GHC.Classes.Eq Unison.Util.Text.Pattern.Pattern
instance GHC.Classes.Eq Unison.Util.Text.Pattern.CPattern
instance GHC.Classes.Ord Unison.Util.Text.Pattern.CPattern

module Unison.Runtime.Foreign
data Foreign
[Wrap] :: Reference -> !e -> Foreign
data HashAlgorithm
[HashAlgorithm] :: HashAlgorithm a => Reference -> a -> HashAlgorithm
unwrapForeign :: Foreign -> a
maybeUnwrapForeign :: Reference -> Foreign -> Maybe a
wrapBuiltin :: forall f. BuiltinForeign f => f -> Foreign
maybeUnwrapBuiltin :: forall f. BuiltinForeign f => Foreign -> Maybe f
unwrapBuiltin :: BuiltinForeign f => Foreign -> f
class BuiltinForeign f
foreignRef :: BuiltinForeign f => Tagged f Reference
newtype Tls
Tls :: Context -> Tls
data Failure a
Failure :: Reference -> Text -> a -> Failure a
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.Foreign.HashAlgorithm
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Text
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Bytes.Bytes
instance Unison.Runtime.Foreign.BuiltinForeign GHC.IO.Handle.Types.Handle
instance Unison.Runtime.Foreign.BuiltinForeign System.Process.Common.ProcessHandle
instance Unison.Runtime.Foreign.BuiltinForeign Network.Socket.Types.Socket
instance Unison.Runtime.Foreign.BuiltinForeign GHC.Conc.Sync.ThreadId
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Parameters.ClientParams
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Parameters.ServerParams
instance Unison.Runtime.Foreign.BuiltinForeign Data.X509.SignedCertificate
instance Unison.Runtime.Foreign.BuiltinForeign Data.X509.PrivateKey.PrivKey
instance Unison.Runtime.Foreign.BuiltinForeign GHC.IO.FilePath
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Context.Internal.Context
instance Unison.Runtime.Foreign.BuiltinForeign (Unison.Runtime.ANF.SuperGroup Unison.Symbol.Symbol)
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.ANF.Value
instance Unison.Runtime.Foreign.BuiltinForeign System.Clock.TimeSpec
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Pattern.CPattern
instance GHC.Classes.Eq Unison.Runtime.Foreign.Foreign
instance GHC.Classes.Ord Unison.Runtime.Foreign.Foreign
instance GHC.Show.Show Unison.Runtime.Foreign.Foreign

module Unison.Runtime.Stack
data K
KE :: K
CB :: Callback -> K
Mark :: !Int -> !Int -> !EnumSet Word64 -> !EnumMap Word64 Closure -> !K -> K
Push :: !Int -> !Int -> !Int -> !Int -> !CombIx -> !K -> K
data Closure
PAp :: {-# UNPACK #-} !CombIx -> {-# UNPACK #-} !Seg 'UN -> !Seg 'BX -> Closure
Enum :: !Reference -> !Word64 -> Closure
DataU1 :: !Reference -> !Word64 -> !Int -> Closure
DataU2 :: !Reference -> !Word64 -> !Int -> !Int -> Closure
DataB1 :: !Reference -> !Word64 -> !Closure -> Closure
DataB2 :: !Reference -> !Word64 -> !Closure -> !Closure -> Closure
DataUB :: !Reference -> !Word64 -> !Int -> !Closure -> Closure
DataG :: !Reference -> !Word64 -> !Seg 'UN -> !Seg 'BX -> Closure
Captured :: !K -> !Int -> !Int -> {-# UNPACK #-} !Seg 'UN -> !Seg 'BX -> Closure
Foreign :: !Foreign -> Closure
BlackHole :: Closure
pattern DataC :: Reference -> Word64 -> [Int] -> [Closure] -> Closure
pattern PApV :: CombIx -> [Int] -> [Closure] -> Closure
pattern CapV :: K -> Int -> Int -> [Int] -> [Closure] -> Closure
newtype Callback
Hook :: (Stack 'UN -> Stack 'BX -> IO ()) -> Callback
data Augment
I :: Augment
K :: Augment
C :: Augment
data Dump
A :: Dump
F :: Int -> Int -> Dump
S :: Dump
class MEM (b :: Mem) where {
    data family Stack b :: Type;
    type family Elem b :: Type;
    type family Seg b :: Type;
}
alloc :: MEM b => IO (Stack b)
peek :: MEM b => Stack b -> IO (Elem b)
peekOff :: MEM b => Stack b -> Off -> IO (Elem b)
poke :: MEM b => Stack b -> Elem b -> IO ()
pokeOff :: MEM b => Stack b -> Off -> Elem b -> IO ()
grab :: MEM b => Stack b -> SZ -> IO (Seg b, Stack b)
ensure :: MEM b => Stack b -> SZ -> IO (Stack b)
bump :: MEM b => Stack b -> IO (Stack b)
bumpn :: MEM b => Stack b -> SZ -> IO (Stack b)
duplicate :: MEM b => Stack b -> IO (Stack b)
discardFrame :: MEM b => Stack b -> IO (Stack b)
saveFrame :: MEM b => Stack b -> IO (Stack b, SZ, SZ)
saveArgs :: MEM b => Stack b -> IO (Stack b, SZ)
restoreFrame :: MEM b => Stack b -> SZ -> SZ -> IO (Stack b)
prepareArgs :: MEM b => Stack b -> Args' -> IO (Stack b)
acceptArgs :: MEM b => Stack b -> Int -> IO (Stack b)
frameArgs :: MEM b => Stack b -> IO (Stack b)
augSeg :: MEM b => Augment -> Stack b -> Seg b -> Maybe Args' -> IO (Seg b)
dumpSeg :: MEM b => Stack b -> Seg b -> Dump -> IO (Stack b)
adjustArgs :: MEM b => Stack b -> SZ -> IO (Stack b)
fsize :: MEM b => Stack b -> SZ
asize :: MEM b => Stack b -> SZ
type Off = Int
type SZ = Int
type FP = Int
traceK :: Reference -> K -> [(Reference, Int)]
frameDataSize :: K -> (Int, Int)
marshalToForeign :: HasCallStack => Closure -> Foreign
unull :: Seg 'UN
bnull :: Seg 'BX
peekD :: Stack 'UN -> IO Double
peekOffD :: Stack 'UN -> Int -> IO Double
pokeD :: Stack 'UN -> Double -> IO ()
pokeOffD :: Stack 'UN -> Int -> Double -> IO ()
peekN :: Stack 'UN -> IO Word64
peekOffN :: Stack 'UN -> Int -> IO Word64
pokeN :: Stack 'UN -> Word64 -> IO ()
pokeOffN :: Stack 'UN -> Int -> Word64 -> IO ()
peekBi :: BuiltinForeign b => Stack 'BX -> IO b
peekOffBi :: BuiltinForeign b => Stack 'BX -> Int -> IO b
pokeBi :: BuiltinForeign b => Stack 'BX -> b -> IO ()
pokeOffBi :: BuiltinForeign b => Stack 'BX -> Int -> b -> IO ()
peekOffS :: Stack 'BX -> Int -> IO (Seq Closure)
pokeS :: Stack 'BX -> Seq Closure -> IO ()
pokeOffS :: Stack 'BX -> Int -> Seq Closure -> IO ()
frameView :: MEM b => Show (Elem b) => Stack b -> IO ()
uscount :: Seg 'UN -> Int
bscount :: Seg 'BX -> Int
closureTermRefs :: Monoid m => (Reference -> m) -> Closure -> m
instance GHC.Classes.Ord Unison.Runtime.Stack.Closure
instance GHC.Classes.Eq Unison.Runtime.Stack.Closure
instance GHC.Show.Show Unison.Runtime.Stack.Closure
instance GHC.Classes.Ord Unison.Runtime.Stack.K
instance GHC.Classes.Eq Unison.Runtime.Stack.K
instance GHC.Show.Show Unison.Runtime.Stack.K
instance Unison.Runtime.Stack.MEM 'Unison.Runtime.ANF.BX
instance GHC.Classes.Eq Unison.Runtime.Stack.Callback
instance GHC.Classes.Ord Unison.Runtime.Stack.Callback
instance Unison.Runtime.Stack.MEM 'Unison.Runtime.ANF.UN
instance GHC.Show.Show (Unison.Runtime.Stack.Stack 'Unison.Runtime.ANF.BX)
instance GHC.Show.Show (Unison.Runtime.Stack.Stack 'Unison.Runtime.ANF.UN)

module Unison.Runtime.Exception
data RuntimeExn
PE :: CallStack -> Pretty ColorText -> RuntimeExn
BU :: [(Reference, Int)] -> Text -> Closure -> RuntimeExn
die :: HasCallStack => String -> IO a
exn :: HasCallStack => String -> a
instance GHC.Show.Show Unison.Runtime.Exception.RuntimeExn
instance GHC.Exception.Type.Exception Unison.Runtime.Exception.RuntimeExn

module Unison.Runtime.Serialize
unknownTag :: MonadGet m => String -> Word8 -> m a
class Tag t
tag2word :: Tag t => t -> Word8
word2tag :: (Tag t, MonadGet m) => Word8 -> m t
putTag :: MonadPut m => Tag t => t -> m ()
getTag :: MonadGet m => Tag t => m t
putChar :: MonadPut m => Char -> m ()
getChar :: MonadGet m => m Char
putFloat :: MonadPut m => Double -> m ()
getFloat :: MonadGet m => m Double
putNat :: MonadPut m => Word64 -> m ()
getNat :: MonadGet m => m Word64
putInt :: MonadPut m => Int64 -> m ()
getInt :: MonadGet m => m Int64
putLength :: (MonadPut m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => n -> m ()
getLength :: (MonadGet m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => m n
putFoldable :: (Foldable f, MonadPut m) => (a -> m ()) -> f a -> m ()
putMap :: MonadPut m => (a -> m ()) -> (b -> m ()) -> Map a b -> m ()
getList :: MonadGet m => m a -> m [a]
getMap :: (MonadGet m, Ord a) => m a -> m b -> m (Map a b)
putEnumMap :: MonadPut m => EnumKey k => (k -> m ()) -> (v -> m ()) -> EnumMap k v -> m ()
getEnumMap :: MonadGet m => EnumKey k => m k -> m v -> m (EnumMap k v)
putEnumSet :: MonadPut m => EnumKey k => (k -> m ()) -> EnumSet k -> m ()
getEnumSet :: MonadGet m => EnumKey k => m k -> m (EnumSet k)
putMaybe :: MonadPut m => Maybe a -> (a -> m ()) -> m ()
getMaybe :: MonadGet m => m a -> m (Maybe a)
putPair :: MonadPut m => (a -> m ()) -> (b -> m ()) -> (a, b) -> m ()
getPair :: MonadGet m => m a -> m b -> m (a, b)
getBytes :: MonadGet m => m Bytes
putBytes :: MonadPut m => Bytes -> m ()
getByteArray :: MonadGet m => m ByteArray
putByteArray :: MonadPut m => ByteArray -> m ()
getBlock :: MonadGet m => m Chunk
putBlock :: MonadPut m => Chunk -> m ()
putHash :: MonadPut m => Hash -> m ()
getHash :: MonadGet m => m Hash
putReferent :: MonadPut m => Referent -> m ()
getReferent :: MonadGet m => m Referent
getConstructorType :: MonadGet m => m ConstructorType
putConstructorType :: MonadPut m => ConstructorType -> m ()
putText :: MonadPut m => Text -> m ()
getText :: MonadGet m => m Text
putReference :: MonadPut m => Reference -> m ()
getReference :: MonadGet m => m Reference
putConstructorReference :: MonadPut m => ConstructorReference -> m ()
getConstructorReference :: MonadGet m => m ConstructorReference
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.UPrim1
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.UPrim2
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.BPrim1
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.BPrim2

module Unison.Runtime.MCode.Serialize
putComb :: MonadPut m => Comb -> m ()
getComb :: MonadGet m => m Comb
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.BranchT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.MLitT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.RefT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.ArgsT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.InstrT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.SectionT

module Unison.Runtime.ANF.Serialize
type Version = Word32
data TmTag
VarT :: TmTag
ForceT :: TmTag
AppT :: TmTag
HandleT :: TmTag
ShiftT :: TmTag
MatchT :: TmTag
LitT :: TmTag
NameRefT :: TmTag
NameVarT :: TmTag
LetDirT :: TmTag
LetIndT :: TmTag
data FnTag
FVarT :: FnTag
FCombT :: FnTag
FContT :: FnTag
FConT :: FnTag
FReqT :: FnTag
FPrimT :: FnTag
FForeignT :: FnTag
data MtTag
MIntT :: MtTag
MTextT :: MtTag
MReqT :: MtTag
MEmptyT :: MtTag
MDataT :: MtTag
MSumT :: MtTag
data LtTag
IT :: LtTag
NT :: LtTag
FT :: LtTag
TT :: LtTag
CT :: LtTag
LMT :: LtTag
LYT :: LtTag
data BLTag
TextT :: BLTag
ListT :: BLTag
TmLinkT :: BLTag
TyLinkT :: BLTag
BytesT :: BLTag
QuoteT :: BLTag
CodeT :: BLTag
BArrT :: BLTag
data VaTag
PartialT :: VaTag
DataT :: VaTag
ContT :: VaTag
BLitT :: VaTag
data CoTag
KET :: CoTag
MarkT :: CoTag
PushT :: CoTag
index :: Eq v => [v] -> v -> Maybe Word64
deindex :: HasCallStack => [v] -> Word64 -> v
pushCtx :: [v] -> [v] -> [v]
putIndex :: MonadPut m => Word64 -> m ()
getIndex :: MonadGet m => m Word64
putVar :: MonadPut m => Eq v => [v] -> v -> m ()
getVar :: MonadGet m => [v] -> m v
putArgs :: MonadPut m => Eq v => [v] -> [v] -> m ()
getArgs :: MonadGet m => [v] -> m [v]
putCCs :: MonadPut m => [Mem] -> m ()
getCCs :: MonadGet m => m [Mem]
putGroup :: MonadPut m => Var v => EnumMap FOp Text -> SuperGroup v -> m ()
getGroup :: MonadGet m => Var v => m (SuperGroup v)
putComb :: MonadPut m => Var v => EnumMap FOp Text -> [v] -> SuperNormal v -> m ()
getFresh :: Var v => Word64 -> v
getComb :: MonadGet m => Var v => [v] -> Word64 -> m (SuperNormal v)
putNormal :: MonadPut m => Var v => EnumMap FOp Text -> [v] -> ANormal v -> m ()
getNormal :: MonadGet m => Var v => [v] -> Word64 -> m (ANormal v)
putFunc :: MonadPut m => Var v => EnumMap FOp Text -> [v] -> Func v -> m ()
getFunc :: MonadGet m => Var v => [v] -> m (Func v)
putPOp :: MonadPut m => POp -> m ()
getPOp :: MonadGet m => m POp
pOpCode :: POp -> Word16
pOpAssoc :: [(POp, Word16)]
pop2word :: Map POp Word16
word2pop :: Map Word16 POp
putLit :: MonadPut m => Lit -> m ()
getLit :: MonadGet m => m Lit
putBLit :: MonadPut m => BLit -> m ()
getBLit :: MonadGet m => Version -> m BLit
putRefs :: MonadPut m => [Reference] -> m ()
getRefs :: MonadGet m => m [Reference]
putBranches :: MonadPut m => Var v => EnumMap FOp Text -> [v] -> Branched (ANormal v) -> m ()
getBranches :: MonadGet m => Var v => [v] -> Word64 -> m (Branched (ANormal v))
putCase :: MonadPut m => Var v => EnumMap FOp Text -> [v] -> ([Mem], ANormal v) -> m ()
getCase :: MonadGet m => Var v => [v] -> Word64 -> m ([Mem], ANormal v)
putCTag :: MonadPut m => CTag -> m ()
getCTag :: MonadGet m => m CTag
putGroupRef :: MonadPut m => GroupRef -> m ()
getGroupRef :: MonadGet m => m GroupRef
putValue :: MonadPut m => Value -> m ()
getValue :: MonadGet m => Version -> m Value
putCont :: MonadPut m => Cont -> m ()
getCont :: MonadGet m => Version -> m Cont
deserializeGroup :: Var v => ByteString -> Either String (SuperGroup v)
serializeGroup :: Var v => EnumMap FOp Text -> SuperGroup v -> ByteString
deserializeValue :: ByteString -> Either String Value
serializeValue :: Value -> ByteString
serializeValueLazy :: Value -> ByteString
valueVersion :: Word32
codeVersion :: Word32
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.CoTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.VaTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.BLTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.LtTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.MtTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.FnTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.TmTag

module Unison.Runtime.Foreign.Function
data ForeignFunc
[FF] :: (Stack 'UN -> Stack 'BX -> Args -> IO a) -> (Stack 'UN -> Stack 'BX -> r -> IO (Stack 'UN, Stack 'BX)) -> (a -> IO r) -> ForeignFunc
class ForeignConvention a
readForeign :: ForeignConvention a => [Int] -> [Int] -> Stack 'UN -> Stack 'BX -> IO ([Int], [Int], a)
writeForeign :: ForeignConvention a => Stack 'UN -> Stack 'BX -> a -> IO (Stack 'UN, Stack 'BX)
mkForeign :: (ForeignConvention a, ForeignConvention r) => (a -> IO r) -> ForeignFunc
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Int
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word64
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word8
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word16
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word32
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Char
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Stack.Closure
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Util.Text.Text
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Util.Bytes.Bytes
instance Unison.Runtime.Foreign.Function.ForeignConvention Network.Socket.Types.Socket
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Conc.Sync.ThreadId
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Handle.Types.Handle
instance Unison.Runtime.Foreign.Function.ForeignConvention Data.Time.Clock.Internal.POSIXTime.POSIXTime
instance Unison.Runtime.Foreign.Function.ForeignConvention a => Unison.Runtime.Foreign.Function.ForeignConvention (GHC.Maybe.Maybe a)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b) => Unison.Runtime.Foreign.Function.ForeignConvention (Data.Either.Either a b)
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Exception.IOException
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Double
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Bool
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Base.String
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Device.SeekMode
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.IOMode.IOMode
instance Unison.Runtime.Foreign.Function.ForeignConvention ()
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b)
instance Unison.Runtime.Foreign.Function.ForeignConvention a => Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Runtime.Foreign.Failure a)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c, Unison.Runtime.Foreign.Function.ForeignConvention d) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c, d)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c, Unison.Runtime.Foreign.Function.ForeignConvention d, Unison.Runtime.Foreign.Function.ForeignConvention e) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c, d, e)
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Handle.Types.BufferMode
instance Unison.Runtime.Foreign.Function.ForeignConvention [Unison.Runtime.Stack.Closure]
instance Unison.Runtime.Foreign.Function.ForeignConvention [Unison.Runtime.Foreign.Foreign]
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.MVar.MVar Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.Conc.Sync.TVar Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.IORef.IORef Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Atomics.Internal.Ticket Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Util.RefPromise.Promise Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Runtime.ANF.SuperGroup Unison.Symbol.Symbol)
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.ANF.Value
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Foreign.Foreign
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Primitive.Array.MutableArray s Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Primitive.ByteArray.MutableByteArray s)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Primitive.Array.Array Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention Data.Primitive.ByteArray.ByteArray
instance Unison.Runtime.Foreign.BuiltinForeign b => Unison.Runtime.Foreign.Function.ForeignConvention b
instance Unison.Runtime.Foreign.BuiltinForeign b => Unison.Runtime.Foreign.Function.ForeignConvention [b]
instance GHC.Show.Show Unison.Runtime.Foreign.Function.ForeignFunc
instance GHC.Classes.Eq Unison.Runtime.Foreign.Function.ForeignFunc
instance GHC.Classes.Ord Unison.Runtime.Foreign.Function.ForeignFunc

module Unison.Runtime.Decompile
decompile :: Var v => (Word64 -> Word64 -> Maybe (Term v ())) -> Closure -> Either Error (Term v ())

module Unison.Runtime.Builtin
builtinLookup :: Map Reference (Sandbox, SuperNormal Symbol)
builtinTermNumbering :: Map Reference Word64
builtinTypeNumbering :: Map Reference Word64
builtinTermBackref :: EnumMap Word64 Reference
builtinTypeBackref :: EnumMap Word64 Reference
builtinForeigns :: EnumMap Word64 ForeignFunc
sandboxedForeigns :: EnumMap Word64 ForeignFunc
numberedTermLookup :: EnumMap Word64 (SuperNormal Symbol)
data Sandbox
Tracked :: Sandbox
Untracked :: Sandbox
baseSandboxInfo :: Map Reference (Set Reference)
instance GHC.Enum.Bounded Unison.Runtime.Builtin.Sandbox
instance GHC.Enum.Enum Unison.Runtime.Builtin.Sandbox
instance GHC.Read.Read Unison.Runtime.Builtin.Sandbox
instance GHC.Show.Show Unison.Runtime.Builtin.Sandbox
instance GHC.Classes.Ord Unison.Runtime.Builtin.Sandbox
instance GHC.Classes.Eq Unison.Runtime.Builtin.Sandbox
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v, v, v, v)

module Unison.Runtime.Machine

-- | A ref storing every currently active thread. This is helpful for
--   cleaning up orphaned threads when the main process completes. We track
--   threads when running in a host process like UCM, otherwise we don't
--   bother since forked threads are cleaned up automatically on
--   termination.
type ActiveThreads = Maybe (IORef (Set ThreadId))
type Tag = Word64
type DEnv = EnumMap Word64 Closure
data Tracer
NoTrace :: Tracer
MsgTrace :: String -> String -> Tracer
SimpleTrace :: String -> Tracer
data CCache
CCache :: EnumMap Word64 ForeignFunc -> Bool -> (Bool -> Closure -> Tracer) -> TVar (EnumMap Word64 Combs) -> TVar (EnumMap Word64 Reference) -> TVar (EnumMap Word64 Reference) -> TVar Word64 -> TVar Word64 -> TVar (Map Reference (SuperGroup Symbol)) -> TVar (Map Reference Word64) -> TVar (Map Reference Word64) -> TVar (Map Reference (Set Reference)) -> CCache
[$sel:foreignFuncs:CCache] :: CCache -> EnumMap Word64 ForeignFunc
[$sel:sandboxed:CCache] :: CCache -> Bool
[$sel:tracer:CCache] :: CCache -> Bool -> Closure -> Tracer
[$sel:combs:CCache] :: CCache -> TVar (EnumMap Word64 Combs)
[$sel:combRefs:CCache] :: CCache -> TVar (EnumMap Word64 Reference)
[$sel:tagRefs:CCache] :: CCache -> TVar (EnumMap Word64 Reference)
[$sel:freshTm:CCache] :: CCache -> TVar Word64
[$sel:freshTy:CCache] :: CCache -> TVar Word64
[$sel:intermed:CCache] :: CCache -> TVar (Map Reference (SuperGroup Symbol))
[$sel:refTm:CCache] :: CCache -> TVar (Map Reference Word64)
[$sel:refTy:CCache] :: CCache -> TVar (Map Reference Word64)
[$sel:sandbox:CCache] :: CCache -> TVar (Map Reference (Set Reference))
refNumsTm :: CCache -> IO (Map Reference Word64)
refNumsTy :: CCache -> IO (Map Reference Word64)
refNumTm :: CCache -> Reference -> IO Word64
refNumTy :: CCache -> Reference -> IO Word64
refNumTy' :: CCache -> Reference -> IO (Maybe Word64)
baseCCache :: Bool -> IO CCache
info :: Show a => String -> a -> IO ()
infos :: String -> String -> IO ()
stk'info :: Stack 'BX -> IO ()
eval0 :: CCache -> ActiveThreads -> Section -> IO ()
topDEnv :: Map Reference Word64 -> Map Reference Word64 -> (DEnv, K -> K)
apply0 :: Maybe (Stack 'UN -> Stack 'BX -> IO ()) -> CCache -> ActiveThreads -> Word64 -> IO ()
apply1 :: (Stack 'UN -> Stack 'BX -> IO ()) -> CCache -> ActiveThreads -> Closure -> IO ()
jump0 :: (Stack 'UN -> Stack 'BX -> IO ()) -> CCache -> ActiveThreads -> Closure -> IO ()
unitValue :: Closure
lookupDenv :: Word64 -> DEnv -> Closure
exec :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Reference -> Instr -> IO (DEnv, Stack 'UN, Stack 'BX, K)
encodeExn :: Stack 'UN -> Stack 'BX -> Either SomeException () -> IO (Stack 'BX)
eval :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Reference -> Section -> IO ()
forkEval :: CCache -> ActiveThreads -> Closure -> IO ThreadId
nestEval :: CCache -> ActiveThreads -> (Closure -> IO ()) -> Closure -> IO ()
atomicEval :: CCache -> ActiveThreads -> (Closure -> IO ()) -> Closure -> IO ()
enter :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Bool -> Args -> Comb -> IO ()
name :: Stack 'UN -> Stack 'BX -> Args -> Closure -> IO (Stack 'BX)
apply :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Bool -> Args -> Closure -> IO ()
jump :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Args -> Closure -> IO ()
repush :: CCache -> ActiveThreads -> Stack 'UN -> Stack 'BX -> DEnv -> K -> K -> IO ()
moveArgs :: Stack 'UN -> Stack 'BX -> Args -> IO (Stack 'UN, Stack 'BX)
closureArgs :: Stack 'BX -> Args -> IO [Closure]
buildData :: Stack 'UN -> Stack 'BX -> Reference -> Tag -> Args -> IO Closure
dumpData :: Maybe Reference -> Stack 'UN -> Stack 'BX -> Closure -> IO (Stack 'UN, Stack 'BX)
closeArgs :: Augment -> Stack 'UN -> Stack 'BX -> Seg 'UN -> Seg 'BX -> Args -> IO (Seg 'UN, Seg 'BX)
peekForeign :: Stack 'BX -> Int -> IO a
uprim1 :: Stack 'UN -> UPrim1 -> Int -> IO (Stack 'UN)
uprim2 :: Stack 'UN -> UPrim2 -> Int -> Int -> IO (Stack 'UN)
bprim1 :: Stack 'UN -> Stack 'BX -> BPrim1 -> Int -> IO (Stack 'UN, Stack 'BX)
bprim2 :: Stack 'UN -> Stack 'BX -> BPrim2 -> Int -> Int -> IO (Stack 'UN, Stack 'BX)
yield :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> IO ()
selectTextBranch :: Text -> Section -> Map Text Section -> Section
selectBranch :: Tag -> Branch -> Section
splitCont :: DEnv -> Stack 'UN -> Stack 'BX -> K -> Word64 -> IO (Closure, DEnv, Stack 'UN, Stack 'BX, K)
discardCont :: DEnv -> Stack 'UN -> Stack 'BX -> K -> Word64 -> IO (DEnv, Stack 'UN, Stack 'BX, K)
resolve :: CCache -> DEnv -> Stack 'BX -> Ref -> IO Closure
combSection :: HasCallStack => CCache -> CombIx -> IO Comb
dummyRef :: Reference
reserveIds :: Word64 -> TVar Word64 -> IO Word64
updateMap :: Semigroup s => s -> TVar s -> STM s
refLookup :: String -> Map Reference Word64 -> Reference -> Word64
decodeCacheArgument :: Seq Closure -> IO [(Reference, SuperGroup Symbol)]
decodeSandboxArgument :: Seq Closure -> IO [Reference]
addRefs :: TVar Word64 -> TVar (Map Reference Word64) -> TVar (EnumMap Word64 Reference) -> Set Reference -> STM (Map Reference Word64)
codeValidate :: [(Reference, SuperGroup Symbol)] -> CCache -> IO (Maybe (Failure Closure))
checkSandboxing :: CCache -> [Reference] -> Closure -> IO Bool
cacheAdd0 :: Set Reference -> [(Reference, SuperGroup Symbol)] -> [(Reference, Set Reference)] -> CCache -> IO ()
expandSandbox :: Map Reference (Set Reference) -> [(Reference, SuperGroup Symbol)] -> [(Reference, Set Reference)]
cacheAdd :: [(Reference, SuperGroup Symbol)] -> CCache -> IO [Reference]
reflectValue :: EnumMap Word64 Reference -> Closure -> IO Value
reifyValue :: CCache -> Value -> IO (Either [Reference] Closure)
reifyValue0 :: (Map Reference Word64, Map Reference Word64) -> Value -> IO Closure
closureNum :: Closure -> Int
universalEq :: (Foreign -> Foreign -> Bool) -> Closure -> Closure -> Bool
arrayEq :: (Closure -> Closure -> Bool) -> Array Closure -> Array Closure -> Bool
compareAsFloat :: Int -> Int -> Ordering
compareAsNat :: Int -> Int -> Ordering
floatTag :: Word64
natTag :: Word64
charTag :: Word64
unitTag :: Word64
universalCompare :: (Foreign -> Foreign -> Ordering) -> Closure -> Closure -> Ordering
arrayCmp :: (Closure -> Closure -> Ordering) -> Array Closure -> Array Closure -> Ordering

module Unison.Runtime.Interface
startRuntime :: Bool -> RuntimeHost -> Text -> IO (Runtime Symbol)
withRuntime :: MonadUnliftIO m => Bool -> RuntimeHost -> Text -> (Runtime Symbol -> m a) -> m a
standalone :: CCache -> Word64 -> IO StoredCache
runStandalone :: StoredCache -> Word64 -> IO (Either (Pretty ColorText) ())
data StoredCache
decodeStandalone :: ByteString -> Either String (Text, Text, Word64, StoredCache)

-- | Whether the runtime is hosted within a persistent session or as a
--   one-off process. This affects the amount of clean-up and book-keeping
--   the runtime does.
data RuntimeHost
OneOff :: RuntimeHost
Persistent :: RuntimeHost
data Runtime v
Runtime :: IO () -> (CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error (Term v))) -> (CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)) -> Type v Ann -> Type v Ann -> Runtime v
[$sel:terminate:Runtime] :: Runtime v -> IO ()
[$sel:evaluate:Runtime] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error (Term v))
[$sel:compileTo:Runtime] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)
[$sel:mainType:Runtime] :: Runtime v -> Type v Ann
[$sel:ioTestType:Runtime] :: Runtime v -> Type v Ann
instance GHC.Show.Show Unison.Runtime.Interface.StoredCache

module Unison.Util.TransitiveClosure
transitiveClosure :: forall m a. (Monad m, Ord a) => (a -> m (Set a)) -> Set a -> m (Set a)
transitiveClosure' :: Ord a => (a -> Set a) -> Set a -> Set a
transitiveClosure1 :: forall m a. (Monad m, Ord a) => (a -> m (Set a)) -> a -> m (Set a)
transitiveClosure1' :: Ord a => (a -> Set a) -> a -> Set a

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-syntax
@version 0.0.0

module Unison.Lexer.Pos
data Pos
Pos :: {-# UNPACK #-} !Line -> {-# UNPACK #-} !Column -> Pos
type Line = Int
type Column = Int
line :: Pos -> Line
column :: Pos -> Column
instance GHC.Classes.Ord Unison.Lexer.Pos.Pos
instance GHC.Classes.Eq Unison.Lexer.Pos.Pos
instance GHC.Show.Show Unison.Lexer.Pos.Pos
instance GHC.Base.Semigroup Unison.Lexer.Pos.Pos
instance GHC.Base.Monoid Unison.Lexer.Pos.Pos

module Unison.Parser.Ann
data Ann
Intrinsic :: Ann
External :: Ann
Ann :: Pos -> Pos -> Ann
[$sel:start:Intrinsic] :: Ann -> Pos
[$sel:end:Intrinsic] :: Ann -> Pos
startingLine :: Ann -> Maybe Line

-- | Checks whether an annotation contains a given position i.e. pos ∈
--   [start, end)
--   
--   <pre>
--   &gt;&gt;&gt; Intrinsic `contains` L.Pos 1 1
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; External `contains` L.Pos 1 1
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 0 0) (L.Pos 0 10) `contains` L.Pos 0 5
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 0 0) (L.Pos 0 10) `contains` L.Pos 0 10
--   False
--   </pre>
contains :: Ann -> Pos -> Bool

-- | Checks whether an annotation contains another annotation.
--   
--   i.e. pos ∈ [start, end)
--   
--   <pre>
--   &gt;&gt;&gt; Intrinsic `encompasses` Ann (L.Pos 1 1) (L.Pos 2 1)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; External `encompasses` Ann (L.Pos 1 1) (L.Pos 2 1)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 0 0) (L.Pos 0 10) `encompasses` Ann (L.Pos 0 1) (L.Pos 0 5)
--   Just True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 1 0) (L.Pos 1 10) `encompasses` Ann (L.Pos 0 0) (L.Pos 2 0)
--   Just False
--   </pre>
encompasses :: Ann -> Ann -> Maybe Bool
instance GHC.Show.Show Unison.Parser.Ann.Ann
instance GHC.Classes.Ord Unison.Parser.Ann.Ann
instance GHC.Classes.Eq Unison.Parser.Ann.Ann
instance GHC.Base.Monoid Unison.Parser.Ann.Ann
instance GHC.Base.Semigroup Unison.Parser.Ann.Ann

module Unison.Syntax.Lexer
data Token a
Token :: a -> !Pos -> !Pos -> Token a
[$sel:payload:Token] :: Token a -> a
[$sel:start:Token] :: Token a -> !Pos
[$sel:end:Token] :: Token a -> !Pos
type Line = Int
type Column = Int
data Err
InvalidWordyId :: String -> Err
ReservedWordyId :: String -> Err
InvalidSymbolyId :: String -> Err
ReservedSymbolyId :: String -> Err
InvalidShortHash :: String -> Err
InvalidBytesLiteral :: String -> Err
InvalidHexLiteral :: Err
InvalidOctalLiteral :: Err
Both :: Err -> Err -> Err
MissingFractional :: String -> Err
MissingExponent :: String -> Err
UnknownLexeme :: Err
TextLiteralMissingClosingQuote :: String -> Err
InvalidEscapeCharacter :: Char -> Err
LayoutError :: Err
CloseWithoutMatchingOpen :: String -> String -> Err
UnexpectedDelimiter :: String -> Err
Opaque :: String -> Err
data Pos
Pos :: {-# UNPACK #-} !Line -> {-# UNPACK #-} !Column -> Pos
data Lexeme
Open :: String -> Lexeme
Semi :: IsVirtual -> Lexeme
Close :: Lexeme
Reserved :: String -> Lexeme
Textual :: String -> Lexeme
Character :: Char -> Lexeme
WordyId :: String -> Maybe ShortHash -> Lexeme
SymbolyId :: String -> Maybe ShortHash -> Lexeme
Blank :: String -> Lexeme
Numeric :: String -> Lexeme
Bytes :: Bytes -> Lexeme
Hash :: ShortHash -> Lexeme
Err :: Err -> Lexeme
lexer :: String -> String -> [Token Lexeme]
simpleWordyId :: String -> Lexeme
simpleSymbolyId :: String -> Lexeme
line :: Pos -> Line
column :: Pos -> Column
escapeChars :: [(Char, Char)]
debugFileLex :: String -> IO ()
debugLex' :: String -> String
debugLex'' :: [Token Lexeme] -> String
debugLex''' :: String -> String -> String
showEscapeChar :: Char -> Maybe Char
touches :: Token a -> Token b -> Bool
typeModifiers :: Set String
typeOrAbilityAlt :: Alternative f => (String -> f a) -> f a
typeModifiersAlt :: Alternative f => (String -> f a) -> f a
wordyIdChar :: Char -> Bool
wordyIdStartChar :: Char -> Bool
wordyId :: String -> Either Err (String, String)
symbolyId :: String -> Either Err (String, String)
symbolyIdChar :: Char -> Bool
wordyId0 :: String -> Either Err (String, String)
symbolyId0 :: String -> Either Err (String, String)
instance Data.Traversable.Traversable Unison.Syntax.Lexer.T
instance Data.Foldable.Foldable Unison.Syntax.Lexer.T
instance GHC.Base.Functor Unison.Syntax.Lexer.T
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Lexer.T a)
instance Text.Megaparsec.Error.ShowErrorComponent (Unison.Syntax.Lexer.Token Unison.Syntax.Lexer.Err)
instance Text.Megaparsec.Stream.VisualStream [Unison.Syntax.Lexer.Token Unison.Syntax.Lexer.Lexeme]
instance GHC.Base.Applicative Unison.Syntax.Lexer.Token
instance Data.Traversable.Traversable Unison.Syntax.Lexer.Token
instance Data.Foldable.Foldable Unison.Syntax.Lexer.Token
instance GHC.Base.Functor Unison.Syntax.Lexer.Token
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Lexer.Token a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Lexer.Token a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Lexer.Token a)
instance GHC.Show.Show Unison.Syntax.Lexer.ParsingEnv
instance GHC.Show.Show Unison.Syntax.Lexer.Err
instance GHC.Classes.Ord Unison.Syntax.Lexer.Err
instance GHC.Classes.Eq Unison.Syntax.Lexer.Err
instance GHC.Classes.Ord Unison.Syntax.Lexer.Lexeme
instance GHC.Show.Show Unison.Syntax.Lexer.Lexeme
instance GHC.Classes.Eq Unison.Syntax.Lexer.Lexeme


-- | Syntax-related combinators for Name (to/from string types).
module Unison.Syntax.Name

-- | Parse a name from a string literal.
--   
--   Performs very minor validation (a name can't be empty, nor contain a
--   <tt>#</tt> character [at least currently?]) but makes no attempt at
--   rejecting bogus names like "foo...bar...baz".
fromText :: Text -> Maybe Name

-- | Parse a name from a string literal.
--   
--   Performs very minor validation (a name can't be empty, nor contain a
--   <tt>#</tt> character [at least currently?]) but makes no attempt at
--   rejecting bogus names like "foo...bar...baz".
fromTextEither :: Text -> Either Text Name

-- | Unsafely parse a name from a string literal. See
--   <a>unsafeFromText</a>.
unsafeFromString :: String -> Name

-- | Unsafely parse a name from a string literal.
--   
--   Performs very minor validation (a name can't be empty, nor contain a
--   <tt>#</tt> character [at least currently?]) but makes no attempt at
--   rejecting bogus names like "foo...bar...baz".
unsafeFromText :: HasCallStack => Text -> Name

-- | Unsafely parse a name from a var, by first rendering the var as a
--   string.
--   
--   See <a>unsafeFromText</a>.
unsafeFromVar :: Var v => v -> Name

-- | Convert a name to a string representation.
toString :: Name -> String

-- | Convert a name to a string representation.
toText :: Name -> Text

-- | Convert a name to a string representation, then parse that as a var.
toVar :: Var v => Name -> v
instance Data.String.IsString Unison.Name.Internal.Name


-- | Syntax-related combinators for HashQualified' (to/from string types).
module Unison.Syntax.HashQualified'
fromString :: String -> Maybe (HashQualified Name)
fromText :: Text -> Maybe (HashQualified Name)
unsafeFromText :: HasCallStack => Text -> HashQualified Name
toString :: HashQualified Name -> String
toText :: HashQualified Name -> Text
instance Data.String.IsString (Unison.HashQualified'.HashQualified Unison.Name.Internal.Name)
instance Unison.Name.Parse Data.Text.Internal.Text (Unison.HashQualified'.HashQualified Unison.Name.Internal.Name)


-- | Syntax-related combinators for HashQualified (to/from string types).
module Unison.Syntax.HashQualified
fromString :: String -> Maybe (HashQualified Name)
fromText :: Text -> Maybe (HashQualified Name)
unsafeFromString :: String -> HashQualified Name
unsafeFromText :: Text -> HashQualified Name
unsafeFromVar :: Var v => v -> HashQualified Name
toString :: HashQualified Name -> String
toText :: HashQualified Name -> Text
toVar :: Var v => HashQualified Name -> v
instance Unison.Name.Parse Data.Text.Internal.Text (Unison.HashQualified.HashQualified Unison.Name.Internal.Name)

module Unison.UnisonFile.Error
data Error v a
UnknownType :: v -> a -> Error v a
DupDataAndAbility :: v -> a -> a -> Error v a
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.UnisonFile.Error.Error v a)
instance (GHC.Classes.Ord v, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.UnisonFile.Error.Error v a)
instance (GHC.Classes.Eq v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.UnisonFile.Error.Error v a)

module Unison.Syntax.Parser
class Annotated a
ann :: Annotated a => a -> Ann
type Err v = ParseError Input (Error v)
data Error v
SignatureNeedsAccompanyingBody :: Token v -> Error v
DisallowedAbsoluteName :: Token Name -> Error v
EmptyBlock :: Token String -> Error v
UnknownAbilityConstructor :: Token (HashQualified Name) -> Set ConstructorReference -> Error v
UnknownDataConstructor :: Token (HashQualified Name) -> Set ConstructorReference -> Error v
UnknownTerm :: Token (HashQualified Name) -> Set Referent -> Error v
UnknownType :: Token (HashQualified Name) -> Set Reference -> Error v
UnknownId :: Token (HashQualified Name) -> Set Referent -> Set Reference -> Error v
ExpectedBlockOpen :: String -> Token Lexeme -> Error v
EmptyMatch :: Token () -> Error v
EmptyWatch :: Ann -> Error v
UseInvalidPrefixSuffix :: Either (Token Name) (Token Name) -> Maybe [Token Name] -> Error v
UseEmpty :: Token String -> Error v
DidntExpectExpression :: Token Lexeme -> Maybe (Token Lexeme) -> Error v
TypeDeclarationErrors :: [Error v Ann] -> Error v
MissingTypeModifier :: Token String -> Token v -> Error v
ResolutionFailures :: [ResolutionFailure v Ann] -> Error v
DuplicateTypeNames :: [(v, [Ann])] -> Error v
DuplicateTermNames :: [(v, [Ann])] -> Error v
PatternArityMismatch :: Int -> Int -> Ann -> Error v
FloatPattern :: Ann -> Error v
data Input
type P v m = ParsecT (Error v) Input (ReaderT (ParsingEnv m) m)
data ParsingEnv (m :: Type -> Type)
ParsingEnv :: UniqueName -> (Name -> m (Maybe Text)) -> NamesWithHistory -> ParsingEnv (m :: Type -> Type)
[$sel:uniqueNames:ParsingEnv] :: ParsingEnv (m :: Type -> Type) -> UniqueName

-- | Return a GUID to reuse for a unique type of the given name, if any.
--   
--   This callback is called for every `unique type` declaration that does
--   not explicitly specify a GUID.
--   
--   The name (e.g. <tt>Foo</tt> in `unique type Foo`) is passed in, and if
--   the function returns a Just, that GUID is used; otherwise, a random
--   one is generated from <a>$sel:uniqueNames:ParsingEnv</a>.
[$sel:uniqueTypeGuid:ParsingEnv] :: ParsingEnv (m :: Type -> Type) -> Name -> m (Maybe Text)
[$sel:names:ParsingEnv] :: ParsingEnv (m :: Type -> Type) -> NamesWithHistory
data UniqueName
anyToken :: Ord v => P v m (Token Lexeme)
blank :: Ord v => P v m (Token String)
bytesToken :: Ord v => P v m (Token Bytes)
chainl1 :: Ord v => P v m a -> P v m (a -> a -> a) -> P v m a
chainr1 :: Ord v => P v m a -> P v m (a -> a -> a) -> P v m a
character :: Ord v => P v m (Token Char)
closeBlock :: Ord v => P v m (Token ())
failCommitted :: Ord v => Error v -> P v m x
failureIf :: Ord v => P v m (P v m b) -> P v m a -> P v m b
hqInfixId :: Ord v => P v m (Token (HashQualified Name))
hqPrefixId :: Ord v => P v m (Token (HashQualified Name))
importDotId :: Ord v => P v m (Token Name)
importSymbolyId :: Ord v => P v m (Token Name)
importWordyId :: Ord v => P v m (Token Name)
label :: (Ord v, Show a) => String -> P v m a -> P v m a
matchToken :: Ord v => Lexeme -> P v m (Token Lexeme)
mkAnn :: (Annotated a, Annotated b) => a -> b -> Ann
numeric :: Ord v => P v m (Token String)
openBlock :: Ord v => P v m (Token String)
openBlockWith :: Ord v => String -> P v m (Token ())
peekAny :: Ord v => P v m (Token Lexeme)
positionalVar :: (Annotated a, Var v) => a -> v -> v
prefixDefinitionName :: Var v => P v m (Token v)
prefixTermName :: Var v => P v m (Token v)
queryToken :: Ord v => (Lexeme -> Maybe a) -> P v m (Token a)
reserved :: Ord v => String -> P v m (Token String)
root :: Ord v => P v m a -> P v m a
rootFile :: Ord v => P v m a -> P v m a
run' :: (Monad m, Ord v) => P v m a -> String -> String -> ParsingEnv m -> m (Either (Err v) a)
run :: (Monad m, Ord v) => P v m a -> String -> ParsingEnv m -> m (Either (Err v) a)
semi :: Ord v => P v m (Token ())
seq :: Ord v => (Ann -> [a] -> a) -> P v m a -> P v m a
sepBy :: Ord v => P v m a -> P v m b -> P v m [b]
sepBy1 :: Ord v => P v m a -> P v m b -> P v m [b]
string :: Ord v => P v m (Token Text)
symbolyDefinitionName :: Var v => P v m (Token v)
symbolyIdString :: Ord v => P v m (Token String)
tok :: (Ann -> a -> b) -> Token a -> b
tokenToPair :: Token a -> (Ann, a)
tupleOrParenthesized :: Ord v => P v m a -> (Ann -> a) -> (a -> a -> a) -> P v m a
uniqueBase32Namegen :: forall gen. DRG gen => gen -> UniqueName
uniqueName :: (Monad m, Var v) => Int -> P v m Text
wordyDefinitionName :: Var v => P v m (Token v)
wordyIdString :: Ord v => P v m (Token String)
wordyPatternName :: Var v => P v m (Token v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Syntax.Parser.Error v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Syntax.Parser.Error v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Syntax.Parser.Error v)
instance Text.Megaparsec.Stream.VisualStream Unison.Syntax.Parser.Input
instance Text.Megaparsec.Stream.Stream Unison.Syntax.Parser.Input
instance GHC.Show.Show Unison.Syntax.Parser.Input
instance GHC.Classes.Ord Unison.Syntax.Parser.Input
instance GHC.Classes.Eq Unison.Syntax.Parser.Input
instance Unison.Syntax.Parser.Annotated Unison.Parser.Ann.Ann
instance Unison.Syntax.Parser.Annotated (Unison.Syntax.Lexer.Token a)
instance Unison.Syntax.Parser.Annotated a => Unison.Syntax.Parser.Annotated (U.Core.ABT.Term f v a)
instance Unison.Syntax.Parser.Annotated a => Unison.Syntax.Parser.Annotated (Unison.Pattern.Pattern a)
instance Unison.Syntax.Parser.Annotated a => Unison.Syntax.Parser.Annotated [a]
instance (Unison.Syntax.Parser.Annotated a, Unison.Syntax.Parser.Annotated b) => Unison.Syntax.Parser.Annotated (Unison.Term.MatchCase a b)
instance GHC.Base.Semigroup Unison.Syntax.Parser.UniqueName
instance GHC.Base.Monoid Unison.Syntax.Parser.UniqueName

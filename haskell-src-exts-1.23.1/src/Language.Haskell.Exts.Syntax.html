<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621679444697"><span id="local-6989586621679444698"><span id="local-6989586621679444699"><span id="local-6989586621679444700"><span id="local-6989586621679444701"><span id="local-6989586621679444702"><span id="local-6989586621679444703"><span id="local-6989586621679444704"><span id="local-6989586621679444705"><span id="local-6989586621679444706"><span id="local-6989586621679444707"><span id="local-6989586621679444708"><span id="local-6989586621679444709"><span id="local-6989586621679444710"><span id="local-6989586621679444711"><span id="local-6989586621679444712"><span id="local-6989586621679444713"><span id="local-6989586621679444714"><span id="local-6989586621679444715"><span id="local-6989586621679444716"><span id="local-6989586621679444717"><span id="local-6989586621679444718"><span id="local-6989586621679444719"><span id="local-6989586621679444720"><span id="local-6989586621679444721"><span id="local-6989586621679444722"><span id="local-6989586621679444723"><span id="local-6989586621679444724"><span id="local-6989586621679444725"><span id="local-6989586621679444726"><span id="local-6989586621679444727"><span id="local-6989586621679444728"><span id="local-6989586621679444729"><span id="local-6989586621679444730"><span id="local-6989586621679444731"><span id="local-6989586621679444732"><span id="local-6989586621679444733"><span id="local-6989586621679444734"><span id="local-6989586621679444735"><span id="local-6989586621679444736"><span id="local-6989586621679444737"><span id="local-6989586621679444738"><span id="local-6989586621679444739"><span id="local-6989586621679444740"><span id="local-6989586621679444741"><span id="local-6989586621679444742"><span id="local-6989586621679444743"><span id="local-6989586621679444744"><span id="local-6989586621679444745"><span id="local-6989586621679444746"><span id="local-6989586621679444747"><span id="local-6989586621679444748"><span id="local-6989586621679444749"><span id="local-6989586621679444750"><span id="local-6989586621679444751"><span id="local-6989586621679444752"><span id="local-6989586621679444753"><span id="local-6989586621679444754"><span id="local-6989586621679444755"><span id="local-6989586621679444756"><span id="local-6989586621679444757"><span id="local-6989586621679444758"><span id="local-6989586621679444759"><span id="local-6989586621679444760"><span id="local-6989586621679444761"><span id="local-6989586621679444762"><span id="local-6989586621679444763"><span id="local-6989586621679444764"><span id="local-6989586621679444765"><span id="local-6989586621679444766"><span id="local-6989586621679444767"><span id="local-6989586621679444768"><span id="local-6989586621679444769"><span id="local-6989586621679444770"><span id="local-6989586621679444771"><span id="local-6989586621679444772"><span id="local-6989586621679444773"><span id="local-6989586621679444774"><span id="local-6989586621679444775"><span id="local-6989586621679444776"><span id="local-6989586621679444777"><span id="local-6989586621679444778"><span id="local-6989586621679444779"><span id="local-6989586621679444780"><span id="local-6989586621679444781"><span id="local-6989586621679444782"><span id="local-6989586621679444783"><span id="local-6989586621679444784"><span id="local-6989586621679444785"><span id="local-6989586621679444786"><span id="local-6989586621679444787"><span id="local-6989586621679444788"><span id="local-6989586621679444789"><span id="local-6989586621679444790"><span id="local-6989586621679444791"><span id="local-6989586621679444792"><span id="local-6989586621679444793"><span id="local-6989586621679444794"><span id="local-6989586621679444795"><span id="local-6989586621679444796"><span id="local-6989586621679444797"><span id="local-6989586621679444798"><span id="local-6989586621679444799"><span id="local-6989586621679444800"><span id="local-6989586621679444801"><span id="local-6989586621679444802"><span id="local-6989586621679444803"><span id="local-6989586621679444804"><span id="local-6989586621679444805"><span id="local-6989586621679444806"><span id="local-6989586621679444807"><span id="local-6989586621679444808"><span id="local-6989586621679444809"><span id="local-6989586621679444810"><span id="local-6989586621679444811"><span id="local-6989586621679444812"><span id="local-6989586621679444813"><span id="local-6989586621679444814"><span id="local-6989586621679444815"><span id="local-6989586621679444816"><span id="local-6989586621679444817"><span id="local-6989586621679444818"><span id="local-6989586621679444819"><span id="local-6989586621679444820"><span id="local-6989586621679444821"><span id="local-6989586621679444822"><span id="local-6989586621679444823"><span id="local-6989586621679444824"><span id="local-6989586621679444825"><span id="local-6989586621679444826"><span id="local-6989586621679444827"><span id="local-6989586621679444828"><span id="local-6989586621679444829"><span id="local-6989586621679444830"><span id="local-6989586621679444831"><span id="local-6989586621679444832"><span id="local-6989586621679444833"><span id="local-6989586621679444834"><span id="local-6989586621679444835"><span id="local-6989586621679444836"><span id="local-6989586621679444837"><span id="local-6989586621679444838"><span id="local-6989586621679444839"><span id="local-6989586621679444840"><span id="local-6989586621679444841"><span id="local-6989586621679444842"><span id="local-6989586621679444843"><span id="local-6989586621679444844"><span id="local-6989586621679444845"><span id="local-6989586621679444846"><span id="local-6989586621679444847"><span id="local-6989586621679444848"><span id="local-6989586621679444849"><span id="local-6989586621679444850"><span id="local-6989586621679444851"><span id="local-6989586621679444852"><span id="local-6989586621679444853"><span id="local-6989586621679444854"><span id="local-6989586621679444855"><span id="local-6989586621679444856"><span id="local-6989586621679444857"><span id="local-6989586621679444858"><span id="local-6989586621679444859"><span id="local-6989586621679444860"><span id="local-6989586621679444861"><span id="local-6989586621679444862"><span id="local-6989586621679444863"><span id="local-6989586621679444864"><span id="local-6989586621679444865"><span id="local-6989586621679444866"><span id="local-6989586621679444867"><span id="local-6989586621679444868"><span id="local-6989586621679444869"><span id="local-6989586621679444870"><span id="local-6989586621679444871"><span id="local-6989586621679444872"><span id="local-6989586621679444873"><span id="local-6989586621679444874"><span id="local-6989586621679444875"><span id="local-6989586621679444876"><span id="local-6989586621679444877"><span id="local-6989586621679444878"><span id="local-6989586621679444879"><span id="local-6989586621679444880"><span id="local-6989586621679444881"><span id="local-6989586621679444882"><span id="local-6989586621679444883"><span id="local-6989586621679444884"><span id="local-6989586621679444885"><span id="local-6989586621679444886"><span id="local-6989586621679444887"><span id="local-6989586621679444888"><span id="local-6989586621679444889"><span id="local-6989586621679444890"><span id="local-6989586621679444891"><span id="local-6989586621679444892"><span id="local-6989586621679444893"><span id="local-6989586621679444894"><span id="local-6989586621679444895"><span id="local-6989586621679444896"><span id="local-6989586621679444897"><span id="local-6989586621679444898"><span id="local-6989586621679444899"><span id="local-6989586621679444900"><span id="local-6989586621679444901"><span id="local-6989586621679444902"><span id="local-6989586621679444903"><span id="local-6989586621679444904"><span id="local-6989586621679444905"><span id="local-6989586621679444906"><span id="local-6989586621679444907"><span id="local-6989586621679444908"><span id="local-6989586621679444909"><span id="local-6989586621679444910"><span id="local-6989586621679444911"><span id="local-6989586621679444912"><span id="local-6989586621679444913"><span id="local-6989586621679444914"><span id="local-6989586621679444915"><span id="local-6989586621679444916"><span id="local-6989586621679444917"><span id="local-6989586621679444918"><span id="local-6989586621679444919"><span id="local-6989586621679444920"><span id="local-6989586621679444921"><span id="local-6989586621679444922"><span id="local-6989586621679444923"><span id="local-6989586621679444924"><span id="local-6989586621679444925"><span id="local-6989586621679444926"><span id="local-6989586621679444927"><span id="local-6989586621679444928"><span id="local-6989586621679444929"><span id="local-6989586621679444930"><span id="local-6989586621679444931"><span id="local-6989586621679444932"><span id="local-6989586621679444933"><span id="local-6989586621679444934"><span id="local-6989586621679444935"><span id="local-6989586621679444936"><span id="local-6989586621679444937"><span id="local-6989586621679444938"><span id="local-6989586621679444939"><span id="local-6989586621679444940"><span id="local-6989586621679444941"><span id="local-6989586621679444942"><span id="local-6989586621679444943"><span id="local-6989586621679444944"><span id="local-6989586621679444945"><span id="local-6989586621679444946"><span id="local-6989586621679444947"><span id="local-6989586621679444948"><span id="local-6989586621679444949"><span id="local-6989586621679444950"><span id="local-6989586621679444951"><span id="local-6989586621679444952"><span id="local-6989586621679444953"><span id="local-6989586621679444954"><span id="local-6989586621679444955"><span id="local-6989586621679444956"><span id="local-6989586621679444957"><span id="local-6989586621679444958"><span id="local-6989586621679444959"><span id="local-6989586621679444960"><span id="local-6989586621679444961"><span id="local-6989586621679444962"><span id="local-6989586621679444963"><span id="local-6989586621679444964"><span id="local-6989586621679444965"><span id="local-6989586621679444966"><span id="local-6989586621679444967"><span id="local-6989586621679444968"><span id="local-6989586621679444969"><span id="local-6989586621679444970"><span id="local-6989586621679444971"><span id="local-6989586621679444972"><span id="local-6989586621679444973"><span id="local-6989586621679444974"><span id="local-6989586621679444975"><span id="local-6989586621679444976"><span id="local-6989586621679444977"><span id="local-6989586621679444978"><span id="local-6989586621679444979"><span id="local-6989586621679444980"><span id="local-6989586621679444981"><span id="local-6989586621679444982"><span id="local-6989586621679444983"><span id="local-6989586621679444984"><span id="local-6989586621679444985"><span id="local-6989586621679444986"><span id="local-6989586621679444987"><span id="local-6989586621679444988"><span id="local-6989586621679444989"><span id="local-6989586621679444990"><span id="local-6989586621679444991"><span id="local-6989586621679444992"><span id="local-6989586621679444993"><span id="local-6989586621679444994"><span id="local-6989586621679444995"><span id="local-6989586621679444996"><span id="local-6989586621679444997"><span id="local-6989586621679444998"><span id="local-6989586621679444999"><span id="local-6989586621679445000"><span id="local-6989586621679445001"><span id="local-6989586621679445002"><span id="local-6989586621679445003"><span id="local-6989586621679445004"><span id="local-6989586621679445005"><span id="local-6989586621679445006"><span id="local-6989586621679445007"><span id="local-6989586621679445008"><span id="local-6989586621679445009"><span id="local-6989586621679445010"><span id="local-6989586621679445011"><span id="local-6989586621679445012"><span id="local-6989586621679445013"><span id="local-6989586621679445014"><span id="local-6989586621679445015"><span id="local-6989586621679445016"><span id="local-6989586621679445017"><span id="local-6989586621679445018"><span id="local-6989586621679445019"><span id="local-6989586621679445020"><span id="local-6989586621679445021"><span id="local-6989586621679445022"><span id="local-6989586621679445023"><span id="local-6989586621679445024"><span id="local-6989586621679445025"><span id="local-6989586621679445026"><span id="local-6989586621679445027"><span id="local-6989586621679445028"><span id="local-6989586621679445029"><span id="local-6989586621679445030"><span id="local-6989586621679445031"><span id="local-6989586621679445032"><span id="local-6989586621679445033"><span id="local-6989586621679445034"><span id="local-6989586621679445035"><span id="local-6989586621679445036"><span id="local-6989586621679445037"><span id="local-6989586621679445038"><span id="local-6989586621679445039"><span id="local-6989586621679445040"><span id="local-6989586621679445041"><span id="local-6989586621679445042"><span id="local-6989586621679445043"><span id="local-6989586621679445044"><span id="local-6989586621679445045"><span id="local-6989586621679445046"><span id="local-6989586621679445047"><span id="local-6989586621679445048"><span id="local-6989586621679445049"><span id="local-6989586621679445050"><span id="local-6989586621679445051"><span id="local-6989586621679445052"><span id="local-6989586621679445053"><span id="local-6989586621679445054"><span id="local-6989586621679445055"><span id="local-6989586621679445056"><span id="local-6989586621679445057"><span id="local-6989586621679445058"><span id="local-6989586621679445059"><span id="local-6989586621679445060"><span id="local-6989586621679445061"><span id="local-6989586621679445062"><span id="local-6989586621679445063"><span id="local-6989586621679445064"><span id="local-6989586621679445065"><span id="local-6989586621679445066"><span id="local-6989586621679445067"><span id="local-6989586621679445068"><span id="local-6989586621679445069"><span id="local-6989586621679445070"><span id="local-6989586621679445071"><span id="local-6989586621679445072"><span id="local-6989586621679445073"><span id="local-6989586621679445074"><span id="local-6989586621679445075"><span id="local-6989586621679445076"><span id="local-6989586621679445077"><span id="local-6989586621679445078"><span id="local-6989586621679445079"><span id="local-6989586621679445080"><span id="local-6989586621679445081"><span id="local-6989586621679445082"><span id="local-6989586621679445083"><span id="local-6989586621679445084"><span id="local-6989586621679445085"><span id="local-6989586621679445086"><span id="local-6989586621679445087"><span id="local-6989586621679445088"><span id="local-6989586621679445089"><span id="local-6989586621679445090"><span id="local-6989586621679445091"><span id="local-6989586621679445092"><span id="local-6989586621679445093"><span id="local-6989586621679445094"><span id="local-6989586621679445095"><span id="local-6989586621679445096"><span id="local-6989586621679445097"><span id="local-6989586621679445098"><span id="local-6989586621679445099"><span id="local-6989586621679445100"><span id="local-6989586621679445101"><span id="local-6989586621679445102"><span id="local-6989586621679445103"><span id="local-6989586621679445104"><span id="local-6989586621679445105"><span id="local-6989586621679445106"><span id="local-6989586621679445107"><span id="local-6989586621679445108"><span id="local-6989586621679445109"><span id="local-6989586621679445110"><span id="local-6989586621679445111"><span id="local-6989586621679445112"><span id="local-6989586621679445113"><span id="local-6989586621679445114"><span id="local-6989586621679445115"><span id="local-6989586621679445116"><span id="local-6989586621679445117"><span id="local-6989586621679445118"><span id="local-6989586621679445119"><span id="local-6989586621679445120"><span id="local-6989586621679445121"><span id="local-6989586621679445122"><span id="local-6989586621679445123"><span id="local-6989586621679445124"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE DeriveFoldable #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE DeriveTraversable #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE DeriveFunctor #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE DeriveGeneric #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-7"></span><span>
</span><span id="line-8"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- Module      :  Language.Haskell.Exts.Syntax</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- Copyright   :  (c) Niklas Broberg 2004-2009,</span><span>
</span><span id="line-12"></span><span class="hs-comment">--                (c) The GHC Team, 1997-2000</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- License     :  BSD-style (see the file LICENSE.txt)</span><span>
</span><span id="line-14"></span><span class="hs-comment">--</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- Maintainer  :  Niklas Broberg, d00nibro@chalmers.se</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- Stability   :  stable</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- Portability :  portable</span><span>
</span><span id="line-18"></span><span class="hs-comment">--</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- A suite of datatypes describing the (semi-concrete) abstract syntax of Haskell 98</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- &lt;http://www.haskell.org/onlinereport/&gt; plus registered extensions, including:</span><span>
</span><span id="line-21"></span><span class="hs-comment">--</span><span>
</span><span id="line-22"></span><span class="hs-comment">--   * multi-parameter type classes with functional dependencies (MultiParamTypeClasses, FunctionalDependencies)</span><span>
</span><span id="line-23"></span><span class="hs-comment">--</span><span>
</span><span id="line-24"></span><span class="hs-comment">--   * parameters of type class assertions are unrestricted (FlexibleContexts)</span><span>
</span><span id="line-25"></span><span class="hs-comment">--</span><span>
</span><span id="line-26"></span><span class="hs-comment">--   * 'forall' types as universal and existential quantification (RankNTypes, ExistentialQuantification, etc)</span><span>
</span><span id="line-27"></span><span class="hs-comment">--</span><span>
</span><span id="line-28"></span><span class="hs-comment">--   * pattern guards (PatternGuards)</span><span>
</span><span id="line-29"></span><span class="hs-comment">--</span><span>
</span><span id="line-30"></span><span class="hs-comment">--   * implicit parameters (ImplicitParameters)</span><span>
</span><span id="line-31"></span><span class="hs-comment">--</span><span>
</span><span id="line-32"></span><span class="hs-comment">--   * generalised algebraic data types (GADTs)</span><span>
</span><span id="line-33"></span><span class="hs-comment">--</span><span>
</span><span id="line-34"></span><span class="hs-comment">--   * template haskell (TemplateHaskell)</span><span>
</span><span id="line-35"></span><span class="hs-comment">--</span><span>
</span><span id="line-36"></span><span class="hs-comment">--   * empty data type declarations (EmptyDataDecls)</span><span>
</span><span id="line-37"></span><span class="hs-comment">--</span><span>
</span><span id="line-38"></span><span class="hs-comment">--   * unboxed tuples (UnboxedTuples)</span><span>
</span><span id="line-39"></span><span class="hs-comment">--</span><span>
</span><span id="line-40"></span><span class="hs-comment">--   * regular patterns (RegularPatterns)</span><span>
</span><span id="line-41"></span><span class="hs-comment">--</span><span>
</span><span id="line-42"></span><span class="hs-comment">--   * HSP-style XML expressions and patterns (XmlSyntax)</span><span>
</span><span id="line-43"></span><span class="hs-comment">--</span><span>
</span><span id="line-44"></span><span class="hs-comment">-- All nodes in the syntax tree are annotated with something of a user-definable data type.</span><span>
</span><span id="line-45"></span><span class="hs-comment">-- When parsing, this annotation will contain information about the source location that the</span><span>
</span><span id="line-46"></span><span class="hs-comment">-- particular node comes from.</span><span>
</span><span id="line-47"></span><span class="hs-comment">--</span><span>
</span><span id="line-48"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-49"></span><span>
</span><span id="line-50"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.Exts.Syntax</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-51"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Modules</span></span><span>
</span><span id="line-52"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Module"><span class="hs-identifier">Module</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleHead"><span class="hs-identifier">ModuleHead</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#WarningText"><span class="hs-identifier">WarningText</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExportSpecList"><span class="hs-identifier">ExportSpecList</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExportSpec"><span class="hs-identifier">ExportSpec</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-53"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EWildcard"><span class="hs-identifier">EWildcard</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-54"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier">ImportDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportSpecList"><span class="hs-identifier">ImportSpecList</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportSpec"><span class="hs-identifier">ImportSpec</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Assoc"><span class="hs-identifier">Assoc</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Namespace"><span class="hs-identifier">Namespace</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-55"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Declarations</span></span><span>
</span><span id="line-56"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier">Decl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier">DeclHead</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstRule"><span class="hs-identifier">InstRule</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstHead"><span class="hs-identifier">InstHead</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Binds"><span class="hs-identifier">Binds</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPBind"><span class="hs-identifier">IPBind</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatternSynDirection"><span class="hs-identifier">PatternSynDirection</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-57"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InjectivityInfo"><span class="hs-identifier">InjectivityInfo</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ResultSig"><span class="hs-identifier">ResultSig</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-58"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Type classes and instances</span></span><span>
</span><span id="line-59"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClassDecl"><span class="hs-identifier">ClassDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstDecl"><span class="hs-identifier">InstDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier">Deriving</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivStrategy"><span class="hs-identifier">DerivStrategy</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-60"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Data type declarations</span></span><span>
</span><span id="line-61"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataOrNew"><span class="hs-identifier">DataOrNew</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConDecl"><span class="hs-identifier">ConDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldDecl"><span class="hs-identifier">FieldDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualConDecl"><span class="hs-identifier">QualConDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GadtDecl"><span class="hs-identifier">GadtDecl</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BangType"><span class="hs-identifier">BangType</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-62"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Unpackedness"><span class="hs-identifier">Unpackedness</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-63"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Function bindings</span></span><span>
</span><span id="line-64"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Match"><span class="hs-identifier">Match</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rhs"><span class="hs-identifier">Rhs</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GuardedRhs"><span class="hs-identifier">GuardedRhs</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-65"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Class Assertions and Contexts</span></span><span>
</span><span id="line-66"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier">Context</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunDep"><span class="hs-identifier">FunDep</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Asst"><span class="hs-identifier">Asst</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-67"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Types</span></span><span>
</span><span id="line-68"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier">Type</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier">Boxed</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Kind"><span class="hs-identifier">Kind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier">TyVarBind</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Promoted"><span class="hs-identifier">Promoted</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-69"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeEqn"><span class="hs-identifier">TypeEqn</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-70"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Expressions</span></span><span>
</span><span id="line-71"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier">Exp</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier">Stmt</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualStmt"><span class="hs-identifier">QualStmt</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldUpdate"><span class="hs-identifier">FieldUpdate</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-72"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Alt"><span class="hs-identifier">Alt</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XAttr"><span class="hs-identifier">XAttr</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-73"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Patterns</span></span><span>
</span><span id="line-74"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier">Pat</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatField"><span class="hs-identifier">PatField</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXAttr"><span class="hs-identifier">PXAttr</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier">RPat</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPatOp"><span class="hs-identifier">RPatOp</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-75"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Literals</span></span><span>
</span><span id="line-76"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Literal"><span class="hs-identifier">Literal</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Sign"><span class="hs-identifier">Sign</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-77"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Variables, Constructors and Operators</span></span><span>
</span><span id="line-78"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier">ModuleName</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier">QName</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier">Name</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QOp"><span class="hs-identifier">QOp</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Op"><span class="hs-identifier">Op</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-79"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpecialCon"><span class="hs-identifier">SpecialCon</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CName"><span class="hs-identifier">CName</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPName"><span class="hs-identifier">IPName</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier">XName</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Role"><span class="hs-identifier">Role</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-80"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MaybePromotedName"><span class="hs-identifier">MaybePromotedName</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Template Haskell</span></span><span>
</span><span id="line-83"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Bracket"><span class="hs-identifier">Bracket</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Splice"><span class="hs-identifier">Splice</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span>    </span><span class="annot"><span class="hs-comment">-- * FFI</span></span><span>
</span><span id="line-86"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Safety"><span class="hs-identifier">Safety</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CallConv"><span class="hs-identifier">CallConv</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-87"></span><span>
</span><span id="line-88"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Pragmas</span></span><span>
</span><span id="line-89"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModulePragma"><span class="hs-identifier">ModulePragma</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Tool"><span class="hs-identifier">Tool</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlap"><span class="hs-identifier">Overlap</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-90"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rule"><span class="hs-identifier">Rule</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RuleVar"><span class="hs-identifier">RuleVar</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Activation"><span class="hs-identifier">Activation</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-91"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotation"><span class="hs-identifier">Annotation</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BooleanFormula"><span class="hs-identifier">BooleanFormula</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-92"></span><span>
</span><span id="line-93"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Builtin names</span></span><span>
</span><span id="line-94"></span><span>
</span><span id="line-95"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Modules</span></span><span>
</span><span id="line-96"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#prelude_mod"><span class="hs-identifier">prelude_mod</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#main_mod"><span class="hs-identifier">main_mod</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-97"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Main function of a program</span></span><span>
</span><span id="line-98"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#main_name"><span class="hs-identifier">main_name</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-99"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Constructors</span></span><span>
</span><span id="line-100"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unit_con_name"><span class="hs-identifier">unit_con_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#tuple_con_name"><span class="hs-identifier">tuple_con_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#list_con_name"><span class="hs-identifier">list_con_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#list_cons_name"><span class="hs-identifier">list_cons_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_con_name"><span class="hs-identifier">unboxed_singleton_con_name</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-101"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unit_con"><span class="hs-identifier">unit_con</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#tuple_con"><span class="hs-identifier">tuple_con</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_con"><span class="hs-identifier">unboxed_singleton_con</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-102"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Special identifiers</span></span><span>
</span><span id="line-103"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#as_name"><span class="hs-identifier">as_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#qualified_name"><span class="hs-identifier">qualified_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#hiding_name"><span class="hs-identifier">hiding_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#minus_name"><span class="hs-identifier">minus_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#bang_name"><span class="hs-identifier">bang_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#dot_name"><span class="hs-identifier">dot_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#star_name"><span class="hs-identifier">star_name</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-104"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#export_name"><span class="hs-identifier">export_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#safe_name"><span class="hs-identifier">safe_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unsafe_name"><span class="hs-identifier">unsafe_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#interruptible_name"><span class="hs-identifier">interruptible_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#threadsafe_name"><span class="hs-identifier">threadsafe_name</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-105"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#stdcall_name"><span class="hs-identifier">stdcall_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ccall_name"><span class="hs-identifier">ccall_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#cplusplus_name"><span class="hs-identifier">cplusplus_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#dotnet_name"><span class="hs-identifier">dotnet_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#jvm_name"><span class="hs-identifier">jvm_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#js_name"><span class="hs-identifier">js_name</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-106"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#javascript_name"><span class="hs-identifier">javascript_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#capi_name"><span class="hs-identifier">capi_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#forall_name"><span class="hs-identifier">forall_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#family_name"><span class="hs-identifier">family_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#role_name"><span class="hs-identifier">role_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#hole_name"><span class="hs-identifier">hole_name</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-107"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#stock_name"><span class="hs-identifier">stock_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#anyclass_name"><span class="hs-identifier">anyclass_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#via_name"><span class="hs-identifier">via_name</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-108"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Type constructors</span></span><span>
</span><span id="line-109"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unit_tycon_name"><span class="hs-identifier">unit_tycon_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#fun_tycon_name"><span class="hs-identifier">fun_tycon_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#list_tycon_name"><span class="hs-identifier">list_tycon_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#tuple_tycon_name"><span class="hs-identifier">tuple_tycon_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_tycon_name"><span class="hs-identifier">unboxed_singleton_tycon_name</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-110"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unit_tycon"><span class="hs-identifier">unit_tycon</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#fun_tycon"><span class="hs-identifier">fun_tycon</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#list_tycon"><span class="hs-identifier">list_tycon</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#tuple_tycon"><span class="hs-identifier">tuple_tycon</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_tycon"><span class="hs-identifier">unboxed_singleton_tycon</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-111"></span><span>
</span><span id="line-112"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Source coordinates</span></span><span>
</span><span id="line-113"></span><span>    </span><span class="hs-comment">-- SrcLoc(..),</span><span>
</span><span id="line-114"></span><span>
</span><span id="line-115"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Annotated trees</span></span><span>
</span><span id="line-116"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier">Annotated</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#%3D~%3D"><span class="hs-operator">(=~=)</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-117"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-118"></span><span>
</span><span id="line-119"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">id</span></span><span class="hs-special">)</span><span>
</span><span id="line-120"></span><span>
</span><span id="line-121"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Data</span></span><span>
</span><span id="line-122"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Generic</span></span><span class="hs-special">)</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &lt; 710
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data.Foldable</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Foldable</span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data.Traversable</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Traversable</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-128"></span><span class="hs-comment">-- | The name of a Haskell module.</span><span>
</span><span id="line-129"></span><span id="local-6989586621679444645"><span id="local-6989586621679444646"></span></span><span class="hs-keyword">data</span><span> </span><span id="ModuleName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-var">ModuleName</span></a></span></span><span> </span><span id="local-6989586621679452933"><span class="annot"><a href="#local-6989586621679452933"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ModuleName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-var">ModuleName</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452933"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-130"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679444636"><span id="local-6989586621679444642"><span class="annot"><span class="annottext">ModuleName l -&gt; ModuleName l -&gt; Bool
forall l. Eq l =&gt; ModuleName l -&gt; ModuleName l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ModuleName l -&gt; ModuleName l -&gt; Bool
$c/= :: forall l. Eq l =&gt; ModuleName l -&gt; ModuleName l -&gt; Bool
== :: ModuleName l -&gt; ModuleName l -&gt; Bool
$c== :: forall l. Eq l =&gt; ModuleName l -&gt; ModuleName l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444608"><span id="local-6989586621679444610"><span id="local-6989586621679444613"><span id="local-6989586621679444616"><span id="local-6989586621679444619"><span id="local-6989586621679444624"><span id="local-6989586621679444630"><span class="annot"><span class="annottext">ModuleName l -&gt; ModuleName l -&gt; Bool
ModuleName l -&gt; ModuleName l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (ModuleName l)
forall l. Ord l =&gt; ModuleName l -&gt; ModuleName l -&gt; Bool
forall l. Ord l =&gt; ModuleName l -&gt; ModuleName l -&gt; Ordering
forall l. Ord l =&gt; ModuleName l -&gt; ModuleName l -&gt; ModuleName l
min :: ModuleName l -&gt; ModuleName l -&gt; ModuleName l
$cmin :: forall l. Ord l =&gt; ModuleName l -&gt; ModuleName l -&gt; ModuleName l
max :: ModuleName l -&gt; ModuleName l -&gt; ModuleName l
$cmax :: forall l. Ord l =&gt; ModuleName l -&gt; ModuleName l -&gt; ModuleName l
&gt;= :: ModuleName l -&gt; ModuleName l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; ModuleName l -&gt; ModuleName l -&gt; Bool
&gt; :: ModuleName l -&gt; ModuleName l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; ModuleName l -&gt; ModuleName l -&gt; Bool
&lt;= :: ModuleName l -&gt; ModuleName l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; ModuleName l -&gt; ModuleName l -&gt; Bool
&lt; :: ModuleName l -&gt; ModuleName l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; ModuleName l -&gt; ModuleName l -&gt; Bool
compare :: ModuleName l -&gt; ModuleName l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; ModuleName l -&gt; ModuleName l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444594"><span id="local-6989586621679444596"><span id="local-6989586621679444604"><span class="annot"><span class="annottext">Int -&gt; ModuleName l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; ModuleName l -&gt; ShowS
forall l. Show l =&gt; [ModuleName l] -&gt; ShowS
forall l. Show l =&gt; ModuleName l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ModuleName l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [ModuleName l] -&gt; ShowS
show :: ModuleName l -&gt; String
$cshow :: forall l. Show l =&gt; ModuleName l -&gt; String
showsPrec :: Int -&gt; ModuleName l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; ModuleName l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679444550"><span id="local-6989586621679444552"><span id="local-6989586621679444554"><span id="local-6989586621679444556"><span id="local-6989586621679444558"><span id="local-6989586621679444560"><span id="local-6989586621679444562"><span id="local-6989586621679444564"><span id="local-6989586621679444566"><span id="local-6989586621679444572"><span id="local-6989586621679444574"><span id="local-6989586621679444576"><span id="local-6989586621679444581"><span id="local-6989586621679444587"><span class="annot"><span class="annottext">ModuleName l -&gt; DataType
ModuleName l -&gt; Constr
forall {l}. Data l =&gt; Typeable (ModuleName l)
forall l. Data l =&gt; ModuleName l -&gt; DataType
forall l. Data l =&gt; ModuleName l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ModuleName l -&gt; ModuleName l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleName l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ModuleName l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleName l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleName l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleName l -&gt; m (ModuleName l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleName l -&gt; m (ModuleName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModuleName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModuleName l -&gt; c (ModuleName l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModuleName l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ModuleName l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModuleName l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModuleName l -&gt; c (ModuleName l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModuleName l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleName l -&gt; m (ModuleName l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleName l -&gt; m (ModuleName l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleName l -&gt; m (ModuleName l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleName l -&gt; m (ModuleName l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleName l -&gt; m (ModuleName l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleName l -&gt; m (ModuleName l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleName l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleName l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleName l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ModuleName l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleName l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleName l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleName l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleName l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ModuleName l -&gt; ModuleName l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ModuleName l -&gt; ModuleName l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ModuleName l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ModuleName l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModuleName l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModuleName l))
dataTypeOf :: ModuleName l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; ModuleName l -&gt; DataType
toConstr :: ModuleName l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; ModuleName l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModuleName l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModuleName l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModuleName l -&gt; c (ModuleName l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModuleName l -&gt; c (ModuleName l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444513"><span id="local-6989586621679444515"><span id="local-6989586621679444517"><span id="local-6989586621679444519"><span id="local-6989586621679444521"><span id="local-6989586621679444523"><span id="local-6989586621679444525"><span id="local-6989586621679444527"><span id="local-6989586621679444529"><span id="local-6989586621679444531"><span id="local-6989586621679444533"><span id="local-6989586621679444535"><span id="local-6989586621679444537"><span id="local-6989586621679444539"><span id="local-6989586621679444541"><span id="local-6989586621679444544"><span id="local-6989586621679444546"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; ModuleName a -&gt; Bool
forall a. Num a =&gt; ModuleName a -&gt; a
forall a. Ord a =&gt; ModuleName a -&gt; a
forall m. Monoid m =&gt; ModuleName m -&gt; m
forall a. ModuleName a -&gt; Bool
forall a. ModuleName a -&gt; Int
forall a. ModuleName a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; ModuleName a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModuleName a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModuleName a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModuleName a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; ModuleName a -&gt; a
$cproduct :: forall a. Num a =&gt; ModuleName a -&gt; a
sum :: forall a. Num a =&gt; ModuleName a -&gt; a
$csum :: forall a. Num a =&gt; ModuleName a -&gt; a
minimum :: forall a. Ord a =&gt; ModuleName a -&gt; a
$cminimum :: forall a. Ord a =&gt; ModuleName a -&gt; a
maximum :: forall a. Ord a =&gt; ModuleName a -&gt; a
$cmaximum :: forall a. Ord a =&gt; ModuleName a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; ModuleName a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; ModuleName a -&gt; Bool
length :: forall a. ModuleName a -&gt; Int
$clength :: forall a. ModuleName a -&gt; Int
null :: forall a. ModuleName a -&gt; Bool
$cnull :: forall a. ModuleName a -&gt; Bool
toList :: forall a. ModuleName a -&gt; [a]
$ctoList :: forall a. ModuleName a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModuleName a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModuleName a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModuleName a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModuleName a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModuleName a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModuleName a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModuleName a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModuleName a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModuleName a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModuleName a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModuleName a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModuleName a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModuleName a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModuleName a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModuleName a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModuleName a -&gt; m
fold :: forall m. Monoid m =&gt; ModuleName m -&gt; m
$cfold :: forall m. Monoid m =&gt; ModuleName m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444496"><span id="local-6989586621679444498"><span id="local-6989586621679444500"><span id="local-6989586621679444505"><span class="annot"><span class="annottext">Functor ModuleName
Foldable ModuleName
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
ModuleName (m a) -&gt; m (ModuleName a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
ModuleName (f a) -&gt; f (ModuleName a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ModuleName a -&gt; m (ModuleName b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ModuleName a -&gt; f (ModuleName b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ModuleName (m a) -&gt; m (ModuleName a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ModuleName (m a) -&gt; m (ModuleName a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ModuleName a -&gt; m (ModuleName b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ModuleName a -&gt; m (ModuleName b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ModuleName (f a) -&gt; f (ModuleName a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ModuleName (f a) -&gt; f (ModuleName a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ModuleName a -&gt; f (ModuleName b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ModuleName a -&gt; f (ModuleName b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444490"><span id="local-6989586621679444492"><span class="annot"><span class="annottext">forall a b. a -&gt; ModuleName b -&gt; ModuleName a
forall a b. (a -&gt; b) -&gt; ModuleName a -&gt; ModuleName b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; ModuleName b -&gt; ModuleName a
$c&lt;$ :: forall a b. a -&gt; ModuleName b -&gt; ModuleName a
fmap :: forall a b. (a -&gt; b) -&gt; ModuleName a -&gt; ModuleName b
$cfmap :: forall a b. (a -&gt; b) -&gt; ModuleName a -&gt; ModuleName b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (ModuleName l) x -&gt; ModuleName l
forall l x. ModuleName l -&gt; Rep (ModuleName l) x
$cto :: forall l x. Rep (ModuleName l) x -&gt; ModuleName l
$cfrom :: forall l x. ModuleName l -&gt; Rep (ModuleName l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-131"></span><span>
</span><span id="line-132"></span><span class="hs-comment">-- | Constructors with special syntax.</span><span>
</span><span id="line-133"></span><span class="hs-comment">-- These names are never qualified, and always refer to builtin type or</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- data constructors.</span><span>
</span><span id="line-135"></span><span id="local-6989586621679444483"><span id="local-6989586621679444484"></span></span><span class="hs-keyword">data</span><span> </span><span id="SpecialCon"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpecialCon"><span class="hs-identifier hs-var">SpecialCon</span></a></span></span><span> </span><span id="local-6989586621679452851"><span class="annot"><a href="#local-6989586621679452851"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-136"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="UnitCon"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnitCon"><span class="hs-identifier hs-var">UnitCon</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452851"><span class="hs-identifier hs-type">l</span></a></span><span>             </span><span class="hs-comment">-- ^ unit type and data constructor @()@</span><span>
</span><span id="line-137"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ListCon"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ListCon"><span class="hs-identifier hs-var">ListCon</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452851"><span class="hs-identifier hs-type">l</span></a></span><span>             </span><span class="hs-comment">-- ^ list type and data constructor @[]@</span><span>
</span><span id="line-138"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="FunCon"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunCon"><span class="hs-identifier hs-var">FunCon</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452851"><span class="hs-identifier hs-type">l</span></a></span><span>             </span><span class="hs-comment">-- ^ function type constructor @-&gt;@</span><span>
</span><span id="line-139"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="TupleCon"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TupleCon"><span class="hs-identifier hs-var">TupleCon</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452851"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier hs-type">Boxed</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>  </span><span class="hs-comment">-- ^ /n/-ary tuple type and data</span><span>
</span><span id="line-140"></span><span>                            </span><span class="hs-comment">--   constructors @(,)@ etc, possibly boxed @(\#,\#)@</span><span>
</span><span id="line-141"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Cons"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Cons"><span class="hs-identifier hs-var">Cons</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452851"><span class="hs-identifier hs-type">l</span></a></span><span>                </span><span class="hs-comment">-- ^ list data constructor @(:)@</span><span>
</span><span id="line-142"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="UnboxedSingleCon"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnboxedSingleCon"><span class="hs-identifier hs-var">UnboxedSingleCon</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452851"><span class="hs-identifier hs-type">l</span></a></span><span>    </span><span class="hs-comment">-- ^ unboxed singleton tuple constructor @(\# \#)@</span><span>
</span><span id="line-143"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ExprHole"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExprHole"><span class="hs-identifier hs-var">ExprHole</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452851"><span class="hs-identifier hs-type">l</span></a></span><span>            </span><span class="hs-comment">-- ^ An expression hole _</span><span>
</span><span id="line-144"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679444462"><span id="local-6989586621679444474"><span class="annot"><span class="annottext">SpecialCon l -&gt; SpecialCon l -&gt; Bool
forall l. Eq l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: SpecialCon l -&gt; SpecialCon l -&gt; Bool
$c/= :: forall l. Eq l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; Bool
== :: SpecialCon l -&gt; SpecialCon l -&gt; Bool
$c== :: forall l. Eq l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444437"><span id="local-6989586621679444439"><span id="local-6989586621679444441"><span id="local-6989586621679444443"><span id="local-6989586621679444445"><span id="local-6989586621679444447"><span id="local-6989586621679444458"><span class="annot"><span class="annottext">SpecialCon l -&gt; SpecialCon l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (SpecialCon l)
forall l. Ord l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; Bool
forall l. Ord l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; Ordering
forall l. Ord l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; SpecialCon l
min :: SpecialCon l -&gt; SpecialCon l -&gt; SpecialCon l
$cmin :: forall l. Ord l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; SpecialCon l
max :: SpecialCon l -&gt; SpecialCon l -&gt; SpecialCon l
$cmax :: forall l. Ord l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; SpecialCon l
&gt;= :: SpecialCon l -&gt; SpecialCon l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; Bool
&gt; :: SpecialCon l -&gt; SpecialCon l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; Bool
&lt;= :: SpecialCon l -&gt; SpecialCon l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; Bool
&lt; :: SpecialCon l -&gt; SpecialCon l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; Bool
compare :: SpecialCon l -&gt; SpecialCon l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; SpecialCon l -&gt; SpecialCon l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444414"><span id="local-6989586621679444416"><span id="local-6989586621679444435"><span class="annot"><span class="annottext">Int -&gt; SpecialCon l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; SpecialCon l -&gt; ShowS
forall l. Show l =&gt; [SpecialCon l] -&gt; ShowS
forall l. Show l =&gt; SpecialCon l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [SpecialCon l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [SpecialCon l] -&gt; ShowS
show :: SpecialCon l -&gt; String
$cshow :: forall l. Show l =&gt; SpecialCon l -&gt; String
showsPrec :: Int -&gt; SpecialCon l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; SpecialCon l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679444360"><span id="local-6989586621679444362"><span id="local-6989586621679444364"><span id="local-6989586621679444366"><span id="local-6989586621679444368"><span id="local-6989586621679444370"><span id="local-6989586621679444372"><span id="local-6989586621679444374"><span id="local-6989586621679444376"><span id="local-6989586621679444382"><span id="local-6989586621679444384"><span id="local-6989586621679444386"><span id="local-6989586621679444397"><span id="local-6989586621679444409"><span class="annot"><span class="annottext">SpecialCon l -&gt; DataType
SpecialCon l -&gt; Constr
forall {l}. Data l =&gt; Typeable (SpecialCon l)
forall l. Data l =&gt; SpecialCon l -&gt; DataType
forall l. Data l =&gt; SpecialCon l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; SpecialCon l -&gt; SpecialCon l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SpecialCon l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; SpecialCon l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpecialCon l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpecialCon l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; SpecialCon l -&gt; m (SpecialCon l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; SpecialCon l -&gt; m (SpecialCon l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (SpecialCon l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SpecialCon l -&gt; c (SpecialCon l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (SpecialCon l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (SpecialCon l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (SpecialCon l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SpecialCon l -&gt; c (SpecialCon l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (SpecialCon l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; SpecialCon l -&gt; m (SpecialCon l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; SpecialCon l -&gt; m (SpecialCon l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; SpecialCon l -&gt; m (SpecialCon l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; SpecialCon l -&gt; m (SpecialCon l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; SpecialCon l -&gt; m (SpecialCon l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; SpecialCon l -&gt; m (SpecialCon l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SpecialCon l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SpecialCon l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SpecialCon l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; SpecialCon l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpecialCon l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpecialCon l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpecialCon l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpecialCon l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; SpecialCon l -&gt; SpecialCon l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; SpecialCon l -&gt; SpecialCon l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (SpecialCon l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (SpecialCon l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (SpecialCon l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (SpecialCon l))
dataTypeOf :: SpecialCon l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; SpecialCon l -&gt; DataType
toConstr :: SpecialCon l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; SpecialCon l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (SpecialCon l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (SpecialCon l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SpecialCon l -&gt; c (SpecialCon l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SpecialCon l -&gt; c (SpecialCon l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444325"><span id="local-6989586621679444327"><span id="local-6989586621679444329"><span id="local-6989586621679444331"><span id="local-6989586621679444333"><span id="local-6989586621679444335"><span id="local-6989586621679444337"><span id="local-6989586621679444339"><span id="local-6989586621679444341"><span id="local-6989586621679444343"><span id="local-6989586621679444345"><span id="local-6989586621679444347"><span id="local-6989586621679444349"><span id="local-6989586621679444351"><span id="local-6989586621679444353"><span id="local-6989586621679444356"><span id="local-6989586621679444358"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; SpecialCon a -&gt; Bool
forall a. Num a =&gt; SpecialCon a -&gt; a
forall a. Ord a =&gt; SpecialCon a -&gt; a
forall m. Monoid m =&gt; SpecialCon m -&gt; m
forall a. SpecialCon a -&gt; Bool
forall a. SpecialCon a -&gt; Int
forall a. SpecialCon a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; SpecialCon a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; SpecialCon a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; SpecialCon a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; SpecialCon a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; SpecialCon a -&gt; a
$cproduct :: forall a. Num a =&gt; SpecialCon a -&gt; a
sum :: forall a. Num a =&gt; SpecialCon a -&gt; a
$csum :: forall a. Num a =&gt; SpecialCon a -&gt; a
minimum :: forall a. Ord a =&gt; SpecialCon a -&gt; a
$cminimum :: forall a. Ord a =&gt; SpecialCon a -&gt; a
maximum :: forall a. Ord a =&gt; SpecialCon a -&gt; a
$cmaximum :: forall a. Ord a =&gt; SpecialCon a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; SpecialCon a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; SpecialCon a -&gt; Bool
length :: forall a. SpecialCon a -&gt; Int
$clength :: forall a. SpecialCon a -&gt; Int
null :: forall a. SpecialCon a -&gt; Bool
$cnull :: forall a. SpecialCon a -&gt; Bool
toList :: forall a. SpecialCon a -&gt; [a]
$ctoList :: forall a. SpecialCon a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; SpecialCon a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; SpecialCon a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; SpecialCon a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; SpecialCon a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; SpecialCon a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; SpecialCon a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; SpecialCon a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; SpecialCon a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; SpecialCon a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; SpecialCon a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; SpecialCon a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; SpecialCon a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; SpecialCon a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; SpecialCon a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; SpecialCon a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; SpecialCon a -&gt; m
fold :: forall m. Monoid m =&gt; SpecialCon m -&gt; m
$cfold :: forall m. Monoid m =&gt; SpecialCon m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444303"><span id="local-6989586621679444305"><span id="local-6989586621679444307"><span id="local-6989586621679444318"><span class="annot"><span class="annottext">Functor SpecialCon
Foldable SpecialCon
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
SpecialCon (m a) -&gt; m (SpecialCon a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
SpecialCon (f a) -&gt; f (SpecialCon a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; SpecialCon a -&gt; m (SpecialCon b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; SpecialCon a -&gt; f (SpecialCon b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
SpecialCon (m a) -&gt; m (SpecialCon a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
SpecialCon (m a) -&gt; m (SpecialCon a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; SpecialCon a -&gt; m (SpecialCon b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; SpecialCon a -&gt; m (SpecialCon b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
SpecialCon (f a) -&gt; f (SpecialCon a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
SpecialCon (f a) -&gt; f (SpecialCon a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; SpecialCon a -&gt; f (SpecialCon b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; SpecialCon a -&gt; f (SpecialCon b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444299"><span id="local-6989586621679444301"><span class="annot"><span class="annottext">forall a b. a -&gt; SpecialCon b -&gt; SpecialCon a
forall a b. (a -&gt; b) -&gt; SpecialCon a -&gt; SpecialCon b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; SpecialCon b -&gt; SpecialCon a
$c&lt;$ :: forall a b. a -&gt; SpecialCon b -&gt; SpecialCon a
fmap :: forall a b. (a -&gt; b) -&gt; SpecialCon a -&gt; SpecialCon b
$cfmap :: forall a b. (a -&gt; b) -&gt; SpecialCon a -&gt; SpecialCon b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (SpecialCon l) x -&gt; SpecialCon l
forall l x. SpecialCon l -&gt; Rep (SpecialCon l) x
$cto :: forall l x. Rep (SpecialCon l) x -&gt; SpecialCon l
$cfrom :: forall l x. SpecialCon l -&gt; Rep (SpecialCon l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-145"></span><span>
</span><span id="line-146"></span><span class="hs-comment">-- | This type is used to represent qualified variables, and also</span><span>
</span><span id="line-147"></span><span class="hs-comment">-- qualified constructors.</span><span>
</span><span id="line-148"></span><span id="local-6989586621679444294"><span id="local-6989586621679444295"></span></span><span class="hs-keyword">data</span><span> </span><span id="QName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-var">QName</span></a></span></span><span> </span><span id="local-6989586621679452846"><span class="annot"><a href="#local-6989586621679452846"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-149"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="Qual"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Qual"><span class="hs-identifier hs-var">Qual</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452846"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452846"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452846"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ name qualified with a module name</span><span>
</span><span id="line-150"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="UnQual"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnQual"><span class="hs-identifier hs-var">UnQual</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452846"><span class="hs-identifier hs-type">l</span></a></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452846"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ unqualified local name</span><span>
</span><span id="line-151"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Special"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-var">Special</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452846"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpecialCon"><span class="hs-identifier hs-type">SpecialCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452846"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>          </span><span class="hs-comment">-- ^ built-in constructor with special syntax</span><span>
</span><span id="line-152"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679444280"><span id="local-6989586621679444289"><span class="annot"><span class="annottext">QName l -&gt; QName l -&gt; Bool
forall l. Eq l =&gt; QName l -&gt; QName l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: QName l -&gt; QName l -&gt; Bool
$c/= :: forall l. Eq l =&gt; QName l -&gt; QName l -&gt; Bool
== :: QName l -&gt; QName l -&gt; Bool
$c== :: forall l. Eq l =&gt; QName l -&gt; QName l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444247"><span id="local-6989586621679444249"><span id="local-6989586621679444252"><span id="local-6989586621679444255"><span id="local-6989586621679444258"><span id="local-6989586621679444267"><span id="local-6989586621679444276"><span class="annot"><span class="annottext">QName l -&gt; QName l -&gt; Bool
QName l -&gt; QName l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (QName l)
forall l. Ord l =&gt; QName l -&gt; QName l -&gt; Bool
forall l. Ord l =&gt; QName l -&gt; QName l -&gt; Ordering
forall l. Ord l =&gt; QName l -&gt; QName l -&gt; QName l
min :: QName l -&gt; QName l -&gt; QName l
$cmin :: forall l. Ord l =&gt; QName l -&gt; QName l -&gt; QName l
max :: QName l -&gt; QName l -&gt; QName l
$cmax :: forall l. Ord l =&gt; QName l -&gt; QName l -&gt; QName l
&gt;= :: QName l -&gt; QName l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; QName l -&gt; QName l -&gt; Bool
&gt; :: QName l -&gt; QName l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; QName l -&gt; QName l -&gt; Bool
&lt;= :: QName l -&gt; QName l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; QName l -&gt; QName l -&gt; Bool
&lt; :: QName l -&gt; QName l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; QName l -&gt; QName l -&gt; Bool
compare :: QName l -&gt; QName l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; QName l -&gt; QName l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444231"><span id="local-6989586621679444233"><span id="local-6989586621679444245"><span class="annot"><span class="annottext">Int -&gt; QName l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; QName l -&gt; ShowS
forall l. Show l =&gt; [QName l] -&gt; ShowS
forall l. Show l =&gt; QName l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [QName l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [QName l] -&gt; ShowS
show :: QName l -&gt; String
$cshow :: forall l. Show l =&gt; QName l -&gt; String
showsPrec :: Int -&gt; QName l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; QName l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679444182"><span id="local-6989586621679444184"><span id="local-6989586621679444186"><span id="local-6989586621679444188"><span id="local-6989586621679444190"><span id="local-6989586621679444192"><span id="local-6989586621679444194"><span id="local-6989586621679444196"><span id="local-6989586621679444198"><span id="local-6989586621679444204"><span id="local-6989586621679444206"><span id="local-6989586621679444208"><span id="local-6989586621679444217"><span id="local-6989586621679444226"><span class="annot"><span class="annottext">QName l -&gt; DataType
QName l -&gt; Constr
forall {l}. Data l =&gt; Typeable (QName l)
forall l. Data l =&gt; QName l -&gt; DataType
forall l. Data l =&gt; QName l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; QName l -&gt; QName l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QName l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; QName l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QName l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QName l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QName l -&gt; m (QName l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QName l -&gt; m (QName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QName l -&gt; c (QName l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QName l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (QName l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QName l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QName l -&gt; c (QName l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QName l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QName l -&gt; m (QName l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QName l -&gt; m (QName l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QName l -&gt; m (QName l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QName l -&gt; m (QName l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QName l -&gt; m (QName l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QName l -&gt; m (QName l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QName l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QName l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; QName l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; QName l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QName l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QName l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QName l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QName l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; QName l -&gt; QName l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; QName l -&gt; QName l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (QName l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (QName l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QName l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QName l))
dataTypeOf :: QName l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; QName l -&gt; DataType
toConstr :: QName l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; QName l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QName l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QName l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QName l -&gt; c (QName l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QName l -&gt; c (QName l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444131"><span id="local-6989586621679444133"><span id="local-6989586621679444135"><span id="local-6989586621679444137"><span id="local-6989586621679444139"><span id="local-6989586621679444141"><span id="local-6989586621679444143"><span id="local-6989586621679444145"><span id="local-6989586621679444147"><span id="local-6989586621679444149"><span id="local-6989586621679444151"><span id="local-6989586621679444153"><span id="local-6989586621679444155"><span id="local-6989586621679444161"><span id="local-6989586621679444163"><span id="local-6989586621679444178"><span id="local-6989586621679444180"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; QName a -&gt; Bool
forall a. Num a =&gt; QName a -&gt; a
forall a. Ord a =&gt; QName a -&gt; a
forall m. Monoid m =&gt; QName m -&gt; m
forall a. QName a -&gt; Bool
forall a. QName a -&gt; Int
forall a. QName a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; QName a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QName a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QName a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QName a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; QName a -&gt; a
$cproduct :: forall a. Num a =&gt; QName a -&gt; a
sum :: forall a. Num a =&gt; QName a -&gt; a
$csum :: forall a. Num a =&gt; QName a -&gt; a
minimum :: forall a. Ord a =&gt; QName a -&gt; a
$cminimum :: forall a. Ord a =&gt; QName a -&gt; a
maximum :: forall a. Ord a =&gt; QName a -&gt; a
$cmaximum :: forall a. Ord a =&gt; QName a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; QName a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; QName a -&gt; Bool
length :: forall a. QName a -&gt; Int
$clength :: forall a. QName a -&gt; Int
null :: forall a. QName a -&gt; Bool
$cnull :: forall a. QName a -&gt; Bool
toList :: forall a. QName a -&gt; [a]
$ctoList :: forall a. QName a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; QName a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; QName a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; QName a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; QName a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QName a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QName a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QName a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QName a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QName a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QName a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QName a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QName a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QName a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QName a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QName a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QName a -&gt; m
fold :: forall m. Monoid m =&gt; QName m -&gt; m
$cfold :: forall m. Monoid m =&gt; QName m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444105"><span id="local-6989586621679444107"><span id="local-6989586621679444109"><span id="local-6989586621679444124"><span class="annot"><span class="annottext">Functor QName
Foldable QName
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; QName (m a) -&gt; m (QName a)
forall (f :: * -&gt; *) a. Applicative f =&gt; QName (f a) -&gt; f (QName a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QName a -&gt; m (QName b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QName a -&gt; f (QName b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; QName (m a) -&gt; m (QName a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; QName (m a) -&gt; m (QName a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QName a -&gt; m (QName b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QName a -&gt; m (QName b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; QName (f a) -&gt; f (QName a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; QName (f a) -&gt; f (QName a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QName a -&gt; f (QName b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QName a -&gt; f (QName b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444096"><span id="local-6989586621679444103"><span class="annot"><span class="annottext">forall a b. a -&gt; QName b -&gt; QName a
forall a b. (a -&gt; b) -&gt; QName a -&gt; QName b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; QName b -&gt; QName a
$c&lt;$ :: forall a b. a -&gt; QName b -&gt; QName a
fmap :: forall a b. (a -&gt; b) -&gt; QName a -&gt; QName b
$cfmap :: forall a b. (a -&gt; b) -&gt; QName a -&gt; QName b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (QName l) x -&gt; QName l
forall l x. QName l -&gt; Rep (QName l) x
$cto :: forall l x. Rep (QName l) x -&gt; QName l
$cfrom :: forall l x. QName l -&gt; Rep (QName l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-153"></span><span>
</span><span id="line-154"></span><span class="hs-comment">-- | This type is used to represent variables, and also constructors.</span><span>
</span><span id="line-155"></span><span id="local-6989586621679444087"><span id="local-6989586621679444088"></span></span><span class="hs-keyword">data</span><span> </span><span id="Name"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span></span><span> </span><span id="local-6989586621679452845"><span class="annot"><a href="#local-6989586621679452845"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-156"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="Ident"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452845"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>   </span><span class="hs-comment">-- ^ /varid/ or /conid/.</span><span>
</span><span id="line-157"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Symbol"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Symbol"><span class="hs-identifier hs-var">Symbol</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452845"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>   </span><span class="hs-comment">-- ^ /varsym/ or /consym/</span><span>
</span><span id="line-158"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679444076"><span id="local-6989586621679444083"><span class="annot"><span class="annottext">Name l -&gt; Name l -&gt; Bool
forall l. Eq l =&gt; Name l -&gt; Name l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Name l -&gt; Name l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Name l -&gt; Name l -&gt; Bool
== :: Name l -&gt; Name l -&gt; Bool
$c== :: forall l. Eq l =&gt; Name l -&gt; Name l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444047"><span id="local-6989586621679444049"><span id="local-6989586621679444052"><span id="local-6989586621679444055"><span id="local-6989586621679444058"><span id="local-6989586621679444065"><span id="local-6989586621679444072"><span class="annot"><span class="annottext">Name l -&gt; Name l -&gt; Bool
Name l -&gt; Name l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Name l)
forall l. Ord l =&gt; Name l -&gt; Name l -&gt; Bool
forall l. Ord l =&gt; Name l -&gt; Name l -&gt; Ordering
forall l. Ord l =&gt; Name l -&gt; Name l -&gt; Name l
min :: Name l -&gt; Name l -&gt; Name l
$cmin :: forall l. Ord l =&gt; Name l -&gt; Name l -&gt; Name l
max :: Name l -&gt; Name l -&gt; Name l
$cmax :: forall l. Ord l =&gt; Name l -&gt; Name l -&gt; Name l
&gt;= :: Name l -&gt; Name l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Name l -&gt; Name l -&gt; Bool
&gt; :: Name l -&gt; Name l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Name l -&gt; Name l -&gt; Bool
&lt;= :: Name l -&gt; Name l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Name l -&gt; Name l -&gt; Bool
&lt; :: Name l -&gt; Name l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Name l -&gt; Name l -&gt; Bool
compare :: Name l -&gt; Name l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Name l -&gt; Name l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679444034"><span id="local-6989586621679444036"><span id="local-6989586621679444045"><span class="annot"><span class="annottext">Int -&gt; Name l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Name l -&gt; ShowS
forall l. Show l =&gt; [Name l] -&gt; ShowS
forall l. Show l =&gt; Name l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Name l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Name l] -&gt; ShowS
show :: Name l -&gt; String
$cshow :: forall l. Show l =&gt; Name l -&gt; String
showsPrec :: Int -&gt; Name l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Name l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679443989"><span id="local-6989586621679443991"><span id="local-6989586621679443993"><span id="local-6989586621679443995"><span id="local-6989586621679443997"><span id="local-6989586621679443999"><span id="local-6989586621679444001"><span id="local-6989586621679444003"><span id="local-6989586621679444005"><span id="local-6989586621679444011"><span id="local-6989586621679444013"><span id="local-6989586621679444015"><span id="local-6989586621679444022"><span id="local-6989586621679444029"><span class="annot"><span class="annottext">Name l -&gt; DataType
Name l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Name l)
forall l. Data l =&gt; Name l -&gt; DataType
forall l. Data l =&gt; Name l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Name l -&gt; Name l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Name l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Name l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name l -&gt; m (Name l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name l -&gt; m (Name l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Name l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Name l -&gt; c (Name l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Name l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Name l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Name l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Name l -&gt; c (Name l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Name l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name l -&gt; m (Name l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name l -&gt; m (Name l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name l -&gt; m (Name l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name l -&gt; m (Name l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name l -&gt; m (Name l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Name l -&gt; m (Name l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Name l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Name l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Name l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Name l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Name l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Name l -&gt; Name l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Name l -&gt; Name l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Name l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Name l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Name l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Name l))
dataTypeOf :: Name l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Name l -&gt; DataType
toConstr :: Name l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Name l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Name l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Name l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Name l -&gt; c (Name l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Name l -&gt; c (Name l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443954"><span id="local-6989586621679443956"><span id="local-6989586621679443958"><span id="local-6989586621679443960"><span id="local-6989586621679443962"><span id="local-6989586621679443964"><span id="local-6989586621679443966"><span id="local-6989586621679443968"><span id="local-6989586621679443970"><span id="local-6989586621679443972"><span id="local-6989586621679443974"><span id="local-6989586621679443976"><span id="local-6989586621679443978"><span id="local-6989586621679443980"><span id="local-6989586621679443982"><span id="local-6989586621679443985"><span id="local-6989586621679443987"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Name a -&gt; Bool
forall a. Num a =&gt; Name a -&gt; a
forall a. Ord a =&gt; Name a -&gt; a
forall m. Monoid m =&gt; Name m -&gt; m
forall a. Name a -&gt; Bool
forall a. Name a -&gt; Int
forall a. Name a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Name a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Name a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Name a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Name a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Name a -&gt; a
$cproduct :: forall a. Num a =&gt; Name a -&gt; a
sum :: forall a. Num a =&gt; Name a -&gt; a
$csum :: forall a. Num a =&gt; Name a -&gt; a
minimum :: forall a. Ord a =&gt; Name a -&gt; a
$cminimum :: forall a. Ord a =&gt; Name a -&gt; a
maximum :: forall a. Ord a =&gt; Name a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Name a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Name a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Name a -&gt; Bool
length :: forall a. Name a -&gt; Int
$clength :: forall a. Name a -&gt; Int
null :: forall a. Name a -&gt; Bool
$cnull :: forall a. Name a -&gt; Bool
toList :: forall a. Name a -&gt; [a]
$ctoList :: forall a. Name a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Name a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Name a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Name a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Name a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Name a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Name a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Name a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Name a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Name a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Name a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Name a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Name a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Name a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Name a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Name a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Name a -&gt; m
fold :: forall m. Monoid m =&gt; Name m -&gt; m
$cfold :: forall m. Monoid m =&gt; Name m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443938"><span id="local-6989586621679443940"><span id="local-6989586621679443942"><span id="local-6989586621679443948"><span class="annot"><span class="annottext">Functor Name
Foldable Name
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Name (m a) -&gt; m (Name a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Name (f a) -&gt; f (Name a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Name a -&gt; m (Name b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Name a -&gt; f (Name b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Name (m a) -&gt; m (Name a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Name (m a) -&gt; m (Name a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Name a -&gt; m (Name b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Name a -&gt; m (Name b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Name (f a) -&gt; f (Name a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Name (f a) -&gt; f (Name a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Name a -&gt; f (Name b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Name a -&gt; f (Name b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443934"><span id="local-6989586621679443936"><span class="annot"><span class="annottext">forall a b. a -&gt; Name b -&gt; Name a
forall a b. (a -&gt; b) -&gt; Name a -&gt; Name b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Name b -&gt; Name a
$c&lt;$ :: forall a b. a -&gt; Name b -&gt; Name a
fmap :: forall a b. (a -&gt; b) -&gt; Name a -&gt; Name b
$cfmap :: forall a b. (a -&gt; b) -&gt; Name a -&gt; Name b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Name l) x -&gt; Name l
forall l x. Name l -&gt; Rep (Name l) x
$cto :: forall l x. Rep (Name l) x -&gt; Name l
$cfrom :: forall l x. Name l -&gt; Rep (Name l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span class="hs-comment">-- | An implicit parameter name.</span><span>
</span><span id="line-161"></span><span id="local-6989586621679443929"><span id="local-6989586621679443930"></span></span><span class="hs-keyword">data</span><span> </span><span id="IPName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPName"><span class="hs-identifier hs-var">IPName</span></a></span></span><span> </span><span id="local-6989586621679452836"><span class="annot"><a href="#local-6989586621679452836"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-162"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="IPDup"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPDup"><span class="hs-identifier hs-var">IPDup</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452836"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-comment">-- ^ ?/ident/, non-linear implicit parameter</span><span>
</span><span id="line-163"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="IPLin"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPLin"><span class="hs-identifier hs-var">IPLin</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452836"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-comment">-- ^ %/ident/, linear implicit parameter</span><span>
</span><span id="line-164"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679443918"><span id="local-6989586621679443925"><span class="annot"><span class="annottext">IPName l -&gt; IPName l -&gt; Bool
forall l. Eq l =&gt; IPName l -&gt; IPName l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: IPName l -&gt; IPName l -&gt; Bool
$c/= :: forall l. Eq l =&gt; IPName l -&gt; IPName l -&gt; Bool
== :: IPName l -&gt; IPName l -&gt; Bool
$c== :: forall l. Eq l =&gt; IPName l -&gt; IPName l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443889"><span id="local-6989586621679443891"><span id="local-6989586621679443894"><span id="local-6989586621679443897"><span id="local-6989586621679443900"><span id="local-6989586621679443907"><span id="local-6989586621679443914"><span class="annot"><span class="annottext">IPName l -&gt; IPName l -&gt; Bool
IPName l -&gt; IPName l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (IPName l)
forall l. Ord l =&gt; IPName l -&gt; IPName l -&gt; Bool
forall l. Ord l =&gt; IPName l -&gt; IPName l -&gt; Ordering
forall l. Ord l =&gt; IPName l -&gt; IPName l -&gt; IPName l
min :: IPName l -&gt; IPName l -&gt; IPName l
$cmin :: forall l. Ord l =&gt; IPName l -&gt; IPName l -&gt; IPName l
max :: IPName l -&gt; IPName l -&gt; IPName l
$cmax :: forall l. Ord l =&gt; IPName l -&gt; IPName l -&gt; IPName l
&gt;= :: IPName l -&gt; IPName l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; IPName l -&gt; IPName l -&gt; Bool
&gt; :: IPName l -&gt; IPName l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; IPName l -&gt; IPName l -&gt; Bool
&lt;= :: IPName l -&gt; IPName l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; IPName l -&gt; IPName l -&gt; Bool
&lt; :: IPName l -&gt; IPName l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; IPName l -&gt; IPName l -&gt; Bool
compare :: IPName l -&gt; IPName l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; IPName l -&gt; IPName l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443876"><span id="local-6989586621679443878"><span id="local-6989586621679443887"><span class="annot"><span class="annottext">Int -&gt; IPName l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; IPName l -&gt; ShowS
forall l. Show l =&gt; [IPName l] -&gt; ShowS
forall l. Show l =&gt; IPName l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [IPName l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [IPName l] -&gt; ShowS
show :: IPName l -&gt; String
$cshow :: forall l. Show l =&gt; IPName l -&gt; String
showsPrec :: Int -&gt; IPName l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; IPName l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679443831"><span id="local-6989586621679443833"><span id="local-6989586621679443835"><span id="local-6989586621679443837"><span id="local-6989586621679443839"><span id="local-6989586621679443841"><span id="local-6989586621679443843"><span id="local-6989586621679443845"><span id="local-6989586621679443847"><span id="local-6989586621679443853"><span id="local-6989586621679443855"><span id="local-6989586621679443857"><span id="local-6989586621679443864"><span id="local-6989586621679443871"><span class="annot"><span class="annottext">IPName l -&gt; DataType
IPName l -&gt; Constr
forall {l}. Data l =&gt; Typeable (IPName l)
forall l. Data l =&gt; IPName l -&gt; DataType
forall l. Data l =&gt; IPName l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; IPName l -&gt; IPName l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; IPName l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; IPName l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPName l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPName l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPName l -&gt; m (IPName l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPName l -&gt; m (IPName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (IPName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; IPName l -&gt; c (IPName l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (IPName l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (IPName l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (IPName l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; IPName l -&gt; c (IPName l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (IPName l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPName l -&gt; m (IPName l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPName l -&gt; m (IPName l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPName l -&gt; m (IPName l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPName l -&gt; m (IPName l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPName l -&gt; m (IPName l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPName l -&gt; m (IPName l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; IPName l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; IPName l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; IPName l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; IPName l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPName l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPName l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPName l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPName l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; IPName l -&gt; IPName l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; IPName l -&gt; IPName l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (IPName l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (IPName l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (IPName l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (IPName l))
dataTypeOf :: IPName l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; IPName l -&gt; DataType
toConstr :: IPName l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; IPName l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (IPName l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (IPName l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; IPName l -&gt; c (IPName l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; IPName l -&gt; c (IPName l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443796"><span id="local-6989586621679443798"><span id="local-6989586621679443800"><span id="local-6989586621679443802"><span id="local-6989586621679443804"><span id="local-6989586621679443806"><span id="local-6989586621679443808"><span id="local-6989586621679443810"><span id="local-6989586621679443812"><span id="local-6989586621679443814"><span id="local-6989586621679443816"><span id="local-6989586621679443818"><span id="local-6989586621679443820"><span id="local-6989586621679443822"><span id="local-6989586621679443824"><span id="local-6989586621679443827"><span id="local-6989586621679443829"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; IPName a -&gt; Bool
forall a. Num a =&gt; IPName a -&gt; a
forall a. Ord a =&gt; IPName a -&gt; a
forall m. Monoid m =&gt; IPName m -&gt; m
forall a. IPName a -&gt; Bool
forall a. IPName a -&gt; Int
forall a. IPName a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; IPName a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; IPName a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; IPName a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; IPName a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; IPName a -&gt; a
$cproduct :: forall a. Num a =&gt; IPName a -&gt; a
sum :: forall a. Num a =&gt; IPName a -&gt; a
$csum :: forall a. Num a =&gt; IPName a -&gt; a
minimum :: forall a. Ord a =&gt; IPName a -&gt; a
$cminimum :: forall a. Ord a =&gt; IPName a -&gt; a
maximum :: forall a. Ord a =&gt; IPName a -&gt; a
$cmaximum :: forall a. Ord a =&gt; IPName a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; IPName a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; IPName a -&gt; Bool
length :: forall a. IPName a -&gt; Int
$clength :: forall a. IPName a -&gt; Int
null :: forall a. IPName a -&gt; Bool
$cnull :: forall a. IPName a -&gt; Bool
toList :: forall a. IPName a -&gt; [a]
$ctoList :: forall a. IPName a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; IPName a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; IPName a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; IPName a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; IPName a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; IPName a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; IPName a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; IPName a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; IPName a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; IPName a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; IPName a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; IPName a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; IPName a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; IPName a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; IPName a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; IPName a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; IPName a -&gt; m
fold :: forall m. Monoid m =&gt; IPName m -&gt; m
$cfold :: forall m. Monoid m =&gt; IPName m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443779"><span id="local-6989586621679443781"><span id="local-6989586621679443783"><span id="local-6989586621679443789"><span class="annot"><span class="annottext">Functor IPName
Foldable IPName
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; IPName (m a) -&gt; m (IPName a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
IPName (f a) -&gt; f (IPName a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; IPName a -&gt; m (IPName b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; IPName a -&gt; f (IPName b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; IPName (m a) -&gt; m (IPName a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; IPName (m a) -&gt; m (IPName a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; IPName a -&gt; m (IPName b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; IPName a -&gt; m (IPName b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
IPName (f a) -&gt; f (IPName a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
IPName (f a) -&gt; f (IPName a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; IPName a -&gt; f (IPName b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; IPName a -&gt; f (IPName b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443775"><span id="local-6989586621679443777"><span class="annot"><span class="annottext">forall a b. a -&gt; IPName b -&gt; IPName a
forall a b. (a -&gt; b) -&gt; IPName a -&gt; IPName b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; IPName b -&gt; IPName a
$c&lt;$ :: forall a b. a -&gt; IPName b -&gt; IPName a
fmap :: forall a b. (a -&gt; b) -&gt; IPName a -&gt; IPName b
$cfmap :: forall a b. (a -&gt; b) -&gt; IPName a -&gt; IPName b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (IPName l) x -&gt; IPName l
forall l x. IPName l -&gt; Rep (IPName l) x
$cto :: forall l x. Rep (IPName l) x -&gt; IPName l
$cfrom :: forall l x. IPName l -&gt; Rep (IPName l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-165"></span><span>
</span><span id="line-166"></span><span class="hs-comment">-- | Possibly qualified infix operators (/qop/), appearing in expressions.</span><span>
</span><span id="line-167"></span><span id="local-6989586621679443770"><span id="local-6989586621679443771"></span></span><span class="hs-keyword">data</span><span> </span><span id="QOp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QOp"><span class="hs-identifier hs-var">QOp</span></a></span></span><span> </span><span id="local-6989586621679452831"><span class="annot"><a href="#local-6989586621679452831"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-168"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="QVarOp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QVarOp"><span class="hs-identifier hs-var">QVarOp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452831"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452831"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ variable operator (/qvarop/)</span><span>
</span><span id="line-169"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="QConOp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QConOp"><span class="hs-identifier hs-var">QConOp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452831"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452831"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ constructor operator (/qconop/)</span><span>
</span><span id="line-170"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679443760"><span id="local-6989586621679443766"><span class="annot"><span class="annottext">QOp l -&gt; QOp l -&gt; Bool
forall l. Eq l =&gt; QOp l -&gt; QOp l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: QOp l -&gt; QOp l -&gt; Bool
$c/= :: forall l. Eq l =&gt; QOp l -&gt; QOp l -&gt; Bool
== :: QOp l -&gt; QOp l -&gt; Bool
$c== :: forall l. Eq l =&gt; QOp l -&gt; QOp l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443733"><span id="local-6989586621679443735"><span id="local-6989586621679443738"><span id="local-6989586621679443741"><span id="local-6989586621679443744"><span id="local-6989586621679443750"><span id="local-6989586621679443756"><span class="annot"><span class="annottext">QOp l -&gt; QOp l -&gt; Bool
QOp l -&gt; QOp l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (QOp l)
forall l. Ord l =&gt; QOp l -&gt; QOp l -&gt; Bool
forall l. Ord l =&gt; QOp l -&gt; QOp l -&gt; Ordering
forall l. Ord l =&gt; QOp l -&gt; QOp l -&gt; QOp l
min :: QOp l -&gt; QOp l -&gt; QOp l
$cmin :: forall l. Ord l =&gt; QOp l -&gt; QOp l -&gt; QOp l
max :: QOp l -&gt; QOp l -&gt; QOp l
$cmax :: forall l. Ord l =&gt; QOp l -&gt; QOp l -&gt; QOp l
&gt;= :: QOp l -&gt; QOp l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; QOp l -&gt; QOp l -&gt; Bool
&gt; :: QOp l -&gt; QOp l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; QOp l -&gt; QOp l -&gt; Bool
&lt;= :: QOp l -&gt; QOp l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; QOp l -&gt; QOp l -&gt; Bool
&lt; :: QOp l -&gt; QOp l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; QOp l -&gt; QOp l -&gt; Bool
compare :: QOp l -&gt; QOp l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; QOp l -&gt; QOp l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443721"><span id="local-6989586621679443723"><span id="local-6989586621679443731"><span class="annot"><span class="annottext">Int -&gt; QOp l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; QOp l -&gt; ShowS
forall l. Show l =&gt; [QOp l] -&gt; ShowS
forall l. Show l =&gt; QOp l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [QOp l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [QOp l] -&gt; ShowS
show :: QOp l -&gt; String
$cshow :: forall l. Show l =&gt; QOp l -&gt; String
showsPrec :: Int -&gt; QOp l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; QOp l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679443678"><span id="local-6989586621679443680"><span id="local-6989586621679443682"><span id="local-6989586621679443684"><span id="local-6989586621679443686"><span id="local-6989586621679443688"><span id="local-6989586621679443690"><span id="local-6989586621679443692"><span id="local-6989586621679443694"><span id="local-6989586621679443700"><span id="local-6989586621679443702"><span id="local-6989586621679443704"><span id="local-6989586621679443710"><span id="local-6989586621679443716"><span class="annot"><span class="annottext">QOp l -&gt; DataType
QOp l -&gt; Constr
forall {l}. Data l =&gt; Typeable (QOp l)
forall l. Data l =&gt; QOp l -&gt; DataType
forall l. Data l =&gt; QOp l -&gt; Constr
forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; QOp l -&gt; QOp l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QOp l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QOp l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QOp l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QOp l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QOp l -&gt; m (QOp l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QOp l -&gt; m (QOp l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QOp l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QOp l -&gt; c (QOp l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QOp l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (QOp l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QOp l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QOp l -&gt; c (QOp l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QOp l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QOp l -&gt; m (QOp l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QOp l -&gt; m (QOp l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QOp l -&gt; m (QOp l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QOp l -&gt; m (QOp l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QOp l -&gt; m (QOp l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QOp l -&gt; m (QOp l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QOp l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QOp l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; QOp l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QOp l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QOp l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QOp l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QOp l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QOp l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; QOp l -&gt; QOp l
$cgmapT :: forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; QOp l -&gt; QOp l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (QOp l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (QOp l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QOp l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QOp l))
dataTypeOf :: QOp l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; QOp l -&gt; DataType
toConstr :: QOp l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; QOp l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QOp l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QOp l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QOp l -&gt; c (QOp l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QOp l -&gt; c (QOp l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443635"><span id="local-6989586621679443637"><span id="local-6989586621679443639"><span id="local-6989586621679443641"><span id="local-6989586621679443643"><span id="local-6989586621679443645"><span id="local-6989586621679443647"><span id="local-6989586621679443649"><span id="local-6989586621679443651"><span id="local-6989586621679443653"><span id="local-6989586621679443655"><span id="local-6989586621679443657"><span id="local-6989586621679443659"><span id="local-6989586621679443663"><span id="local-6989586621679443665"><span id="local-6989586621679443674"><span id="local-6989586621679443676"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; QOp a -&gt; Bool
forall a. Num a =&gt; QOp a -&gt; a
forall a. Ord a =&gt; QOp a -&gt; a
forall m. Monoid m =&gt; QOp m -&gt; m
forall a. QOp a -&gt; Bool
forall a. QOp a -&gt; Int
forall a. QOp a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; QOp a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QOp a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QOp a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QOp a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; QOp a -&gt; a
$cproduct :: forall a. Num a =&gt; QOp a -&gt; a
sum :: forall a. Num a =&gt; QOp a -&gt; a
$csum :: forall a. Num a =&gt; QOp a -&gt; a
minimum :: forall a. Ord a =&gt; QOp a -&gt; a
$cminimum :: forall a. Ord a =&gt; QOp a -&gt; a
maximum :: forall a. Ord a =&gt; QOp a -&gt; a
$cmaximum :: forall a. Ord a =&gt; QOp a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; QOp a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; QOp a -&gt; Bool
length :: forall a. QOp a -&gt; Int
$clength :: forall a. QOp a -&gt; Int
null :: forall a. QOp a -&gt; Bool
$cnull :: forall a. QOp a -&gt; Bool
toList :: forall a. QOp a -&gt; [a]
$ctoList :: forall a. QOp a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; QOp a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; QOp a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; QOp a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; QOp a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QOp a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QOp a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QOp a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QOp a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QOp a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QOp a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QOp a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QOp a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QOp a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QOp a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QOp a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QOp a -&gt; m
fold :: forall m. Monoid m =&gt; QOp m -&gt; m
$cfold :: forall m. Monoid m =&gt; QOp m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443615"><span id="local-6989586621679443617"><span id="local-6989586621679443619"><span id="local-6989586621679443628"><span class="annot"><span class="annottext">Functor QOp
Foldable QOp
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; QOp (m a) -&gt; m (QOp a)
forall (f :: * -&gt; *) a. Applicative f =&gt; QOp (f a) -&gt; f (QOp a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QOp a -&gt; m (QOp b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QOp a -&gt; f (QOp b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; QOp (m a) -&gt; m (QOp a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; QOp (m a) -&gt; m (QOp a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QOp a -&gt; m (QOp b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QOp a -&gt; m (QOp b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; QOp (f a) -&gt; f (QOp a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; QOp (f a) -&gt; f (QOp a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QOp a -&gt; f (QOp b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QOp a -&gt; f (QOp b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443609"><span id="local-6989586621679443613"><span class="annot"><span class="annottext">forall a b. a -&gt; QOp b -&gt; QOp a
forall a b. (a -&gt; b) -&gt; QOp a -&gt; QOp b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; QOp b -&gt; QOp a
$c&lt;$ :: forall a b. a -&gt; QOp b -&gt; QOp a
fmap :: forall a b. (a -&gt; b) -&gt; QOp a -&gt; QOp b
$cfmap :: forall a b. (a -&gt; b) -&gt; QOp a -&gt; QOp b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (QOp l) x -&gt; QOp l
forall l x. QOp l -&gt; Rep (QOp l) x
$cto :: forall l x. Rep (QOp l) x -&gt; QOp l
$cfrom :: forall l x. QOp l -&gt; Rep (QOp l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-171"></span><span>
</span><span id="line-172"></span><span class="hs-comment">-- | Operators appearing in @infix@ declarations are never qualified.</span><span>
</span><span id="line-173"></span><span id="local-6989586621679443602"><span id="local-6989586621679443603"></span></span><span class="hs-keyword">data</span><span> </span><span id="Op"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Op"><span class="hs-identifier hs-var">Op</span></a></span></span><span> </span><span id="local-6989586621679452826"><span class="annot"><a href="#local-6989586621679452826"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-174"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="VarOp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarOp"><span class="hs-identifier hs-var">VarOp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452826"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452826"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ variable operator (/varop/)</span><span>
</span><span id="line-175"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ConOp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConOp"><span class="hs-identifier hs-var">ConOp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452826"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452826"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ constructor operator (/conop/)</span><span>
</span><span id="line-176"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679443592"><span id="local-6989586621679443598"><span class="annot"><span class="annottext">Op l -&gt; Op l -&gt; Bool
forall l. Eq l =&gt; Op l -&gt; Op l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Op l -&gt; Op l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Op l -&gt; Op l -&gt; Bool
== :: Op l -&gt; Op l -&gt; Bool
$c== :: forall l. Eq l =&gt; Op l -&gt; Op l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443565"><span id="local-6989586621679443567"><span id="local-6989586621679443570"><span id="local-6989586621679443573"><span id="local-6989586621679443576"><span id="local-6989586621679443582"><span id="local-6989586621679443588"><span class="annot"><span class="annottext">Op l -&gt; Op l -&gt; Bool
Op l -&gt; Op l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Op l)
forall l. Ord l =&gt; Op l -&gt; Op l -&gt; Bool
forall l. Ord l =&gt; Op l -&gt; Op l -&gt; Ordering
forall l. Ord l =&gt; Op l -&gt; Op l -&gt; Op l
min :: Op l -&gt; Op l -&gt; Op l
$cmin :: forall l. Ord l =&gt; Op l -&gt; Op l -&gt; Op l
max :: Op l -&gt; Op l -&gt; Op l
$cmax :: forall l. Ord l =&gt; Op l -&gt; Op l -&gt; Op l
&gt;= :: Op l -&gt; Op l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Op l -&gt; Op l -&gt; Bool
&gt; :: Op l -&gt; Op l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Op l -&gt; Op l -&gt; Bool
&lt;= :: Op l -&gt; Op l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Op l -&gt; Op l -&gt; Bool
&lt; :: Op l -&gt; Op l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Op l -&gt; Op l -&gt; Bool
compare :: Op l -&gt; Op l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Op l -&gt; Op l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443553"><span id="local-6989586621679443555"><span id="local-6989586621679443563"><span class="annot"><span class="annottext">Int -&gt; Op l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Op l -&gt; ShowS
forall l. Show l =&gt; [Op l] -&gt; ShowS
forall l. Show l =&gt; Op l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Op l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Op l] -&gt; ShowS
show :: Op l -&gt; String
$cshow :: forall l. Show l =&gt; Op l -&gt; String
showsPrec :: Int -&gt; Op l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Op l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679443510"><span id="local-6989586621679443512"><span id="local-6989586621679443514"><span id="local-6989586621679443516"><span id="local-6989586621679443518"><span id="local-6989586621679443520"><span id="local-6989586621679443522"><span id="local-6989586621679443524"><span id="local-6989586621679443526"><span id="local-6989586621679443532"><span id="local-6989586621679443534"><span id="local-6989586621679443536"><span id="local-6989586621679443542"><span id="local-6989586621679443548"><span class="annot"><span class="annottext">Op l -&gt; DataType
Op l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Op l)
forall l. Data l =&gt; Op l -&gt; DataType
forall l. Data l =&gt; Op l -&gt; Constr
forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; Op l -&gt; Op l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Op l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Op l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Op l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Op l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Op l -&gt; m (Op l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Op l -&gt; m (Op l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Op l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Op l -&gt; c (Op l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Op l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Op l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Op l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Op l -&gt; c (Op l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Op l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Op l -&gt; m (Op l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Op l -&gt; m (Op l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Op l -&gt; m (Op l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Op l -&gt; m (Op l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Op l -&gt; m (Op l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Op l -&gt; m (Op l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Op l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Op l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Op l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Op l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Op l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Op l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Op l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Op l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Op l -&gt; Op l
$cgmapT :: forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; Op l -&gt; Op l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Op l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Op l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Op l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Op l))
dataTypeOf :: Op l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Op l -&gt; DataType
toConstr :: Op l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Op l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Op l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Op l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Op l -&gt; c (Op l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Op l -&gt; c (Op l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443467"><span id="local-6989586621679443469"><span id="local-6989586621679443471"><span id="local-6989586621679443473"><span id="local-6989586621679443475"><span id="local-6989586621679443477"><span id="local-6989586621679443479"><span id="local-6989586621679443481"><span id="local-6989586621679443483"><span id="local-6989586621679443485"><span id="local-6989586621679443487"><span id="local-6989586621679443489"><span id="local-6989586621679443491"><span id="local-6989586621679443495"><span id="local-6989586621679443497"><span id="local-6989586621679443506"><span id="local-6989586621679443508"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Op a -&gt; Bool
forall a. Num a =&gt; Op a -&gt; a
forall a. Ord a =&gt; Op a -&gt; a
forall m. Monoid m =&gt; Op m -&gt; m
forall a. Op a -&gt; Bool
forall a. Op a -&gt; Int
forall a. Op a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Op a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Op a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Op a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Op a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Op a -&gt; a
$cproduct :: forall a. Num a =&gt; Op a -&gt; a
sum :: forall a. Num a =&gt; Op a -&gt; a
$csum :: forall a. Num a =&gt; Op a -&gt; a
minimum :: forall a. Ord a =&gt; Op a -&gt; a
$cminimum :: forall a. Ord a =&gt; Op a -&gt; a
maximum :: forall a. Ord a =&gt; Op a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Op a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Op a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Op a -&gt; Bool
length :: forall a. Op a -&gt; Int
$clength :: forall a. Op a -&gt; Int
null :: forall a. Op a -&gt; Bool
$cnull :: forall a. Op a -&gt; Bool
toList :: forall a. Op a -&gt; [a]
$ctoList :: forall a. Op a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Op a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Op a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Op a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Op a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Op a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Op a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Op a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Op a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Op a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Op a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Op a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Op a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Op a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Op a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Op a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Op a -&gt; m
fold :: forall m. Monoid m =&gt; Op m -&gt; m
$cfold :: forall m. Monoid m =&gt; Op m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443447"><span id="local-6989586621679443449"><span id="local-6989586621679443451"><span id="local-6989586621679443460"><span class="annot"><span class="annottext">Functor Op
Foldable Op
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Op (m a) -&gt; m (Op a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Op (f a) -&gt; f (Op a)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; Op a -&gt; m (Op b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Op a -&gt; f (Op b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Op (m a) -&gt; m (Op a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Op (m a) -&gt; m (Op a)
mapM :: forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; Op a -&gt; m (Op b)
$cmapM :: forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; Op a -&gt; m (Op b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Op (f a) -&gt; f (Op a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Op (f a) -&gt; f (Op a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Op a -&gt; f (Op b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Op a -&gt; f (Op b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443441"><span id="local-6989586621679443445"><span class="annot"><span class="annottext">forall a b. a -&gt; Op b -&gt; Op a
forall a b. (a -&gt; b) -&gt; Op a -&gt; Op b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Op b -&gt; Op a
$c&lt;$ :: forall a b. a -&gt; Op b -&gt; Op a
fmap :: forall a b. (a -&gt; b) -&gt; Op a -&gt; Op b
$cfmap :: forall a b. (a -&gt; b) -&gt; Op a -&gt; Op b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Op l) x -&gt; Op l
forall l x. Op l -&gt; Rep (Op l) x
$cto :: forall l x. Rep (Op l) x -&gt; Op l
$cfrom :: forall l x. Op l -&gt; Rep (Op l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-177"></span><span>
</span><span id="line-178"></span><span class="hs-comment">-- | A name (/cname/) of a component of a class or data type in an @import@</span><span>
</span><span id="line-179"></span><span class="hs-comment">-- or export specification.</span><span>
</span><span id="line-180"></span><span id="local-6989586621679443434"><span id="local-6989586621679443435"></span></span><span class="hs-keyword">data</span><span> </span><span id="CName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CName"><span class="hs-identifier hs-var">CName</span></a></span></span><span> </span><span id="local-6989586621679452821"><span class="annot"><a href="#local-6989586621679452821"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-181"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="VarName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarName"><span class="hs-identifier hs-var">VarName</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452821"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452821"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ name of a method or field</span><span>
</span><span id="line-182"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ConName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConName"><span class="hs-identifier hs-var">ConName</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452821"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452821"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ name of a data constructor</span><span>
</span><span id="line-183"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679443424"><span id="local-6989586621679443430"><span class="annot"><span class="annottext">CName l -&gt; CName l -&gt; Bool
forall l. Eq l =&gt; CName l -&gt; CName l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: CName l -&gt; CName l -&gt; Bool
$c/= :: forall l. Eq l =&gt; CName l -&gt; CName l -&gt; Bool
== :: CName l -&gt; CName l -&gt; Bool
$c== :: forall l. Eq l =&gt; CName l -&gt; CName l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443397"><span id="local-6989586621679443399"><span id="local-6989586621679443402"><span id="local-6989586621679443405"><span id="local-6989586621679443408"><span id="local-6989586621679443414"><span id="local-6989586621679443420"><span class="annot"><span class="annottext">CName l -&gt; CName l -&gt; Bool
CName l -&gt; CName l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (CName l)
forall l. Ord l =&gt; CName l -&gt; CName l -&gt; Bool
forall l. Ord l =&gt; CName l -&gt; CName l -&gt; Ordering
forall l. Ord l =&gt; CName l -&gt; CName l -&gt; CName l
min :: CName l -&gt; CName l -&gt; CName l
$cmin :: forall l. Ord l =&gt; CName l -&gt; CName l -&gt; CName l
max :: CName l -&gt; CName l -&gt; CName l
$cmax :: forall l. Ord l =&gt; CName l -&gt; CName l -&gt; CName l
&gt;= :: CName l -&gt; CName l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; CName l -&gt; CName l -&gt; Bool
&gt; :: CName l -&gt; CName l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; CName l -&gt; CName l -&gt; Bool
&lt;= :: CName l -&gt; CName l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; CName l -&gt; CName l -&gt; Bool
&lt; :: CName l -&gt; CName l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; CName l -&gt; CName l -&gt; Bool
compare :: CName l -&gt; CName l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; CName l -&gt; CName l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443385"><span id="local-6989586621679443387"><span id="local-6989586621679443395"><span class="annot"><span class="annottext">Int -&gt; CName l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; CName l -&gt; ShowS
forall l. Show l =&gt; [CName l] -&gt; ShowS
forall l. Show l =&gt; CName l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [CName l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [CName l] -&gt; ShowS
show :: CName l -&gt; String
$cshow :: forall l. Show l =&gt; CName l -&gt; String
showsPrec :: Int -&gt; CName l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; CName l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679443342"><span id="local-6989586621679443344"><span id="local-6989586621679443346"><span id="local-6989586621679443348"><span id="local-6989586621679443350"><span id="local-6989586621679443352"><span id="local-6989586621679443354"><span id="local-6989586621679443356"><span id="local-6989586621679443358"><span id="local-6989586621679443364"><span id="local-6989586621679443366"><span id="local-6989586621679443368"><span id="local-6989586621679443374"><span id="local-6989586621679443380"><span class="annot"><span class="annottext">CName l -&gt; DataType
CName l -&gt; Constr
forall {l}. Data l =&gt; Typeable (CName l)
forall l. Data l =&gt; CName l -&gt; DataType
forall l. Data l =&gt; CName l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; CName l -&gt; CName l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; CName l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; CName l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CName l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CName l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CName l -&gt; m (CName l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CName l -&gt; m (CName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (CName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; CName l -&gt; c (CName l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (CName l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (CName l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (CName l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; CName l -&gt; c (CName l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (CName l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CName l -&gt; m (CName l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CName l -&gt; m (CName l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CName l -&gt; m (CName l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CName l -&gt; m (CName l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CName l -&gt; m (CName l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CName l -&gt; m (CName l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; CName l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; CName l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; CName l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; CName l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CName l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CName l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CName l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CName l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; CName l -&gt; CName l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; CName l -&gt; CName l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (CName l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (CName l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (CName l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (CName l))
dataTypeOf :: CName l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; CName l -&gt; DataType
toConstr :: CName l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; CName l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (CName l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (CName l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; CName l -&gt; c (CName l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; CName l -&gt; c (CName l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443299"><span id="local-6989586621679443301"><span id="local-6989586621679443303"><span id="local-6989586621679443305"><span id="local-6989586621679443307"><span id="local-6989586621679443309"><span id="local-6989586621679443311"><span id="local-6989586621679443313"><span id="local-6989586621679443315"><span id="local-6989586621679443317"><span id="local-6989586621679443319"><span id="local-6989586621679443321"><span id="local-6989586621679443323"><span id="local-6989586621679443327"><span id="local-6989586621679443329"><span id="local-6989586621679443338"><span id="local-6989586621679443340"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; CName a -&gt; Bool
forall a. Num a =&gt; CName a -&gt; a
forall a. Ord a =&gt; CName a -&gt; a
forall m. Monoid m =&gt; CName m -&gt; m
forall a. CName a -&gt; Bool
forall a. CName a -&gt; Int
forall a. CName a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; CName a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; CName a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; CName a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; CName a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; CName a -&gt; a
$cproduct :: forall a. Num a =&gt; CName a -&gt; a
sum :: forall a. Num a =&gt; CName a -&gt; a
$csum :: forall a. Num a =&gt; CName a -&gt; a
minimum :: forall a. Ord a =&gt; CName a -&gt; a
$cminimum :: forall a. Ord a =&gt; CName a -&gt; a
maximum :: forall a. Ord a =&gt; CName a -&gt; a
$cmaximum :: forall a. Ord a =&gt; CName a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; CName a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; CName a -&gt; Bool
length :: forall a. CName a -&gt; Int
$clength :: forall a. CName a -&gt; Int
null :: forall a. CName a -&gt; Bool
$cnull :: forall a. CName a -&gt; Bool
toList :: forall a. CName a -&gt; [a]
$ctoList :: forall a. CName a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; CName a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; CName a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; CName a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; CName a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; CName a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; CName a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; CName a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; CName a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; CName a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; CName a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; CName a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; CName a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; CName a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; CName a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; CName a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; CName a -&gt; m
fold :: forall m. Monoid m =&gt; CName m -&gt; m
$cfold :: forall m. Monoid m =&gt; CName m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443279"><span id="local-6989586621679443281"><span id="local-6989586621679443283"><span id="local-6989586621679443292"><span class="annot"><span class="annottext">Functor CName
Foldable CName
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; CName (m a) -&gt; m (CName a)
forall (f :: * -&gt; *) a. Applicative f =&gt; CName (f a) -&gt; f (CName a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; CName a -&gt; m (CName b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; CName a -&gt; f (CName b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; CName (m a) -&gt; m (CName a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; CName (m a) -&gt; m (CName a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; CName a -&gt; m (CName b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; CName a -&gt; m (CName b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; CName (f a) -&gt; f (CName a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; CName (f a) -&gt; f (CName a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; CName a -&gt; f (CName b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; CName a -&gt; f (CName b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443273"><span id="local-6989586621679443277"><span class="annot"><span class="annottext">forall a b. a -&gt; CName b -&gt; CName a
forall a b. (a -&gt; b) -&gt; CName a -&gt; CName b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; CName b -&gt; CName a
$c&lt;$ :: forall a b. a -&gt; CName b -&gt; CName a
fmap :: forall a b. (a -&gt; b) -&gt; CName a -&gt; CName b
$cfmap :: forall a b. (a -&gt; b) -&gt; CName a -&gt; CName b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (CName l) x -&gt; CName l
forall l x. CName l -&gt; Rep (CName l) x
$cto :: forall l x. Rep (CName l) x -&gt; CName l
$cfrom :: forall l x. CName l -&gt; Rep (CName l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-184"></span><span>
</span><span id="line-185"></span><span class="hs-comment">-- | A complete Haskell source module.</span><span>
</span><span id="line-186"></span><span id="local-6989586621679443266"><span id="local-6989586621679443267"></span></span><span class="hs-keyword">data</span><span> </span><span id="Module"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Module"><span class="hs-identifier hs-var">Module</span></a></span></span><span> </span><span id="local-6989586621679452815"><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-187"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="Module"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Module"><span class="hs-identifier hs-var">Module</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleHead"><span class="hs-identifier hs-type">ModuleHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModulePragma"><span class="hs-identifier hs-type">ModulePragma</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-type">ImportDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-188"></span><span>    </span><span class="hs-comment">-- ^ an ordinary Haskell module</span><span>
</span><span id="line-189"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="XmlPage"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XmlPage"><span class="hs-identifier hs-var">XmlPage</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModulePragma"><span class="hs-identifier hs-type">ModulePragma</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-type">XName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XAttr"><span class="hs-identifier hs-type">XAttr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-190"></span><span>    </span><span class="hs-comment">-- ^ a module consisting of a single XML document. The ModuleName never appears in the source</span><span>
</span><span id="line-191"></span><span>    </span><span class="hs-comment">--   but is needed for semantic purposes, it will be the same as the file name.</span><span>
</span><span id="line-192"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="XmlHybrid"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XmlHybrid"><span class="hs-identifier hs-var">XmlHybrid</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleHead"><span class="hs-identifier hs-type">ModuleHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModulePragma"><span class="hs-identifier hs-type">ModulePragma</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-type">ImportDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-193"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-type">XName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XAttr"><span class="hs-identifier hs-type">XAttr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452815"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-194"></span><span>    </span><span class="hs-comment">-- ^ a hybrid module combining an XML document with an ordinary module</span><span>
</span><span id="line-195"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679443231"><span id="local-6989586621679443261"><span class="annot"><span class="annottext">Module l -&gt; Module l -&gt; Bool
forall l. Eq l =&gt; Module l -&gt; Module l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Module l -&gt; Module l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Module l -&gt; Module l -&gt; Bool
== :: Module l -&gt; Module l -&gt; Bool
$c== :: forall l. Eq l =&gt; Module l -&gt; Module l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443157"><span id="local-6989586621679443159"><span id="local-6989586621679443162"><span id="local-6989586621679443165"><span id="local-6989586621679443168"><span id="local-6989586621679443197"><span id="local-6989586621679443227"><span class="annot"><span class="annottext">Module l -&gt; Module l -&gt; Bool
Module l -&gt; Module l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Module l)
forall l. Ord l =&gt; Module l -&gt; Module l -&gt; Bool
forall l. Ord l =&gt; Module l -&gt; Module l -&gt; Ordering
forall l. Ord l =&gt; Module l -&gt; Module l -&gt; Module l
min :: Module l -&gt; Module l -&gt; Module l
$cmin :: forall l. Ord l =&gt; Module l -&gt; Module l -&gt; Module l
max :: Module l -&gt; Module l -&gt; Module l
$cmax :: forall l. Ord l =&gt; Module l -&gt; Module l -&gt; Module l
&gt;= :: Module l -&gt; Module l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Module l -&gt; Module l -&gt; Bool
&gt; :: Module l -&gt; Module l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Module l -&gt; Module l -&gt; Bool
&lt;= :: Module l -&gt; Module l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Module l -&gt; Module l -&gt; Bool
&lt; :: Module l -&gt; Module l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Module l -&gt; Module l -&gt; Bool
compare :: Module l -&gt; Module l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Module l -&gt; Module l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679443120"><span id="local-6989586621679443122"><span id="local-6989586621679443155"><span class="annot"><span class="annottext">Int -&gt; Module l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Module l -&gt; ShowS
forall l. Show l =&gt; [Module l] -&gt; ShowS
forall l. Show l =&gt; Module l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Module l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Module l] -&gt; ShowS
show :: Module l -&gt; String
$cshow :: forall l. Show l =&gt; Module l -&gt; String
showsPrec :: Int -&gt; Module l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Module l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679443030"><span id="local-6989586621679443032"><span id="local-6989586621679443034"><span id="local-6989586621679443036"><span id="local-6989586621679443038"><span id="local-6989586621679443040"><span id="local-6989586621679443042"><span id="local-6989586621679443044"><span id="local-6989586621679443046"><span id="local-6989586621679443052"><span id="local-6989586621679443054"><span id="local-6989586621679443056"><span id="local-6989586621679443085"><span id="local-6989586621679443115"><span class="annot"><span class="annottext">Module l -&gt; DataType
Module l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Module l)
forall l. Data l =&gt; Module l -&gt; DataType
forall l. Data l =&gt; Module l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Module l -&gt; Module l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Module l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Module l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module l -&gt; m (Module l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module l -&gt; m (Module l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Module l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Module l -&gt; c (Module l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Module l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Module l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Module l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Module l -&gt; c (Module l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Module l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module l -&gt; m (Module l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module l -&gt; m (Module l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module l -&gt; m (Module l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module l -&gt; m (Module l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module l -&gt; m (Module l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Module l -&gt; m (Module l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Module l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Module l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Module l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Module l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Module l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Module l -&gt; Module l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Module l -&gt; Module l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Module l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Module l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Module l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Module l))
dataTypeOf :: Module l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Module l -&gt; DataType
toConstr :: Module l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Module l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Module l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Module l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Module l -&gt; c (Module l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Module l -&gt; c (Module l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442876"><span id="local-6989586621679442878"><span id="local-6989586621679442880"><span id="local-6989586621679442882"><span id="local-6989586621679442884"><span id="local-6989586621679442886"><span id="local-6989586621679442888"><span id="local-6989586621679442890"><span id="local-6989586621679442892"><span id="local-6989586621679442894"><span id="local-6989586621679442896"><span id="local-6989586621679442898"><span id="local-6989586621679442900"><span id="local-6989586621679442935"><span id="local-6989586621679442937"><span id="local-6989586621679443026"><span id="local-6989586621679443028"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Module a -&gt; Bool
forall a. Num a =&gt; Module a -&gt; a
forall a. Ord a =&gt; Module a -&gt; a
forall m. Monoid m =&gt; Module m -&gt; m
forall a. Module a -&gt; Bool
forall a. Module a -&gt; Int
forall a. Module a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Module a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Module a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Module a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Module a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Module a -&gt; a
$cproduct :: forall a. Num a =&gt; Module a -&gt; a
sum :: forall a. Num a =&gt; Module a -&gt; a
$csum :: forall a. Num a =&gt; Module a -&gt; a
minimum :: forall a. Ord a =&gt; Module a -&gt; a
$cminimum :: forall a. Ord a =&gt; Module a -&gt; a
maximum :: forall a. Ord a =&gt; Module a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Module a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Module a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Module a -&gt; Bool
length :: forall a. Module a -&gt; Int
$clength :: forall a. Module a -&gt; Int
null :: forall a. Module a -&gt; Bool
$cnull :: forall a. Module a -&gt; Bool
toList :: forall a. Module a -&gt; [a]
$ctoList :: forall a. Module a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Module a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Module a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Module a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Module a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Module a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Module a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Module a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Module a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Module a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Module a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Module a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Module a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Module a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Module a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Module a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Module a -&gt; m
fold :: forall m. Monoid m =&gt; Module m -&gt; m
$cfold :: forall m. Monoid m =&gt; Module m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442776"><span id="local-6989586621679442778"><span id="local-6989586621679442780"><span id="local-6989586621679442869"><span class="annot"><span class="annottext">Functor Module
Foldable Module
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Module (m a) -&gt; m (Module a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Module (f a) -&gt; f (Module a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Module a -&gt; m (Module b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Module a -&gt; f (Module b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Module (m a) -&gt; m (Module a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Module (m a) -&gt; m (Module a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Module a -&gt; m (Module b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Module a -&gt; m (Module b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Module (f a) -&gt; f (Module a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Module (f a) -&gt; f (Module a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Module a -&gt; f (Module b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Module a -&gt; f (Module b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442730"><span id="local-6989586621679442774"><span class="annot"><span class="annottext">forall a b. a -&gt; Module b -&gt; Module a
forall a b. (a -&gt; b) -&gt; Module a -&gt; Module b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Module b -&gt; Module a
$c&lt;$ :: forall a b. a -&gt; Module b -&gt; Module a
fmap :: forall a b. (a -&gt; b) -&gt; Module a -&gt; Module b
$cfmap :: forall a b. (a -&gt; b) -&gt; Module a -&gt; Module b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Module l) x -&gt; Module l
forall l x. Module l -&gt; Rep (Module l) x
$cto :: forall l x. Rep (Module l) x -&gt; Module l
$cfrom :: forall l x. Module l -&gt; Rep (Module l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-196"></span><span>
</span><span id="line-197"></span><span class="hs-comment">-- | The head of a module, including the name and export specification.</span><span>
</span><span id="line-198"></span><span id="local-6989586621679442692"><span id="local-6989586621679442693"></span></span><span class="hs-keyword">data</span><span> </span><span id="ModuleHead"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleHead"><span class="hs-identifier hs-var">ModuleHead</span></a></span></span><span> </span><span id="local-6989586621679452810"><span class="annot"><a href="#local-6989586621679452810"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ModuleHead"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleHead"><span class="hs-identifier hs-var">ModuleHead</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452810"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452810"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#WarningText"><span class="hs-identifier hs-type">WarningText</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452810"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExportSpecList"><span class="hs-identifier hs-type">ExportSpecList</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452810"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-199"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679442681"><span id="local-6989586621679442689"><span class="annot"><span class="annottext">ModuleHead l -&gt; ModuleHead l -&gt; Bool
forall l. Eq l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ModuleHead l -&gt; ModuleHead l -&gt; Bool
$c/= :: forall l. Eq l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; Bool
== :: ModuleHead l -&gt; ModuleHead l -&gt; Bool
$c== :: forall l. Eq l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442650"><span id="local-6989586621679442652"><span id="local-6989586621679442655"><span id="local-6989586621679442658"><span id="local-6989586621679442661"><span id="local-6989586621679442669"><span id="local-6989586621679442677"><span class="annot"><span class="annottext">ModuleHead l -&gt; ModuleHead l -&gt; Bool
ModuleHead l -&gt; ModuleHead l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (ModuleHead l)
forall l. Ord l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; Bool
forall l. Ord l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; Ordering
forall l. Ord l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; ModuleHead l
min :: ModuleHead l -&gt; ModuleHead l -&gt; ModuleHead l
$cmin :: forall l. Ord l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; ModuleHead l
max :: ModuleHead l -&gt; ModuleHead l -&gt; ModuleHead l
$cmax :: forall l. Ord l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; ModuleHead l
&gt;= :: ModuleHead l -&gt; ModuleHead l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; Bool
&gt; :: ModuleHead l -&gt; ModuleHead l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; Bool
&lt;= :: ModuleHead l -&gt; ModuleHead l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; Bool
&lt; :: ModuleHead l -&gt; ModuleHead l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; Bool
compare :: ModuleHead l -&gt; ModuleHead l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; ModuleHead l -&gt; ModuleHead l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442637"><span id="local-6989586621679442639"><span id="local-6989586621679442648"><span class="annot"><span class="annottext">Int -&gt; ModuleHead l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; ModuleHead l -&gt; ShowS
forall l. Show l =&gt; [ModuleHead l] -&gt; ShowS
forall l. Show l =&gt; ModuleHead l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ModuleHead l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [ModuleHead l] -&gt; ShowS
show :: ModuleHead l -&gt; String
$cshow :: forall l. Show l =&gt; ModuleHead l -&gt; String
showsPrec :: Int -&gt; ModuleHead l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; ModuleHead l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679442590"><span id="local-6989586621679442592"><span id="local-6989586621679442594"><span id="local-6989586621679442596"><span id="local-6989586621679442598"><span id="local-6989586621679442600"><span id="local-6989586621679442602"><span id="local-6989586621679442604"><span id="local-6989586621679442606"><span id="local-6989586621679442612"><span id="local-6989586621679442614"><span id="local-6989586621679442616"><span id="local-6989586621679442624"><span id="local-6989586621679442632"><span class="annot"><span class="annottext">ModuleHead l -&gt; DataType
ModuleHead l -&gt; Constr
forall {l}. Data l =&gt; Typeable (ModuleHead l)
forall l. Data l =&gt; ModuleHead l -&gt; DataType
forall l. Data l =&gt; ModuleHead l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ModuleHead l -&gt; ModuleHead l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleHead l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ModuleHead l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleHead l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleHead l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleHead l -&gt; m (ModuleHead l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleHead l -&gt; m (ModuleHead l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModuleHead l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModuleHead l -&gt; c (ModuleHead l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModuleHead l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ModuleHead l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModuleHead l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModuleHead l -&gt; c (ModuleHead l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModuleHead l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleHead l -&gt; m (ModuleHead l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleHead l -&gt; m (ModuleHead l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleHead l -&gt; m (ModuleHead l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleHead l -&gt; m (ModuleHead l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleHead l -&gt; m (ModuleHead l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ModuleHead l -&gt; m (ModuleHead l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleHead l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleHead l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ModuleHead l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ModuleHead l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleHead l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleHead l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleHead l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModuleHead l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ModuleHead l -&gt; ModuleHead l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ModuleHead l -&gt; ModuleHead l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ModuleHead l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ModuleHead l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModuleHead l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModuleHead l))
dataTypeOf :: ModuleHead l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; ModuleHead l -&gt; DataType
toConstr :: ModuleHead l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; ModuleHead l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModuleHead l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModuleHead l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModuleHead l -&gt; c (ModuleHead l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModuleHead l -&gt; c (ModuleHead l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442537"><span id="local-6989586621679442539"><span id="local-6989586621679442541"><span id="local-6989586621679442543"><span id="local-6989586621679442545"><span id="local-6989586621679442547"><span id="local-6989586621679442549"><span id="local-6989586621679442551"><span id="local-6989586621679442553"><span id="local-6989586621679442555"><span id="local-6989586621679442557"><span id="local-6989586621679442559"><span id="local-6989586621679442561"><span id="local-6989586621679442568"><span id="local-6989586621679442570"><span id="local-6989586621679442586"><span id="local-6989586621679442588"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; ModuleHead a -&gt; Bool
forall a. Num a =&gt; ModuleHead a -&gt; a
forall a. Ord a =&gt; ModuleHead a -&gt; a
forall m. Monoid m =&gt; ModuleHead m -&gt; m
forall a. ModuleHead a -&gt; Bool
forall a. ModuleHead a -&gt; Int
forall a. ModuleHead a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; ModuleHead a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModuleHead a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModuleHead a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModuleHead a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; ModuleHead a -&gt; a
$cproduct :: forall a. Num a =&gt; ModuleHead a -&gt; a
sum :: forall a. Num a =&gt; ModuleHead a -&gt; a
$csum :: forall a. Num a =&gt; ModuleHead a -&gt; a
minimum :: forall a. Ord a =&gt; ModuleHead a -&gt; a
$cminimum :: forall a. Ord a =&gt; ModuleHead a -&gt; a
maximum :: forall a. Ord a =&gt; ModuleHead a -&gt; a
$cmaximum :: forall a. Ord a =&gt; ModuleHead a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; ModuleHead a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; ModuleHead a -&gt; Bool
length :: forall a. ModuleHead a -&gt; Int
$clength :: forall a. ModuleHead a -&gt; Int
null :: forall a. ModuleHead a -&gt; Bool
$cnull :: forall a. ModuleHead a -&gt; Bool
toList :: forall a. ModuleHead a -&gt; [a]
$ctoList :: forall a. ModuleHead a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModuleHead a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModuleHead a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModuleHead a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModuleHead a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModuleHead a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModuleHead a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModuleHead a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModuleHead a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModuleHead a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModuleHead a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModuleHead a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModuleHead a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModuleHead a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModuleHead a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModuleHead a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModuleHead a -&gt; m
fold :: forall m. Monoid m =&gt; ModuleHead m -&gt; m
$cfold :: forall m. Monoid m =&gt; ModuleHead m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442511"><span id="local-6989586621679442513"><span id="local-6989586621679442515"><span id="local-6989586621679442531"><span class="annot"><span class="annottext">Functor ModuleHead
Foldable ModuleHead
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
ModuleHead (m a) -&gt; m (ModuleHead a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
ModuleHead (f a) -&gt; f (ModuleHead a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ModuleHead a -&gt; m (ModuleHead b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ModuleHead a -&gt; f (ModuleHead b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ModuleHead (m a) -&gt; m (ModuleHead a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ModuleHead (m a) -&gt; m (ModuleHead a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ModuleHead a -&gt; m (ModuleHead b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ModuleHead a -&gt; m (ModuleHead b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ModuleHead (f a) -&gt; f (ModuleHead a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ModuleHead (f a) -&gt; f (ModuleHead a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ModuleHead a -&gt; f (ModuleHead b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ModuleHead a -&gt; f (ModuleHead b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442500"><span id="local-6989586621679442509"><span class="annot"><span class="annottext">forall a b. a -&gt; ModuleHead b -&gt; ModuleHead a
forall a b. (a -&gt; b) -&gt; ModuleHead a -&gt; ModuleHead b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; ModuleHead b -&gt; ModuleHead a
$c&lt;$ :: forall a b. a -&gt; ModuleHead b -&gt; ModuleHead a
fmap :: forall a b. (a -&gt; b) -&gt; ModuleHead a -&gt; ModuleHead b
$cfmap :: forall a b. (a -&gt; b) -&gt; ModuleHead a -&gt; ModuleHead b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (ModuleHead l) x -&gt; ModuleHead l
forall l x. ModuleHead l -&gt; Rep (ModuleHead l) x
$cto :: forall l x. Rep (ModuleHead l) x -&gt; ModuleHead l
$cfrom :: forall l x. ModuleHead l -&gt; Rep (ModuleHead l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-200"></span><span>
</span><span id="line-201"></span><span class="hs-comment">-- | An explicit export specification.</span><span>
</span><span id="line-202"></span><span id="local-6989586621679442490"><span id="local-6989586621679442491"></span></span><span class="hs-keyword">data</span><span> </span><span id="ExportSpecList"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExportSpecList"><span class="hs-identifier hs-var">ExportSpecList</span></a></span></span><span> </span><span id="local-6989586621679452799"><span class="annot"><a href="#local-6989586621679452799"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-203"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="ExportSpecList"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExportSpecList"><span class="hs-identifier hs-var">ExportSpecList</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452799"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExportSpec"><span class="hs-identifier hs-type">ExportSpec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452799"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-204"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679442482"><span id="local-6989586621679442487"><span class="annot"><span class="annottext">ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
forall l. Eq l =&gt; ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
$c/= :: forall l. Eq l =&gt; ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
== :: ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
$c== :: forall l. Eq l =&gt; ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442457"><span id="local-6989586621679442459"><span id="local-6989586621679442462"><span id="local-6989586621679442465"><span id="local-6989586621679442468"><span id="local-6989586621679442473"><span id="local-6989586621679442478"><span class="annot"><span class="annottext">ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
ExportSpecList l -&gt; ExportSpecList l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (ExportSpecList l)
forall l. Ord l =&gt; ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
forall l. Ord l =&gt; ExportSpecList l -&gt; ExportSpecList l -&gt; Ordering
forall l.
Ord l =&gt;
ExportSpecList l -&gt; ExportSpecList l -&gt; ExportSpecList l
min :: ExportSpecList l -&gt; ExportSpecList l -&gt; ExportSpecList l
$cmin :: forall l.
Ord l =&gt;
ExportSpecList l -&gt; ExportSpecList l -&gt; ExportSpecList l
max :: ExportSpecList l -&gt; ExportSpecList l -&gt; ExportSpecList l
$cmax :: forall l.
Ord l =&gt;
ExportSpecList l -&gt; ExportSpecList l -&gt; ExportSpecList l
&gt;= :: ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
&gt; :: ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
&lt;= :: ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
&lt; :: ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; ExportSpecList l -&gt; ExportSpecList l -&gt; Bool
compare :: ExportSpecList l -&gt; ExportSpecList l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; ExportSpecList l -&gt; ExportSpecList l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442447"><span id="local-6989586621679442449"><span id="local-6989586621679442455"><span class="annot"><span class="annottext">Int -&gt; ExportSpecList l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; ExportSpecList l -&gt; ShowS
forall l. Show l =&gt; [ExportSpecList l] -&gt; ShowS
forall l. Show l =&gt; ExportSpecList l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ExportSpecList l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [ExportSpecList l] -&gt; ShowS
show :: ExportSpecList l -&gt; String
$cshow :: forall l. Show l =&gt; ExportSpecList l -&gt; String
showsPrec :: Int -&gt; ExportSpecList l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; ExportSpecList l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679442406"><span id="local-6989586621679442408"><span id="local-6989586621679442410"><span id="local-6989586621679442412"><span id="local-6989586621679442414"><span id="local-6989586621679442416"><span id="local-6989586621679442418"><span id="local-6989586621679442420"><span id="local-6989586621679442422"><span id="local-6989586621679442428"><span id="local-6989586621679442430"><span id="local-6989586621679442432"><span id="local-6989586621679442437"><span id="local-6989586621679442442"><span class="annot"><span class="annottext">ExportSpecList l -&gt; DataType
ExportSpecList l -&gt; Constr
forall {l}. Data l =&gt; Typeable (ExportSpecList l)
forall l. Data l =&gt; ExportSpecList l -&gt; DataType
forall l. Data l =&gt; ExportSpecList l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; ExportSpecList l -&gt; ExportSpecList l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpecList l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpecList l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpecList l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpecList l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ExportSpecList l -&gt; m (ExportSpecList l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ExportSpecList l -&gt; m (ExportSpecList l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ExportSpecList l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ExportSpecList l -&gt; c (ExportSpecList l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ExportSpecList l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ExportSpecList l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ExportSpecList l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ExportSpecList l -&gt; c (ExportSpecList l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ExportSpecList l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ExportSpecList l -&gt; m (ExportSpecList l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ExportSpecList l -&gt; m (ExportSpecList l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ExportSpecList l -&gt; m (ExportSpecList l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ExportSpecList l -&gt; m (ExportSpecList l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ExportSpecList l -&gt; m (ExportSpecList l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ExportSpecList l -&gt; m (ExportSpecList l)
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpecList l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpecList l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpecList l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpecList l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpecList l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpecList l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpecList l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpecList l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; ExportSpecList l -&gt; ExportSpecList l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; ExportSpecList l -&gt; ExportSpecList l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ExportSpecList l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ExportSpecList l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ExportSpecList l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ExportSpecList l))
dataTypeOf :: ExportSpecList l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; ExportSpecList l -&gt; DataType
toConstr :: ExportSpecList l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; ExportSpecList l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ExportSpecList l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ExportSpecList l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ExportSpecList l -&gt; c (ExportSpecList l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ExportSpecList l -&gt; c (ExportSpecList l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442364"><span id="local-6989586621679442366"><span id="local-6989586621679442368"><span id="local-6989586621679442370"><span id="local-6989586621679442372"><span id="local-6989586621679442374"><span id="local-6989586621679442376"><span id="local-6989586621679442378"><span id="local-6989586621679442380"><span id="local-6989586621679442382"><span id="local-6989586621679442384"><span id="local-6989586621679442386"><span id="local-6989586621679442388"><span id="local-6989586621679442392"><span id="local-6989586621679442394"><span id="local-6989586621679442402"><span id="local-6989586621679442404"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; ExportSpecList a -&gt; Bool
forall a. Num a =&gt; ExportSpecList a -&gt; a
forall a. Ord a =&gt; ExportSpecList a -&gt; a
forall m. Monoid m =&gt; ExportSpecList m -&gt; m
forall a. ExportSpecList a -&gt; Bool
forall a. ExportSpecList a -&gt; Int
forall a. ExportSpecList a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; ExportSpecList a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ExportSpecList a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ExportSpecList a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ExportSpecList a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; ExportSpecList a -&gt; a
$cproduct :: forall a. Num a =&gt; ExportSpecList a -&gt; a
sum :: forall a. Num a =&gt; ExportSpecList a -&gt; a
$csum :: forall a. Num a =&gt; ExportSpecList a -&gt; a
minimum :: forall a. Ord a =&gt; ExportSpecList a -&gt; a
$cminimum :: forall a. Ord a =&gt; ExportSpecList a -&gt; a
maximum :: forall a. Ord a =&gt; ExportSpecList a -&gt; a
$cmaximum :: forall a. Ord a =&gt; ExportSpecList a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; ExportSpecList a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; ExportSpecList a -&gt; Bool
length :: forall a. ExportSpecList a -&gt; Int
$clength :: forall a. ExportSpecList a -&gt; Int
null :: forall a. ExportSpecList a -&gt; Bool
$cnull :: forall a. ExportSpecList a -&gt; Bool
toList :: forall a. ExportSpecList a -&gt; [a]
$ctoList :: forall a. ExportSpecList a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ExportSpecList a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ExportSpecList a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ExportSpecList a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ExportSpecList a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ExportSpecList a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ExportSpecList a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ExportSpecList a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ExportSpecList a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ExportSpecList a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ExportSpecList a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ExportSpecList a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ExportSpecList a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ExportSpecList a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ExportSpecList a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ExportSpecList a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ExportSpecList a -&gt; m
fold :: forall m. Monoid m =&gt; ExportSpecList m -&gt; m
$cfold :: forall m. Monoid m =&gt; ExportSpecList m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442346"><span id="local-6989586621679442348"><span id="local-6989586621679442350"><span id="local-6989586621679442358"><span class="annot"><span class="annottext">Functor ExportSpecList
Foldable ExportSpecList
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
ExportSpecList (m a) -&gt; m (ExportSpecList a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
ExportSpecList (f a) -&gt; f (ExportSpecList a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ExportSpecList a -&gt; m (ExportSpecList b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ExportSpecList a -&gt; f (ExportSpecList b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ExportSpecList (m a) -&gt; m (ExportSpecList a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ExportSpecList (m a) -&gt; m (ExportSpecList a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ExportSpecList a -&gt; m (ExportSpecList b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ExportSpecList a -&gt; m (ExportSpecList b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ExportSpecList (f a) -&gt; f (ExportSpecList a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ExportSpecList (f a) -&gt; f (ExportSpecList a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ExportSpecList a -&gt; f (ExportSpecList b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ExportSpecList a -&gt; f (ExportSpecList b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442339"><span id="local-6989586621679442344"><span class="annot"><span class="annottext">forall a b. a -&gt; ExportSpecList b -&gt; ExportSpecList a
forall a b. (a -&gt; b) -&gt; ExportSpecList a -&gt; ExportSpecList b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; ExportSpecList b -&gt; ExportSpecList a
$c&lt;$ :: forall a b. a -&gt; ExportSpecList b -&gt; ExportSpecList a
fmap :: forall a b. (a -&gt; b) -&gt; ExportSpecList a -&gt; ExportSpecList b
$cfmap :: forall a b. (a -&gt; b) -&gt; ExportSpecList a -&gt; ExportSpecList b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (ExportSpecList l) x -&gt; ExportSpecList l
forall l x. ExportSpecList l -&gt; Rep (ExportSpecList l) x
$cto :: forall l x. Rep (ExportSpecList l) x -&gt; ExportSpecList l
$cfrom :: forall l x. ExportSpecList l -&gt; Rep (ExportSpecList l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-205"></span><span>
</span><span id="line-206"></span><span class="hs-comment">-- | An item in a module's export specification.</span><span>
</span><span id="line-207"></span><span id="local-6989586621679442332"><span id="local-6989586621679442333"></span></span><span class="hs-keyword">data</span><span> </span><span id="ExportSpec"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExportSpec"><span class="hs-identifier hs-var">ExportSpec</span></a></span></span><span> </span><span id="local-6989586621679452794"><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-208"></span><span>     </span><span class="hs-glyph">=</span><span> </span><span id="EVar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EVar"><span class="hs-identifier hs-var">EVar</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                 </span><span class="hs-comment">-- ^ variable.</span><span>
</span><span id="line-209"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="EAbs"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EAbs"><span class="hs-identifier hs-var">EAbs</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Namespace"><span class="hs-identifier hs-type">Namespace</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- ^ @T@:</span><span>
</span><span id="line-210"></span><span>                                        </span><span class="hs-comment">--   a class or datatype exported abstractly,</span><span>
</span><span id="line-211"></span><span>                                        </span><span class="hs-comment">--   or a type synonym.</span><span>
</span><span id="line-212"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="EThingWith"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EThingWith"><span class="hs-identifier hs-var">EThingWith</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EWildcard"><span class="hs-identifier hs-type">EWildcard</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CName"><span class="hs-identifier hs-type">CName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ @T(C_1,...,C_n)@:</span><span>
</span><span id="line-213"></span><span>                                        </span><span class="hs-comment">--   a class exported with some of its methods, or</span><span>
</span><span id="line-214"></span><span>                                        </span><span class="hs-comment">--   a datatype exported with some of its constructors.</span><span>
</span><span id="line-215"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="EModuleContents"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EModuleContents"><span class="hs-identifier hs-var">EModuleContents</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452794"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ @module M@:</span><span>
</span><span id="line-216"></span><span>                                        </span><span class="hs-comment">--   re-export a module.</span><span>
</span><span id="line-217"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679442312"><span id="local-6989586621679442326"><span class="annot"><span class="annottext">ExportSpec l -&gt; ExportSpec l -&gt; Bool
forall l. Eq l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ExportSpec l -&gt; ExportSpec l -&gt; Bool
$c/= :: forall l. Eq l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; Bool
== :: ExportSpec l -&gt; ExportSpec l -&gt; Bool
$c== :: forall l. Eq l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442284"><span id="local-6989586621679442286"><span id="local-6989586621679442288"><span id="local-6989586621679442290"><span id="local-6989586621679442292"><span id="local-6989586621679442294"><span id="local-6989586621679442308"><span class="annot"><span class="annottext">ExportSpec l -&gt; ExportSpec l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (ExportSpec l)
forall l. Ord l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; Bool
forall l. Ord l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; Ordering
forall l. Ord l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; ExportSpec l
min :: ExportSpec l -&gt; ExportSpec l -&gt; ExportSpec l
$cmin :: forall l. Ord l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; ExportSpec l
max :: ExportSpec l -&gt; ExportSpec l -&gt; ExportSpec l
$cmax :: forall l. Ord l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; ExportSpec l
&gt;= :: ExportSpec l -&gt; ExportSpec l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; Bool
&gt; :: ExportSpec l -&gt; ExportSpec l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; Bool
&lt;= :: ExportSpec l -&gt; ExportSpec l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; Bool
&lt; :: ExportSpec l -&gt; ExportSpec l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; Bool
compare :: ExportSpec l -&gt; ExportSpec l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; ExportSpec l -&gt; ExportSpec l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442262"><span id="local-6989586621679442264"><span id="local-6989586621679442282"><span class="annot"><span class="annottext">Int -&gt; ExportSpec l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; ExportSpec l -&gt; ShowS
forall l. Show l =&gt; [ExportSpec l] -&gt; ShowS
forall l. Show l =&gt; ExportSpec l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ExportSpec l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [ExportSpec l] -&gt; ShowS
show :: ExportSpec l -&gt; String
$cshow :: forall l. Show l =&gt; ExportSpec l -&gt; String
showsPrec :: Int -&gt; ExportSpec l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; ExportSpec l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679442203"><span id="local-6989586621679442205"><span id="local-6989586621679442207"><span id="local-6989586621679442209"><span id="local-6989586621679442211"><span id="local-6989586621679442213"><span id="local-6989586621679442215"><span id="local-6989586621679442217"><span id="local-6989586621679442219"><span id="local-6989586621679442225"><span id="local-6989586621679442227"><span id="local-6989586621679442229"><span id="local-6989586621679442243"><span id="local-6989586621679442257"><span class="annot"><span class="annottext">ExportSpec l -&gt; DataType
ExportSpec l -&gt; Constr
forall {l}. Data l =&gt; Typeable (ExportSpec l)
forall l. Data l =&gt; ExportSpec l -&gt; DataType
forall l. Data l =&gt; ExportSpec l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ExportSpec l -&gt; ExportSpec l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpec l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpec l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpec l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpec l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ExportSpec l -&gt; m (ExportSpec l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ExportSpec l -&gt; m (ExportSpec l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ExportSpec l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ExportSpec l -&gt; c (ExportSpec l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ExportSpec l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ExportSpec l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ExportSpec l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ExportSpec l -&gt; c (ExportSpec l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ExportSpec l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ExportSpec l -&gt; m (ExportSpec l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ExportSpec l -&gt; m (ExportSpec l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ExportSpec l -&gt; m (ExportSpec l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ExportSpec l -&gt; m (ExportSpec l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ExportSpec l -&gt; m (ExportSpec l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ExportSpec l -&gt; m (ExportSpec l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpec l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpec l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpec l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ExportSpec l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpec l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpec l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpec l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ExportSpec l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ExportSpec l -&gt; ExportSpec l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ExportSpec l -&gt; ExportSpec l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ExportSpec l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ExportSpec l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ExportSpec l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ExportSpec l))
dataTypeOf :: ExportSpec l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; ExportSpec l -&gt; DataType
toConstr :: ExportSpec l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; ExportSpec l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ExportSpec l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ExportSpec l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ExportSpec l -&gt; c (ExportSpec l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ExportSpec l -&gt; c (ExportSpec l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442137"><span id="local-6989586621679442139"><span id="local-6989586621679442141"><span id="local-6989586621679442143"><span id="local-6989586621679442145"><span id="local-6989586621679442147"><span id="local-6989586621679442149"><span id="local-6989586621679442151"><span id="local-6989586621679442153"><span id="local-6989586621679442155"><span id="local-6989586621679442157"><span id="local-6989586621679442159"><span id="local-6989586621679442161"><span id="local-6989586621679442171"><span id="local-6989586621679442173"><span id="local-6989586621679442199"><span id="local-6989586621679442201"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; ExportSpec a -&gt; Bool
forall a. Num a =&gt; ExportSpec a -&gt; a
forall a. Ord a =&gt; ExportSpec a -&gt; a
forall m. Monoid m =&gt; ExportSpec m -&gt; m
forall a. ExportSpec a -&gt; Bool
forall a. ExportSpec a -&gt; Int
forall a. ExportSpec a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; ExportSpec a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ExportSpec a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ExportSpec a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ExportSpec a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; ExportSpec a -&gt; a
$cproduct :: forall a. Num a =&gt; ExportSpec a -&gt; a
sum :: forall a. Num a =&gt; ExportSpec a -&gt; a
$csum :: forall a. Num a =&gt; ExportSpec a -&gt; a
minimum :: forall a. Ord a =&gt; ExportSpec a -&gt; a
$cminimum :: forall a. Ord a =&gt; ExportSpec a -&gt; a
maximum :: forall a. Ord a =&gt; ExportSpec a -&gt; a
$cmaximum :: forall a. Ord a =&gt; ExportSpec a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; ExportSpec a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; ExportSpec a -&gt; Bool
length :: forall a. ExportSpec a -&gt; Int
$clength :: forall a. ExportSpec a -&gt; Int
null :: forall a. ExportSpec a -&gt; Bool
$cnull :: forall a. ExportSpec a -&gt; Bool
toList :: forall a. ExportSpec a -&gt; [a]
$ctoList :: forall a. ExportSpec a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ExportSpec a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ExportSpec a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ExportSpec a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ExportSpec a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ExportSpec a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ExportSpec a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ExportSpec a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ExportSpec a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ExportSpec a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ExportSpec a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ExportSpec a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ExportSpec a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ExportSpec a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ExportSpec a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ExportSpec a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ExportSpec a -&gt; m
fold :: forall m. Monoid m =&gt; ExportSpec m -&gt; m
$cfold :: forall m. Monoid m =&gt; ExportSpec m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442101"><span id="local-6989586621679442103"><span id="local-6989586621679442105"><span id="local-6989586621679442131"><span class="annot"><span class="annottext">Functor ExportSpec
Foldable ExportSpec
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
ExportSpec (m a) -&gt; m (ExportSpec a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
ExportSpec (f a) -&gt; f (ExportSpec a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ExportSpec a -&gt; m (ExportSpec b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ExportSpec a -&gt; f (ExportSpec b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ExportSpec (m a) -&gt; m (ExportSpec a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ExportSpec (m a) -&gt; m (ExportSpec a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ExportSpec a -&gt; m (ExportSpec b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ExportSpec a -&gt; m (ExportSpec b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ExportSpec (f a) -&gt; f (ExportSpec a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ExportSpec (f a) -&gt; f (ExportSpec a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ExportSpec a -&gt; f (ExportSpec b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ExportSpec a -&gt; f (ExportSpec b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442087"><span id="local-6989586621679442099"><span class="annot"><span class="annottext">forall a b. a -&gt; ExportSpec b -&gt; ExportSpec a
forall a b. (a -&gt; b) -&gt; ExportSpec a -&gt; ExportSpec b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; ExportSpec b -&gt; ExportSpec a
$c&lt;$ :: forall a b. a -&gt; ExportSpec b -&gt; ExportSpec a
fmap :: forall a b. (a -&gt; b) -&gt; ExportSpec a -&gt; ExportSpec b
$cfmap :: forall a b. (a -&gt; b) -&gt; ExportSpec a -&gt; ExportSpec b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (ExportSpec l) x -&gt; ExportSpec l
forall l x. ExportSpec l -&gt; Rep (ExportSpec l) x
$cto :: forall l x. Rep (ExportSpec l) x -&gt; ExportSpec l
$cfrom :: forall l x. ExportSpec l -&gt; Rep (ExportSpec l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-218"></span><span>
</span><span id="line-219"></span><span class="hs-comment">-- | Indicates the position of the wildcard in an export list</span><span>
</span><span id="line-220"></span><span id="local-6989586621679442074"><span id="local-6989586621679442075"></span></span><span class="hs-keyword">data</span><span> </span><span id="EWildcard"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EWildcard"><span class="hs-identifier hs-var">EWildcard</span></a></span></span><span> </span><span id="local-6989586621679452788"><span class="annot"><a href="#local-6989586621679452788"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="NoWildcard"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoWildcard"><span class="hs-identifier hs-var">NoWildcard</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452788"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="EWildcard"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EWildcard"><span class="hs-identifier hs-var">EWildcard</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452788"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-221"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679442065"><span id="local-6989586621679442070"><span class="annot"><span class="annottext">EWildcard l -&gt; EWildcard l -&gt; Bool
forall l. Eq l =&gt; EWildcard l -&gt; EWildcard l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: EWildcard l -&gt; EWildcard l -&gt; Bool
$c/= :: forall l. Eq l =&gt; EWildcard l -&gt; EWildcard l -&gt; Bool
== :: EWildcard l -&gt; EWildcard l -&gt; Bool
$c== :: forall l. Eq l =&gt; EWildcard l -&gt; EWildcard l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442040"><span id="local-6989586621679442042"><span id="local-6989586621679442045"><span id="local-6989586621679442048"><span id="local-6989586621679442051"><span id="local-6989586621679442056"><span id="local-6989586621679442061"><span class="annot"><span class="annottext">EWildcard l -&gt; EWildcard l -&gt; Bool
EWildcard l -&gt; EWildcard l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (EWildcard l)
forall l. Ord l =&gt; EWildcard l -&gt; EWildcard l -&gt; Bool
forall l. Ord l =&gt; EWildcard l -&gt; EWildcard l -&gt; Ordering
forall l. Ord l =&gt; EWildcard l -&gt; EWildcard l -&gt; EWildcard l
min :: EWildcard l -&gt; EWildcard l -&gt; EWildcard l
$cmin :: forall l. Ord l =&gt; EWildcard l -&gt; EWildcard l -&gt; EWildcard l
max :: EWildcard l -&gt; EWildcard l -&gt; EWildcard l
$cmax :: forall l. Ord l =&gt; EWildcard l -&gt; EWildcard l -&gt; EWildcard l
&gt;= :: EWildcard l -&gt; EWildcard l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; EWildcard l -&gt; EWildcard l -&gt; Bool
&gt; :: EWildcard l -&gt; EWildcard l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; EWildcard l -&gt; EWildcard l -&gt; Bool
&lt;= :: EWildcard l -&gt; EWildcard l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; EWildcard l -&gt; EWildcard l -&gt; Bool
&lt; :: EWildcard l -&gt; EWildcard l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; EWildcard l -&gt; EWildcard l -&gt; Bool
compare :: EWildcard l -&gt; EWildcard l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; EWildcard l -&gt; EWildcard l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679442029"><span id="local-6989586621679442031"><span id="local-6989586621679442038"><span class="annot"><span class="annottext">Int -&gt; EWildcard l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; EWildcard l -&gt; ShowS
forall l. Show l =&gt; [EWildcard l] -&gt; ShowS
forall l. Show l =&gt; EWildcard l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [EWildcard l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [EWildcard l] -&gt; ShowS
show :: EWildcard l -&gt; String
$cshow :: forall l. Show l =&gt; EWildcard l -&gt; String
showsPrec :: Int -&gt; EWildcard l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; EWildcard l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679441988"><span id="local-6989586621679441990"><span id="local-6989586621679441992"><span id="local-6989586621679441994"><span id="local-6989586621679441996"><span id="local-6989586621679441998"><span id="local-6989586621679442000"><span id="local-6989586621679442002"><span id="local-6989586621679442004"><span id="local-6989586621679442010"><span id="local-6989586621679442012"><span id="local-6989586621679442014"><span id="local-6989586621679442019"><span id="local-6989586621679442024"><span class="annot"><span class="annottext">EWildcard l -&gt; DataType
EWildcard l -&gt; Constr
forall {l}. Data l =&gt; Typeable (EWildcard l)
forall l. Data l =&gt; EWildcard l -&gt; DataType
forall l. Data l =&gt; EWildcard l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; EWildcard l -&gt; EWildcard l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EWildcard l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; EWildcard l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EWildcard l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EWildcard l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EWildcard l -&gt; m (EWildcard l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EWildcard l -&gt; m (EWildcard l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (EWildcard l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EWildcard l -&gt; c (EWildcard l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (EWildcard l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (EWildcard l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (EWildcard l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EWildcard l -&gt; c (EWildcard l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (EWildcard l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EWildcard l -&gt; m (EWildcard l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EWildcard l -&gt; m (EWildcard l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EWildcard l -&gt; m (EWildcard l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EWildcard l -&gt; m (EWildcard l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EWildcard l -&gt; m (EWildcard l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EWildcard l -&gt; m (EWildcard l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EWildcard l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EWildcard l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EWildcard l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; EWildcard l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EWildcard l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EWildcard l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EWildcard l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EWildcard l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; EWildcard l -&gt; EWildcard l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; EWildcard l -&gt; EWildcard l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (EWildcard l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (EWildcard l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (EWildcard l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (EWildcard l))
dataTypeOf :: EWildcard l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; EWildcard l -&gt; DataType
toConstr :: EWildcard l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; EWildcard l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (EWildcard l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (EWildcard l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EWildcard l -&gt; c (EWildcard l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EWildcard l -&gt; c (EWildcard l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441953"><span id="local-6989586621679441955"><span id="local-6989586621679441957"><span id="local-6989586621679441959"><span id="local-6989586621679441961"><span id="local-6989586621679441963"><span id="local-6989586621679441965"><span id="local-6989586621679441967"><span id="local-6989586621679441969"><span id="local-6989586621679441971"><span id="local-6989586621679441973"><span id="local-6989586621679441975"><span id="local-6989586621679441977"><span id="local-6989586621679441979"><span id="local-6989586621679441981"><span id="local-6989586621679441984"><span id="local-6989586621679441986"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; EWildcard a -&gt; Bool
forall a. Num a =&gt; EWildcard a -&gt; a
forall a. Ord a =&gt; EWildcard a -&gt; a
forall m. Monoid m =&gt; EWildcard m -&gt; m
forall a. EWildcard a -&gt; Bool
forall a. EWildcard a -&gt; Int
forall a. EWildcard a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; EWildcard a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; EWildcard a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; EWildcard a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; EWildcard a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; EWildcard a -&gt; a
$cproduct :: forall a. Num a =&gt; EWildcard a -&gt; a
sum :: forall a. Num a =&gt; EWildcard a -&gt; a
$csum :: forall a. Num a =&gt; EWildcard a -&gt; a
minimum :: forall a. Ord a =&gt; EWildcard a -&gt; a
$cminimum :: forall a. Ord a =&gt; EWildcard a -&gt; a
maximum :: forall a. Ord a =&gt; EWildcard a -&gt; a
$cmaximum :: forall a. Ord a =&gt; EWildcard a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; EWildcard a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; EWildcard a -&gt; Bool
length :: forall a. EWildcard a -&gt; Int
$clength :: forall a. EWildcard a -&gt; Int
null :: forall a. EWildcard a -&gt; Bool
$cnull :: forall a. EWildcard a -&gt; Bool
toList :: forall a. EWildcard a -&gt; [a]
$ctoList :: forall a. EWildcard a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; EWildcard a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; EWildcard a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; EWildcard a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; EWildcard a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; EWildcard a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; EWildcard a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; EWildcard a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; EWildcard a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; EWildcard a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; EWildcard a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; EWildcard a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; EWildcard a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; EWildcard a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; EWildcard a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; EWildcard a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; EWildcard a -&gt; m
fold :: forall m. Monoid m =&gt; EWildcard m -&gt; m
$cfold :: forall m. Monoid m =&gt; EWildcard m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441937"><span id="local-6989586621679441939"><span id="local-6989586621679441941"><span id="local-6989586621679441947"><span class="annot"><span class="annottext">Functor EWildcard
Foldable EWildcard
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
EWildcard (m a) -&gt; m (EWildcard a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
EWildcard (f a) -&gt; f (EWildcard a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; EWildcard a -&gt; m (EWildcard b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; EWildcard a -&gt; f (EWildcard b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
EWildcard (m a) -&gt; m (EWildcard a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
EWildcard (m a) -&gt; m (EWildcard a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; EWildcard a -&gt; m (EWildcard b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; EWildcard a -&gt; m (EWildcard b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
EWildcard (f a) -&gt; f (EWildcard a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
EWildcard (f a) -&gt; f (EWildcard a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; EWildcard a -&gt; f (EWildcard b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; EWildcard a -&gt; f (EWildcard b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441933"><span id="local-6989586621679441935"><span class="annot"><span class="annottext">forall a b. a -&gt; EWildcard b -&gt; EWildcard a
forall a b. (a -&gt; b) -&gt; EWildcard a -&gt; EWildcard b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; EWildcard b -&gt; EWildcard a
$c&lt;$ :: forall a b. a -&gt; EWildcard b -&gt; EWildcard a
fmap :: forall a b. (a -&gt; b) -&gt; EWildcard a -&gt; EWildcard b
$cfmap :: forall a b. (a -&gt; b) -&gt; EWildcard a -&gt; EWildcard b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (EWildcard l) x -&gt; EWildcard l
forall l x. EWildcard l -&gt; Rep (EWildcard l) x
$cto :: forall l x. Rep (EWildcard l) x -&gt; EWildcard l
$cfrom :: forall l x. EWildcard l -&gt; Rep (EWildcard l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-222"></span><span>
</span><span id="line-223"></span><span class="hs-comment">-- | Namespaces for imports/exports.</span><span>
</span><span id="line-224"></span><span id="local-6989586621679441928"><span id="local-6989586621679441929"></span></span><span class="hs-keyword">data</span><span> </span><span id="Namespace"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Namespace"><span class="hs-identifier hs-var">Namespace</span></a></span></span><span> </span><span id="local-6989586621679452789"><span class="annot"><a href="#local-6989586621679452789"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="NoNamespace"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoNamespace"><span class="hs-identifier hs-var">NoNamespace</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452789"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="TypeNamespace"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeNamespace"><span class="hs-identifier hs-var">TypeNamespace</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452789"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="PatternNamespace"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatternNamespace"><span class="hs-identifier hs-var">PatternNamespace</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452789"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-225"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679441918"><span id="local-6989586621679441923"><span class="annot"><span class="annottext">Namespace l -&gt; Namespace l -&gt; Bool
forall l. Eq l =&gt; Namespace l -&gt; Namespace l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Namespace l -&gt; Namespace l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Namespace l -&gt; Namespace l -&gt; Bool
== :: Namespace l -&gt; Namespace l -&gt; Bool
$c== :: forall l. Eq l =&gt; Namespace l -&gt; Namespace l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441893"><span id="local-6989586621679441895"><span id="local-6989586621679441898"><span id="local-6989586621679441901"><span id="local-6989586621679441904"><span id="local-6989586621679441909"><span id="local-6989586621679441914"><span class="annot"><span class="annottext">Namespace l -&gt; Namespace l -&gt; Bool
Namespace l -&gt; Namespace l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Namespace l)
forall l. Ord l =&gt; Namespace l -&gt; Namespace l -&gt; Bool
forall l. Ord l =&gt; Namespace l -&gt; Namespace l -&gt; Ordering
forall l. Ord l =&gt; Namespace l -&gt; Namespace l -&gt; Namespace l
min :: Namespace l -&gt; Namespace l -&gt; Namespace l
$cmin :: forall l. Ord l =&gt; Namespace l -&gt; Namespace l -&gt; Namespace l
max :: Namespace l -&gt; Namespace l -&gt; Namespace l
$cmax :: forall l. Ord l =&gt; Namespace l -&gt; Namespace l -&gt; Namespace l
&gt;= :: Namespace l -&gt; Namespace l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Namespace l -&gt; Namespace l -&gt; Bool
&gt; :: Namespace l -&gt; Namespace l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Namespace l -&gt; Namespace l -&gt; Bool
&lt;= :: Namespace l -&gt; Namespace l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Namespace l -&gt; Namespace l -&gt; Bool
&lt; :: Namespace l -&gt; Namespace l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Namespace l -&gt; Namespace l -&gt; Bool
compare :: Namespace l -&gt; Namespace l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Namespace l -&gt; Namespace l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441881"><span id="local-6989586621679441883"><span id="local-6989586621679441891"><span class="annot"><span class="annottext">Int -&gt; Namespace l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Namespace l -&gt; ShowS
forall l. Show l =&gt; [Namespace l] -&gt; ShowS
forall l. Show l =&gt; Namespace l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Namespace l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Namespace l] -&gt; ShowS
show :: Namespace l -&gt; String
$cshow :: forall l. Show l =&gt; Namespace l -&gt; String
showsPrec :: Int -&gt; Namespace l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Namespace l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679441840"><span id="local-6989586621679441842"><span id="local-6989586621679441844"><span id="local-6989586621679441846"><span id="local-6989586621679441848"><span id="local-6989586621679441850"><span id="local-6989586621679441852"><span id="local-6989586621679441854"><span id="local-6989586621679441856"><span id="local-6989586621679441862"><span id="local-6989586621679441864"><span id="local-6989586621679441866"><span id="local-6989586621679441871"><span id="local-6989586621679441876"><span class="annot"><span class="annottext">Namespace l -&gt; DataType
Namespace l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Namespace l)
forall l. Data l =&gt; Namespace l -&gt; DataType
forall l. Data l =&gt; Namespace l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Namespace l -&gt; Namespace l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Namespace l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Namespace l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Namespace l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Namespace l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Namespace l -&gt; m (Namespace l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Namespace l -&gt; m (Namespace l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Namespace l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Namespace l -&gt; c (Namespace l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Namespace l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Namespace l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Namespace l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Namespace l -&gt; c (Namespace l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Namespace l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Namespace l -&gt; m (Namespace l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Namespace l -&gt; m (Namespace l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Namespace l -&gt; m (Namespace l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Namespace l -&gt; m (Namespace l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Namespace l -&gt; m (Namespace l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Namespace l -&gt; m (Namespace l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Namespace l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Namespace l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Namespace l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Namespace l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Namespace l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Namespace l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Namespace l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Namespace l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Namespace l -&gt; Namespace l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Namespace l -&gt; Namespace l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Namespace l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Namespace l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Namespace l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Namespace l))
dataTypeOf :: Namespace l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Namespace l -&gt; DataType
toConstr :: Namespace l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Namespace l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Namespace l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Namespace l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Namespace l -&gt; c (Namespace l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Namespace l -&gt; c (Namespace l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441805"><span id="local-6989586621679441807"><span id="local-6989586621679441809"><span id="local-6989586621679441811"><span id="local-6989586621679441813"><span id="local-6989586621679441815"><span id="local-6989586621679441817"><span id="local-6989586621679441819"><span id="local-6989586621679441821"><span id="local-6989586621679441823"><span id="local-6989586621679441825"><span id="local-6989586621679441827"><span id="local-6989586621679441829"><span id="local-6989586621679441831"><span id="local-6989586621679441833"><span id="local-6989586621679441836"><span id="local-6989586621679441838"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Namespace a -&gt; Bool
forall a. Num a =&gt; Namespace a -&gt; a
forall a. Ord a =&gt; Namespace a -&gt; a
forall m. Monoid m =&gt; Namespace m -&gt; m
forall a. Namespace a -&gt; Bool
forall a. Namespace a -&gt; Int
forall a. Namespace a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Namespace a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Namespace a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Namespace a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Namespace a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Namespace a -&gt; a
$cproduct :: forall a. Num a =&gt; Namespace a -&gt; a
sum :: forall a. Num a =&gt; Namespace a -&gt; a
$csum :: forall a. Num a =&gt; Namespace a -&gt; a
minimum :: forall a. Ord a =&gt; Namespace a -&gt; a
$cminimum :: forall a. Ord a =&gt; Namespace a -&gt; a
maximum :: forall a. Ord a =&gt; Namespace a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Namespace a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Namespace a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Namespace a -&gt; Bool
length :: forall a. Namespace a -&gt; Int
$clength :: forall a. Namespace a -&gt; Int
null :: forall a. Namespace a -&gt; Bool
$cnull :: forall a. Namespace a -&gt; Bool
toList :: forall a. Namespace a -&gt; [a]
$ctoList :: forall a. Namespace a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Namespace a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Namespace a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Namespace a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Namespace a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Namespace a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Namespace a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Namespace a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Namespace a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Namespace a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Namespace a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Namespace a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Namespace a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Namespace a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Namespace a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Namespace a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Namespace a -&gt; m
fold :: forall m. Monoid m =&gt; Namespace m -&gt; m
$cfold :: forall m. Monoid m =&gt; Namespace m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441788"><span id="local-6989586621679441790"><span id="local-6989586621679441792"><span id="local-6989586621679441799"><span class="annot"><span class="annottext">Functor Namespace
Foldable Namespace
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
Namespace (m a) -&gt; m (Namespace a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Namespace (f a) -&gt; f (Namespace a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Namespace a -&gt; m (Namespace b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Namespace a -&gt; f (Namespace b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
Namespace (m a) -&gt; m (Namespace a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
Namespace (m a) -&gt; m (Namespace a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Namespace a -&gt; m (Namespace b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Namespace a -&gt; m (Namespace b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Namespace (f a) -&gt; f (Namespace a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Namespace (f a) -&gt; f (Namespace a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Namespace a -&gt; f (Namespace b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Namespace a -&gt; f (Namespace b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441784"><span id="local-6989586621679441786"><span class="annot"><span class="annottext">forall a b. a -&gt; Namespace b -&gt; Namespace a
forall a b. (a -&gt; b) -&gt; Namespace a -&gt; Namespace b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Namespace b -&gt; Namespace a
$c&lt;$ :: forall a b. a -&gt; Namespace b -&gt; Namespace a
fmap :: forall a b. (a -&gt; b) -&gt; Namespace a -&gt; Namespace b
$cfmap :: forall a b. (a -&gt; b) -&gt; Namespace a -&gt; Namespace b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Namespace l) x -&gt; Namespace l
forall l x. Namespace l -&gt; Rep (Namespace l) x
$cto :: forall l x. Rep (Namespace l) x -&gt; Namespace l
$cfrom :: forall l x. Namespace l -&gt; Rep (Namespace l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-226"></span><span>
</span><span id="line-227"></span><span class="hs-comment">-- | An import declaration.</span><span>
</span><span id="line-228"></span><span id="local-6989586621679441779"><span id="local-6989586621679441780"></span></span><span class="hs-keyword">data</span><span> </span><span id="ImportDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-var">ImportDecl</span></a></span></span><span> </span><span id="local-6989586621679452808"><span class="annot"><a href="#local-6989586621679452808"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ImportDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-var">ImportDecl</span></a></span></span><span>
</span><span id="line-229"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="importAnn"><span class="annot"><span class="annottext">forall l. ImportDecl l -&gt; l
</span><a href="Language.Haskell.Exts.Syntax.html#importAnn"><span class="hs-identifier hs-var hs-var">importAnn</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679452808"><span class="hs-identifier hs-type">l</span></a></span><span>                   </span><span class="hs-comment">-- ^ annotation, used by parser for position of the @import@ keyword.</span><span>
</span><span id="line-230"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="importModule"><span class="annot"><span class="annottext">forall l. ImportDecl l -&gt; ModuleName l
</span><a href="Language.Haskell.Exts.Syntax.html#importModule"><span class="hs-identifier hs-var hs-var">importModule</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452808"><span class="hs-identifier hs-type">l</span></a></span><span>     </span><span class="hs-comment">-- ^ name of the module imported.</span><span>
</span><span id="line-231"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="importQualified"><span class="annot"><span class="annottext">forall l. ImportDecl l -&gt; Bool
</span><a href="Language.Haskell.Exts.Syntax.html#importQualified"><span class="hs-identifier hs-var hs-var">importQualified</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>          </span><span class="hs-comment">-- ^ imported @qualified@?</span><span>
</span><span id="line-232"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="importSrc"><span class="annot"><span class="annottext">forall l. ImportDecl l -&gt; Bool
</span><a href="Language.Haskell.Exts.Syntax.html#importSrc"><span class="hs-identifier hs-var hs-var">importSrc</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>                </span><span class="hs-comment">-- ^ imported with @{-\# SOURCE \#-}@?</span><span>
</span><span id="line-233"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="importSafe"><span class="annot"><span class="annottext">forall l. ImportDecl l -&gt; Bool
</span><a href="Language.Haskell.Exts.Syntax.html#importSafe"><span class="hs-identifier hs-var hs-var">importSafe</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>               </span><span class="hs-comment">-- ^ Import @safe@?</span><span>
</span><span id="line-234"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="importPkg"><span class="annot"><span class="annottext">forall l. ImportDecl l -&gt; Maybe String
</span><a href="Language.Haskell.Exts.Syntax.html#importPkg"><span class="hs-identifier hs-var hs-var">importPkg</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>        </span><span class="hs-comment">-- ^ imported with explicit package name</span><span>
</span><span id="line-235"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="importAs"><span class="annot"><span class="annottext">forall l. ImportDecl l -&gt; Maybe (ModuleName l)
</span><a href="Language.Haskell.Exts.Syntax.html#importAs"><span class="hs-identifier hs-var hs-var">importAs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452808"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ optional alias name in an @as@ clause.</span><span>
</span><span id="line-236"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="importSpecs"><span class="annot"><span class="annottext">forall l. ImportDecl l -&gt; Maybe (ImportSpecList l)
</span><a href="Language.Haskell.Exts.Syntax.html#importSpecs"><span class="hs-identifier hs-var hs-var">importSpecs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportSpecList"><span class="hs-identifier hs-type">ImportSpecList</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452808"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-237"></span><span>            </span><span class="hs-comment">-- ^ optional list of import specifications.</span><span>
</span><span id="line-238"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-239"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679441755"><span id="local-6989586621679441768"><span class="annot"><span class="annottext">ImportDecl l -&gt; ImportDecl l -&gt; Bool
forall l. Eq l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ImportDecl l -&gt; ImportDecl l -&gt; Bool
$c/= :: forall l. Eq l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; Bool
== :: ImportDecl l -&gt; ImportDecl l -&gt; Bool
$c== :: forall l. Eq l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441714"><span id="local-6989586621679441716"><span id="local-6989586621679441719"><span id="local-6989586621679441722"><span id="local-6989586621679441725"><span id="local-6989586621679441737"><span id="local-6989586621679441750"><span class="annot"><span class="annottext">ImportDecl l -&gt; ImportDecl l -&gt; Bool
ImportDecl l -&gt; ImportDecl l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (ImportDecl l)
forall l. Ord l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; Bool
forall l. Ord l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; Ordering
forall l. Ord l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; ImportDecl l
min :: ImportDecl l -&gt; ImportDecl l -&gt; ImportDecl l
$cmin :: forall l. Ord l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; ImportDecl l
max :: ImportDecl l -&gt; ImportDecl l -&gt; ImportDecl l
$cmax :: forall l. Ord l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; ImportDecl l
&gt;= :: ImportDecl l -&gt; ImportDecl l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; Bool
&gt; :: ImportDecl l -&gt; ImportDecl l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; Bool
&lt;= :: ImportDecl l -&gt; ImportDecl l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; Bool
&lt; :: ImportDecl l -&gt; ImportDecl l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; Bool
compare :: ImportDecl l -&gt; ImportDecl l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; ImportDecl l -&gt; ImportDecl l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441694"><span id="local-6989586621679441696"><span id="local-6989586621679441710"><span class="annot"><span class="annottext">Int -&gt; ImportDecl l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; ImportDecl l -&gt; ShowS
forall l. Show l =&gt; [ImportDecl l] -&gt; ShowS
forall l. Show l =&gt; ImportDecl l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ImportDecl l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [ImportDecl l] -&gt; ShowS
show :: ImportDecl l -&gt; String
$cshow :: forall l. Show l =&gt; ImportDecl l -&gt; String
showsPrec :: Int -&gt; ImportDecl l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; ImportDecl l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679441635"><span id="local-6989586621679441637"><span id="local-6989586621679441639"><span id="local-6989586621679441641"><span id="local-6989586621679441643"><span id="local-6989586621679441645"><span id="local-6989586621679441647"><span id="local-6989586621679441649"><span id="local-6989586621679441651"><span id="local-6989586621679441657"><span id="local-6989586621679441659"><span id="local-6989586621679441661"><span id="local-6989586621679441674"><span id="local-6989586621679441688"><span class="annot"><span class="annottext">ImportDecl l -&gt; DataType
ImportDecl l -&gt; Constr
forall {l}. Data l =&gt; Typeable (ImportDecl l)
forall l. Data l =&gt; ImportDecl l -&gt; DataType
forall l. Data l =&gt; ImportDecl l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ImportDecl l -&gt; ImportDecl l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ImportDecl l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ImportDecl l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportDecl l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportDecl l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportDecl l -&gt; m (ImportDecl l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportDecl l -&gt; m (ImportDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportDecl l -&gt; c (ImportDecl l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportDecl l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ImportDecl l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportDecl l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportDecl l -&gt; c (ImportDecl l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportDecl l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportDecl l -&gt; m (ImportDecl l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportDecl l -&gt; m (ImportDecl l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportDecl l -&gt; m (ImportDecl l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportDecl l -&gt; m (ImportDecl l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportDecl l -&gt; m (ImportDecl l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportDecl l -&gt; m (ImportDecl l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ImportDecl l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ImportDecl l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ImportDecl l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ImportDecl l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportDecl l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportDecl l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportDecl l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportDecl l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ImportDecl l -&gt; ImportDecl l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ImportDecl l -&gt; ImportDecl l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ImportDecl l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ImportDecl l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportDecl l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportDecl l))
dataTypeOf :: ImportDecl l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; ImportDecl l -&gt; DataType
toConstr :: ImportDecl l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; ImportDecl l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportDecl l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportDecl l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportDecl l -&gt; c (ImportDecl l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportDecl l -&gt; c (ImportDecl l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441580"><span id="local-6989586621679441582"><span id="local-6989586621679441584"><span id="local-6989586621679441586"><span id="local-6989586621679441588"><span id="local-6989586621679441590"><span id="local-6989586621679441592"><span id="local-6989586621679441594"><span id="local-6989586621679441596"><span id="local-6989586621679441598"><span id="local-6989586621679441600"><span id="local-6989586621679441602"><span id="local-6989586621679441604"><span id="local-6989586621679441611"><span id="local-6989586621679441613"><span id="local-6989586621679441629"><span id="local-6989586621679441631"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; ImportDecl a -&gt; Bool
forall a. Num a =&gt; ImportDecl a -&gt; a
forall a. Ord a =&gt; ImportDecl a -&gt; a
forall m. Monoid m =&gt; ImportDecl m -&gt; m
forall l. ImportDecl l -&gt; Bool
forall a. ImportDecl a -&gt; Int
forall a. ImportDecl a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; ImportDecl a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportDecl a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportDecl a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportDecl a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; ImportDecl a -&gt; a
$cproduct :: forall a. Num a =&gt; ImportDecl a -&gt; a
sum :: forall a. Num a =&gt; ImportDecl a -&gt; a
$csum :: forall a. Num a =&gt; ImportDecl a -&gt; a
minimum :: forall a. Ord a =&gt; ImportDecl a -&gt; a
$cminimum :: forall a. Ord a =&gt; ImportDecl a -&gt; a
maximum :: forall a. Ord a =&gt; ImportDecl a -&gt; a
$cmaximum :: forall a. Ord a =&gt; ImportDecl a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; ImportDecl a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; ImportDecl a -&gt; Bool
length :: forall a. ImportDecl a -&gt; Int
$clength :: forall a. ImportDecl a -&gt; Int
null :: forall l. ImportDecl l -&gt; Bool
$cnull :: forall l. ImportDecl l -&gt; Bool
toList :: forall a. ImportDecl a -&gt; [a]
$ctoList :: forall a. ImportDecl a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportDecl a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportDecl a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportDecl a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportDecl a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportDecl a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportDecl a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportDecl a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportDecl a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportDecl a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportDecl a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportDecl a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportDecl a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportDecl a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportDecl a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportDecl a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportDecl a -&gt; m
fold :: forall m. Monoid m =&gt; ImportDecl m -&gt; m
$cfold :: forall m. Monoid m =&gt; ImportDecl m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441554"><span id="local-6989586621679441556"><span id="local-6989586621679441558"><span id="local-6989586621679441574"><span class="annot"><span class="annottext">Functor ImportDecl
Foldable ImportDecl
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
ImportDecl (m a) -&gt; m (ImportDecl a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
ImportDecl (f a) -&gt; f (ImportDecl a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ImportDecl a -&gt; m (ImportDecl b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ImportDecl a -&gt; f (ImportDecl b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ImportDecl (m a) -&gt; m (ImportDecl a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ImportDecl (m a) -&gt; m (ImportDecl a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ImportDecl a -&gt; m (ImportDecl b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ImportDecl a -&gt; m (ImportDecl b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ImportDecl (f a) -&gt; f (ImportDecl a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ImportDecl (f a) -&gt; f (ImportDecl a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ImportDecl a -&gt; f (ImportDecl b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ImportDecl a -&gt; f (ImportDecl b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441544"><span id="local-6989586621679441552"><span class="annot"><span class="annottext">forall a b. a -&gt; ImportDecl b -&gt; ImportDecl a
forall a b. (a -&gt; b) -&gt; ImportDecl a -&gt; ImportDecl b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; ImportDecl b -&gt; ImportDecl a
$c&lt;$ :: forall a b. a -&gt; ImportDecl b -&gt; ImportDecl a
fmap :: forall a b. (a -&gt; b) -&gt; ImportDecl a -&gt; ImportDecl b
$cfmap :: forall a b. (a -&gt; b) -&gt; ImportDecl a -&gt; ImportDecl b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (ImportDecl l) x -&gt; ImportDecl l
forall l x. ImportDecl l -&gt; Rep (ImportDecl l) x
$cto :: forall l x. Rep (ImportDecl l) x -&gt; ImportDecl l
$cfrom :: forall l x. ImportDecl l -&gt; Rep (ImportDecl l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-240"></span><span>
</span><span id="line-241"></span><span class="hs-comment">-- | An explicit import specification list.</span><span>
</span><span id="line-242"></span><span id="local-6989586621679441534"><span id="local-6989586621679441535"></span></span><span class="hs-keyword">data</span><span> </span><span id="ImportSpecList"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportSpecList"><span class="hs-identifier hs-var">ImportSpecList</span></a></span></span><span> </span><span id="local-6989586621679452767"><span class="annot"><a href="#local-6989586621679452767"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-243"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="ImportSpecList"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportSpecList"><span class="hs-identifier hs-var">ImportSpecList</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452767"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportSpec"><span class="hs-identifier hs-type">ImportSpec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452767"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-244"></span><span>            </span><span class="hs-comment">-- ^ A list of import specifications.</span><span>
</span><span id="line-245"></span><span>            </span><span class="hs-comment">-- The 'Bool' is 'True' if the names are excluded</span><span>
</span><span id="line-246"></span><span>            </span><span class="hs-comment">-- by @hiding@.</span><span>
</span><span id="line-247"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679441525"><span id="local-6989586621679441531"><span class="annot"><span class="annottext">ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
forall l. Eq l =&gt; ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
$c/= :: forall l. Eq l =&gt; ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
== :: ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
$c== :: forall l. Eq l =&gt; ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441498"><span id="local-6989586621679441500"><span id="local-6989586621679441503"><span id="local-6989586621679441506"><span id="local-6989586621679441509"><span id="local-6989586621679441515"><span id="local-6989586621679441521"><span class="annot"><span class="annottext">ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
ImportSpecList l -&gt; ImportSpecList l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (ImportSpecList l)
forall l. Ord l =&gt; ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
forall l. Ord l =&gt; ImportSpecList l -&gt; ImportSpecList l -&gt; Ordering
forall l.
Ord l =&gt;
ImportSpecList l -&gt; ImportSpecList l -&gt; ImportSpecList l
min :: ImportSpecList l -&gt; ImportSpecList l -&gt; ImportSpecList l
$cmin :: forall l.
Ord l =&gt;
ImportSpecList l -&gt; ImportSpecList l -&gt; ImportSpecList l
max :: ImportSpecList l -&gt; ImportSpecList l -&gt; ImportSpecList l
$cmax :: forall l.
Ord l =&gt;
ImportSpecList l -&gt; ImportSpecList l -&gt; ImportSpecList l
&gt;= :: ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
&gt; :: ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
&lt;= :: ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
&lt; :: ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; ImportSpecList l -&gt; ImportSpecList l -&gt; Bool
compare :: ImportSpecList l -&gt; ImportSpecList l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; ImportSpecList l -&gt; ImportSpecList l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441487"><span id="local-6989586621679441489"><span id="local-6989586621679441496"><span class="annot"><span class="annottext">Int -&gt; ImportSpecList l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; ImportSpecList l -&gt; ShowS
forall l. Show l =&gt; [ImportSpecList l] -&gt; ShowS
forall l. Show l =&gt; ImportSpecList l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ImportSpecList l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [ImportSpecList l] -&gt; ShowS
show :: ImportSpecList l -&gt; String
$cshow :: forall l. Show l =&gt; ImportSpecList l -&gt; String
showsPrec :: Int -&gt; ImportSpecList l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; ImportSpecList l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679441444"><span id="local-6989586621679441446"><span id="local-6989586621679441448"><span id="local-6989586621679441450"><span id="local-6989586621679441452"><span id="local-6989586621679441454"><span id="local-6989586621679441456"><span id="local-6989586621679441458"><span id="local-6989586621679441460"><span id="local-6989586621679441466"><span id="local-6989586621679441468"><span id="local-6989586621679441470"><span id="local-6989586621679441476"><span id="local-6989586621679441482"><span class="annot"><span class="annottext">ImportSpecList l -&gt; DataType
ImportSpecList l -&gt; Constr
forall {l}. Data l =&gt; Typeable (ImportSpecList l)
forall l. Data l =&gt; ImportSpecList l -&gt; DataType
forall l. Data l =&gt; ImportSpecList l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; ImportSpecList l -&gt; ImportSpecList l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpecList l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpecList l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpecList l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpecList l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ImportSpecList l -&gt; m (ImportSpecList l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ImportSpecList l -&gt; m (ImportSpecList l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportSpecList l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportSpecList l -&gt; c (ImportSpecList l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportSpecList l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ImportSpecList l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportSpecList l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportSpecList l -&gt; c (ImportSpecList l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportSpecList l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ImportSpecList l -&gt; m (ImportSpecList l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ImportSpecList l -&gt; m (ImportSpecList l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ImportSpecList l -&gt; m (ImportSpecList l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ImportSpecList l -&gt; m (ImportSpecList l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ImportSpecList l -&gt; m (ImportSpecList l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ImportSpecList l -&gt; m (ImportSpecList l)
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpecList l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpecList l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpecList l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpecList l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpecList l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpecList l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpecList l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpecList l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; ImportSpecList l -&gt; ImportSpecList l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; ImportSpecList l -&gt; ImportSpecList l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ImportSpecList l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ImportSpecList l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportSpecList l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportSpecList l))
dataTypeOf :: ImportSpecList l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; ImportSpecList l -&gt; DataType
toConstr :: ImportSpecList l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; ImportSpecList l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportSpecList l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportSpecList l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportSpecList l -&gt; c (ImportSpecList l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportSpecList l -&gt; c (ImportSpecList l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441402"><span id="local-6989586621679441404"><span id="local-6989586621679441406"><span id="local-6989586621679441408"><span id="local-6989586621679441410"><span id="local-6989586621679441412"><span id="local-6989586621679441414"><span id="local-6989586621679441416"><span id="local-6989586621679441418"><span id="local-6989586621679441420"><span id="local-6989586621679441422"><span id="local-6989586621679441424"><span id="local-6989586621679441426"><span id="local-6989586621679441430"><span id="local-6989586621679441432"><span id="local-6989586621679441440"><span id="local-6989586621679441442"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; ImportSpecList a -&gt; Bool
forall a. Num a =&gt; ImportSpecList a -&gt; a
forall a. Ord a =&gt; ImportSpecList a -&gt; a
forall m. Monoid m =&gt; ImportSpecList m -&gt; m
forall a. ImportSpecList a -&gt; Bool
forall a. ImportSpecList a -&gt; Int
forall a. ImportSpecList a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; ImportSpecList a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportSpecList a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportSpecList a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportSpecList a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; ImportSpecList a -&gt; a
$cproduct :: forall a. Num a =&gt; ImportSpecList a -&gt; a
sum :: forall a. Num a =&gt; ImportSpecList a -&gt; a
$csum :: forall a. Num a =&gt; ImportSpecList a -&gt; a
minimum :: forall a. Ord a =&gt; ImportSpecList a -&gt; a
$cminimum :: forall a. Ord a =&gt; ImportSpecList a -&gt; a
maximum :: forall a. Ord a =&gt; ImportSpecList a -&gt; a
$cmaximum :: forall a. Ord a =&gt; ImportSpecList a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; ImportSpecList a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; ImportSpecList a -&gt; Bool
length :: forall a. ImportSpecList a -&gt; Int
$clength :: forall a. ImportSpecList a -&gt; Int
null :: forall a. ImportSpecList a -&gt; Bool
$cnull :: forall a. ImportSpecList a -&gt; Bool
toList :: forall a. ImportSpecList a -&gt; [a]
$ctoList :: forall a. ImportSpecList a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportSpecList a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportSpecList a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportSpecList a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportSpecList a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportSpecList a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportSpecList a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportSpecList a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportSpecList a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportSpecList a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportSpecList a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportSpecList a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportSpecList a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportSpecList a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportSpecList a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportSpecList a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportSpecList a -&gt; m
fold :: forall m. Monoid m =&gt; ImportSpecList m -&gt; m
$cfold :: forall m. Monoid m =&gt; ImportSpecList m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441384"><span id="local-6989586621679441386"><span id="local-6989586621679441388"><span id="local-6989586621679441396"><span class="annot"><span class="annottext">Functor ImportSpecList
Foldable ImportSpecList
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
ImportSpecList (m a) -&gt; m (ImportSpecList a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
ImportSpecList (f a) -&gt; f (ImportSpecList a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ImportSpecList a -&gt; m (ImportSpecList b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ImportSpecList a -&gt; f (ImportSpecList b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ImportSpecList (m a) -&gt; m (ImportSpecList a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ImportSpecList (m a) -&gt; m (ImportSpecList a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ImportSpecList a -&gt; m (ImportSpecList b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ImportSpecList a -&gt; m (ImportSpecList b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ImportSpecList (f a) -&gt; f (ImportSpecList a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ImportSpecList (f a) -&gt; f (ImportSpecList a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ImportSpecList a -&gt; f (ImportSpecList b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ImportSpecList a -&gt; f (ImportSpecList b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441377"><span id="local-6989586621679441382"><span class="annot"><span class="annottext">forall a b. a -&gt; ImportSpecList b -&gt; ImportSpecList a
forall a b. (a -&gt; b) -&gt; ImportSpecList a -&gt; ImportSpecList b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; ImportSpecList b -&gt; ImportSpecList a
$c&lt;$ :: forall a b. a -&gt; ImportSpecList b -&gt; ImportSpecList a
fmap :: forall a b. (a -&gt; b) -&gt; ImportSpecList a -&gt; ImportSpecList b
$cfmap :: forall a b. (a -&gt; b) -&gt; ImportSpecList a -&gt; ImportSpecList b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (ImportSpecList l) x -&gt; ImportSpecList l
forall l x. ImportSpecList l -&gt; Rep (ImportSpecList l) x
$cto :: forall l x. Rep (ImportSpecList l) x -&gt; ImportSpecList l
$cfrom :: forall l x. ImportSpecList l -&gt; Rep (ImportSpecList l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-248"></span><span>
</span><span id="line-249"></span><span class="hs-comment">-- | An import specification, representing a single explicit item imported</span><span>
</span><span id="line-250"></span><span class="hs-comment">--   (or hidden) from a module.</span><span>
</span><span id="line-251"></span><span id="local-6989586621679441370"><span id="local-6989586621679441371"></span></span><span class="hs-keyword">data</span><span> </span><span id="ImportSpec"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportSpec"><span class="hs-identifier hs-var">ImportSpec</span></a></span></span><span> </span><span id="local-6989586621679452762"><span class="annot"><a href="#local-6989586621679452762"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-252"></span><span>     </span><span class="hs-glyph">=</span><span> </span><span id="IVar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IVar"><span class="hs-identifier hs-var">IVar</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452762"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452762"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                  </span><span class="hs-comment">-- ^ variable</span><span>
</span><span id="line-253"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="IAbs"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IAbs"><span class="hs-identifier hs-var">IAbs</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452762"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Namespace"><span class="hs-identifier hs-type">Namespace</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452762"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452762"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ @T@:</span><span>
</span><span id="line-254"></span><span>                                        </span><span class="hs-comment">--   the name of a class, datatype or type synonym.</span><span>
</span><span id="line-255"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="IThingAll"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IThingAll"><span class="hs-identifier hs-var">IThingAll</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452762"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452762"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- ^ @T(..)@:</span><span>
</span><span id="line-256"></span><span>                                        </span><span class="hs-comment">--   a class imported with all of its methods, or</span><span>
</span><span id="line-257"></span><span>                                        </span><span class="hs-comment">--   a datatype imported with all of its constructors.</span><span>
</span><span id="line-258"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="IThingWith"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IThingWith"><span class="hs-identifier hs-var">IThingWith</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452762"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452762"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CName"><span class="hs-identifier hs-type">CName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452762"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- ^ @T(C_1,...,C_n)@:</span><span>
</span><span id="line-259"></span><span>                                        </span><span class="hs-comment">--   a class imported with some of its methods, or</span><span>
</span><span id="line-260"></span><span>                                        </span><span class="hs-comment">--   a datatype imported with some of its constructors.</span><span>
</span><span id="line-261"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679441351"><span id="local-6989586621679441364"><span class="annot"><span class="annottext">ImportSpec l -&gt; ImportSpec l -&gt; Bool
forall l. Eq l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ImportSpec l -&gt; ImportSpec l -&gt; Bool
$c/= :: forall l. Eq l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; Bool
== :: ImportSpec l -&gt; ImportSpec l -&gt; Bool
$c== :: forall l. Eq l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441324"><span id="local-6989586621679441326"><span id="local-6989586621679441328"><span id="local-6989586621679441330"><span id="local-6989586621679441332"><span id="local-6989586621679441334"><span id="local-6989586621679441347"><span class="annot"><span class="annottext">ImportSpec l -&gt; ImportSpec l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (ImportSpec l)
forall l. Ord l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; Bool
forall l. Ord l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; Ordering
forall l. Ord l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; ImportSpec l
min :: ImportSpec l -&gt; ImportSpec l -&gt; ImportSpec l
$cmin :: forall l. Ord l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; ImportSpec l
max :: ImportSpec l -&gt; ImportSpec l -&gt; ImportSpec l
$cmax :: forall l. Ord l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; ImportSpec l
&gt;= :: ImportSpec l -&gt; ImportSpec l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; Bool
&gt; :: ImportSpec l -&gt; ImportSpec l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; Bool
&lt;= :: ImportSpec l -&gt; ImportSpec l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; Bool
&lt; :: ImportSpec l -&gt; ImportSpec l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; Bool
compare :: ImportSpec l -&gt; ImportSpec l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; ImportSpec l -&gt; ImportSpec l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441303"><span id="local-6989586621679441305"><span id="local-6989586621679441322"><span class="annot"><span class="annottext">Int -&gt; ImportSpec l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; ImportSpec l -&gt; ShowS
forall l. Show l =&gt; [ImportSpec l] -&gt; ShowS
forall l. Show l =&gt; ImportSpec l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ImportSpec l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [ImportSpec l] -&gt; ShowS
show :: ImportSpec l -&gt; String
$cshow :: forall l. Show l =&gt; ImportSpec l -&gt; String
showsPrec :: Int -&gt; ImportSpec l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; ImportSpec l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679441246"><span id="local-6989586621679441248"><span id="local-6989586621679441250"><span id="local-6989586621679441252"><span id="local-6989586621679441254"><span id="local-6989586621679441256"><span id="local-6989586621679441258"><span id="local-6989586621679441260"><span id="local-6989586621679441262"><span id="local-6989586621679441268"><span id="local-6989586621679441270"><span id="local-6989586621679441272"><span id="local-6989586621679441285"><span id="local-6989586621679441298"><span class="annot"><span class="annottext">ImportSpec l -&gt; DataType
ImportSpec l -&gt; Constr
forall {l}. Data l =&gt; Typeable (ImportSpec l)
forall l. Data l =&gt; ImportSpec l -&gt; DataType
forall l. Data l =&gt; ImportSpec l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ImportSpec l -&gt; ImportSpec l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpec l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpec l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpec l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpec l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportSpec l -&gt; m (ImportSpec l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportSpec l -&gt; m (ImportSpec l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportSpec l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportSpec l -&gt; c (ImportSpec l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportSpec l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ImportSpec l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportSpec l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportSpec l -&gt; c (ImportSpec l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportSpec l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportSpec l -&gt; m (ImportSpec l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportSpec l -&gt; m (ImportSpec l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportSpec l -&gt; m (ImportSpec l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportSpec l -&gt; m (ImportSpec l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportSpec l -&gt; m (ImportSpec l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ImportSpec l -&gt; m (ImportSpec l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpec l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpec l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpec l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ImportSpec l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpec l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpec l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpec l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ImportSpec l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ImportSpec l -&gt; ImportSpec l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ImportSpec l -&gt; ImportSpec l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ImportSpec l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ImportSpec l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportSpec l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ImportSpec l))
dataTypeOf :: ImportSpec l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; ImportSpec l -&gt; DataType
toConstr :: ImportSpec l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; ImportSpec l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportSpec l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ImportSpec l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportSpec l -&gt; c (ImportSpec l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ImportSpec l -&gt; c (ImportSpec l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441184"><span id="local-6989586621679441186"><span id="local-6989586621679441188"><span id="local-6989586621679441190"><span id="local-6989586621679441192"><span id="local-6989586621679441194"><span id="local-6989586621679441196"><span id="local-6989586621679441198"><span id="local-6989586621679441200"><span id="local-6989586621679441202"><span id="local-6989586621679441204"><span id="local-6989586621679441206"><span id="local-6989586621679441208"><span id="local-6989586621679441217"><span id="local-6989586621679441219"><span id="local-6989586621679441242"><span id="local-6989586621679441244"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; ImportSpec a -&gt; Bool
forall a. Num a =&gt; ImportSpec a -&gt; a
forall a. Ord a =&gt; ImportSpec a -&gt; a
forall m. Monoid m =&gt; ImportSpec m -&gt; m
forall a. ImportSpec a -&gt; Bool
forall a. ImportSpec a -&gt; Int
forall a. ImportSpec a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; ImportSpec a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportSpec a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportSpec a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportSpec a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; ImportSpec a -&gt; a
$cproduct :: forall a. Num a =&gt; ImportSpec a -&gt; a
sum :: forall a. Num a =&gt; ImportSpec a -&gt; a
$csum :: forall a. Num a =&gt; ImportSpec a -&gt; a
minimum :: forall a. Ord a =&gt; ImportSpec a -&gt; a
$cminimum :: forall a. Ord a =&gt; ImportSpec a -&gt; a
maximum :: forall a. Ord a =&gt; ImportSpec a -&gt; a
$cmaximum :: forall a. Ord a =&gt; ImportSpec a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; ImportSpec a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; ImportSpec a -&gt; Bool
length :: forall a. ImportSpec a -&gt; Int
$clength :: forall a. ImportSpec a -&gt; Int
null :: forall a. ImportSpec a -&gt; Bool
$cnull :: forall a. ImportSpec a -&gt; Bool
toList :: forall a. ImportSpec a -&gt; [a]
$ctoList :: forall a. ImportSpec a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportSpec a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportSpec a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportSpec a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ImportSpec a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportSpec a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportSpec a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportSpec a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ImportSpec a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportSpec a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportSpec a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportSpec a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ImportSpec a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportSpec a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportSpec a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportSpec a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ImportSpec a -&gt; m
fold :: forall m. Monoid m =&gt; ImportSpec m -&gt; m
$cfold :: forall m. Monoid m =&gt; ImportSpec m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441151"><span id="local-6989586621679441153"><span id="local-6989586621679441155"><span id="local-6989586621679441178"><span class="annot"><span class="annottext">Functor ImportSpec
Foldable ImportSpec
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
ImportSpec (m a) -&gt; m (ImportSpec a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
ImportSpec (f a) -&gt; f (ImportSpec a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ImportSpec a -&gt; m (ImportSpec b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ImportSpec a -&gt; f (ImportSpec b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ImportSpec (m a) -&gt; m (ImportSpec a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ImportSpec (m a) -&gt; m (ImportSpec a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ImportSpec a -&gt; m (ImportSpec b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ImportSpec a -&gt; m (ImportSpec b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ImportSpec (f a) -&gt; f (ImportSpec a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ImportSpec (f a) -&gt; f (ImportSpec a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ImportSpec a -&gt; f (ImportSpec b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ImportSpec a -&gt; f (ImportSpec b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441140"><span id="local-6989586621679441149"><span class="annot"><span class="annottext">forall a b. a -&gt; ImportSpec b -&gt; ImportSpec a
forall a b. (a -&gt; b) -&gt; ImportSpec a -&gt; ImportSpec b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; ImportSpec b -&gt; ImportSpec a
$c&lt;$ :: forall a b. a -&gt; ImportSpec b -&gt; ImportSpec a
fmap :: forall a b. (a -&gt; b) -&gt; ImportSpec a -&gt; ImportSpec b
$cfmap :: forall a b. (a -&gt; b) -&gt; ImportSpec a -&gt; ImportSpec b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (ImportSpec l) x -&gt; ImportSpec l
forall l x. ImportSpec l -&gt; Rep (ImportSpec l) x
$cto :: forall l x. Rep (ImportSpec l) x -&gt; ImportSpec l
$cfrom :: forall l x. ImportSpec l -&gt; Rep (ImportSpec l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-262"></span><span>
</span><span id="line-263"></span><span class="hs-comment">-- | Associativity of an operator.</span><span>
</span><span id="line-264"></span><span id="local-6989586621679441128"><span id="local-6989586621679441129"></span></span><span class="hs-keyword">data</span><span> </span><span id="Assoc"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Assoc"><span class="hs-identifier hs-var">Assoc</span></a></span></span><span> </span><span id="local-6989586621679452753"><span class="annot"><a href="#local-6989586621679452753"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-265"></span><span>     </span><span class="hs-glyph">=</span><span> </span><span id="AssocNone"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AssocNone"><span class="hs-identifier hs-var">AssocNone</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452753"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-comment">-- ^ non-associative operator (declared with @infix@)</span><span>
</span><span id="line-266"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="AssocLeft"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AssocLeft"><span class="hs-identifier hs-var">AssocLeft</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452753"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-comment">-- ^ left-associative operator (declared with @infixl@).</span><span>
</span><span id="line-267"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="AssocRight"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AssocRight"><span class="hs-identifier hs-var">AssocRight</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452753"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-comment">-- ^ right-associative operator (declared with @infixr@)</span><span>
</span><span id="line-268"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679441118"><span id="local-6989586621679441123"><span class="annot"><span class="annottext">Assoc l -&gt; Assoc l -&gt; Bool
forall l. Eq l =&gt; Assoc l -&gt; Assoc l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Assoc l -&gt; Assoc l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Assoc l -&gt; Assoc l -&gt; Bool
== :: Assoc l -&gt; Assoc l -&gt; Bool
$c== :: forall l. Eq l =&gt; Assoc l -&gt; Assoc l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441093"><span id="local-6989586621679441095"><span id="local-6989586621679441098"><span id="local-6989586621679441101"><span id="local-6989586621679441104"><span id="local-6989586621679441109"><span id="local-6989586621679441114"><span class="annot"><span class="annottext">Assoc l -&gt; Assoc l -&gt; Bool
Assoc l -&gt; Assoc l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Assoc l)
forall l. Ord l =&gt; Assoc l -&gt; Assoc l -&gt; Bool
forall l. Ord l =&gt; Assoc l -&gt; Assoc l -&gt; Ordering
forall l. Ord l =&gt; Assoc l -&gt; Assoc l -&gt; Assoc l
min :: Assoc l -&gt; Assoc l -&gt; Assoc l
$cmin :: forall l. Ord l =&gt; Assoc l -&gt; Assoc l -&gt; Assoc l
max :: Assoc l -&gt; Assoc l -&gt; Assoc l
$cmax :: forall l. Ord l =&gt; Assoc l -&gt; Assoc l -&gt; Assoc l
&gt;= :: Assoc l -&gt; Assoc l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Assoc l -&gt; Assoc l -&gt; Bool
&gt; :: Assoc l -&gt; Assoc l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Assoc l -&gt; Assoc l -&gt; Bool
&lt;= :: Assoc l -&gt; Assoc l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Assoc l -&gt; Assoc l -&gt; Bool
&lt; :: Assoc l -&gt; Assoc l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Assoc l -&gt; Assoc l -&gt; Bool
compare :: Assoc l -&gt; Assoc l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Assoc l -&gt; Assoc l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441081"><span id="local-6989586621679441083"><span id="local-6989586621679441091"><span class="annot"><span class="annottext">Int -&gt; Assoc l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Assoc l -&gt; ShowS
forall l. Show l =&gt; [Assoc l] -&gt; ShowS
forall l. Show l =&gt; Assoc l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Assoc l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Assoc l] -&gt; ShowS
show :: Assoc l -&gt; String
$cshow :: forall l. Show l =&gt; Assoc l -&gt; String
showsPrec :: Int -&gt; Assoc l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Assoc l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679441040"><span id="local-6989586621679441042"><span id="local-6989586621679441044"><span id="local-6989586621679441046"><span id="local-6989586621679441048"><span id="local-6989586621679441050"><span id="local-6989586621679441052"><span id="local-6989586621679441054"><span id="local-6989586621679441056"><span id="local-6989586621679441062"><span id="local-6989586621679441064"><span id="local-6989586621679441066"><span id="local-6989586621679441071"><span id="local-6989586621679441076"><span class="annot"><span class="annottext">Assoc l -&gt; DataType
Assoc l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Assoc l)
forall l. Data l =&gt; Assoc l -&gt; DataType
forall l. Data l =&gt; Assoc l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Assoc l -&gt; Assoc l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Assoc l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Assoc l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Assoc l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Assoc l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Assoc l -&gt; m (Assoc l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Assoc l -&gt; m (Assoc l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Assoc l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Assoc l -&gt; c (Assoc l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Assoc l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Assoc l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Assoc l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Assoc l -&gt; c (Assoc l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Assoc l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Assoc l -&gt; m (Assoc l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Assoc l -&gt; m (Assoc l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Assoc l -&gt; m (Assoc l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Assoc l -&gt; m (Assoc l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Assoc l -&gt; m (Assoc l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Assoc l -&gt; m (Assoc l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Assoc l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Assoc l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Assoc l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Assoc l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Assoc l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Assoc l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Assoc l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Assoc l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Assoc l -&gt; Assoc l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Assoc l -&gt; Assoc l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Assoc l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Assoc l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Assoc l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Assoc l))
dataTypeOf :: Assoc l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Assoc l -&gt; DataType
toConstr :: Assoc l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Assoc l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Assoc l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Assoc l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Assoc l -&gt; c (Assoc l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Assoc l -&gt; c (Assoc l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679441005"><span id="local-6989586621679441007"><span id="local-6989586621679441009"><span id="local-6989586621679441011"><span id="local-6989586621679441013"><span id="local-6989586621679441015"><span id="local-6989586621679441017"><span id="local-6989586621679441019"><span id="local-6989586621679441021"><span id="local-6989586621679441023"><span id="local-6989586621679441025"><span id="local-6989586621679441027"><span id="local-6989586621679441029"><span id="local-6989586621679441031"><span id="local-6989586621679441033"><span id="local-6989586621679441036"><span id="local-6989586621679441038"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Assoc a -&gt; Bool
forall a. Num a =&gt; Assoc a -&gt; a
forall a. Ord a =&gt; Assoc a -&gt; a
forall m. Monoid m =&gt; Assoc m -&gt; m
forall a. Assoc a -&gt; Bool
forall a. Assoc a -&gt; Int
forall a. Assoc a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Assoc a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Assoc a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Assoc a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Assoc a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Assoc a -&gt; a
$cproduct :: forall a. Num a =&gt; Assoc a -&gt; a
sum :: forall a. Num a =&gt; Assoc a -&gt; a
$csum :: forall a. Num a =&gt; Assoc a -&gt; a
minimum :: forall a. Ord a =&gt; Assoc a -&gt; a
$cminimum :: forall a. Ord a =&gt; Assoc a -&gt; a
maximum :: forall a. Ord a =&gt; Assoc a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Assoc a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Assoc a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Assoc a -&gt; Bool
length :: forall a. Assoc a -&gt; Int
$clength :: forall a. Assoc a -&gt; Int
null :: forall a. Assoc a -&gt; Bool
$cnull :: forall a. Assoc a -&gt; Bool
toList :: forall a. Assoc a -&gt; [a]
$ctoList :: forall a. Assoc a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Assoc a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Assoc a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Assoc a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Assoc a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Assoc a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Assoc a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Assoc a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Assoc a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Assoc a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Assoc a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Assoc a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Assoc a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Assoc a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Assoc a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Assoc a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Assoc a -&gt; m
fold :: forall m. Monoid m =&gt; Assoc m -&gt; m
$cfold :: forall m. Monoid m =&gt; Assoc m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679440987"><span id="local-6989586621679440989"><span id="local-6989586621679440991"><span id="local-6989586621679440998"><span class="annot"><span class="annottext">Functor Assoc
Foldable Assoc
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Assoc (m a) -&gt; m (Assoc a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Assoc (f a) -&gt; f (Assoc a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Assoc a -&gt; m (Assoc b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Assoc a -&gt; f (Assoc b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Assoc (m a) -&gt; m (Assoc a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Assoc (m a) -&gt; m (Assoc a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Assoc a -&gt; m (Assoc b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Assoc a -&gt; m (Assoc b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Assoc (f a) -&gt; f (Assoc a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Assoc (f a) -&gt; f (Assoc a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Assoc a -&gt; f (Assoc b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Assoc a -&gt; f (Assoc b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679440983"><span id="local-6989586621679440985"><span class="annot"><span class="annottext">forall a b. a -&gt; Assoc b -&gt; Assoc a
forall a b. (a -&gt; b) -&gt; Assoc a -&gt; Assoc b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Assoc b -&gt; Assoc a
$c&lt;$ :: forall a b. a -&gt; Assoc b -&gt; Assoc a
fmap :: forall a b. (a -&gt; b) -&gt; Assoc a -&gt; Assoc b
$cfmap :: forall a b. (a -&gt; b) -&gt; Assoc a -&gt; Assoc b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Assoc l) x -&gt; Assoc l
forall l x. Assoc l -&gt; Rep (Assoc l) x
$cto :: forall l x. Rep (Assoc l) x -&gt; Assoc l
$cfrom :: forall l x. Assoc l -&gt; Rep (Assoc l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-269"></span><span>
</span><span id="line-270"></span><span class="hs-comment">-- | A top-level declaration.</span><span>
</span><span id="line-271"></span><span id="local-6989586621679440978"><span id="local-6989586621679440979"></span></span><span class="hs-keyword">data</span><span> </span><span id="Decl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-var">Decl</span></a></span></span><span> </span><span id="local-6989586621679452812"><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-272"></span><span>     </span><span class="hs-glyph">=</span><span> </span><span id="TypeDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeDecl"><span class="hs-identifier hs-var">TypeDecl</span></a></span></span><span>     </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-273"></span><span>     </span><span class="hs-comment">-- ^ A type declaration</span><span>
</span><span id="line-274"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TypeFamDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeFamDecl"><span class="hs-identifier hs-var">TypeFamDecl</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ResultSig"><span class="hs-identifier hs-type">ResultSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InjectivityInfo"><span class="hs-identifier hs-type">InjectivityInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-275"></span><span>     </span><span class="hs-comment">-- ^ A type family declaration</span><span>
</span><span id="line-276"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="ClosedTypeFamDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClosedTypeFamDecl"><span class="hs-identifier hs-var">ClosedTypeFamDecl</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ResultSig"><span class="hs-identifier hs-type">ResultSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InjectivityInfo"><span class="hs-identifier hs-type">InjectivityInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeEqn"><span class="hs-identifier hs-type">TypeEqn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-277"></span><span>     </span><span class="hs-comment">-- ^ A closed type family declaration</span><span>
</span><span id="line-278"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="DataDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataDecl"><span class="hs-identifier hs-var">DataDecl</span></a></span></span><span>     </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataOrNew"><span class="hs-identifier hs-type">DataOrNew</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                  </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualConDecl"><span class="hs-identifier hs-type">QualConDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-type">Deriving</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-279"></span><span>     </span><span class="hs-comment">-- ^ A data OR newtype declaration</span><span>
</span><span id="line-280"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="GDataDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GDataDecl"><span class="hs-identifier hs-var">GDataDecl</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataOrNew"><span class="hs-identifier hs-type">DataOrNew</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GadtDecl"><span class="hs-identifier hs-type">GadtDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-type">Deriving</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-281"></span><span>     </span><span class="hs-comment">-- ^ A data OR newtype declaration, GADT style</span><span>
</span><span id="line-282"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="DataFamDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataFamDecl"><span class="hs-identifier hs-var">DataFamDecl</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-comment">{-data-}</span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ResultSig"><span class="hs-identifier hs-type">ResultSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-283"></span><span>     </span><span class="hs-comment">-- ^ A data family declaration</span><span>
</span><span id="line-284"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TypeInsDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeInsDecl"><span class="hs-identifier hs-var">TypeInsDecl</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-285"></span><span>     </span><span class="hs-comment">-- ^ A type family instance declaration</span><span>
</span><span id="line-286"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="DataInsDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataInsDecl"><span class="hs-identifier hs-var">DataInsDecl</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataOrNew"><span class="hs-identifier hs-type">DataOrNew</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                  </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualConDecl"><span class="hs-identifier hs-type">QualConDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-type">Deriving</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-287"></span><span>     </span><span class="hs-comment">-- ^ A data family instance declaration</span><span>
</span><span id="line-288"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="GDataInsDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GDataInsDecl"><span class="hs-identifier hs-var">GDataInsDecl</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataOrNew"><span class="hs-identifier hs-type">DataOrNew</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GadtDecl"><span class="hs-identifier hs-type">GadtDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>    </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-type">Deriving</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-289"></span><span>     </span><span class="hs-comment">-- ^ A data family instance declaration, GADT style</span><span>
</span><span id="line-290"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="ClassDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClassDecl"><span class="hs-identifier hs-var">ClassDecl</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunDep"><span class="hs-identifier hs-type">FunDep</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClassDecl"><span class="hs-identifier hs-type">ClassDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-291"></span><span>     </span><span class="hs-comment">-- ^ A declaration of a type class</span><span>
</span><span id="line-292"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="InstDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstDecl"><span class="hs-identifier hs-var">InstDecl</span></a></span></span><span>     </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlap"><span class="hs-identifier hs-type">Overlap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstRule"><span class="hs-identifier hs-type">InstRule</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstDecl"><span class="hs-identifier hs-type">InstDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-293"></span><span>     </span><span class="hs-comment">-- ^ An declaration of a type class instance</span><span>
</span><span id="line-294"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="DerivDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivDecl"><span class="hs-identifier hs-var">DerivDecl</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivStrategy"><span class="hs-identifier hs-type">DerivStrategy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlap"><span class="hs-identifier hs-type">Overlap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstRule"><span class="hs-identifier hs-type">InstRule</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-295"></span><span>     </span><span class="hs-comment">-- ^ A standalone deriving declaration</span><span>
</span><span id="line-296"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="InfixDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixDecl"><span class="hs-identifier hs-var">InfixDecl</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Assoc"><span class="hs-identifier hs-type">Assoc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Op"><span class="hs-identifier hs-type">Op</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-297"></span><span>     </span><span class="hs-comment">-- ^ A declaration of operator fixity</span><span>
</span><span id="line-298"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="DefaultDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DefaultDecl"><span class="hs-identifier hs-var">DefaultDecl</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-299"></span><span>     </span><span class="hs-comment">-- ^ A declaration of default types</span><span>
</span><span id="line-300"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="SpliceDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpliceDecl"><span class="hs-identifier hs-var">SpliceDecl</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-301"></span><span>     </span><span class="hs-comment">-- ^ A Template Haskell splicing declaration</span><span>
</span><span id="line-302"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TSpliceDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TSpliceDecl"><span class="hs-identifier hs-var">TSpliceDecl</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-303"></span><span>     </span><span class="hs-comment">-- ^ A typed Template Haskell splicing declaration</span><span>
</span><span id="line-304"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TypeSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeSig"><span class="hs-identifier hs-var">TypeSig</span></a></span></span><span>      </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-305"></span><span>     </span><span class="hs-comment">-- ^ A type signature declaration</span><span>
</span><span id="line-306"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="PatSynSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatSynSig"><span class="hs-identifier hs-var">PatSynSig</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier hs-type">TyVarBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-307"></span><span>                               </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier hs-type">TyVarBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-308"></span><span>                                                     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-309"></span><span>     </span><span class="hs-comment">-- ^ A pattern synonym signature declation</span><span>
</span><span id="line-310"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="FunBind"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunBind"><span class="hs-identifier hs-var">FunBind</span></a></span></span><span>      </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-311"></span><span>     </span><span class="hs-comment">-- ^ A set of function binding clauses</span><span>
</span><span id="line-312"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="PatBind"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatBind"><span class="hs-identifier hs-var">PatBind</span></a></span></span><span>      </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rhs"><span class="hs-identifier hs-type">Rhs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">{-where-}</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Binds"><span class="hs-identifier hs-type">Binds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-313"></span><span>     </span><span class="hs-comment">-- ^ A pattern binding</span><span>
</span><span id="line-314"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="PatSyn"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatSyn"><span class="hs-identifier hs-var">PatSyn</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatternSynDirection"><span class="hs-identifier hs-type">PatternSynDirection</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-315"></span><span>     </span><span class="hs-comment">-- ^ A pattern synonym binding</span><span>
</span><span id="line-316"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="ForImp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ForImp"><span class="hs-identifier hs-var">ForImp</span></a></span></span><span>       </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CallConv"><span class="hs-identifier hs-type">CallConv</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Safety"><span class="hs-identifier hs-type">Safety</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-317"></span><span>     </span><span class="hs-comment">-- ^ A foreign import declaration</span><span>
</span><span id="line-318"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="ForExp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ForExp"><span class="hs-identifier hs-var">ForExp</span></a></span></span><span>       </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CallConv"><span class="hs-identifier hs-type">CallConv</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                    </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-319"></span><span>     </span><span class="hs-comment">-- ^ A foreign export declaration</span><span>
</span><span id="line-320"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="RulePragmaDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RulePragmaDecl"><span class="hs-identifier hs-var">RulePragmaDecl</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rule"><span class="hs-identifier hs-type">Rule</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-321"></span><span>     </span><span class="hs-comment">-- ^ A RULES pragma</span><span>
</span><span id="line-322"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="DeprPragmaDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeprPragmaDecl"><span class="hs-identifier hs-var">DeprPragmaDecl</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-323"></span><span>     </span><span class="hs-comment">-- ^ A DEPRECATED pragma</span><span>
</span><span id="line-324"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="WarnPragmaDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#WarnPragmaDecl"><span class="hs-identifier hs-var">WarnPragmaDecl</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-325"></span><span>     </span><span class="hs-comment">-- ^ A WARNING pragma</span><span>
</span><span id="line-326"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="InlineSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InlineSig"><span class="hs-identifier hs-var">InlineSig</span></a></span></span><span>        </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Activation"><span class="hs-identifier hs-type">Activation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-327"></span><span>     </span><span class="hs-comment">-- ^ An INLINE pragma</span><span>
</span><span id="line-328"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="InlineConlikeSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InlineConlikeSig"><span class="hs-identifier hs-var">InlineConlikeSig</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Activation"><span class="hs-identifier hs-type">Activation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-329"></span><span>     </span><span class="hs-comment">-- ^ An INLINE CONLIKE pragma</span><span>
</span><span id="line-330"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="SpecSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpecSig"><span class="hs-identifier hs-var">SpecSig</span></a></span></span><span>          </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Activation"><span class="hs-identifier hs-type">Activation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-331"></span><span>     </span><span class="hs-comment">-- ^ A SPECIALISE pragma</span><span>
</span><span id="line-332"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="SpecInlineSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpecInlineSig"><span class="hs-identifier hs-var">SpecInlineSig</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Activation"><span class="hs-identifier hs-type">Activation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-333"></span><span>     </span><span class="hs-comment">-- ^ A SPECIALISE INLINE pragma</span><span>
</span><span id="line-334"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="InstSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstSig"><span class="hs-identifier hs-var">InstSig</span></a></span></span><span>          </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstRule"><span class="hs-identifier hs-type">InstRule</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-335"></span><span>     </span><span class="hs-comment">-- ^ A SPECIALISE instance pragma</span><span>
</span><span id="line-336"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="AnnPragma"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AnnPragma"><span class="hs-identifier hs-var">AnnPragma</span></a></span></span><span>        </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotation"><span class="hs-identifier hs-type">Annotation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-337"></span><span>     </span><span class="hs-comment">-- ^ An ANN pragma</span><span>
</span><span id="line-338"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="MinimalPragma"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MinimalPragma"><span class="hs-identifier hs-var">MinimalPragma</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BooleanFormula"><span class="hs-identifier hs-type">BooleanFormula</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-339"></span><span>     </span><span class="hs-comment">-- ^ A MINIMAL pragma</span><span>
</span><span id="line-340"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="RoleAnnotDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RoleAnnotDecl"><span class="hs-identifier hs-var">RoleAnnotDecl</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Role"><span class="hs-identifier hs-type">Role</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-341"></span><span>     </span><span class="hs-comment">-- ^ A role annotation</span><span>
</span><span id="line-342"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="CompletePragma"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CompletePragma"><span class="hs-identifier hs-var">CompletePragma</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452812"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-343"></span><span>     </span><span class="hs-comment">-- ^ A COMPLETE pragma</span><span>
</span><span id="line-344"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679440783"><span id="local-6989586621679440941"><span class="annot"><span class="annottext">Decl l -&gt; Decl l -&gt; Bool
forall l. Eq l =&gt; Decl l -&gt; Decl l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Decl l -&gt; Decl l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Decl l -&gt; Decl l -&gt; Bool
== :: Decl l -&gt; Decl l -&gt; Bool
$c== :: forall l. Eq l =&gt; Decl l -&gt; Decl l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679440606"><span id="local-6989586621679440608"><span id="local-6989586621679440610"><span id="local-6989586621679440612"><span id="local-6989586621679440614"><span id="local-6989586621679440616"><span id="local-6989586621679440774"><span class="annot"><span class="annottext">Decl l -&gt; Decl l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Decl l)
forall l. Ord l =&gt; Decl l -&gt; Decl l -&gt; Bool
forall l. Ord l =&gt; Decl l -&gt; Decl l -&gt; Ordering
forall l. Ord l =&gt; Decl l -&gt; Decl l -&gt; Decl l
min :: Decl l -&gt; Decl l -&gt; Decl l
$cmin :: forall l. Ord l =&gt; Decl l -&gt; Decl l -&gt; Decl l
max :: Decl l -&gt; Decl l -&gt; Decl l
$cmax :: forall l. Ord l =&gt; Decl l -&gt; Decl l -&gt; Decl l
&gt;= :: Decl l -&gt; Decl l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Decl l -&gt; Decl l -&gt; Bool
&gt; :: Decl l -&gt; Decl l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Decl l -&gt; Decl l -&gt; Bool
&lt;= :: Decl l -&gt; Decl l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Decl l -&gt; Decl l -&gt; Bool
&lt; :: Decl l -&gt; Decl l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Decl l -&gt; Decl l -&gt; Bool
compare :: Decl l -&gt; Decl l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Decl l -&gt; Decl l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679440404"><span id="local-6989586621679440406"><span id="local-6989586621679440599"><span class="annot"><span class="annottext">Int -&gt; Decl l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Decl l -&gt; ShowS
forall l. Show l =&gt; [Decl l] -&gt; ShowS
forall l. Show l =&gt; Decl l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Decl l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Decl l] -&gt; ShowS
show :: Decl l -&gt; String
$cshow :: forall l. Show l =&gt; Decl l -&gt; String
showsPrec :: Int -&gt; Decl l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Decl l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679440052"><span id="local-6989586621679440054"><span id="local-6989586621679440056"><span id="local-6989586621679440058"><span id="local-6989586621679440060"><span id="local-6989586621679440062"><span id="local-6989586621679440064"><span id="local-6989586621679440066"><span id="local-6989586621679440068"><span id="local-6989586621679440074"><span id="local-6989586621679440076"><span id="local-6989586621679440078"><span id="local-6989586621679440236"><span id="local-6989586621679440394"><span class="annot"><span class="annottext">Decl l -&gt; DataType
Decl l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Decl l)
forall l. Data l =&gt; Decl l -&gt; DataType
forall l. Data l =&gt; Decl l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Decl l -&gt; Decl l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Decl l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Decl l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Decl l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Decl l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Decl l -&gt; m (Decl l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Decl l -&gt; m (Decl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Decl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Decl l -&gt; c (Decl l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Decl l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Decl l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Decl l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Decl l -&gt; c (Decl l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Decl l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Decl l -&gt; m (Decl l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Decl l -&gt; m (Decl l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Decl l -&gt; m (Decl l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Decl l -&gt; m (Decl l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Decl l -&gt; m (Decl l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Decl l -&gt; m (Decl l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Decl l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Decl l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Decl l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Decl l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Decl l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Decl l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Decl l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Decl l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Decl l -&gt; Decl l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Decl l -&gt; Decl l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Decl l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Decl l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Decl l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Decl l))
dataTypeOf :: Decl l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Decl l -&gt; DataType
toConstr :: Decl l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Decl l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Decl l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Decl l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Decl l -&gt; c (Decl l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Decl l -&gt; c (Decl l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679439476"><span id="local-6989586621679439478"><span id="local-6989586621679439480"><span id="local-6989586621679439482"><span id="local-6989586621679439484"><span id="local-6989586621679439486"><span id="local-6989586621679439488"><span id="local-6989586621679439490"><span id="local-6989586621679439492"><span id="local-6989586621679439494"><span id="local-6989586621679439496"><span id="local-6989586621679439498"><span id="local-6989586621679439500"><span id="local-6989586621679439649"><span id="local-6989586621679439651"><span id="local-6989586621679440039"><span id="local-6989586621679440041"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Decl a -&gt; Bool
forall a. Num a =&gt; Decl a -&gt; a
forall a. Ord a =&gt; Decl a -&gt; a
forall m. Monoid m =&gt; Decl m -&gt; m
forall a. Decl a -&gt; Bool
forall a. Decl a -&gt; Int
forall a. Decl a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Decl a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Decl a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Decl a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Decl a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Decl a -&gt; a
$cproduct :: forall a. Num a =&gt; Decl a -&gt; a
sum :: forall a. Num a =&gt; Decl a -&gt; a
$csum :: forall a. Num a =&gt; Decl a -&gt; a
minimum :: forall a. Ord a =&gt; Decl a -&gt; a
$cminimum :: forall a. Ord a =&gt; Decl a -&gt; a
maximum :: forall a. Ord a =&gt; Decl a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Decl a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Decl a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Decl a -&gt; Bool
length :: forall a. Decl a -&gt; Int
$clength :: forall a. Decl a -&gt; Int
null :: forall a. Decl a -&gt; Bool
$cnull :: forall a. Decl a -&gt; Bool
toList :: forall a. Decl a -&gt; [a]
$ctoList :: forall a. Decl a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Decl a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Decl a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Decl a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Decl a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Decl a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Decl a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Decl a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Decl a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Decl a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Decl a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Decl a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Decl a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Decl a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Decl a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Decl a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Decl a -&gt; m
fold :: forall m. Monoid m =&gt; Decl m -&gt; m
$cfold :: forall m. Monoid m =&gt; Decl m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679439075"><span id="local-6989586621679439077"><span id="local-6989586621679439079"><span id="local-6989586621679439470"><span class="annot"><span class="annottext">Functor Decl
Foldable Decl
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Decl (m a) -&gt; m (Decl a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Decl (f a) -&gt; f (Decl a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Decl a -&gt; m (Decl b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Decl a -&gt; f (Decl b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Decl (m a) -&gt; m (Decl a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Decl (m a) -&gt; m (Decl a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Decl a -&gt; m (Decl b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Decl a -&gt; m (Decl b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Decl (f a) -&gt; f (Decl a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Decl (f a) -&gt; f (Decl a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Decl a -&gt; f (Decl b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Decl a -&gt; f (Decl b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438895"><span id="local-6989586621679439073"><span class="annot"><span class="annottext">forall a b. a -&gt; Decl b -&gt; Decl a
forall a b. (a -&gt; b) -&gt; Decl a -&gt; Decl b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Decl b -&gt; Decl a
$c&lt;$ :: forall a b. a -&gt; Decl b -&gt; Decl a
fmap :: forall a b. (a -&gt; b) -&gt; Decl a -&gt; Decl b
$cfmap :: forall a b. (a -&gt; b) -&gt; Decl a -&gt; Decl b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Decl l) x -&gt; Decl l
forall l x. Decl l -&gt; Rep (Decl l) x
$cto :: forall l x. Rep (Decl l) x -&gt; Decl l
$cfrom :: forall l x. Decl l -&gt; Rep (Decl l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-345"></span><span>
</span><span id="line-346"></span><span id="local-6989586621679438743"><span id="local-6989586621679438744"></span></span><span class="hs-keyword">data</span><span>  </span><span id="PatternSynDirection"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatternSynDirection"><span class="hs-identifier hs-var">PatternSynDirection</span></a></span></span><span> </span><span id="local-6989586621679452727"><span class="annot"><a href="#local-6989586621679452727"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-347"></span><span>      </span><span id="Unidirectional"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Unidirectional"><span class="hs-identifier hs-var">Unidirectional</span></a></span></span><span> </span><span class="hs-comment">-- ^ A unidirectional pattern synonym with &quot;&lt;-&quot;</span><span>
</span><span id="line-348"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ImplicitBidirectional"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImplicitBidirectional"><span class="hs-identifier hs-var">ImplicitBidirectional</span></a></span></span><span>  </span><span class="hs-comment">-- ^ A bidirectional pattern synonym with &quot;=&quot;</span><span>
</span><span id="line-349"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ExplicitBidirectional"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExplicitBidirectional"><span class="hs-identifier hs-var">ExplicitBidirectional</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452727"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452727"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- ^ A birectional pattern synonym with the construction specified.</span><span>
</span><span id="line-350"></span><span>    </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679438733"><span id="local-6989586621679438738"><span class="annot"><span class="annottext">PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
forall l.
Eq l =&gt;
PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
$c/= :: forall l.
Eq l =&gt;
PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
== :: PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
$c== :: forall l.
Eq l =&gt;
PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679438708"><span id="local-6989586621679438710"><span id="local-6989586621679438713"><span id="local-6989586621679438716"><span id="local-6989586621679438719"><span id="local-6989586621679438724"><span id="local-6989586621679438729"><span class="annot"><span class="annottext">PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
PatternSynDirection l -&gt; PatternSynDirection l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (PatternSynDirection l)
forall l.
Ord l =&gt;
PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
forall l.
Ord l =&gt;
PatternSynDirection l -&gt; PatternSynDirection l -&gt; Ordering
forall l.
Ord l =&gt;
PatternSynDirection l
-&gt; PatternSynDirection l -&gt; PatternSynDirection l
min :: PatternSynDirection l
-&gt; PatternSynDirection l -&gt; PatternSynDirection l
$cmin :: forall l.
Ord l =&gt;
PatternSynDirection l
-&gt; PatternSynDirection l -&gt; PatternSynDirection l
max :: PatternSynDirection l
-&gt; PatternSynDirection l -&gt; PatternSynDirection l
$cmax :: forall l.
Ord l =&gt;
PatternSynDirection l
-&gt; PatternSynDirection l -&gt; PatternSynDirection l
&gt;= :: PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
$c&gt;= :: forall l.
Ord l =&gt;
PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
&gt; :: PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
$c&gt; :: forall l.
Ord l =&gt;
PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
&lt;= :: PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
$c&lt;= :: forall l.
Ord l =&gt;
PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
&lt; :: PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
$c&lt; :: forall l.
Ord l =&gt;
PatternSynDirection l -&gt; PatternSynDirection l -&gt; Bool
compare :: PatternSynDirection l -&gt; PatternSynDirection l -&gt; Ordering
$ccompare :: forall l.
Ord l =&gt;
PatternSynDirection l -&gt; PatternSynDirection l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679438698"><span id="local-6989586621679438700"><span id="local-6989586621679438706"><span class="annot"><span class="annottext">Int -&gt; PatternSynDirection l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; PatternSynDirection l -&gt; ShowS
forall l. Show l =&gt; [PatternSynDirection l] -&gt; ShowS
forall l. Show l =&gt; PatternSynDirection l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [PatternSynDirection l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [PatternSynDirection l] -&gt; ShowS
show :: PatternSynDirection l -&gt; String
$cshow :: forall l. Show l =&gt; PatternSynDirection l -&gt; String
showsPrec :: Int -&gt; PatternSynDirection l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; PatternSynDirection l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679438657"><span id="local-6989586621679438659"><span id="local-6989586621679438661"><span id="local-6989586621679438663"><span id="local-6989586621679438665"><span id="local-6989586621679438667"><span id="local-6989586621679438669"><span id="local-6989586621679438671"><span id="local-6989586621679438673"><span id="local-6989586621679438679"><span id="local-6989586621679438681"><span id="local-6989586621679438683"><span id="local-6989586621679438688"><span id="local-6989586621679438693"><span class="annot"><span class="annottext">PatternSynDirection l -&gt; DataType
PatternSynDirection l -&gt; Constr
forall {l}. Data l =&gt; Typeable (PatternSynDirection l)
forall l. Data l =&gt; PatternSynDirection l -&gt; DataType
forall l. Data l =&gt; PatternSynDirection l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; PatternSynDirection l -&gt; PatternSynDirection l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatternSynDirection l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; PatternSynDirection l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatternSynDirection l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatternSynDirection l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PatternSynDirection l -&gt; m (PatternSynDirection l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PatternSynDirection l -&gt; m (PatternSynDirection l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PatternSynDirection l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; PatternSynDirection l
-&gt; c (PatternSynDirection l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PatternSynDirection l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (PatternSynDirection l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PatternSynDirection l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; PatternSynDirection l
-&gt; c (PatternSynDirection l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PatternSynDirection l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PatternSynDirection l -&gt; m (PatternSynDirection l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PatternSynDirection l -&gt; m (PatternSynDirection l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PatternSynDirection l -&gt; m (PatternSynDirection l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PatternSynDirection l -&gt; m (PatternSynDirection l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PatternSynDirection l -&gt; m (PatternSynDirection l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; PatternSynDirection l -&gt; m (PatternSynDirection l)
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatternSynDirection l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatternSynDirection l -&gt; u
gmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; PatternSynDirection l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; PatternSynDirection l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatternSynDirection l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatternSynDirection l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatternSynDirection l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatternSynDirection l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; PatternSynDirection l -&gt; PatternSynDirection l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; PatternSynDirection l -&gt; PatternSynDirection l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (PatternSynDirection l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (PatternSynDirection l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PatternSynDirection l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PatternSynDirection l))
dataTypeOf :: PatternSynDirection l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; PatternSynDirection l -&gt; DataType
toConstr :: PatternSynDirection l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; PatternSynDirection l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PatternSynDirection l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PatternSynDirection l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; PatternSynDirection l
-&gt; c (PatternSynDirection l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; PatternSynDirection l
-&gt; c (PatternSynDirection l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679438613"><span id="local-6989586621679438615"><span id="local-6989586621679438617"><span id="local-6989586621679438619"><span id="local-6989586621679438621"><span id="local-6989586621679438623"><span id="local-6989586621679438625"><span id="local-6989586621679438627"><span id="local-6989586621679438629"><span id="local-6989586621679438631"><span id="local-6989586621679438633"><span id="local-6989586621679438635"><span id="local-6989586621679438637"><span id="local-6989586621679438641"><span id="local-6989586621679438643"><span id="local-6989586621679438653"><span id="local-6989586621679438655"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; PatternSynDirection a -&gt; Bool
forall a. Num a =&gt; PatternSynDirection a -&gt; a
forall a. Ord a =&gt; PatternSynDirection a -&gt; a
forall m. Monoid m =&gt; PatternSynDirection m -&gt; m
forall a. PatternSynDirection a -&gt; Bool
forall a. PatternSynDirection a -&gt; Int
forall a. PatternSynDirection a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; PatternSynDirection a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PatternSynDirection a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PatternSynDirection a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PatternSynDirection a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; PatternSynDirection a -&gt; a
$cproduct :: forall a. Num a =&gt; PatternSynDirection a -&gt; a
sum :: forall a. Num a =&gt; PatternSynDirection a -&gt; a
$csum :: forall a. Num a =&gt; PatternSynDirection a -&gt; a
minimum :: forall a. Ord a =&gt; PatternSynDirection a -&gt; a
$cminimum :: forall a. Ord a =&gt; PatternSynDirection a -&gt; a
maximum :: forall a. Ord a =&gt; PatternSynDirection a -&gt; a
$cmaximum :: forall a. Ord a =&gt; PatternSynDirection a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; PatternSynDirection a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; PatternSynDirection a -&gt; Bool
length :: forall a. PatternSynDirection a -&gt; Int
$clength :: forall a. PatternSynDirection a -&gt; Int
null :: forall a. PatternSynDirection a -&gt; Bool
$cnull :: forall a. PatternSynDirection a -&gt; Bool
toList :: forall a. PatternSynDirection a -&gt; [a]
$ctoList :: forall a. PatternSynDirection a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; PatternSynDirection a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; PatternSynDirection a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; PatternSynDirection a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; PatternSynDirection a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PatternSynDirection a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PatternSynDirection a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PatternSynDirection a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PatternSynDirection a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PatternSynDirection a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PatternSynDirection a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PatternSynDirection a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PatternSynDirection a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PatternSynDirection a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PatternSynDirection a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PatternSynDirection a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PatternSynDirection a -&gt; m
fold :: forall m. Monoid m =&gt; PatternSynDirection m -&gt; m
$cfold :: forall m. Monoid m =&gt; PatternSynDirection m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679438593"><span id="local-6989586621679438595"><span id="local-6989586621679438597"><span id="local-6989586621679438607"><span class="annot"><span class="annottext">Functor PatternSynDirection
Foldable PatternSynDirection
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
PatternSynDirection (m a) -&gt; m (PatternSynDirection a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
PatternSynDirection (f a) -&gt; f (PatternSynDirection a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PatternSynDirection a -&gt; m (PatternSynDirection b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PatternSynDirection a -&gt; f (PatternSynDirection b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
PatternSynDirection (m a) -&gt; m (PatternSynDirection a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
PatternSynDirection (m a) -&gt; m (PatternSynDirection a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PatternSynDirection a -&gt; m (PatternSynDirection b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PatternSynDirection a -&gt; m (PatternSynDirection b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
PatternSynDirection (f a) -&gt; f (PatternSynDirection a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
PatternSynDirection (f a) -&gt; f (PatternSynDirection a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PatternSynDirection a -&gt; f (PatternSynDirection b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PatternSynDirection a -&gt; f (PatternSynDirection b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679438587"><span id="local-6989586621679438591"><span class="annot"><span class="annottext">forall a b. a -&gt; PatternSynDirection b -&gt; PatternSynDirection a
forall a b.
(a -&gt; b) -&gt; PatternSynDirection a -&gt; PatternSynDirection b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; PatternSynDirection b -&gt; PatternSynDirection a
$c&lt;$ :: forall a b. a -&gt; PatternSynDirection b -&gt; PatternSynDirection a
fmap :: forall a b.
(a -&gt; b) -&gt; PatternSynDirection a -&gt; PatternSynDirection b
$cfmap :: forall a b.
(a -&gt; b) -&gt; PatternSynDirection a -&gt; PatternSynDirection b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (PatternSynDirection l) x -&gt; PatternSynDirection l
forall l x. PatternSynDirection l -&gt; Rep (PatternSynDirection l) x
$cto :: forall l x. Rep (PatternSynDirection l) x -&gt; PatternSynDirection l
$cfrom :: forall l x. PatternSynDirection l -&gt; Rep (PatternSynDirection l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-351"></span><span>
</span><span id="line-352"></span><span class="hs-comment">-- | A type equation as found in closed type families.</span><span>
</span><span id="line-353"></span><span id="local-6989586621679438580"><span id="local-6989586621679438581"></span></span><span class="hs-keyword">data</span><span> </span><span id="TypeEqn"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeEqn"><span class="hs-identifier hs-var">TypeEqn</span></a></span></span><span> </span><span id="local-6989586621679452731"><span class="annot"><a href="#local-6989586621679452731"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="TypeEqn"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeEqn"><span class="hs-identifier hs-var">TypeEqn</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452731"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452731"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452731"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679438572"><span id="local-6989586621679438577"><span class="annot"><span class="annottext">TypeEqn l -&gt; TypeEqn l -&gt; Bool
forall l. Eq l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: TypeEqn l -&gt; TypeEqn l -&gt; Bool
$c/= :: forall l. Eq l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; Bool
== :: TypeEqn l -&gt; TypeEqn l -&gt; Bool
$c== :: forall l. Eq l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438547"><span id="local-6989586621679438549"><span id="local-6989586621679438552"><span id="local-6989586621679438555"><span id="local-6989586621679438558"><span id="local-6989586621679438563"><span id="local-6989586621679438568"><span class="annot"><span class="annottext">TypeEqn l -&gt; TypeEqn l -&gt; Bool
TypeEqn l -&gt; TypeEqn l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (TypeEqn l)
forall l. Ord l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; Bool
forall l. Ord l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; Ordering
forall l. Ord l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; TypeEqn l
min :: TypeEqn l -&gt; TypeEqn l -&gt; TypeEqn l
$cmin :: forall l. Ord l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; TypeEqn l
max :: TypeEqn l -&gt; TypeEqn l -&gt; TypeEqn l
$cmax :: forall l. Ord l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; TypeEqn l
&gt;= :: TypeEqn l -&gt; TypeEqn l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; Bool
&gt; :: TypeEqn l -&gt; TypeEqn l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; Bool
&lt;= :: TypeEqn l -&gt; TypeEqn l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; Bool
&lt; :: TypeEqn l -&gt; TypeEqn l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; Bool
compare :: TypeEqn l -&gt; TypeEqn l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; TypeEqn l -&gt; TypeEqn l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438537"><span id="local-6989586621679438539"><span id="local-6989586621679438545"><span class="annot"><span class="annottext">Int -&gt; TypeEqn l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; TypeEqn l -&gt; ShowS
forall l. Show l =&gt; [TypeEqn l] -&gt; ShowS
forall l. Show l =&gt; TypeEqn l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [TypeEqn l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [TypeEqn l] -&gt; ShowS
show :: TypeEqn l -&gt; String
$cshow :: forall l. Show l =&gt; TypeEqn l -&gt; String
showsPrec :: Int -&gt; TypeEqn l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; TypeEqn l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679438496"><span id="local-6989586621679438498"><span id="local-6989586621679438500"><span id="local-6989586621679438502"><span id="local-6989586621679438504"><span id="local-6989586621679438506"><span id="local-6989586621679438508"><span id="local-6989586621679438510"><span id="local-6989586621679438512"><span id="local-6989586621679438518"><span id="local-6989586621679438520"><span id="local-6989586621679438522"><span id="local-6989586621679438527"><span id="local-6989586621679438532"><span class="annot"><span class="annottext">TypeEqn l -&gt; DataType
TypeEqn l -&gt; Constr
forall {l}. Data l =&gt; Typeable (TypeEqn l)
forall l. Data l =&gt; TypeEqn l -&gt; DataType
forall l. Data l =&gt; TypeEqn l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; TypeEqn l -&gt; TypeEqn l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TypeEqn l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; TypeEqn l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeEqn l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeEqn l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeEqn l -&gt; m (TypeEqn l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeEqn l -&gt; m (TypeEqn l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TypeEqn l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TypeEqn l -&gt; c (TypeEqn l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TypeEqn l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (TypeEqn l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TypeEqn l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TypeEqn l -&gt; c (TypeEqn l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TypeEqn l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeEqn l -&gt; m (TypeEqn l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeEqn l -&gt; m (TypeEqn l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeEqn l -&gt; m (TypeEqn l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeEqn l -&gt; m (TypeEqn l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeEqn l -&gt; m (TypeEqn l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeEqn l -&gt; m (TypeEqn l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TypeEqn l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TypeEqn l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TypeEqn l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; TypeEqn l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeEqn l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeEqn l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeEqn l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeEqn l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TypeEqn l -&gt; TypeEqn l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; TypeEqn l -&gt; TypeEqn l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (TypeEqn l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (TypeEqn l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TypeEqn l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TypeEqn l))
dataTypeOf :: TypeEqn l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; TypeEqn l -&gt; DataType
toConstr :: TypeEqn l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; TypeEqn l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TypeEqn l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TypeEqn l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TypeEqn l -&gt; c (TypeEqn l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TypeEqn l -&gt; c (TypeEqn l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438453"><span id="local-6989586621679438455"><span id="local-6989586621679438457"><span id="local-6989586621679438459"><span id="local-6989586621679438461"><span id="local-6989586621679438463"><span id="local-6989586621679438465"><span id="local-6989586621679438467"><span id="local-6989586621679438469"><span id="local-6989586621679438471"><span id="local-6989586621679438473"><span id="local-6989586621679438475"><span id="local-6989586621679438477"><span id="local-6989586621679438481"><span id="local-6989586621679438483"><span id="local-6989586621679438492"><span id="local-6989586621679438494"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; TypeEqn a -&gt; Bool
forall a. Num a =&gt; TypeEqn a -&gt; a
forall a. Ord a =&gt; TypeEqn a -&gt; a
forall m. Monoid m =&gt; TypeEqn m -&gt; m
forall a. TypeEqn a -&gt; Bool
forall a. TypeEqn a -&gt; Int
forall a. TypeEqn a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; TypeEqn a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TypeEqn a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TypeEqn a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TypeEqn a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; TypeEqn a -&gt; a
$cproduct :: forall a. Num a =&gt; TypeEqn a -&gt; a
sum :: forall a. Num a =&gt; TypeEqn a -&gt; a
$csum :: forall a. Num a =&gt; TypeEqn a -&gt; a
minimum :: forall a. Ord a =&gt; TypeEqn a -&gt; a
$cminimum :: forall a. Ord a =&gt; TypeEqn a -&gt; a
maximum :: forall a. Ord a =&gt; TypeEqn a -&gt; a
$cmaximum :: forall a. Ord a =&gt; TypeEqn a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; TypeEqn a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; TypeEqn a -&gt; Bool
length :: forall a. TypeEqn a -&gt; Int
$clength :: forall a. TypeEqn a -&gt; Int
null :: forall a. TypeEqn a -&gt; Bool
$cnull :: forall a. TypeEqn a -&gt; Bool
toList :: forall a. TypeEqn a -&gt; [a]
$ctoList :: forall a. TypeEqn a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; TypeEqn a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; TypeEqn a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; TypeEqn a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; TypeEqn a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TypeEqn a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TypeEqn a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TypeEqn a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TypeEqn a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TypeEqn a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TypeEqn a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TypeEqn a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TypeEqn a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TypeEqn a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TypeEqn a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TypeEqn a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TypeEqn a -&gt; m
fold :: forall m. Monoid m =&gt; TypeEqn m -&gt; m
$cfold :: forall m. Monoid m =&gt; TypeEqn m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438434"><span id="local-6989586621679438436"><span id="local-6989586621679438438"><span id="local-6989586621679438447"><span class="annot"><span class="annottext">Functor TypeEqn
Foldable TypeEqn
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; TypeEqn (m a) -&gt; m (TypeEqn a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
TypeEqn (f a) -&gt; f (TypeEqn a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; TypeEqn a -&gt; m (TypeEqn b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; TypeEqn a -&gt; f (TypeEqn b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; TypeEqn (m a) -&gt; m (TypeEqn a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; TypeEqn (m a) -&gt; m (TypeEqn a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; TypeEqn a -&gt; m (TypeEqn b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; TypeEqn a -&gt; m (TypeEqn b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
TypeEqn (f a) -&gt; f (TypeEqn a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
TypeEqn (f a) -&gt; f (TypeEqn a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; TypeEqn a -&gt; f (TypeEqn b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; TypeEqn a -&gt; f (TypeEqn b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438428"><span id="local-6989586621679438432"><span class="annot"><span class="annottext">forall a b. a -&gt; TypeEqn b -&gt; TypeEqn a
forall a b. (a -&gt; b) -&gt; TypeEqn a -&gt; TypeEqn b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; TypeEqn b -&gt; TypeEqn a
$c&lt;$ :: forall a b. a -&gt; TypeEqn b -&gt; TypeEqn a
fmap :: forall a b. (a -&gt; b) -&gt; TypeEqn a -&gt; TypeEqn b
$cfmap :: forall a b. (a -&gt; b) -&gt; TypeEqn a -&gt; TypeEqn b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (TypeEqn l) x -&gt; TypeEqn l
forall l x. TypeEqn l -&gt; Rep (TypeEqn l) x
$cto :: forall l x. Rep (TypeEqn l) x -&gt; TypeEqn l
$cfrom :: forall l x. TypeEqn l -&gt; Rep (TypeEqn l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-354"></span><span>
</span><span id="line-355"></span><span class="hs-comment">-- | An annotation through an ANN pragma.</span><span>
</span><span id="line-356"></span><span id="local-6989586621679438421"><span id="local-6989586621679438422"></span></span><span class="hs-keyword">data</span><span> </span><span id="Annotation"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotation"><span class="hs-identifier hs-var">Annotation</span></a></span></span><span> </span><span id="local-6989586621679452728"><span class="annot"><a href="#local-6989586621679452728"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-357"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="Ann"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Ann"><span class="hs-identifier hs-var">Ann</span></a></span></span><span>       </span><span class="annot"><a href="#local-6989586621679452728"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452728"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452728"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-358"></span><span>    </span><span class="hs-comment">-- ^ An annotation for a declared name.</span><span>
</span><span id="line-359"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="TypeAnn"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeAnn"><span class="hs-identifier hs-var">TypeAnn</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452728"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452728"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452728"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-360"></span><span>    </span><span class="hs-comment">-- ^ An annotation for a declared type.</span><span>
</span><span id="line-361"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ModuleAnn"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleAnn"><span class="hs-identifier hs-var">ModuleAnn</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452728"><span class="hs-identifier hs-type">l</span></a></span><span>           </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452728"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-362"></span><span>    </span><span class="hs-comment">-- ^ An annotation for the defining module.</span><span>
</span><span id="line-363"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679438406"><span id="local-6989586621679438416"><span class="annot"><span class="annottext">Annotation l -&gt; Annotation l -&gt; Bool
forall l. Eq l =&gt; Annotation l -&gt; Annotation l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Annotation l -&gt; Annotation l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Annotation l -&gt; Annotation l -&gt; Bool
== :: Annotation l -&gt; Annotation l -&gt; Bool
$c== :: forall l. Eq l =&gt; Annotation l -&gt; Annotation l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438371"><span id="local-6989586621679438373"><span id="local-6989586621679438376"><span id="local-6989586621679438379"><span id="local-6989586621679438382"><span id="local-6989586621679438392"><span id="local-6989586621679438402"><span class="annot"><span class="annottext">Annotation l -&gt; Annotation l -&gt; Bool
Annotation l -&gt; Annotation l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Annotation l)
forall l. Ord l =&gt; Annotation l -&gt; Annotation l -&gt; Bool
forall l. Ord l =&gt; Annotation l -&gt; Annotation l -&gt; Ordering
forall l. Ord l =&gt; Annotation l -&gt; Annotation l -&gt; Annotation l
min :: Annotation l -&gt; Annotation l -&gt; Annotation l
$cmin :: forall l. Ord l =&gt; Annotation l -&gt; Annotation l -&gt; Annotation l
max :: Annotation l -&gt; Annotation l -&gt; Annotation l
$cmax :: forall l. Ord l =&gt; Annotation l -&gt; Annotation l -&gt; Annotation l
&gt;= :: Annotation l -&gt; Annotation l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Annotation l -&gt; Annotation l -&gt; Bool
&gt; :: Annotation l -&gt; Annotation l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Annotation l -&gt; Annotation l -&gt; Bool
&lt;= :: Annotation l -&gt; Annotation l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Annotation l -&gt; Annotation l -&gt; Bool
&lt; :: Annotation l -&gt; Annotation l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Annotation l -&gt; Annotation l -&gt; Bool
compare :: Annotation l -&gt; Annotation l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Annotation l -&gt; Annotation l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438354"><span id="local-6989586621679438356"><span id="local-6989586621679438369"><span class="annot"><span class="annottext">Int -&gt; Annotation l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Annotation l -&gt; ShowS
forall l. Show l =&gt; [Annotation l] -&gt; ShowS
forall l. Show l =&gt; Annotation l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Annotation l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Annotation l] -&gt; ShowS
show :: Annotation l -&gt; String
$cshow :: forall l. Show l =&gt; Annotation l -&gt; String
showsPrec :: Int -&gt; Annotation l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Annotation l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679438303"><span id="local-6989586621679438305"><span id="local-6989586621679438307"><span id="local-6989586621679438309"><span id="local-6989586621679438311"><span id="local-6989586621679438313"><span id="local-6989586621679438315"><span id="local-6989586621679438317"><span id="local-6989586621679438319"><span id="local-6989586621679438325"><span id="local-6989586621679438327"><span id="local-6989586621679438329"><span id="local-6989586621679438339"><span id="local-6989586621679438349"><span class="annot"><span class="annottext">Annotation l -&gt; DataType
Annotation l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Annotation l)
forall l. Data l =&gt; Annotation l -&gt; DataType
forall l. Data l =&gt; Annotation l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Annotation l -&gt; Annotation l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Annotation l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Annotation l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Annotation l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Annotation l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Annotation l -&gt; m (Annotation l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Annotation l -&gt; m (Annotation l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Annotation l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Annotation l -&gt; c (Annotation l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Annotation l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Annotation l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Annotation l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Annotation l -&gt; c (Annotation l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Annotation l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Annotation l -&gt; m (Annotation l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Annotation l -&gt; m (Annotation l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Annotation l -&gt; m (Annotation l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Annotation l -&gt; m (Annotation l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Annotation l -&gt; m (Annotation l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Annotation l -&gt; m (Annotation l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Annotation l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Annotation l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Annotation l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Annotation l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Annotation l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Annotation l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Annotation l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Annotation l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Annotation l -&gt; Annotation l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Annotation l -&gt; Annotation l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Annotation l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Annotation l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Annotation l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Annotation l))
dataTypeOf :: Annotation l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Annotation l -&gt; DataType
toConstr :: Annotation l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Annotation l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Annotation l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Annotation l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Annotation l -&gt; c (Annotation l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Annotation l -&gt; c (Annotation l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438248"><span id="local-6989586621679438250"><span id="local-6989586621679438252"><span id="local-6989586621679438254"><span id="local-6989586621679438256"><span id="local-6989586621679438258"><span id="local-6989586621679438260"><span id="local-6989586621679438262"><span id="local-6989586621679438264"><span id="local-6989586621679438266"><span id="local-6989586621679438268"><span id="local-6989586621679438270"><span id="local-6989586621679438272"><span id="local-6989586621679438279"><span id="local-6989586621679438281"><span id="local-6989586621679438299"><span id="local-6989586621679438301"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Annotation a -&gt; Bool
forall a. Num a =&gt; Annotation a -&gt; a
forall a. Ord a =&gt; Annotation a -&gt; a
forall m. Monoid m =&gt; Annotation m -&gt; m
forall a. Annotation a -&gt; Bool
forall a. Annotation a -&gt; Int
forall a. Annotation a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Annotation a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Annotation a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Annotation a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Annotation a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Annotation a -&gt; a
$cproduct :: forall a. Num a =&gt; Annotation a -&gt; a
sum :: forall a. Num a =&gt; Annotation a -&gt; a
$csum :: forall a. Num a =&gt; Annotation a -&gt; a
minimum :: forall a. Ord a =&gt; Annotation a -&gt; a
$cminimum :: forall a. Ord a =&gt; Annotation a -&gt; a
maximum :: forall a. Ord a =&gt; Annotation a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Annotation a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Annotation a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Annotation a -&gt; Bool
length :: forall a. Annotation a -&gt; Int
$clength :: forall a. Annotation a -&gt; Int
null :: forall a. Annotation a -&gt; Bool
$cnull :: forall a. Annotation a -&gt; Bool
toList :: forall a. Annotation a -&gt; [a]
$ctoList :: forall a. Annotation a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Annotation a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Annotation a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Annotation a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Annotation a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Annotation a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Annotation a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Annotation a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Annotation a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Annotation a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Annotation a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Annotation a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Annotation a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Annotation a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Annotation a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Annotation a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Annotation a -&gt; m
fold :: forall m. Monoid m =&gt; Annotation m -&gt; m
$cfold :: forall m. Monoid m =&gt; Annotation m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438220"><span id="local-6989586621679438222"><span id="local-6989586621679438224"><span id="local-6989586621679438242"><span class="annot"><span class="annottext">Functor Annotation
Foldable Annotation
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
Annotation (m a) -&gt; m (Annotation a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Annotation (f a) -&gt; f (Annotation a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Annotation a -&gt; m (Annotation b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Annotation a -&gt; f (Annotation b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
Annotation (m a) -&gt; m (Annotation a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
Annotation (m a) -&gt; m (Annotation a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Annotation a -&gt; m (Annotation b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Annotation a -&gt; m (Annotation b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Annotation (f a) -&gt; f (Annotation a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Annotation (f a) -&gt; f (Annotation a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Annotation a -&gt; f (Annotation b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Annotation a -&gt; f (Annotation b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438211"><span id="local-6989586621679438218"><span class="annot"><span class="annottext">forall a b. a -&gt; Annotation b -&gt; Annotation a
forall a b. (a -&gt; b) -&gt; Annotation a -&gt; Annotation b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Annotation b -&gt; Annotation a
$c&lt;$ :: forall a b. a -&gt; Annotation b -&gt; Annotation a
fmap :: forall a b. (a -&gt; b) -&gt; Annotation a -&gt; Annotation b
$cfmap :: forall a b. (a -&gt; b) -&gt; Annotation a -&gt; Annotation b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Annotation l) x -&gt; Annotation l
forall l x. Annotation l -&gt; Rep (Annotation l) x
$cto :: forall l x. Rep (Annotation l) x -&gt; Annotation l
$cfrom :: forall l x. Annotation l -&gt; Rep (Annotation l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-364"></span><span>
</span><span id="line-365"></span><span class="hs-comment">-- | A boolean formula for MINIMAL pragmas.</span><span>
</span><span id="line-366"></span><span id="local-6989586621679438201"><span id="local-6989586621679438202"></span></span><span class="hs-keyword">data</span><span> </span><span id="BooleanFormula"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BooleanFormula"><span class="hs-identifier hs-var">BooleanFormula</span></a></span></span><span> </span><span id="local-6989586621679452718"><span class="annot"><a href="#local-6989586621679452718"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-367"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="VarFormula"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarFormula"><span class="hs-identifier hs-var">VarFormula</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452718"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452718"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>              </span><span class="hs-comment">-- ^ A variable.</span><span>
</span><span id="line-368"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="AndFormula"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AndFormula"><span class="hs-identifier hs-var">AndFormula</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452718"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BooleanFormula"><span class="hs-identifier hs-type">BooleanFormula</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452718"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>    </span><span class="hs-comment">-- ^ And boolean formulas.</span><span>
</span><span id="line-369"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="OrFormula"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#OrFormula"><span class="hs-identifier hs-var">OrFormula</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452718"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BooleanFormula"><span class="hs-identifier hs-type">BooleanFormula</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452718"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">-- ^ Or boolean formulas.</span><span>
</span><span id="line-370"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ParenFormula"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParenFormula"><span class="hs-identifier hs-var">ParenFormula</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452718"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BooleanFormula"><span class="hs-identifier hs-type">BooleanFormula</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452718"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- ^ Parenthesized boolean formulas.</span><span>
</span><span id="line-371"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679438184"><span id="local-6989586621679438195"><span class="annot"><span class="annottext">BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
forall l. Eq l =&gt; BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
$c/= :: forall l. Eq l =&gt; BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
== :: BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
$c== :: forall l. Eq l =&gt; BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438159"><span id="local-6989586621679438161"><span id="local-6989586621679438163"><span id="local-6989586621679438165"><span id="local-6989586621679438167"><span id="local-6989586621679438169"><span id="local-6989586621679438180"><span class="annot"><span class="annottext">BooleanFormula l -&gt; BooleanFormula l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (BooleanFormula l)
forall l. Ord l =&gt; BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
forall l. Ord l =&gt; BooleanFormula l -&gt; BooleanFormula l -&gt; Ordering
forall l.
Ord l =&gt;
BooleanFormula l -&gt; BooleanFormula l -&gt; BooleanFormula l
min :: BooleanFormula l -&gt; BooleanFormula l -&gt; BooleanFormula l
$cmin :: forall l.
Ord l =&gt;
BooleanFormula l -&gt; BooleanFormula l -&gt; BooleanFormula l
max :: BooleanFormula l -&gt; BooleanFormula l -&gt; BooleanFormula l
$cmax :: forall l.
Ord l =&gt;
BooleanFormula l -&gt; BooleanFormula l -&gt; BooleanFormula l
&gt;= :: BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
&gt; :: BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
&lt;= :: BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
&lt; :: BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; BooleanFormula l -&gt; BooleanFormula l -&gt; Bool
compare :: BooleanFormula l -&gt; BooleanFormula l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; BooleanFormula l -&gt; BooleanFormula l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438140"><span id="local-6989586621679438142"><span id="local-6989586621679438157"><span class="annot"><span class="annottext">Int -&gt; BooleanFormula l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; BooleanFormula l -&gt; ShowS
forall l. Show l =&gt; [BooleanFormula l] -&gt; ShowS
forall l. Show l =&gt; BooleanFormula l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [BooleanFormula l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [BooleanFormula l] -&gt; ShowS
show :: BooleanFormula l -&gt; String
$cshow :: forall l. Show l =&gt; BooleanFormula l -&gt; String
showsPrec :: Int -&gt; BooleanFormula l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; BooleanFormula l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679438087"><span id="local-6989586621679438089"><span id="local-6989586621679438091"><span id="local-6989586621679438093"><span id="local-6989586621679438095"><span id="local-6989586621679438097"><span id="local-6989586621679438099"><span id="local-6989586621679438101"><span id="local-6989586621679438103"><span id="local-6989586621679438109"><span id="local-6989586621679438111"><span id="local-6989586621679438113"><span id="local-6989586621679438124"><span id="local-6989586621679438135"><span class="annot"><span class="annottext">BooleanFormula l -&gt; DataType
BooleanFormula l -&gt; Constr
forall {l}. Data l =&gt; Typeable (BooleanFormula l)
forall l. Data l =&gt; BooleanFormula l -&gt; DataType
forall l. Data l =&gt; BooleanFormula l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; BooleanFormula l -&gt; BooleanFormula l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BooleanFormula l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; BooleanFormula l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BooleanFormula l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BooleanFormula l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; BooleanFormula l -&gt; m (BooleanFormula l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; BooleanFormula l -&gt; m (BooleanFormula l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (BooleanFormula l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BooleanFormula l -&gt; c (BooleanFormula l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (BooleanFormula l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (BooleanFormula l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (BooleanFormula l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BooleanFormula l -&gt; c (BooleanFormula l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (BooleanFormula l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; BooleanFormula l -&gt; m (BooleanFormula l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; BooleanFormula l -&gt; m (BooleanFormula l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; BooleanFormula l -&gt; m (BooleanFormula l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; BooleanFormula l -&gt; m (BooleanFormula l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; BooleanFormula l -&gt; m (BooleanFormula l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; BooleanFormula l -&gt; m (BooleanFormula l)
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BooleanFormula l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BooleanFormula l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; BooleanFormula l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; BooleanFormula l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BooleanFormula l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BooleanFormula l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BooleanFormula l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BooleanFormula l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; BooleanFormula l -&gt; BooleanFormula l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; BooleanFormula l -&gt; BooleanFormula l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (BooleanFormula l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (BooleanFormula l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (BooleanFormula l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (BooleanFormula l))
dataTypeOf :: BooleanFormula l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; BooleanFormula l -&gt; DataType
toConstr :: BooleanFormula l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; BooleanFormula l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (BooleanFormula l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (BooleanFormula l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BooleanFormula l -&gt; c (BooleanFormula l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BooleanFormula l -&gt; c (BooleanFormula l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438030"><span id="local-6989586621679438032"><span id="local-6989586621679438034"><span id="local-6989586621679438036"><span id="local-6989586621679438038"><span id="local-6989586621679438040"><span id="local-6989586621679438042"><span id="local-6989586621679438044"><span id="local-6989586621679438046"><span id="local-6989586621679438048"><span id="local-6989586621679438050"><span id="local-6989586621679438052"><span id="local-6989586621679438054"><span id="local-6989586621679438062"><span id="local-6989586621679438064"><span id="local-6989586621679438083"><span id="local-6989586621679438085"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; BooleanFormula a -&gt; Bool
forall a. Num a =&gt; BooleanFormula a -&gt; a
forall a. Ord a =&gt; BooleanFormula a -&gt; a
forall m. Monoid m =&gt; BooleanFormula m -&gt; m
forall a. BooleanFormula a -&gt; Bool
forall a. BooleanFormula a -&gt; Int
forall a. BooleanFormula a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; BooleanFormula a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; BooleanFormula a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; BooleanFormula a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; BooleanFormula a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; BooleanFormula a -&gt; a
$cproduct :: forall a. Num a =&gt; BooleanFormula a -&gt; a
sum :: forall a. Num a =&gt; BooleanFormula a -&gt; a
$csum :: forall a. Num a =&gt; BooleanFormula a -&gt; a
minimum :: forall a. Ord a =&gt; BooleanFormula a -&gt; a
$cminimum :: forall a. Ord a =&gt; BooleanFormula a -&gt; a
maximum :: forall a. Ord a =&gt; BooleanFormula a -&gt; a
$cmaximum :: forall a. Ord a =&gt; BooleanFormula a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; BooleanFormula a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; BooleanFormula a -&gt; Bool
length :: forall a. BooleanFormula a -&gt; Int
$clength :: forall a. BooleanFormula a -&gt; Int
null :: forall a. BooleanFormula a -&gt; Bool
$cnull :: forall a. BooleanFormula a -&gt; Bool
toList :: forall a. BooleanFormula a -&gt; [a]
$ctoList :: forall a. BooleanFormula a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; BooleanFormula a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; BooleanFormula a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; BooleanFormula a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; BooleanFormula a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; BooleanFormula a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; BooleanFormula a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; BooleanFormula a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; BooleanFormula a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; BooleanFormula a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; BooleanFormula a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; BooleanFormula a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; BooleanFormula a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; BooleanFormula a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; BooleanFormula a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; BooleanFormula a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; BooleanFormula a -&gt; m
fold :: forall m. Monoid m =&gt; BooleanFormula m -&gt; m
$cfold :: forall m. Monoid m =&gt; BooleanFormula m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679438001"><span id="local-6989586621679438003"><span id="local-6989586621679438005"><span id="local-6989586621679438024"><span class="annot"><span class="annottext">Functor BooleanFormula
Foldable BooleanFormula
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
BooleanFormula (m a) -&gt; m (BooleanFormula a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
BooleanFormula (f a) -&gt; f (BooleanFormula a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; BooleanFormula a -&gt; m (BooleanFormula b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; BooleanFormula a -&gt; f (BooleanFormula b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
BooleanFormula (m a) -&gt; m (BooleanFormula a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
BooleanFormula (m a) -&gt; m (BooleanFormula a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; BooleanFormula a -&gt; m (BooleanFormula b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; BooleanFormula a -&gt; m (BooleanFormula b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
BooleanFormula (f a) -&gt; f (BooleanFormula a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
BooleanFormula (f a) -&gt; f (BooleanFormula a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; BooleanFormula a -&gt; f (BooleanFormula b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; BooleanFormula a -&gt; f (BooleanFormula b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437991"><span id="local-6989586621679437999"><span class="annot"><span class="annottext">forall a b. a -&gt; BooleanFormula b -&gt; BooleanFormula a
forall a b. (a -&gt; b) -&gt; BooleanFormula a -&gt; BooleanFormula b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; BooleanFormula b -&gt; BooleanFormula a
$c&lt;$ :: forall a b. a -&gt; BooleanFormula b -&gt; BooleanFormula a
fmap :: forall a b. (a -&gt; b) -&gt; BooleanFormula a -&gt; BooleanFormula b
$cfmap :: forall a b. (a -&gt; b) -&gt; BooleanFormula a -&gt; BooleanFormula b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (BooleanFormula l) x -&gt; BooleanFormula l
forall l x. BooleanFormula l -&gt; Rep (BooleanFormula l) x
$cto :: forall l x. Rep (BooleanFormula l) x -&gt; BooleanFormula l
$cfrom :: forall l x. BooleanFormula l -&gt; Rep (BooleanFormula l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-372"></span><span>
</span><span id="line-373"></span><span id="local-6989586621679437980"><span id="local-6989586621679437981"></span></span><span class="hs-keyword">data</span><span> </span><span id="Role"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Role"><span class="hs-identifier hs-var">Role</span></a></span></span><span> </span><span id="local-6989586621679452719"><span class="annot"><a href="#local-6989586621679452719"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-374"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Nominal"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Nominal"><span class="hs-identifier hs-var">Nominal</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452719"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-375"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Representational"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Representational"><span class="hs-identifier hs-var">Representational</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452719"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-376"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Phantom"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Phantom"><span class="hs-identifier hs-var">Phantom</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452719"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-377"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RoleWildcard"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RoleWildcard"><span class="hs-identifier hs-var">RoleWildcard</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452719"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-378"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679437968"><span id="local-6989586621679437974"><span class="annot"><span class="annottext">Role l -&gt; Role l -&gt; Bool
forall l. Eq l =&gt; Role l -&gt; Role l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Role l -&gt; Role l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Role l -&gt; Role l -&gt; Bool
== :: Role l -&gt; Role l -&gt; Bool
$c== :: forall l. Eq l =&gt; Role l -&gt; Role l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437948"><span id="local-6989586621679437950"><span id="local-6989586621679437952"><span id="local-6989586621679437954"><span id="local-6989586621679437956"><span id="local-6989586621679437958"><span id="local-6989586621679437964"><span class="annot"><span class="annottext">Role l -&gt; Role l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Role l)
forall l. Ord l =&gt; Role l -&gt; Role l -&gt; Bool
forall l. Ord l =&gt; Role l -&gt; Role l -&gt; Ordering
forall l. Ord l =&gt; Role l -&gt; Role l -&gt; Role l
min :: Role l -&gt; Role l -&gt; Role l
$cmin :: forall l. Ord l =&gt; Role l -&gt; Role l -&gt; Role l
max :: Role l -&gt; Role l -&gt; Role l
$cmax :: forall l. Ord l =&gt; Role l -&gt; Role l -&gt; Role l
&gt;= :: Role l -&gt; Role l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Role l -&gt; Role l -&gt; Bool
&gt; :: Role l -&gt; Role l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Role l -&gt; Role l -&gt; Bool
&lt;= :: Role l -&gt; Role l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Role l -&gt; Role l -&gt; Bool
&lt; :: Role l -&gt; Role l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Role l -&gt; Role l -&gt; Bool
compare :: Role l -&gt; Role l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Role l -&gt; Role l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437934"><span id="local-6989586621679437936"><span id="local-6989586621679437946"><span class="annot"><span class="annottext">Int -&gt; Role l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Role l -&gt; ShowS
forall l. Show l =&gt; [Role l] -&gt; ShowS
forall l. Show l =&gt; Role l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Role l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Role l] -&gt; ShowS
show :: Role l -&gt; String
$cshow :: forall l. Show l =&gt; Role l -&gt; String
showsPrec :: Int -&gt; Role l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Role l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679437891"><span id="local-6989586621679437893"><span id="local-6989586621679437895"><span id="local-6989586621679437897"><span id="local-6989586621679437899"><span id="local-6989586621679437901"><span id="local-6989586621679437903"><span id="local-6989586621679437905"><span id="local-6989586621679437907"><span id="local-6989586621679437913"><span id="local-6989586621679437915"><span id="local-6989586621679437917"><span id="local-6989586621679437923"><span id="local-6989586621679437929"><span class="annot"><span class="annottext">Role l -&gt; DataType
Role l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Role l)
forall l. Data l =&gt; Role l -&gt; DataType
forall l. Data l =&gt; Role l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Role l -&gt; Role l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Role l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Role l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role l -&gt; m (Role l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role l -&gt; m (Role l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Role l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Role l -&gt; c (Role l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Role l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Role l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Role l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Role l -&gt; c (Role l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Role l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role l -&gt; m (Role l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role l -&gt; m (Role l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role l -&gt; m (Role l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role l -&gt; m (Role l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role l -&gt; m (Role l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Role l -&gt; m (Role l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Role l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Role l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Role l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Role l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Role l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Role l -&gt; Role l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Role l -&gt; Role l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Role l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Role l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Role l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Role l))
dataTypeOf :: Role l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Role l -&gt; DataType
toConstr :: Role l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Role l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Role l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Role l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Role l -&gt; c (Role l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Role l -&gt; c (Role l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437856"><span id="local-6989586621679437858"><span id="local-6989586621679437860"><span id="local-6989586621679437862"><span id="local-6989586621679437864"><span id="local-6989586621679437866"><span id="local-6989586621679437868"><span id="local-6989586621679437870"><span id="local-6989586621679437872"><span id="local-6989586621679437874"><span id="local-6989586621679437876"><span id="local-6989586621679437878"><span id="local-6989586621679437880"><span id="local-6989586621679437882"><span id="local-6989586621679437884"><span id="local-6989586621679437887"><span id="local-6989586621679437889"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Role a -&gt; Bool
forall a. Num a =&gt; Role a -&gt; a
forall a. Ord a =&gt; Role a -&gt; a
forall m. Monoid m =&gt; Role m -&gt; m
forall a. Role a -&gt; Bool
forall a. Role a -&gt; Int
forall a. Role a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Role a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Role a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Role a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Role a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Role a -&gt; a
$cproduct :: forall a. Num a =&gt; Role a -&gt; a
sum :: forall a. Num a =&gt; Role a -&gt; a
$csum :: forall a. Num a =&gt; Role a -&gt; a
minimum :: forall a. Ord a =&gt; Role a -&gt; a
$cminimum :: forall a. Ord a =&gt; Role a -&gt; a
maximum :: forall a. Ord a =&gt; Role a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Role a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Role a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Role a -&gt; Bool
length :: forall a. Role a -&gt; Int
$clength :: forall a. Role a -&gt; Int
null :: forall a. Role a -&gt; Bool
$cnull :: forall a. Role a -&gt; Bool
toList :: forall a. Role a -&gt; [a]
$ctoList :: forall a. Role a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Role a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Role a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Role a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Role a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Role a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Role a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Role a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Role a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Role a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Role a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Role a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Role a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Role a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Role a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Role a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Role a -&gt; m
fold :: forall m. Monoid m =&gt; Role m -&gt; m
$cfold :: forall m. Monoid m =&gt; Role m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437838"><span id="local-6989586621679437840"><span id="local-6989586621679437842"><span id="local-6989586621679437850"><span class="annot"><span class="annottext">Functor Role
Foldable Role
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Role (m a) -&gt; m (Role a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Role (f a) -&gt; f (Role a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Role a -&gt; m (Role b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Role a -&gt; f (Role b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Role (m a) -&gt; m (Role a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Role (m a) -&gt; m (Role a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Role a -&gt; m (Role b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Role a -&gt; m (Role b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Role (f a) -&gt; f (Role a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Role (f a) -&gt; f (Role a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Role a -&gt; f (Role b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Role a -&gt; f (Role b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437834"><span id="local-6989586621679437836"><span class="annot"><span class="annottext">forall a b. a -&gt; Role b -&gt; Role a
forall a b. (a -&gt; b) -&gt; Role a -&gt; Role b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Role b -&gt; Role a
$c&lt;$ :: forall a b. a -&gt; Role b -&gt; Role a
fmap :: forall a b. (a -&gt; b) -&gt; Role a -&gt; Role b
$cfmap :: forall a b. (a -&gt; b) -&gt; Role a -&gt; Role b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Role l) x -&gt; Role l
forall l x. Role l -&gt; Rep (Role l) x
$cto :: forall l x. Rep (Role l) x -&gt; Role l
$cfrom :: forall l x. Role l -&gt; Rep (Role l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-379"></span><span>
</span><span id="line-380"></span><span class="hs-comment">-- | A flag stating whether a declaration is a data or newtype declaration.</span><span>
</span><span id="line-381"></span><span id="local-6989586621679437829"><span id="local-6989586621679437830"></span></span><span class="hs-keyword">data</span><span> </span><span id="DataOrNew"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataOrNew"><span class="hs-identifier hs-var">DataOrNew</span></a></span></span><span> </span><span id="local-6989586621679452720"><span class="annot"><a href="#local-6989586621679452720"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DataType"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataType"><span class="hs-identifier hs-var">DataType</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452720"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="NewType"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NewType"><span class="hs-identifier hs-var">NewType</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452720"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-382"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679437821"><span id="local-6989586621679437825"><span class="annot"><span class="annottext">DataOrNew l -&gt; DataOrNew l -&gt; Bool
forall l. Eq l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DataOrNew l -&gt; DataOrNew l -&gt; Bool
$c/= :: forall l. Eq l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; Bool
== :: DataOrNew l -&gt; DataOrNew l -&gt; Bool
$c== :: forall l. Eq l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437798"><span id="local-6989586621679437800"><span id="local-6989586621679437803"><span id="local-6989586621679437806"><span id="local-6989586621679437809"><span id="local-6989586621679437813"><span id="local-6989586621679437817"><span class="annot"><span class="annottext">DataOrNew l -&gt; DataOrNew l -&gt; Bool
DataOrNew l -&gt; DataOrNew l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (DataOrNew l)
forall l. Ord l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; Bool
forall l. Ord l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; Ordering
forall l. Ord l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; DataOrNew l
min :: DataOrNew l -&gt; DataOrNew l -&gt; DataOrNew l
$cmin :: forall l. Ord l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; DataOrNew l
max :: DataOrNew l -&gt; DataOrNew l -&gt; DataOrNew l
$cmax :: forall l. Ord l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; DataOrNew l
&gt;= :: DataOrNew l -&gt; DataOrNew l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; Bool
&gt; :: DataOrNew l -&gt; DataOrNew l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; Bool
&lt;= :: DataOrNew l -&gt; DataOrNew l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; Bool
&lt; :: DataOrNew l -&gt; DataOrNew l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; Bool
compare :: DataOrNew l -&gt; DataOrNew l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; DataOrNew l -&gt; DataOrNew l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437788"><span id="local-6989586621679437790"><span id="local-6989586621679437796"><span class="annot"><span class="annottext">Int -&gt; DataOrNew l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; DataOrNew l -&gt; ShowS
forall l. Show l =&gt; [DataOrNew l] -&gt; ShowS
forall l. Show l =&gt; DataOrNew l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DataOrNew l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [DataOrNew l] -&gt; ShowS
show :: DataOrNew l -&gt; String
$cshow :: forall l. Show l =&gt; DataOrNew l -&gt; String
showsPrec :: Int -&gt; DataOrNew l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; DataOrNew l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679437749"><span id="local-6989586621679437751"><span id="local-6989586621679437753"><span id="local-6989586621679437755"><span id="local-6989586621679437757"><span id="local-6989586621679437759"><span id="local-6989586621679437761"><span id="local-6989586621679437763"><span id="local-6989586621679437765"><span id="local-6989586621679437771"><span id="local-6989586621679437773"><span id="local-6989586621679437775"><span id="local-6989586621679437779"><span id="local-6989586621679437783"><span class="annot"><span class="annottext">DataOrNew l -&gt; DataType
DataOrNew l -&gt; Constr
forall {l}. Data l =&gt; Typeable (DataOrNew l)
forall l. Data l =&gt; DataOrNew l -&gt; DataType
forall l. Data l =&gt; DataOrNew l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; DataOrNew l -&gt; DataOrNew l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DataOrNew l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; DataOrNew l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataOrNew l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataOrNew l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DataOrNew l -&gt; m (DataOrNew l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DataOrNew l -&gt; m (DataOrNew l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DataOrNew l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DataOrNew l -&gt; c (DataOrNew l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DataOrNew l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DataOrNew l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DataOrNew l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DataOrNew l -&gt; c (DataOrNew l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DataOrNew l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DataOrNew l -&gt; m (DataOrNew l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DataOrNew l -&gt; m (DataOrNew l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DataOrNew l -&gt; m (DataOrNew l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DataOrNew l -&gt; m (DataOrNew l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DataOrNew l -&gt; m (DataOrNew l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DataOrNew l -&gt; m (DataOrNew l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DataOrNew l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DataOrNew l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DataOrNew l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; DataOrNew l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataOrNew l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataOrNew l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataOrNew l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DataOrNew l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DataOrNew l -&gt; DataOrNew l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; DataOrNew l -&gt; DataOrNew l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DataOrNew l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DataOrNew l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DataOrNew l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DataOrNew l))
dataTypeOf :: DataOrNew l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; DataOrNew l -&gt; DataType
toConstr :: DataOrNew l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; DataOrNew l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DataOrNew l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DataOrNew l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DataOrNew l -&gt; c (DataOrNew l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DataOrNew l -&gt; c (DataOrNew l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437714"><span id="local-6989586621679437716"><span id="local-6989586621679437718"><span id="local-6989586621679437720"><span id="local-6989586621679437722"><span id="local-6989586621679437724"><span id="local-6989586621679437726"><span id="local-6989586621679437728"><span id="local-6989586621679437730"><span id="local-6989586621679437732"><span id="local-6989586621679437734"><span id="local-6989586621679437736"><span id="local-6989586621679437738"><span id="local-6989586621679437740"><span id="local-6989586621679437742"><span id="local-6989586621679437745"><span id="local-6989586621679437747"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; DataOrNew a -&gt; Bool
forall a. Num a =&gt; DataOrNew a -&gt; a
forall a. Ord a =&gt; DataOrNew a -&gt; a
forall m. Monoid m =&gt; DataOrNew m -&gt; m
forall a. DataOrNew a -&gt; Bool
forall a. DataOrNew a -&gt; Int
forall a. DataOrNew a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; DataOrNew a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataOrNew a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataOrNew a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataOrNew a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; DataOrNew a -&gt; a
$cproduct :: forall a. Num a =&gt; DataOrNew a -&gt; a
sum :: forall a. Num a =&gt; DataOrNew a -&gt; a
$csum :: forall a. Num a =&gt; DataOrNew a -&gt; a
minimum :: forall a. Ord a =&gt; DataOrNew a -&gt; a
$cminimum :: forall a. Ord a =&gt; DataOrNew a -&gt; a
maximum :: forall a. Ord a =&gt; DataOrNew a -&gt; a
$cmaximum :: forall a. Ord a =&gt; DataOrNew a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; DataOrNew a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; DataOrNew a -&gt; Bool
length :: forall a. DataOrNew a -&gt; Int
$clength :: forall a. DataOrNew a -&gt; Int
null :: forall a. DataOrNew a -&gt; Bool
$cnull :: forall a. DataOrNew a -&gt; Bool
toList :: forall a. DataOrNew a -&gt; [a]
$ctoList :: forall a. DataOrNew a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; DataOrNew a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; DataOrNew a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; DataOrNew a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; DataOrNew a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataOrNew a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataOrNew a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataOrNew a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DataOrNew a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataOrNew a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataOrNew a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataOrNew a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DataOrNew a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataOrNew a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataOrNew a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataOrNew a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DataOrNew a -&gt; m
fold :: forall m. Monoid m =&gt; DataOrNew m -&gt; m
$cfold :: forall m. Monoid m =&gt; DataOrNew m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437698"><span id="local-6989586621679437700"><span id="local-6989586621679437702"><span id="local-6989586621679437708"><span class="annot"><span class="annottext">Functor DataOrNew
Foldable DataOrNew
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
DataOrNew (m a) -&gt; m (DataOrNew a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
DataOrNew (f a) -&gt; f (DataOrNew a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DataOrNew a -&gt; m (DataOrNew b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DataOrNew a -&gt; f (DataOrNew b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
DataOrNew (m a) -&gt; m (DataOrNew a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
DataOrNew (m a) -&gt; m (DataOrNew a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DataOrNew a -&gt; m (DataOrNew b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DataOrNew a -&gt; m (DataOrNew b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
DataOrNew (f a) -&gt; f (DataOrNew a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
DataOrNew (f a) -&gt; f (DataOrNew a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DataOrNew a -&gt; f (DataOrNew b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DataOrNew a -&gt; f (DataOrNew b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437694"><span id="local-6989586621679437696"><span class="annot"><span class="annottext">forall a b. a -&gt; DataOrNew b -&gt; DataOrNew a
forall a b. (a -&gt; b) -&gt; DataOrNew a -&gt; DataOrNew b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; DataOrNew b -&gt; DataOrNew a
$c&lt;$ :: forall a b. a -&gt; DataOrNew b -&gt; DataOrNew a
fmap :: forall a b. (a -&gt; b) -&gt; DataOrNew a -&gt; DataOrNew b
$cfmap :: forall a b. (a -&gt; b) -&gt; DataOrNew a -&gt; DataOrNew b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (DataOrNew l) x -&gt; DataOrNew l
forall l x. DataOrNew l -&gt; Rep (DataOrNew l) x
$cto :: forall l x. Rep (DataOrNew l) x -&gt; DataOrNew l
$cfrom :: forall l x. DataOrNew l -&gt; Rep (DataOrNew l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-383"></span><span>
</span><span id="line-384"></span><span>
</span><span id="line-385"></span><span class="hs-comment">-- | Injectivity info for injective type families</span><span>
</span><span id="line-386"></span><span id="local-6989586621679437689"><span id="local-6989586621679437690"></span></span><span class="hs-keyword">data</span><span> </span><span id="InjectivityInfo"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InjectivityInfo"><span class="hs-identifier hs-var">InjectivityInfo</span></a></span></span><span> </span><span id="local-6989586621679452721"><span class="annot"><a href="#local-6989586621679452721"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="InjectivityInfo"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InjectivityInfo"><span class="hs-identifier hs-var">InjectivityInfo</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452721"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452721"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452721"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-387"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679437681"><span id="local-6989586621679437686"><span class="annot"><span class="annottext">InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
forall l. Eq l =&gt; InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
$c/= :: forall l. Eq l =&gt; InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
== :: InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
$c== :: forall l. Eq l =&gt; InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437656"><span id="local-6989586621679437658"><span id="local-6989586621679437661"><span id="local-6989586621679437664"><span id="local-6989586621679437667"><span id="local-6989586621679437672"><span id="local-6989586621679437677"><span class="annot"><span class="annottext">InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
InjectivityInfo l -&gt; InjectivityInfo l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (InjectivityInfo l)
forall l. Ord l =&gt; InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
forall l.
Ord l =&gt;
InjectivityInfo l -&gt; InjectivityInfo l -&gt; Ordering
forall l.
Ord l =&gt;
InjectivityInfo l -&gt; InjectivityInfo l -&gt; InjectivityInfo l
min :: InjectivityInfo l -&gt; InjectivityInfo l -&gt; InjectivityInfo l
$cmin :: forall l.
Ord l =&gt;
InjectivityInfo l -&gt; InjectivityInfo l -&gt; InjectivityInfo l
max :: InjectivityInfo l -&gt; InjectivityInfo l -&gt; InjectivityInfo l
$cmax :: forall l.
Ord l =&gt;
InjectivityInfo l -&gt; InjectivityInfo l -&gt; InjectivityInfo l
&gt;= :: InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
&gt; :: InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
&lt;= :: InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
&lt; :: InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; InjectivityInfo l -&gt; InjectivityInfo l -&gt; Bool
compare :: InjectivityInfo l -&gt; InjectivityInfo l -&gt; Ordering
$ccompare :: forall l.
Ord l =&gt;
InjectivityInfo l -&gt; InjectivityInfo l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437646"><span id="local-6989586621679437648"><span id="local-6989586621679437654"><span class="annot"><span class="annottext">Int -&gt; InjectivityInfo l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; InjectivityInfo l -&gt; ShowS
forall l. Show l =&gt; [InjectivityInfo l] -&gt; ShowS
forall l. Show l =&gt; InjectivityInfo l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [InjectivityInfo l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [InjectivityInfo l] -&gt; ShowS
show :: InjectivityInfo l -&gt; String
$cshow :: forall l. Show l =&gt; InjectivityInfo l -&gt; String
showsPrec :: Int -&gt; InjectivityInfo l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; InjectivityInfo l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437603"><span id="local-6989586621679437605"><span id="local-6989586621679437607"><span id="local-6989586621679437609"><span id="local-6989586621679437611"><span id="local-6989586621679437613"><span id="local-6989586621679437615"><span id="local-6989586621679437617"><span id="local-6989586621679437619"><span id="local-6989586621679437625"><span id="local-6989586621679437627"><span id="local-6989586621679437629"><span id="local-6989586621679437635"><span id="local-6989586621679437641"><span class="annot"><span class="annottext">InjectivityInfo l -&gt; DataType
InjectivityInfo l -&gt; Constr
forall {l}. Data l =&gt; Typeable (InjectivityInfo l)
forall l. Data l =&gt; InjectivityInfo l -&gt; DataType
forall l. Data l =&gt; InjectivityInfo l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; InjectivityInfo l -&gt; InjectivityInfo l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityInfo l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityInfo l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityInfo l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityInfo l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityInfo l -&gt; m (InjectivityInfo l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityInfo l -&gt; m (InjectivityInfo l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InjectivityInfo l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; InjectivityInfo l
-&gt; c (InjectivityInfo l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InjectivityInfo l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InjectivityInfo l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InjectivityInfo l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; InjectivityInfo l
-&gt; c (InjectivityInfo l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InjectivityInfo l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityInfo l -&gt; m (InjectivityInfo l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityInfo l -&gt; m (InjectivityInfo l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityInfo l -&gt; m (InjectivityInfo l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityInfo l -&gt; m (InjectivityInfo l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityInfo l -&gt; m (InjectivityInfo l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; InjectivityInfo l -&gt; m (InjectivityInfo l)
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityInfo l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityInfo l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityInfo l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; InjectivityInfo l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityInfo l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityInfo l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityInfo l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InjectivityInfo l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; InjectivityInfo l -&gt; InjectivityInfo l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; InjectivityInfo l -&gt; InjectivityInfo l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InjectivityInfo l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InjectivityInfo l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InjectivityInfo l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InjectivityInfo l))
dataTypeOf :: InjectivityInfo l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; InjectivityInfo l -&gt; DataType
toConstr :: InjectivityInfo l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; InjectivityInfo l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InjectivityInfo l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InjectivityInfo l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; InjectivityInfo l
-&gt; c (InjectivityInfo l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; InjectivityInfo l
-&gt; c (InjectivityInfo l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437557"><span id="local-6989586621679437559"><span id="local-6989586621679437561"><span id="local-6989586621679437563"><span id="local-6989586621679437565"><span id="local-6989586621679437567"><span id="local-6989586621679437569"><span id="local-6989586621679437571"><span id="local-6989586621679437573"><span id="local-6989586621679437575"><span id="local-6989586621679437577"><span id="local-6989586621679437579"><span id="local-6989586621679437581"><span id="local-6989586621679437586"><span id="local-6989586621679437588"><span id="local-6989586621679437599"><span id="local-6989586621679437601"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; InjectivityInfo a -&gt; Bool
forall a. Num a =&gt; InjectivityInfo a -&gt; a
forall a. Ord a =&gt; InjectivityInfo a -&gt; a
forall m. Monoid m =&gt; InjectivityInfo m -&gt; m
forall a. InjectivityInfo a -&gt; Bool
forall a. InjectivityInfo a -&gt; Int
forall a. InjectivityInfo a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; InjectivityInfo a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InjectivityInfo a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InjectivityInfo a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InjectivityInfo a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; InjectivityInfo a -&gt; a
$cproduct :: forall a. Num a =&gt; InjectivityInfo a -&gt; a
sum :: forall a. Num a =&gt; InjectivityInfo a -&gt; a
$csum :: forall a. Num a =&gt; InjectivityInfo a -&gt; a
minimum :: forall a. Ord a =&gt; InjectivityInfo a -&gt; a
$cminimum :: forall a. Ord a =&gt; InjectivityInfo a -&gt; a
maximum :: forall a. Ord a =&gt; InjectivityInfo a -&gt; a
$cmaximum :: forall a. Ord a =&gt; InjectivityInfo a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; InjectivityInfo a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; InjectivityInfo a -&gt; Bool
length :: forall a. InjectivityInfo a -&gt; Int
$clength :: forall a. InjectivityInfo a -&gt; Int
null :: forall a. InjectivityInfo a -&gt; Bool
$cnull :: forall a. InjectivityInfo a -&gt; Bool
toList :: forall a. InjectivityInfo a -&gt; [a]
$ctoList :: forall a. InjectivityInfo a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; InjectivityInfo a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; InjectivityInfo a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; InjectivityInfo a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; InjectivityInfo a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InjectivityInfo a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InjectivityInfo a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InjectivityInfo a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InjectivityInfo a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InjectivityInfo a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InjectivityInfo a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InjectivityInfo a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InjectivityInfo a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InjectivityInfo a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InjectivityInfo a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InjectivityInfo a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InjectivityInfo a -&gt; m
fold :: forall m. Monoid m =&gt; InjectivityInfo m -&gt; m
$cfold :: forall m. Monoid m =&gt; InjectivityInfo m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437536"><span id="local-6989586621679437538"><span id="local-6989586621679437540"><span id="local-6989586621679437551"><span class="annot"><span class="annottext">Functor InjectivityInfo
Foldable InjectivityInfo
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
InjectivityInfo (m a) -&gt; m (InjectivityInfo a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
InjectivityInfo (f a) -&gt; f (InjectivityInfo a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InjectivityInfo a -&gt; m (InjectivityInfo b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InjectivityInfo a -&gt; f (InjectivityInfo b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
InjectivityInfo (m a) -&gt; m (InjectivityInfo a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
InjectivityInfo (m a) -&gt; m (InjectivityInfo a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InjectivityInfo a -&gt; m (InjectivityInfo b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InjectivityInfo a -&gt; m (InjectivityInfo b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
InjectivityInfo (f a) -&gt; f (InjectivityInfo a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
InjectivityInfo (f a) -&gt; f (InjectivityInfo a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InjectivityInfo a -&gt; f (InjectivityInfo b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InjectivityInfo a -&gt; f (InjectivityInfo b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437529"><span id="local-6989586621679437534"><span class="annot"><span class="annottext">forall a b. a -&gt; InjectivityInfo b -&gt; InjectivityInfo a
forall a b. (a -&gt; b) -&gt; InjectivityInfo a -&gt; InjectivityInfo b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; InjectivityInfo b -&gt; InjectivityInfo a
$c&lt;$ :: forall a b. a -&gt; InjectivityInfo b -&gt; InjectivityInfo a
fmap :: forall a b. (a -&gt; b) -&gt; InjectivityInfo a -&gt; InjectivityInfo b
$cfmap :: forall a b. (a -&gt; b) -&gt; InjectivityInfo a -&gt; InjectivityInfo b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (InjectivityInfo l) x -&gt; InjectivityInfo l
forall l x. InjectivityInfo l -&gt; Rep (InjectivityInfo l) x
$cto :: forall l x. Rep (InjectivityInfo l) x -&gt; InjectivityInfo l
$cfrom :: forall l x. InjectivityInfo l -&gt; Rep (InjectivityInfo l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-388"></span><span>
</span><span id="line-389"></span><span id="local-6989586621679437521"><span id="local-6989586621679437522"></span></span><span class="hs-keyword">data</span><span> </span><span id="ResultSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ResultSig"><span class="hs-identifier hs-var">ResultSig</span></a></span></span><span> </span><span id="local-6989586621679452732"><span class="annot"><a href="#local-6989586621679452732"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="KindSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#KindSig"><span class="hs-identifier hs-var">KindSig</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452732"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452732"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="TyVarSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarSig"><span class="hs-identifier hs-var">TyVarSig</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452732"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier hs-type">TyVarBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452732"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-390"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679437511"><span id="local-6989586621679437517"><span class="annot"><span class="annottext">ResultSig l -&gt; ResultSig l -&gt; Bool
forall l. Eq l =&gt; ResultSig l -&gt; ResultSig l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ResultSig l -&gt; ResultSig l -&gt; Bool
$c/= :: forall l. Eq l =&gt; ResultSig l -&gt; ResultSig l -&gt; Bool
== :: ResultSig l -&gt; ResultSig l -&gt; Bool
$c== :: forall l. Eq l =&gt; ResultSig l -&gt; ResultSig l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437484"><span id="local-6989586621679437486"><span id="local-6989586621679437489"><span id="local-6989586621679437492"><span id="local-6989586621679437495"><span id="local-6989586621679437501"><span id="local-6989586621679437507"><span class="annot"><span class="annottext">ResultSig l -&gt; ResultSig l -&gt; Bool
ResultSig l -&gt; ResultSig l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (ResultSig l)
forall l. Ord l =&gt; ResultSig l -&gt; ResultSig l -&gt; Bool
forall l. Ord l =&gt; ResultSig l -&gt; ResultSig l -&gt; Ordering
forall l. Ord l =&gt; ResultSig l -&gt; ResultSig l -&gt; ResultSig l
min :: ResultSig l -&gt; ResultSig l -&gt; ResultSig l
$cmin :: forall l. Ord l =&gt; ResultSig l -&gt; ResultSig l -&gt; ResultSig l
max :: ResultSig l -&gt; ResultSig l -&gt; ResultSig l
$cmax :: forall l. Ord l =&gt; ResultSig l -&gt; ResultSig l -&gt; ResultSig l
&gt;= :: ResultSig l -&gt; ResultSig l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; ResultSig l -&gt; ResultSig l -&gt; Bool
&gt; :: ResultSig l -&gt; ResultSig l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; ResultSig l -&gt; ResultSig l -&gt; Bool
&lt;= :: ResultSig l -&gt; ResultSig l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; ResultSig l -&gt; ResultSig l -&gt; Bool
&lt; :: ResultSig l -&gt; ResultSig l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; ResultSig l -&gt; ResultSig l -&gt; Bool
compare :: ResultSig l -&gt; ResultSig l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; ResultSig l -&gt; ResultSig l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437472"><span id="local-6989586621679437474"><span id="local-6989586621679437482"><span class="annot"><span class="annottext">Int -&gt; ResultSig l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; ResultSig l -&gt; ShowS
forall l. Show l =&gt; [ResultSig l] -&gt; ShowS
forall l. Show l =&gt; ResultSig l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ResultSig l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [ResultSig l] -&gt; ShowS
show :: ResultSig l -&gt; String
$cshow :: forall l. Show l =&gt; ResultSig l -&gt; String
showsPrec :: Int -&gt; ResultSig l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; ResultSig l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437429"><span id="local-6989586621679437431"><span id="local-6989586621679437433"><span id="local-6989586621679437435"><span id="local-6989586621679437437"><span id="local-6989586621679437439"><span id="local-6989586621679437441"><span id="local-6989586621679437443"><span id="local-6989586621679437445"><span id="local-6989586621679437451"><span id="local-6989586621679437453"><span id="local-6989586621679437455"><span id="local-6989586621679437461"><span id="local-6989586621679437467"><span class="annot"><span class="annottext">ResultSig l -&gt; DataType
ResultSig l -&gt; Constr
forall {l}. Data l =&gt; Typeable (ResultSig l)
forall l. Data l =&gt; ResultSig l -&gt; DataType
forall l. Data l =&gt; ResultSig l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ResultSig l -&gt; ResultSig l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ResultSig l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ResultSig l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ResultSig l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ResultSig l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ResultSig l -&gt; m (ResultSig l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ResultSig l -&gt; m (ResultSig l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ResultSig l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ResultSig l -&gt; c (ResultSig l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ResultSig l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ResultSig l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ResultSig l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ResultSig l -&gt; c (ResultSig l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ResultSig l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ResultSig l -&gt; m (ResultSig l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ResultSig l -&gt; m (ResultSig l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ResultSig l -&gt; m (ResultSig l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ResultSig l -&gt; m (ResultSig l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ResultSig l -&gt; m (ResultSig l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ResultSig l -&gt; m (ResultSig l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ResultSig l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ResultSig l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ResultSig l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ResultSig l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ResultSig l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ResultSig l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ResultSig l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ResultSig l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ResultSig l -&gt; ResultSig l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ResultSig l -&gt; ResultSig l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ResultSig l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ResultSig l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ResultSig l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ResultSig l))
dataTypeOf :: ResultSig l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; ResultSig l -&gt; DataType
toConstr :: ResultSig l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; ResultSig l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ResultSig l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ResultSig l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ResultSig l -&gt; c (ResultSig l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ResultSig l -&gt; c (ResultSig l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437386"><span id="local-6989586621679437388"><span id="local-6989586621679437390"><span id="local-6989586621679437392"><span id="local-6989586621679437394"><span id="local-6989586621679437396"><span id="local-6989586621679437398"><span id="local-6989586621679437400"><span id="local-6989586621679437402"><span id="local-6989586621679437404"><span id="local-6989586621679437406"><span id="local-6989586621679437408"><span id="local-6989586621679437410"><span id="local-6989586621679437414"><span id="local-6989586621679437416"><span id="local-6989586621679437425"><span id="local-6989586621679437427"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; ResultSig a -&gt; Bool
forall a. Num a =&gt; ResultSig a -&gt; a
forall a. Ord a =&gt; ResultSig a -&gt; a
forall m. Monoid m =&gt; ResultSig m -&gt; m
forall a. ResultSig a -&gt; Bool
forall a. ResultSig a -&gt; Int
forall a. ResultSig a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; ResultSig a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ResultSig a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ResultSig a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ResultSig a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; ResultSig a -&gt; a
$cproduct :: forall a. Num a =&gt; ResultSig a -&gt; a
sum :: forall a. Num a =&gt; ResultSig a -&gt; a
$csum :: forall a. Num a =&gt; ResultSig a -&gt; a
minimum :: forall a. Ord a =&gt; ResultSig a -&gt; a
$cminimum :: forall a. Ord a =&gt; ResultSig a -&gt; a
maximum :: forall a. Ord a =&gt; ResultSig a -&gt; a
$cmaximum :: forall a. Ord a =&gt; ResultSig a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; ResultSig a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; ResultSig a -&gt; Bool
length :: forall a. ResultSig a -&gt; Int
$clength :: forall a. ResultSig a -&gt; Int
null :: forall a. ResultSig a -&gt; Bool
$cnull :: forall a. ResultSig a -&gt; Bool
toList :: forall a. ResultSig a -&gt; [a]
$ctoList :: forall a. ResultSig a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ResultSig a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ResultSig a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ResultSig a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ResultSig a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ResultSig a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ResultSig a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ResultSig a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ResultSig a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ResultSig a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ResultSig a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ResultSig a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ResultSig a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ResultSig a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ResultSig a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ResultSig a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ResultSig a -&gt; m
fold :: forall m. Monoid m =&gt; ResultSig m -&gt; m
$cfold :: forall m. Monoid m =&gt; ResultSig m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437367"><span id="local-6989586621679437369"><span id="local-6989586621679437371"><span id="local-6989586621679437380"><span class="annot"><span class="annottext">Functor ResultSig
Foldable ResultSig
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
ResultSig (m a) -&gt; m (ResultSig a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
ResultSig (f a) -&gt; f (ResultSig a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ResultSig a -&gt; m (ResultSig b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ResultSig a -&gt; f (ResultSig b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ResultSig (m a) -&gt; m (ResultSig a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ResultSig (m a) -&gt; m (ResultSig a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ResultSig a -&gt; m (ResultSig b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ResultSig a -&gt; m (ResultSig b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ResultSig (f a) -&gt; f (ResultSig a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ResultSig (f a) -&gt; f (ResultSig a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ResultSig a -&gt; f (ResultSig b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ResultSig a -&gt; f (ResultSig b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679437361"><span id="local-6989586621679437365"><span class="annot"><span class="annottext">forall a b. a -&gt; ResultSig b -&gt; ResultSig a
forall a b. (a -&gt; b) -&gt; ResultSig a -&gt; ResultSig b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; ResultSig b -&gt; ResultSig a
$c&lt;$ :: forall a b. a -&gt; ResultSig b -&gt; ResultSig a
fmap :: forall a b. (a -&gt; b) -&gt; ResultSig a -&gt; ResultSig b
$cfmap :: forall a b. (a -&gt; b) -&gt; ResultSig a -&gt; ResultSig b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (ResultSig l) x -&gt; ResultSig l
forall l x. ResultSig l -&gt; Rep (ResultSig l) x
$cto :: forall l x. Rep (ResultSig l) x -&gt; ResultSig l
$cfrom :: forall l x. ResultSig l -&gt; Rep (ResultSig l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-391"></span><span>
</span><span id="line-392"></span><span class="hs-comment">-- | The head of a type or class declaration, which consists of the type</span><span>
</span><span id="line-393"></span><span class="hs-comment">-- or class name applied to some type variables</span><span>
</span><span id="line-394"></span><span class="hs-comment">--</span><span>
</span><span id="line-395"></span><span class="hs-comment">-- @class C a b@ is represented as</span><span>
</span><span id="line-396"></span><span class="hs-comment">--</span><span>
</span><span id="line-397"></span><span class="hs-comment">-- &gt;DHApp</span><span>
</span><span id="line-398"></span><span class="hs-comment">-- &gt;   ()</span><span>
</span><span id="line-399"></span><span class="hs-comment">-- &gt;   (DHApp</span><span>
</span><span id="line-400"></span><span class="hs-comment">-- &gt;      () (DHead () (Ident () &quot;C&quot;)) (UnkindedVar () (Ident () &quot;a&quot;)))</span><span>
</span><span id="line-401"></span><span class="hs-comment">-- &gt;   (UnkindedVar () (Ident () &quot;b&quot;))</span><span>
</span><span id="line-402"></span><span class="hs-comment">--</span><span>
</span><span id="line-403"></span><span class="hs-comment">-- (where the annotation type @l@ is instantiated with @()@)</span><span>
</span><span id="line-404"></span><span class="hs-comment">--</span><span>
</span><span id="line-405"></span><span class="hs-comment">-- @class (a :&lt; b) c@ is represented as</span><span>
</span><span id="line-406"></span><span class="hs-comment">--</span><span>
</span><span id="line-407"></span><span class="hs-comment">-- &gt;DHApp</span><span>
</span><span id="line-408"></span><span class="hs-comment">-- &gt;   ()</span><span>
</span><span id="line-409"></span><span class="hs-comment">-- &gt;   (DHParen</span><span>
</span><span id="line-410"></span><span class="hs-comment">-- &gt;      ()</span><span>
</span><span id="line-411"></span><span class="hs-comment">-- &gt;      (DHApp</span><span>
</span><span id="line-412"></span><span class="hs-comment">-- &gt;         ()</span><span>
</span><span id="line-413"></span><span class="hs-comment">-- &gt;         (DHInfix () (UnkindedVar () (Ident () &quot;a&quot;)) (Symbol () &quot;:&lt;&quot;))</span><span>
</span><span id="line-414"></span><span class="hs-comment">-- &gt;         (UnkindedVar () (Ident () &quot;b&quot;))))</span><span>
</span><span id="line-415"></span><span class="hs-comment">-- &gt;   (UnkindedVar () (Ident () &quot;c&quot;))</span><span>
</span><span id="line-416"></span><span id="local-6989586621679437354"><span id="local-6989586621679437355"></span></span><span class="hs-keyword">data</span><span> </span><span id="DeclHead"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-var">DeclHead</span></a></span></span><span> </span><span id="local-6989586621679452733"><span class="annot"><a href="#local-6989586621679452733"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-417"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="DHead"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHead"><span class="hs-identifier hs-var">DHead</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452733"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452733"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ type or class name</span><span>
</span><span id="line-418"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="DHInfix"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHInfix"><span class="hs-identifier hs-var">DHInfix</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452733"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier hs-type">TyVarBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452733"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452733"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ infix application of the type/class name to the left operand</span><span>
</span><span id="line-419"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="DHParen"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHParen"><span class="hs-identifier hs-var">DHParen</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452733"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452733"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ parenthesized declaration head</span><span>
</span><span id="line-420"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="DHApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHApp"><span class="hs-identifier hs-var">DHApp</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452733"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452733"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier hs-type">TyVarBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452733"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ application to one more type variable</span><span>
</span><span id="line-421"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679437336"><span id="local-6989586621679437348"><span class="annot"><span class="annottext">DeclHead l -&gt; DeclHead l -&gt; Bool
forall l. Eq l =&gt; DeclHead l -&gt; DeclHead l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DeclHead l -&gt; DeclHead l -&gt; Bool
$c/= :: forall l. Eq l =&gt; DeclHead l -&gt; DeclHead l -&gt; Bool
== :: DeclHead l -&gt; DeclHead l -&gt; Bool
$c== :: forall l. Eq l =&gt; DeclHead l -&gt; DeclHead l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437310"><span id="local-6989586621679437312"><span id="local-6989586621679437314"><span id="local-6989586621679437316"><span id="local-6989586621679437318"><span id="local-6989586621679437320"><span id="local-6989586621679437332"><span class="annot"><span class="annottext">DeclHead l -&gt; DeclHead l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (DeclHead l)
forall l. Ord l =&gt; DeclHead l -&gt; DeclHead l -&gt; Bool
forall l. Ord l =&gt; DeclHead l -&gt; DeclHead l -&gt; Ordering
forall l. Ord l =&gt; DeclHead l -&gt; DeclHead l -&gt; DeclHead l
min :: DeclHead l -&gt; DeclHead l -&gt; DeclHead l
$cmin :: forall l. Ord l =&gt; DeclHead l -&gt; DeclHead l -&gt; DeclHead l
max :: DeclHead l -&gt; DeclHead l -&gt; DeclHead l
$cmax :: forall l. Ord l =&gt; DeclHead l -&gt; DeclHead l -&gt; DeclHead l
&gt;= :: DeclHead l -&gt; DeclHead l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; DeclHead l -&gt; DeclHead l -&gt; Bool
&gt; :: DeclHead l -&gt; DeclHead l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; DeclHead l -&gt; DeclHead l -&gt; Bool
&lt;= :: DeclHead l -&gt; DeclHead l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; DeclHead l -&gt; DeclHead l -&gt; Bool
&lt; :: DeclHead l -&gt; DeclHead l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; DeclHead l -&gt; DeclHead l -&gt; Bool
compare :: DeclHead l -&gt; DeclHead l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; DeclHead l -&gt; DeclHead l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437290"><span id="local-6989586621679437292"><span id="local-6989586621679437308"><span class="annot"><span class="annottext">Int -&gt; DeclHead l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; DeclHead l -&gt; ShowS
forall l. Show l =&gt; [DeclHead l] -&gt; ShowS
forall l. Show l =&gt; DeclHead l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DeclHead l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [DeclHead l] -&gt; ShowS
show :: DeclHead l -&gt; String
$cshow :: forall l. Show l =&gt; DeclHead l -&gt; String
showsPrec :: Int -&gt; DeclHead l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; DeclHead l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679437235"><span id="local-6989586621679437237"><span id="local-6989586621679437239"><span id="local-6989586621679437241"><span id="local-6989586621679437243"><span id="local-6989586621679437245"><span id="local-6989586621679437247"><span id="local-6989586621679437249"><span id="local-6989586621679437251"><span id="local-6989586621679437257"><span id="local-6989586621679437259"><span id="local-6989586621679437261"><span id="local-6989586621679437273"><span id="local-6989586621679437285"><span class="annot"><span class="annottext">DeclHead l -&gt; DataType
DeclHead l -&gt; Constr
forall {l}. Data l =&gt; Typeable (DeclHead l)
forall l. Data l =&gt; DeclHead l -&gt; DataType
forall l. Data l =&gt; DeclHead l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; DeclHead l -&gt; DeclHead l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DeclHead l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; DeclHead l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DeclHead l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DeclHead l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DeclHead l -&gt; m (DeclHead l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DeclHead l -&gt; m (DeclHead l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DeclHead l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DeclHead l -&gt; c (DeclHead l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DeclHead l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DeclHead l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DeclHead l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DeclHead l -&gt; c (DeclHead l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DeclHead l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DeclHead l -&gt; m (DeclHead l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DeclHead l -&gt; m (DeclHead l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DeclHead l -&gt; m (DeclHead l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DeclHead l -&gt; m (DeclHead l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DeclHead l -&gt; m (DeclHead l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DeclHead l -&gt; m (DeclHead l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DeclHead l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DeclHead l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DeclHead l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; DeclHead l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DeclHead l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DeclHead l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DeclHead l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DeclHead l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DeclHead l -&gt; DeclHead l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; DeclHead l -&gt; DeclHead l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DeclHead l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DeclHead l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DeclHead l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DeclHead l))
dataTypeOf :: DeclHead l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; DeclHead l -&gt; DataType
toConstr :: DeclHead l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; DeclHead l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DeclHead l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DeclHead l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DeclHead l -&gt; c (DeclHead l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DeclHead l -&gt; c (DeclHead l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437176"><span id="local-6989586621679437178"><span id="local-6989586621679437180"><span id="local-6989586621679437182"><span id="local-6989586621679437184"><span id="local-6989586621679437186"><span id="local-6989586621679437188"><span id="local-6989586621679437190"><span id="local-6989586621679437192"><span id="local-6989586621679437194"><span id="local-6989586621679437196"><span id="local-6989586621679437198"><span id="local-6989586621679437200"><span id="local-6989586621679437208"><span id="local-6989586621679437210"><span id="local-6989586621679437231"><span id="local-6989586621679437233"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; DeclHead a -&gt; Bool
forall a. Num a =&gt; DeclHead a -&gt; a
forall a. Ord a =&gt; DeclHead a -&gt; a
forall m. Monoid m =&gt; DeclHead m -&gt; m
forall a. DeclHead a -&gt; Bool
forall a. DeclHead a -&gt; Int
forall a. DeclHead a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; DeclHead a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DeclHead a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DeclHead a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DeclHead a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; DeclHead a -&gt; a
$cproduct :: forall a. Num a =&gt; DeclHead a -&gt; a
sum :: forall a. Num a =&gt; DeclHead a -&gt; a
$csum :: forall a. Num a =&gt; DeclHead a -&gt; a
minimum :: forall a. Ord a =&gt; DeclHead a -&gt; a
$cminimum :: forall a. Ord a =&gt; DeclHead a -&gt; a
maximum :: forall a. Ord a =&gt; DeclHead a -&gt; a
$cmaximum :: forall a. Ord a =&gt; DeclHead a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; DeclHead a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; DeclHead a -&gt; Bool
length :: forall a. DeclHead a -&gt; Int
$clength :: forall a. DeclHead a -&gt; Int
null :: forall a. DeclHead a -&gt; Bool
$cnull :: forall a. DeclHead a -&gt; Bool
toList :: forall a. DeclHead a -&gt; [a]
$ctoList :: forall a. DeclHead a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; DeclHead a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; DeclHead a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; DeclHead a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; DeclHead a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DeclHead a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DeclHead a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DeclHead a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DeclHead a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DeclHead a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DeclHead a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DeclHead a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DeclHead a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DeclHead a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DeclHead a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DeclHead a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DeclHead a -&gt; m
fold :: forall m. Monoid m =&gt; DeclHead m -&gt; m
$cfold :: forall m. Monoid m =&gt; DeclHead m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437145"><span id="local-6989586621679437147"><span id="local-6989586621679437149"><span id="local-6989586621679437170"><span class="annot"><span class="annottext">Functor DeclHead
Foldable DeclHead
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; DeclHead (m a) -&gt; m (DeclHead a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
DeclHead (f a) -&gt; f (DeclHead a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DeclHead a -&gt; m (DeclHead b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DeclHead a -&gt; f (DeclHead b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; DeclHead (m a) -&gt; m (DeclHead a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; DeclHead (m a) -&gt; m (DeclHead a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DeclHead a -&gt; m (DeclHead b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DeclHead a -&gt; m (DeclHead b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
DeclHead (f a) -&gt; f (DeclHead a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
DeclHead (f a) -&gt; f (DeclHead a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DeclHead a -&gt; f (DeclHead b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DeclHead a -&gt; f (DeclHead b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437135"><span id="local-6989586621679437143"><span class="annot"><span class="annottext">forall a b. a -&gt; DeclHead b -&gt; DeclHead a
forall a b. (a -&gt; b) -&gt; DeclHead a -&gt; DeclHead b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; DeclHead b -&gt; DeclHead a
$c&lt;$ :: forall a b. a -&gt; DeclHead b -&gt; DeclHead a
fmap :: forall a b. (a -&gt; b) -&gt; DeclHead a -&gt; DeclHead b
$cfmap :: forall a b. (a -&gt; b) -&gt; DeclHead a -&gt; DeclHead b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (DeclHead l) x -&gt; DeclHead l
forall l x. DeclHead l -&gt; Rep (DeclHead l) x
$cto :: forall l x. Rep (DeclHead l) x -&gt; DeclHead l
$cfrom :: forall l x. DeclHead l -&gt; Rep (DeclHead l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-422"></span><span>
</span><span id="line-423"></span><span class="hs-comment">-- | The instance declaration rule, which is, roughly, the part of the instance declaration before the @where@ keyword.</span><span>
</span><span id="line-424"></span><span class="hs-comment">--</span><span>
</span><span id="line-425"></span><span class="hs-comment">-- Example: @instance Ord a =&gt; Ord (Maybe a)@ is represented as</span><span>
</span><span id="line-426"></span><span class="hs-comment">--</span><span>
</span><span id="line-427"></span><span class="hs-comment">-- &gt;IRule</span><span>
</span><span id="line-428"></span><span class="hs-comment">-- &gt;   ()</span><span>
</span><span id="line-429"></span><span class="hs-comment">-- &gt;   Nothing</span><span>
</span><span id="line-430"></span><span class="hs-comment">-- &gt;   (Just</span><span>
</span><span id="line-431"></span><span class="hs-comment">-- &gt;      (CxSingle</span><span>
</span><span id="line-432"></span><span class="hs-comment">-- &gt;         ()</span><span>
</span><span id="line-433"></span><span class="hs-comment">-- &gt;         (ClassA</span><span>
</span><span id="line-434"></span><span class="hs-comment">-- &gt;            () (UnQual () (Ident () &quot;Ord&quot;)) [ TyVar () (Ident () &quot;a&quot;) ])))</span><span>
</span><span id="line-435"></span><span class="hs-comment">-- &gt;   (IHApp</span><span>
</span><span id="line-436"></span><span class="hs-comment">-- &gt;      ()</span><span>
</span><span id="line-437"></span><span class="hs-comment">-- &gt;      (IHCon () (UnQual () (Ident () &quot;Ord&quot;)))</span><span>
</span><span id="line-438"></span><span class="hs-comment">-- &gt;      (TyParen</span><span>
</span><span id="line-439"></span><span class="hs-comment">-- &gt;         ()</span><span>
</span><span id="line-440"></span><span class="hs-comment">-- &gt;         (TyApp</span><span>
</span><span id="line-441"></span><span class="hs-comment">-- &gt;            ()</span><span>
</span><span id="line-442"></span><span class="hs-comment">-- &gt;            (TyCon () (UnQual () (Ident () &quot;Maybe&quot;)))</span><span>
</span><span id="line-443"></span><span class="hs-comment">-- &gt;            (TyVar () (Ident () &quot;a&quot;)))))</span><span>
</span><span id="line-444"></span><span class="hs-comment">--</span><span>
</span><span id="line-445"></span><span class="hs-comment">-- An optional explicit forall after @instance@ is supported:</span><span>
</span><span id="line-446"></span><span class="hs-comment">-- @instance forall a . Ord a =&gt; Ord (Maybe a) where@ becomes</span><span>
</span><span id="line-447"></span><span class="hs-comment">--</span><span>
</span><span id="line-448"></span><span class="hs-comment">-- &gt;IRule</span><span>
</span><span id="line-449"></span><span class="hs-comment">-- &gt;   ()</span><span>
</span><span id="line-450"></span><span class="hs-comment">-- &gt;   (Just [ UnkindedVar () (Ident () &quot;a&quot;) ])</span><span>
</span><span id="line-451"></span><span class="hs-comment">-- &gt;   ...</span><span>
</span><span id="line-452"></span><span id="local-6989586621679437124"><span id="local-6989586621679437125"></span></span><span class="hs-keyword">data</span><span> </span><span id="InstRule"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstRule"><span class="hs-identifier hs-var">InstRule</span></a></span></span><span> </span><span id="local-6989586621679452735"><span class="annot"><a href="#local-6989586621679452735"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-453"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="IRule"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IRule"><span class="hs-identifier hs-var">IRule</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452735"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier hs-type">TyVarBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452735"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452735"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstHead"><span class="hs-identifier hs-type">InstHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452735"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-454"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="IParen"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IParen"><span class="hs-identifier hs-var">IParen</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452735"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstRule"><span class="hs-identifier hs-type">InstRule</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452735"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-455"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679437110"><span id="local-6989586621679437120"><span class="annot"><span class="annottext">InstRule l -&gt; InstRule l -&gt; Bool
forall l. Eq l =&gt; InstRule l -&gt; InstRule l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: InstRule l -&gt; InstRule l -&gt; Bool
$c/= :: forall l. Eq l =&gt; InstRule l -&gt; InstRule l -&gt; Bool
== :: InstRule l -&gt; InstRule l -&gt; Bool
$c== :: forall l. Eq l =&gt; InstRule l -&gt; InstRule l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437074"><span id="local-6989586621679437076"><span id="local-6989586621679437079"><span id="local-6989586621679437082"><span id="local-6989586621679437085"><span id="local-6989586621679437095"><span id="local-6989586621679437105"><span class="annot"><span class="annottext">InstRule l -&gt; InstRule l -&gt; Bool
InstRule l -&gt; InstRule l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (InstRule l)
forall l. Ord l =&gt; InstRule l -&gt; InstRule l -&gt; Bool
forall l. Ord l =&gt; InstRule l -&gt; InstRule l -&gt; Ordering
forall l. Ord l =&gt; InstRule l -&gt; InstRule l -&gt; InstRule l
min :: InstRule l -&gt; InstRule l -&gt; InstRule l
$cmin :: forall l. Ord l =&gt; InstRule l -&gt; InstRule l -&gt; InstRule l
max :: InstRule l -&gt; InstRule l -&gt; InstRule l
$cmax :: forall l. Ord l =&gt; InstRule l -&gt; InstRule l -&gt; InstRule l
&gt;= :: InstRule l -&gt; InstRule l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; InstRule l -&gt; InstRule l -&gt; Bool
&gt; :: InstRule l -&gt; InstRule l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; InstRule l -&gt; InstRule l -&gt; Bool
&lt;= :: InstRule l -&gt; InstRule l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; InstRule l -&gt; InstRule l -&gt; Bool
&lt; :: InstRule l -&gt; InstRule l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; InstRule l -&gt; InstRule l -&gt; Bool
compare :: InstRule l -&gt; InstRule l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; InstRule l -&gt; InstRule l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679437056"><span id="local-6989586621679437058"><span id="local-6989586621679437070"><span class="annot"><span class="annottext">Int -&gt; InstRule l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; InstRule l -&gt; ShowS
forall l. Show l =&gt; [InstRule l] -&gt; ShowS
forall l. Show l =&gt; InstRule l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [InstRule l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [InstRule l] -&gt; ShowS
show :: InstRule l -&gt; String
$cshow :: forall l. Show l =&gt; InstRule l -&gt; String
showsPrec :: Int -&gt; InstRule l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; InstRule l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679437004"><span id="local-6989586621679437006"><span id="local-6989586621679437008"><span id="local-6989586621679437010"><span id="local-6989586621679437012"><span id="local-6989586621679437014"><span id="local-6989586621679437016"><span id="local-6989586621679437018"><span id="local-6989586621679437020"><span id="local-6989586621679437026"><span id="local-6989586621679437028"><span id="local-6989586621679437030"><span id="local-6989586621679437040"><span id="local-6989586621679437050"><span class="annot"><span class="annottext">InstRule l -&gt; DataType
InstRule l -&gt; Constr
forall {l}. Data l =&gt; Typeable (InstRule l)
forall l. Data l =&gt; InstRule l -&gt; DataType
forall l. Data l =&gt; InstRule l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; InstRule l -&gt; InstRule l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InstRule l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; InstRule l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstRule l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstRule l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstRule l -&gt; m (InstRule l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstRule l -&gt; m (InstRule l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstRule l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstRule l -&gt; c (InstRule l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstRule l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InstRule l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstRule l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstRule l -&gt; c (InstRule l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstRule l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstRule l -&gt; m (InstRule l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstRule l -&gt; m (InstRule l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstRule l -&gt; m (InstRule l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstRule l -&gt; m (InstRule l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstRule l -&gt; m (InstRule l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstRule l -&gt; m (InstRule l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InstRule l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InstRule l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; InstRule l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; InstRule l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstRule l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstRule l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstRule l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstRule l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; InstRule l -&gt; InstRule l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; InstRule l -&gt; InstRule l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InstRule l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InstRule l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstRule l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstRule l))
dataTypeOf :: InstRule l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; InstRule l -&gt; DataType
toConstr :: InstRule l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; InstRule l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstRule l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstRule l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstRule l -&gt; c (InstRule l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstRule l -&gt; c (InstRule l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436942"><span id="local-6989586621679436944"><span id="local-6989586621679436946"><span id="local-6989586621679436948"><span id="local-6989586621679436950"><span id="local-6989586621679436952"><span id="local-6989586621679436954"><span id="local-6989586621679436956"><span id="local-6989586621679436958"><span id="local-6989586621679436960"><span id="local-6989586621679436962"><span id="local-6989586621679436964"><span id="local-6989586621679436966"><span id="local-6989586621679436975"><span id="local-6989586621679436977"><span id="local-6989586621679436998"><span id="local-6989586621679437000"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; InstRule a -&gt; Bool
forall a. Num a =&gt; InstRule a -&gt; a
forall a. Ord a =&gt; InstRule a -&gt; a
forall m. Monoid m =&gt; InstRule m -&gt; m
forall a. InstRule a -&gt; Bool
forall a. InstRule a -&gt; Int
forall a. InstRule a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; InstRule a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstRule a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstRule a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstRule a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; InstRule a -&gt; a
$cproduct :: forall a. Num a =&gt; InstRule a -&gt; a
sum :: forall a. Num a =&gt; InstRule a -&gt; a
$csum :: forall a. Num a =&gt; InstRule a -&gt; a
minimum :: forall a. Ord a =&gt; InstRule a -&gt; a
$cminimum :: forall a. Ord a =&gt; InstRule a -&gt; a
maximum :: forall a. Ord a =&gt; InstRule a -&gt; a
$cmaximum :: forall a. Ord a =&gt; InstRule a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; InstRule a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; InstRule a -&gt; Bool
length :: forall a. InstRule a -&gt; Int
$clength :: forall a. InstRule a -&gt; Int
null :: forall a. InstRule a -&gt; Bool
$cnull :: forall a. InstRule a -&gt; Bool
toList :: forall a. InstRule a -&gt; [a]
$ctoList :: forall a. InstRule a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstRule a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstRule a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstRule a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstRule a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstRule a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstRule a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstRule a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstRule a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstRule a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstRule a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstRule a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstRule a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstRule a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstRule a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstRule a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstRule a -&gt; m
fold :: forall m. Monoid m =&gt; InstRule m -&gt; m
$cfold :: forall m. Monoid m =&gt; InstRule m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436911"><span id="local-6989586621679436913"><span id="local-6989586621679436915"><span id="local-6989586621679436936"><span class="annot"><span class="annottext">Functor InstRule
Foldable InstRule
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; InstRule (m a) -&gt; m (InstRule a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
InstRule (f a) -&gt; f (InstRule a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InstRule a -&gt; m (InstRule b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InstRule a -&gt; f (InstRule b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; InstRule (m a) -&gt; m (InstRule a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; InstRule (m a) -&gt; m (InstRule a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InstRule a -&gt; m (InstRule b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InstRule a -&gt; m (InstRule b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
InstRule (f a) -&gt; f (InstRule a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
InstRule (f a) -&gt; f (InstRule a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InstRule a -&gt; f (InstRule b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InstRule a -&gt; f (InstRule b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436899"><span id="local-6989586621679436909"><span class="annot"><span class="annottext">forall a b. a -&gt; InstRule b -&gt; InstRule a
forall a b. (a -&gt; b) -&gt; InstRule a -&gt; InstRule b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; InstRule b -&gt; InstRule a
$c&lt;$ :: forall a b. a -&gt; InstRule b -&gt; InstRule a
fmap :: forall a b. (a -&gt; b) -&gt; InstRule a -&gt; InstRule b
$cfmap :: forall a b. (a -&gt; b) -&gt; InstRule a -&gt; InstRule b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (InstRule l) x -&gt; InstRule l
forall l x. InstRule l -&gt; Rep (InstRule l) x
$cto :: forall l x. Rep (InstRule l) x -&gt; InstRule l
$cfrom :: forall l x. InstRule l -&gt; Rep (InstRule l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-456"></span><span>
</span><span id="line-457"></span><span class="hs-comment">-- See bugs #7 and #31 for more details and use cases for the rationale</span><span>
</span><span id="line-458"></span><span class="hs-comment">-- of the split. DeclOrInstHead should be used by DeclHead as the name implies.</span><span>
</span><span id="line-459"></span><span>
</span><span id="line-460"></span><span class="hs-comment">-- | The instance head. The split between rule/head allow us to represent</span><span>
</span><span id="line-461"></span><span class="hs-comment">-- @instance (Bounded a =&gt; Bounded [a]) where@ faithfully.</span><span>
</span><span id="line-462"></span><span class="hs-comment">--</span><span>
</span><span id="line-463"></span><span class="hs-comment">-- The structure of 'InstHead' follows one of 'DeclHead'.</span><span>
</span><span id="line-464"></span><span class="hs-comment">--</span><span>
</span><span id="line-465"></span><span class="hs-comment">-- For example, @instance C (Maybe a) Int where@ is represented as</span><span>
</span><span id="line-466"></span><span class="hs-comment">--</span><span>
</span><span id="line-467"></span><span class="hs-comment">-- &gt;IHApp</span><span>
</span><span id="line-468"></span><span class="hs-comment">-- &gt;   ()</span><span>
</span><span id="line-469"></span><span class="hs-comment">-- &gt;   (IHApp</span><span>
</span><span id="line-470"></span><span class="hs-comment">-- &gt;      ()</span><span>
</span><span id="line-471"></span><span class="hs-comment">-- &gt;      (IHCon () (UnQual () (Ident () &quot;C&quot;)))</span><span>
</span><span id="line-472"></span><span class="hs-comment">-- &gt;      (TyParen</span><span>
</span><span id="line-473"></span><span class="hs-comment">-- &gt;         ()</span><span>
</span><span id="line-474"></span><span class="hs-comment">-- &gt;         (TyApp</span><span>
</span><span id="line-475"></span><span class="hs-comment">-- &gt;            ()</span><span>
</span><span id="line-476"></span><span class="hs-comment">-- &gt;            (TyCon () (UnQual () (Ident () &quot;Maybe&quot;)))</span><span>
</span><span id="line-477"></span><span class="hs-comment">-- &gt;            (TyVar () (Ident () &quot;a&quot;)))))</span><span>
</span><span id="line-478"></span><span class="hs-comment">-- &gt;   (TyCon () (UnQual () (Ident () &quot;Int&quot;)))))</span><span>
</span><span id="line-479"></span><span id="local-6989586621679436887"><span id="local-6989586621679436888"></span></span><span class="hs-keyword">data</span><span> </span><span id="InstHead"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstHead"><span class="hs-identifier hs-var">InstHead</span></a></span></span><span> </span><span id="local-6989586621679452670"><span class="annot"><a href="#local-6989586621679452670"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-480"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="IHCon"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHCon"><span class="hs-identifier hs-var">IHCon</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452670"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452670"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ type or class name</span><span>
</span><span id="line-481"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="IHInfix"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHInfix"><span class="hs-identifier hs-var">IHInfix</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452670"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452670"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452670"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ infix application of the type/class name to the left operand</span><span>
</span><span id="line-482"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="IHParen"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHParen"><span class="hs-identifier hs-var">IHParen</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452670"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstHead"><span class="hs-identifier hs-type">InstHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452670"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ parenthesized instance head</span><span>
</span><span id="line-483"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="IHApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHApp"><span class="hs-identifier hs-var">IHApp</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452670"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstHead"><span class="hs-identifier hs-type">InstHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452670"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452670"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ application to one more type</span><span>
</span><span id="line-484"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679436869"><span id="local-6989586621679436881"><span class="annot"><span class="annottext">InstHead l -&gt; InstHead l -&gt; Bool
forall l. Eq l =&gt; InstHead l -&gt; InstHead l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: InstHead l -&gt; InstHead l -&gt; Bool
$c/= :: forall l. Eq l =&gt; InstHead l -&gt; InstHead l -&gt; Bool
== :: InstHead l -&gt; InstHead l -&gt; Bool
$c== :: forall l. Eq l =&gt; InstHead l -&gt; InstHead l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436843"><span id="local-6989586621679436845"><span id="local-6989586621679436847"><span id="local-6989586621679436849"><span id="local-6989586621679436851"><span id="local-6989586621679436853"><span id="local-6989586621679436865"><span class="annot"><span class="annottext">InstHead l -&gt; InstHead l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (InstHead l)
forall l. Ord l =&gt; InstHead l -&gt; InstHead l -&gt; Bool
forall l. Ord l =&gt; InstHead l -&gt; InstHead l -&gt; Ordering
forall l. Ord l =&gt; InstHead l -&gt; InstHead l -&gt; InstHead l
min :: InstHead l -&gt; InstHead l -&gt; InstHead l
$cmin :: forall l. Ord l =&gt; InstHead l -&gt; InstHead l -&gt; InstHead l
max :: InstHead l -&gt; InstHead l -&gt; InstHead l
$cmax :: forall l. Ord l =&gt; InstHead l -&gt; InstHead l -&gt; InstHead l
&gt;= :: InstHead l -&gt; InstHead l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; InstHead l -&gt; InstHead l -&gt; Bool
&gt; :: InstHead l -&gt; InstHead l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; InstHead l -&gt; InstHead l -&gt; Bool
&lt;= :: InstHead l -&gt; InstHead l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; InstHead l -&gt; InstHead l -&gt; Bool
&lt; :: InstHead l -&gt; InstHead l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; InstHead l -&gt; InstHead l -&gt; Bool
compare :: InstHead l -&gt; InstHead l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; InstHead l -&gt; InstHead l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436823"><span id="local-6989586621679436825"><span id="local-6989586621679436841"><span class="annot"><span class="annottext">Int -&gt; InstHead l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; InstHead l -&gt; ShowS
forall l. Show l =&gt; [InstHead l] -&gt; ShowS
forall l. Show l =&gt; InstHead l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [InstHead l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [InstHead l] -&gt; ShowS
show :: InstHead l -&gt; String
$cshow :: forall l. Show l =&gt; InstHead l -&gt; String
showsPrec :: Int -&gt; InstHead l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; InstHead l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679436768"><span id="local-6989586621679436770"><span id="local-6989586621679436772"><span id="local-6989586621679436774"><span id="local-6989586621679436776"><span id="local-6989586621679436778"><span id="local-6989586621679436780"><span id="local-6989586621679436782"><span id="local-6989586621679436784"><span id="local-6989586621679436790"><span id="local-6989586621679436792"><span id="local-6989586621679436794"><span id="local-6989586621679436806"><span id="local-6989586621679436818"><span class="annot"><span class="annottext">InstHead l -&gt; DataType
InstHead l -&gt; Constr
forall {l}. Data l =&gt; Typeable (InstHead l)
forall l. Data l =&gt; InstHead l -&gt; DataType
forall l. Data l =&gt; InstHead l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; InstHead l -&gt; InstHead l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InstHead l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; InstHead l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstHead l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstHead l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstHead l -&gt; m (InstHead l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstHead l -&gt; m (InstHead l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstHead l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstHead l -&gt; c (InstHead l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstHead l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InstHead l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstHead l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstHead l -&gt; c (InstHead l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstHead l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstHead l -&gt; m (InstHead l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstHead l -&gt; m (InstHead l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstHead l -&gt; m (InstHead l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstHead l -&gt; m (InstHead l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstHead l -&gt; m (InstHead l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstHead l -&gt; m (InstHead l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InstHead l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InstHead l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; InstHead l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; InstHead l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstHead l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstHead l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstHead l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstHead l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; InstHead l -&gt; InstHead l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; InstHead l -&gt; InstHead l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InstHead l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InstHead l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstHead l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstHead l))
dataTypeOf :: InstHead l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; InstHead l -&gt; DataType
toConstr :: InstHead l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; InstHead l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstHead l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstHead l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstHead l -&gt; c (InstHead l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstHead l -&gt; c (InstHead l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436709"><span id="local-6989586621679436711"><span id="local-6989586621679436713"><span id="local-6989586621679436715"><span id="local-6989586621679436717"><span id="local-6989586621679436719"><span id="local-6989586621679436721"><span id="local-6989586621679436723"><span id="local-6989586621679436725"><span id="local-6989586621679436727"><span id="local-6989586621679436729"><span id="local-6989586621679436731"><span id="local-6989586621679436733"><span id="local-6989586621679436741"><span id="local-6989586621679436743"><span id="local-6989586621679436764"><span id="local-6989586621679436766"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; InstHead a -&gt; Bool
forall a. Num a =&gt; InstHead a -&gt; a
forall a. Ord a =&gt; InstHead a -&gt; a
forall m. Monoid m =&gt; InstHead m -&gt; m
forall a. InstHead a -&gt; Bool
forall a. InstHead a -&gt; Int
forall a. InstHead a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; InstHead a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstHead a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstHead a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstHead a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; InstHead a -&gt; a
$cproduct :: forall a. Num a =&gt; InstHead a -&gt; a
sum :: forall a. Num a =&gt; InstHead a -&gt; a
$csum :: forall a. Num a =&gt; InstHead a -&gt; a
minimum :: forall a. Ord a =&gt; InstHead a -&gt; a
$cminimum :: forall a. Ord a =&gt; InstHead a -&gt; a
maximum :: forall a. Ord a =&gt; InstHead a -&gt; a
$cmaximum :: forall a. Ord a =&gt; InstHead a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; InstHead a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; InstHead a -&gt; Bool
length :: forall a. InstHead a -&gt; Int
$clength :: forall a. InstHead a -&gt; Int
null :: forall a. InstHead a -&gt; Bool
$cnull :: forall a. InstHead a -&gt; Bool
toList :: forall a. InstHead a -&gt; [a]
$ctoList :: forall a. InstHead a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstHead a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstHead a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstHead a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstHead a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstHead a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstHead a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstHead a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstHead a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstHead a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstHead a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstHead a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstHead a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstHead a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstHead a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstHead a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstHead a -&gt; m
fold :: forall m. Monoid m =&gt; InstHead m -&gt; m
$cfold :: forall m. Monoid m =&gt; InstHead m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436678"><span id="local-6989586621679436680"><span id="local-6989586621679436682"><span id="local-6989586621679436703"><span class="annot"><span class="annottext">Functor InstHead
Foldable InstHead
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; InstHead (m a) -&gt; m (InstHead a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
InstHead (f a) -&gt; f (InstHead a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InstHead a -&gt; m (InstHead b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InstHead a -&gt; f (InstHead b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; InstHead (m a) -&gt; m (InstHead a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; InstHead (m a) -&gt; m (InstHead a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InstHead a -&gt; m (InstHead b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InstHead a -&gt; m (InstHead b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
InstHead (f a) -&gt; f (InstHead a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
InstHead (f a) -&gt; f (InstHead a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InstHead a -&gt; f (InstHead b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InstHead a -&gt; f (InstHead b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436668"><span id="local-6989586621679436676"><span class="annot"><span class="annottext">forall a b. a -&gt; InstHead b -&gt; InstHead a
forall a b. (a -&gt; b) -&gt; InstHead a -&gt; InstHead b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; InstHead b -&gt; InstHead a
$c&lt;$ :: forall a b. a -&gt; InstHead b -&gt; InstHead a
fmap :: forall a b. (a -&gt; b) -&gt; InstHead a -&gt; InstHead b
$cfmap :: forall a b. (a -&gt; b) -&gt; InstHead a -&gt; InstHead b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (InstHead l) x -&gt; InstHead l
forall l x. InstHead l -&gt; Rep (InstHead l) x
$cto :: forall l x. Rep (InstHead l) x -&gt; InstHead l
$cfrom :: forall l x. InstHead l -&gt; Rep (InstHead l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-485"></span><span>
</span><span id="line-486"></span><span class="hs-comment">-- | A deriving clause following a data type declaration.</span><span>
</span><span id="line-487"></span><span id="local-6989586621679436657"><span id="local-6989586621679436658"></span></span><span class="hs-keyword">data</span><span> </span><span id="Deriving"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-var">Deriving</span></a></span></span><span> </span><span id="local-6989586621679452737"><span class="annot"><a href="#local-6989586621679452737"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Deriving"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-var">Deriving</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452737"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivStrategy"><span class="hs-identifier hs-type">DerivStrategy</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452737"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstRule"><span class="hs-identifier hs-type">InstRule</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452737"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-488"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679436647"><span id="local-6989586621679436654"><span class="annot"><span class="annottext">Deriving l -&gt; Deriving l -&gt; Bool
forall l. Eq l =&gt; Deriving l -&gt; Deriving l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Deriving l -&gt; Deriving l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Deriving l -&gt; Deriving l -&gt; Bool
== :: Deriving l -&gt; Deriving l -&gt; Bool
$c== :: forall l. Eq l =&gt; Deriving l -&gt; Deriving l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436618"><span id="local-6989586621679436620"><span id="local-6989586621679436623"><span id="local-6989586621679436626"><span id="local-6989586621679436629"><span id="local-6989586621679436636"><span id="local-6989586621679436643"><span class="annot"><span class="annottext">Deriving l -&gt; Deriving l -&gt; Bool
Deriving l -&gt; Deriving l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Deriving l)
forall l. Ord l =&gt; Deriving l -&gt; Deriving l -&gt; Bool
forall l. Ord l =&gt; Deriving l -&gt; Deriving l -&gt; Ordering
forall l. Ord l =&gt; Deriving l -&gt; Deriving l -&gt; Deriving l
min :: Deriving l -&gt; Deriving l -&gt; Deriving l
$cmin :: forall l. Ord l =&gt; Deriving l -&gt; Deriving l -&gt; Deriving l
max :: Deriving l -&gt; Deriving l -&gt; Deriving l
$cmax :: forall l. Ord l =&gt; Deriving l -&gt; Deriving l -&gt; Deriving l
&gt;= :: Deriving l -&gt; Deriving l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Deriving l -&gt; Deriving l -&gt; Bool
&gt; :: Deriving l -&gt; Deriving l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Deriving l -&gt; Deriving l -&gt; Bool
&lt;= :: Deriving l -&gt; Deriving l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Deriving l -&gt; Deriving l -&gt; Bool
&lt; :: Deriving l -&gt; Deriving l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Deriving l -&gt; Deriving l -&gt; Bool
compare :: Deriving l -&gt; Deriving l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Deriving l -&gt; Deriving l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436606"><span id="local-6989586621679436608"><span id="local-6989586621679436616"><span class="annot"><span class="annottext">Int -&gt; Deriving l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Deriving l -&gt; ShowS
forall l. Show l =&gt; [Deriving l] -&gt; ShowS
forall l. Show l =&gt; Deriving l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Deriving l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Deriving l] -&gt; ShowS
show :: Deriving l -&gt; String
$cshow :: forall l. Show l =&gt; Deriving l -&gt; String
showsPrec :: Int -&gt; Deriving l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Deriving l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679436561"><span id="local-6989586621679436563"><span id="local-6989586621679436565"><span id="local-6989586621679436567"><span id="local-6989586621679436569"><span id="local-6989586621679436571"><span id="local-6989586621679436573"><span id="local-6989586621679436575"><span id="local-6989586621679436577"><span id="local-6989586621679436583"><span id="local-6989586621679436585"><span id="local-6989586621679436587"><span id="local-6989586621679436594"><span id="local-6989586621679436601"><span class="annot"><span class="annottext">Deriving l -&gt; DataType
Deriving l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Deriving l)
forall l. Data l =&gt; Deriving l -&gt; DataType
forall l. Data l =&gt; Deriving l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Deriving l -&gt; Deriving l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Deriving l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Deriving l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Deriving l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Deriving l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Deriving l -&gt; m (Deriving l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Deriving l -&gt; m (Deriving l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Deriving l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Deriving l -&gt; c (Deriving l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Deriving l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Deriving l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Deriving l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Deriving l -&gt; c (Deriving l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Deriving l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Deriving l -&gt; m (Deriving l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Deriving l -&gt; m (Deriving l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Deriving l -&gt; m (Deriving l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Deriving l -&gt; m (Deriving l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Deriving l -&gt; m (Deriving l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Deriving l -&gt; m (Deriving l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Deriving l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Deriving l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Deriving l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Deriving l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Deriving l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Deriving l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Deriving l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Deriving l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Deriving l -&gt; Deriving l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Deriving l -&gt; Deriving l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Deriving l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Deriving l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Deriving l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Deriving l))
dataTypeOf :: Deriving l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Deriving l -&gt; DataType
toConstr :: Deriving l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Deriving l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Deriving l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Deriving l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Deriving l -&gt; c (Deriving l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Deriving l -&gt; c (Deriving l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436512"><span id="local-6989586621679436514"><span id="local-6989586621679436516"><span id="local-6989586621679436518"><span id="local-6989586621679436520"><span id="local-6989586621679436522"><span id="local-6989586621679436524"><span id="local-6989586621679436526"><span id="local-6989586621679436528"><span id="local-6989586621679436530"><span id="local-6989586621679436532"><span id="local-6989586621679436534"><span id="local-6989586621679436536"><span id="local-6989586621679436542"><span id="local-6989586621679436544"><span id="local-6989586621679436557"><span id="local-6989586621679436559"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Deriving a -&gt; Bool
forall a. Num a =&gt; Deriving a -&gt; a
forall a. Ord a =&gt; Deriving a -&gt; a
forall m. Monoid m =&gt; Deriving m -&gt; m
forall a. Deriving a -&gt; Bool
forall a. Deriving a -&gt; Int
forall a. Deriving a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Deriving a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Deriving a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Deriving a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Deriving a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Deriving a -&gt; a
$cproduct :: forall a. Num a =&gt; Deriving a -&gt; a
sum :: forall a. Num a =&gt; Deriving a -&gt; a
$csum :: forall a. Num a =&gt; Deriving a -&gt; a
minimum :: forall a. Ord a =&gt; Deriving a -&gt; a
$cminimum :: forall a. Ord a =&gt; Deriving a -&gt; a
maximum :: forall a. Ord a =&gt; Deriving a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Deriving a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Deriving a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Deriving a -&gt; Bool
length :: forall a. Deriving a -&gt; Int
$clength :: forall a. Deriving a -&gt; Int
null :: forall a. Deriving a -&gt; Bool
$cnull :: forall a. Deriving a -&gt; Bool
toList :: forall a. Deriving a -&gt; [a]
$ctoList :: forall a. Deriving a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Deriving a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Deriving a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Deriving a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Deriving a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Deriving a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Deriving a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Deriving a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Deriving a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Deriving a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Deriving a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Deriving a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Deriving a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Deriving a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Deriving a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Deriving a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Deriving a -&gt; m
fold :: forall m. Monoid m =&gt; Deriving m -&gt; m
$cfold :: forall m. Monoid m =&gt; Deriving m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436489"><span id="local-6989586621679436491"><span id="local-6989586621679436493"><span id="local-6989586621679436506"><span class="annot"><span class="annottext">Functor Deriving
Foldable Deriving
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Deriving (m a) -&gt; m (Deriving a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Deriving (f a) -&gt; f (Deriving a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Deriving a -&gt; m (Deriving b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Deriving a -&gt; f (Deriving b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Deriving (m a) -&gt; m (Deriving a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Deriving (m a) -&gt; m (Deriving a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Deriving a -&gt; m (Deriving b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Deriving a -&gt; m (Deriving b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Deriving (f a) -&gt; f (Deriving a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Deriving (f a) -&gt; f (Deriving a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Deriving a -&gt; f (Deriving b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Deriving a -&gt; f (Deriving b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436481"><span id="local-6989586621679436487"><span class="annot"><span class="annottext">forall a b. a -&gt; Deriving b -&gt; Deriving a
forall a b. (a -&gt; b) -&gt; Deriving a -&gt; Deriving b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Deriving b -&gt; Deriving a
$c&lt;$ :: forall a b. a -&gt; Deriving b -&gt; Deriving a
fmap :: forall a b. (a -&gt; b) -&gt; Deriving a -&gt; Deriving b
$cfmap :: forall a b. (a -&gt; b) -&gt; Deriving a -&gt; Deriving b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Deriving l) x -&gt; Deriving l
forall l x. Deriving l -&gt; Rep (Deriving l) x
$cto :: forall l x. Rep (Deriving l) x -&gt; Deriving l
$cfrom :: forall l x. Deriving l -&gt; Rep (Deriving l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-489"></span><span>
</span><span id="line-490"></span><span class="hs-comment">-- | Which technique the user explicitly requested when deriving an instance.</span><span>
</span><span id="line-491"></span><span id="local-6989586621679436472"><span id="local-6989586621679436473"></span></span><span class="hs-keyword">data</span><span> </span><span id="DerivStrategy"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivStrategy"><span class="hs-identifier hs-var">DerivStrategy</span></a></span></span><span> </span><span id="local-6989586621679452736"><span class="annot"><a href="#local-6989586621679452736"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-492"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="DerivStock"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivStock"><span class="hs-identifier hs-var">DerivStock</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452736"><span class="hs-identifier hs-type">l</span></a></span><span>        </span><span class="hs-comment">-- ^ GHC's \&quot;standard\&quot; strategy, which is to implement a</span><span>
</span><span id="line-493"></span><span>                        </span><span class="hs-comment">--   custom instance for the data type. This only works for</span><span>
</span><span id="line-494"></span><span>                        </span><span class="hs-comment">--   certain types that GHC knows about (e.g., 'Eq', 'Show',</span><span>
</span><span id="line-495"></span><span>                        </span><span class="hs-comment">--   'Functor' when @-XDeriveFunctor@ is enabled, etc.)</span><span>
</span><span id="line-496"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DerivAnyclass"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivAnyclass"><span class="hs-identifier hs-var">DerivAnyclass</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452736"><span class="hs-identifier hs-type">l</span></a></span><span>     </span><span class="hs-comment">-- ^ @-XDeriveAnyClass@</span><span>
</span><span id="line-497"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DerivNewtype"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivNewtype"><span class="hs-identifier hs-var">DerivNewtype</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452736"><span class="hs-identifier hs-type">l</span></a></span><span>      </span><span class="hs-comment">-- ^ @-XGeneralizedNewtypeDeriving@</span><span>
</span><span id="line-498"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DerivVia"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivVia"><span class="hs-identifier hs-var">DerivVia</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452736"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452736"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ @-XDerivingVia@</span><span>
</span><span id="line-499"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679436459"><span id="local-6989586621679436466"><span class="annot"><span class="annottext">DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
forall l. Eq l =&gt; DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
$c/= :: forall l. Eq l =&gt; DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
== :: DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
$c== :: forall l. Eq l =&gt; DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436438"><span id="local-6989586621679436440"><span id="local-6989586621679436442"><span id="local-6989586621679436444"><span id="local-6989586621679436446"><span id="local-6989586621679436448"><span id="local-6989586621679436455"><span class="annot"><span class="annottext">DerivStrategy l -&gt; DerivStrategy l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (DerivStrategy l)
forall l. Ord l =&gt; DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
forall l. Ord l =&gt; DerivStrategy l -&gt; DerivStrategy l -&gt; Ordering
forall l.
Ord l =&gt;
DerivStrategy l -&gt; DerivStrategy l -&gt; DerivStrategy l
min :: DerivStrategy l -&gt; DerivStrategy l -&gt; DerivStrategy l
$cmin :: forall l.
Ord l =&gt;
DerivStrategy l -&gt; DerivStrategy l -&gt; DerivStrategy l
max :: DerivStrategy l -&gt; DerivStrategy l -&gt; DerivStrategy l
$cmax :: forall l.
Ord l =&gt;
DerivStrategy l -&gt; DerivStrategy l -&gt; DerivStrategy l
&gt;= :: DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
&gt; :: DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
&lt;= :: DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
&lt; :: DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; DerivStrategy l -&gt; DerivStrategy l -&gt; Bool
compare :: DerivStrategy l -&gt; DerivStrategy l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; DerivStrategy l -&gt; DerivStrategy l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436423"><span id="local-6989586621679436425"><span id="local-6989586621679436436"><span class="annot"><span class="annottext">Int -&gt; DerivStrategy l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; DerivStrategy l -&gt; ShowS
forall l. Show l =&gt; [DerivStrategy l] -&gt; ShowS
forall l. Show l =&gt; DerivStrategy l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DerivStrategy l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [DerivStrategy l] -&gt; ShowS
show :: DerivStrategy l -&gt; String
$cshow :: forall l. Show l =&gt; DerivStrategy l -&gt; String
showsPrec :: Int -&gt; DerivStrategy l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; DerivStrategy l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679436378"><span id="local-6989586621679436380"><span id="local-6989586621679436382"><span id="local-6989586621679436384"><span id="local-6989586621679436386"><span id="local-6989586621679436388"><span id="local-6989586621679436390"><span id="local-6989586621679436392"><span id="local-6989586621679436394"><span id="local-6989586621679436400"><span id="local-6989586621679436402"><span id="local-6989586621679436404"><span id="local-6989586621679436411"><span id="local-6989586621679436418"><span class="annot"><span class="annottext">DerivStrategy l -&gt; DataType
DerivStrategy l -&gt; Constr
forall {l}. Data l =&gt; Typeable (DerivStrategy l)
forall l. Data l =&gt; DerivStrategy l -&gt; DataType
forall l. Data l =&gt; DerivStrategy l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; DerivStrategy l -&gt; DerivStrategy l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DerivStrategy l -&gt; m (DerivStrategy l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DerivStrategy l -&gt; m (DerivStrategy l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DerivStrategy l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DerivStrategy l -&gt; c (DerivStrategy l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DerivStrategy l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DerivStrategy l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DerivStrategy l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DerivStrategy l -&gt; c (DerivStrategy l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DerivStrategy l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DerivStrategy l -&gt; m (DerivStrategy l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DerivStrategy l -&gt; m (DerivStrategy l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DerivStrategy l -&gt; m (DerivStrategy l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DerivStrategy l -&gt; m (DerivStrategy l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DerivStrategy l -&gt; m (DerivStrategy l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DerivStrategy l -&gt; m (DerivStrategy l)
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; DerivStrategy l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DerivStrategy l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DerivStrategy l -&gt; DerivStrategy l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; DerivStrategy l -&gt; DerivStrategy l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DerivStrategy l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (DerivStrategy l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DerivStrategy l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (DerivStrategy l))
dataTypeOf :: DerivStrategy l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; DerivStrategy l -&gt; DataType
toConstr :: DerivStrategy l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; DerivStrategy l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DerivStrategy l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (DerivStrategy l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DerivStrategy l -&gt; c (DerivStrategy l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DerivStrategy l -&gt; c (DerivStrategy l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436339"><span id="local-6989586621679436341"><span id="local-6989586621679436343"><span id="local-6989586621679436345"><span id="local-6989586621679436347"><span id="local-6989586621679436349"><span id="local-6989586621679436351"><span id="local-6989586621679436353"><span id="local-6989586621679436355"><span id="local-6989586621679436357"><span id="local-6989586621679436359"><span id="local-6989586621679436361"><span id="local-6989586621679436363"><span id="local-6989586621679436366"><span id="local-6989586621679436368"><span id="local-6989586621679436374"><span id="local-6989586621679436376"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; DerivStrategy a -&gt; Bool
forall a. Num a =&gt; DerivStrategy a -&gt; a
forall a. Ord a =&gt; DerivStrategy a -&gt; a
forall m. Monoid m =&gt; DerivStrategy m -&gt; m
forall a. DerivStrategy a -&gt; Bool
forall a. DerivStrategy a -&gt; Int
forall a. DerivStrategy a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; DerivStrategy a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DerivStrategy a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DerivStrategy a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DerivStrategy a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; DerivStrategy a -&gt; a
$cproduct :: forall a. Num a =&gt; DerivStrategy a -&gt; a
sum :: forall a. Num a =&gt; DerivStrategy a -&gt; a
$csum :: forall a. Num a =&gt; DerivStrategy a -&gt; a
minimum :: forall a. Ord a =&gt; DerivStrategy a -&gt; a
$cminimum :: forall a. Ord a =&gt; DerivStrategy a -&gt; a
maximum :: forall a. Ord a =&gt; DerivStrategy a -&gt; a
$cmaximum :: forall a. Ord a =&gt; DerivStrategy a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; DerivStrategy a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; DerivStrategy a -&gt; Bool
length :: forall a. DerivStrategy a -&gt; Int
$clength :: forall a. DerivStrategy a -&gt; Int
null :: forall a. DerivStrategy a -&gt; Bool
$cnull :: forall a. DerivStrategy a -&gt; Bool
toList :: forall a. DerivStrategy a -&gt; [a]
$ctoList :: forall a. DerivStrategy a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; DerivStrategy a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; DerivStrategy a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; DerivStrategy a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; DerivStrategy a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DerivStrategy a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DerivStrategy a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DerivStrategy a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; DerivStrategy a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DerivStrategy a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DerivStrategy a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DerivStrategy a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; DerivStrategy a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DerivStrategy a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DerivStrategy a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DerivStrategy a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; DerivStrategy a -&gt; m
fold :: forall m. Monoid m =&gt; DerivStrategy m -&gt; m
$cfold :: forall m. Monoid m =&gt; DerivStrategy m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436319"><span id="local-6989586621679436321"><span id="local-6989586621679436323"><span id="local-6989586621679436333"><span class="annot"><span class="annottext">Functor DerivStrategy
Foldable DerivStrategy
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
DerivStrategy (m a) -&gt; m (DerivStrategy a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
DerivStrategy (f a) -&gt; f (DerivStrategy a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DerivStrategy a -&gt; m (DerivStrategy b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DerivStrategy a -&gt; f (DerivStrategy b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
DerivStrategy (m a) -&gt; m (DerivStrategy a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
DerivStrategy (m a) -&gt; m (DerivStrategy a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DerivStrategy a -&gt; m (DerivStrategy b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; DerivStrategy a -&gt; m (DerivStrategy b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
DerivStrategy (f a) -&gt; f (DerivStrategy a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
DerivStrategy (f a) -&gt; f (DerivStrategy a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DerivStrategy a -&gt; f (DerivStrategy b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; DerivStrategy a -&gt; f (DerivStrategy b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436314"><span id="local-6989586621679436317"><span class="annot"><span class="annottext">forall a b. a -&gt; DerivStrategy b -&gt; DerivStrategy a
forall a b. (a -&gt; b) -&gt; DerivStrategy a -&gt; DerivStrategy b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; DerivStrategy b -&gt; DerivStrategy a
$c&lt;$ :: forall a b. a -&gt; DerivStrategy b -&gt; DerivStrategy a
fmap :: forall a b. (a -&gt; b) -&gt; DerivStrategy a -&gt; DerivStrategy b
$cfmap :: forall a b. (a -&gt; b) -&gt; DerivStrategy a -&gt; DerivStrategy b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (DerivStrategy l) x -&gt; DerivStrategy l
forall l x. DerivStrategy l -&gt; Rep (DerivStrategy l) x
$cto :: forall l x. Rep (DerivStrategy l) x -&gt; DerivStrategy l
$cfrom :: forall l x. DerivStrategy l -&gt; Rep (DerivStrategy l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-500"></span><span>
</span><span id="line-501"></span><span class="hs-comment">-- | A binding group inside a @let@ or @where@ clause.</span><span>
</span><span id="line-502"></span><span id="local-6989586621679436308"><span id="local-6989586621679436309"></span></span><span class="hs-keyword">data</span><span> </span><span id="Binds"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Binds"><span class="hs-identifier hs-var">Binds</span></a></span></span><span> </span><span id="local-6989586621679452729"><span class="annot"><a href="#local-6989586621679452729"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-503"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="BDecls"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BDecls"><span class="hs-identifier hs-var">BDecls</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452729"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452729"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">-- ^ An ordinary binding group</span><span>
</span><span id="line-504"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="IPBinds"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPBinds"><span class="hs-identifier hs-var">IPBinds</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452729"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPBind"><span class="hs-identifier hs-type">IPBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452729"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>   </span><span class="hs-comment">-- ^ A binding group for implicit parameters</span><span>
</span><span id="line-505"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679436296"><span id="local-6989586621679436304"><span class="annot"><span class="annottext">Binds l -&gt; Binds l -&gt; Bool
forall l. Eq l =&gt; Binds l -&gt; Binds l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Binds l -&gt; Binds l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Binds l -&gt; Binds l -&gt; Bool
== :: Binds l -&gt; Binds l -&gt; Bool
$c== :: forall l. Eq l =&gt; Binds l -&gt; Binds l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436265"><span id="local-6989586621679436267"><span id="local-6989586621679436270"><span id="local-6989586621679436273"><span id="local-6989586621679436276"><span id="local-6989586621679436284"><span id="local-6989586621679436292"><span class="annot"><span class="annottext">Binds l -&gt; Binds l -&gt; Bool
Binds l -&gt; Binds l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Binds l)
forall l. Ord l =&gt; Binds l -&gt; Binds l -&gt; Bool
forall l. Ord l =&gt; Binds l -&gt; Binds l -&gt; Ordering
forall l. Ord l =&gt; Binds l -&gt; Binds l -&gt; Binds l
min :: Binds l -&gt; Binds l -&gt; Binds l
$cmin :: forall l. Ord l =&gt; Binds l -&gt; Binds l -&gt; Binds l
max :: Binds l -&gt; Binds l -&gt; Binds l
$cmax :: forall l. Ord l =&gt; Binds l -&gt; Binds l -&gt; Binds l
&gt;= :: Binds l -&gt; Binds l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Binds l -&gt; Binds l -&gt; Bool
&gt; :: Binds l -&gt; Binds l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Binds l -&gt; Binds l -&gt; Bool
&lt;= :: Binds l -&gt; Binds l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Binds l -&gt; Binds l -&gt; Bool
&lt; :: Binds l -&gt; Binds l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Binds l -&gt; Binds l -&gt; Bool
compare :: Binds l -&gt; Binds l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Binds l -&gt; Binds l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436251"><span id="local-6989586621679436253"><span id="local-6989586621679436263"><span class="annot"><span class="annottext">Int -&gt; Binds l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Binds l -&gt; ShowS
forall l. Show l =&gt; [Binds l] -&gt; ShowS
forall l. Show l =&gt; Binds l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Binds l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Binds l] -&gt; ShowS
show :: Binds l -&gt; String
$cshow :: forall l. Show l =&gt; Binds l -&gt; String
showsPrec :: Int -&gt; Binds l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Binds l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679436204"><span id="local-6989586621679436206"><span id="local-6989586621679436208"><span id="local-6989586621679436210"><span id="local-6989586621679436212"><span id="local-6989586621679436214"><span id="local-6989586621679436216"><span id="local-6989586621679436218"><span id="local-6989586621679436220"><span id="local-6989586621679436226"><span id="local-6989586621679436228"><span id="local-6989586621679436230"><span id="local-6989586621679436238"><span id="local-6989586621679436246"><span class="annot"><span class="annottext">Binds l -&gt; DataType
Binds l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Binds l)
forall l. Data l =&gt; Binds l -&gt; DataType
forall l. Data l =&gt; Binds l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Binds l -&gt; Binds l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Binds l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Binds l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Binds l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Binds l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Binds l -&gt; m (Binds l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Binds l -&gt; m (Binds l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Binds l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Binds l -&gt; c (Binds l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Binds l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Binds l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Binds l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Binds l -&gt; c (Binds l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Binds l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Binds l -&gt; m (Binds l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Binds l -&gt; m (Binds l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Binds l -&gt; m (Binds l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Binds l -&gt; m (Binds l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Binds l -&gt; m (Binds l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Binds l -&gt; m (Binds l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Binds l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Binds l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Binds l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Binds l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Binds l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Binds l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Binds l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Binds l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Binds l -&gt; Binds l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Binds l -&gt; Binds l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Binds l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Binds l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Binds l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Binds l))
dataTypeOf :: Binds l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Binds l -&gt; DataType
toConstr :: Binds l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Binds l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Binds l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Binds l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Binds l -&gt; c (Binds l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Binds l -&gt; c (Binds l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436155"><span id="local-6989586621679436157"><span id="local-6989586621679436159"><span id="local-6989586621679436161"><span id="local-6989586621679436163"><span id="local-6989586621679436165"><span id="local-6989586621679436167"><span id="local-6989586621679436169"><span id="local-6989586621679436171"><span id="local-6989586621679436173"><span id="local-6989586621679436175"><span id="local-6989586621679436177"><span id="local-6989586621679436179"><span id="local-6989586621679436185"><span id="local-6989586621679436187"><span id="local-6989586621679436200"><span id="local-6989586621679436202"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Binds a -&gt; Bool
forall a. Num a =&gt; Binds a -&gt; a
forall a. Ord a =&gt; Binds a -&gt; a
forall m. Monoid m =&gt; Binds m -&gt; m
forall a. Binds a -&gt; Bool
forall a. Binds a -&gt; Int
forall a. Binds a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Binds a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Binds a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Binds a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Binds a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Binds a -&gt; a
$cproduct :: forall a. Num a =&gt; Binds a -&gt; a
sum :: forall a. Num a =&gt; Binds a -&gt; a
$csum :: forall a. Num a =&gt; Binds a -&gt; a
minimum :: forall a. Ord a =&gt; Binds a -&gt; a
$cminimum :: forall a. Ord a =&gt; Binds a -&gt; a
maximum :: forall a. Ord a =&gt; Binds a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Binds a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Binds a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Binds a -&gt; Bool
length :: forall a. Binds a -&gt; Int
$clength :: forall a. Binds a -&gt; Int
null :: forall a. Binds a -&gt; Bool
$cnull :: forall a. Binds a -&gt; Bool
toList :: forall a. Binds a -&gt; [a]
$ctoList :: forall a. Binds a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Binds a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Binds a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Binds a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Binds a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Binds a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Binds a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Binds a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Binds a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Binds a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Binds a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Binds a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Binds a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Binds a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Binds a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Binds a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Binds a -&gt; m
fold :: forall m. Monoid m =&gt; Binds m -&gt; m
$cfold :: forall m. Monoid m =&gt; Binds m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436132"><span id="local-6989586621679436134"><span id="local-6989586621679436136"><span id="local-6989586621679436149"><span class="annot"><span class="annottext">Functor Binds
Foldable Binds
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Binds (m a) -&gt; m (Binds a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Binds (f a) -&gt; f (Binds a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Binds a -&gt; m (Binds b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Binds a -&gt; f (Binds b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Binds (m a) -&gt; m (Binds a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Binds (m a) -&gt; m (Binds a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Binds a -&gt; m (Binds b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Binds a -&gt; m (Binds b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Binds (f a) -&gt; f (Binds a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Binds (f a) -&gt; f (Binds a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Binds a -&gt; f (Binds b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Binds a -&gt; f (Binds b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436123"><span id="local-6989586621679436130"><span class="annot"><span class="annottext">forall a b. a -&gt; Binds b -&gt; Binds a
forall a b. (a -&gt; b) -&gt; Binds a -&gt; Binds b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Binds b -&gt; Binds a
$c&lt;$ :: forall a b. a -&gt; Binds b -&gt; Binds a
fmap :: forall a b. (a -&gt; b) -&gt; Binds a -&gt; Binds b
$cfmap :: forall a b. (a -&gt; b) -&gt; Binds a -&gt; Binds b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Binds l) x -&gt; Binds l
forall l x. Binds l -&gt; Rep (Binds l) x
$cto :: forall l x. Rep (Binds l) x -&gt; Binds l
$cfrom :: forall l x. Binds l -&gt; Rep (Binds l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-506"></span><span>
</span><span id="line-507"></span><span class="hs-comment">-- | A binding of an implicit parameter.</span><span>
</span><span id="line-508"></span><span id="local-6989586621679436114"><span id="local-6989586621679436115"></span></span><span class="hs-keyword">data</span><span> </span><span id="IPBind"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPBind"><span class="hs-identifier hs-var">IPBind</span></a></span></span><span> </span><span id="local-6989586621679452653"><span class="annot"><a href="#local-6989586621679452653"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="IPBind"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPBind"><span class="hs-identifier hs-var">IPBind</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452653"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPName"><span class="hs-identifier hs-type">IPName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452653"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452653"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-509"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679436106"><span id="local-6989586621679436111"><span class="annot"><span class="annottext">IPBind l -&gt; IPBind l -&gt; Bool
forall l. Eq l =&gt; IPBind l -&gt; IPBind l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: IPBind l -&gt; IPBind l -&gt; Bool
$c/= :: forall l. Eq l =&gt; IPBind l -&gt; IPBind l -&gt; Bool
== :: IPBind l -&gt; IPBind l -&gt; Bool
$c== :: forall l. Eq l =&gt; IPBind l -&gt; IPBind l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436081"><span id="local-6989586621679436083"><span id="local-6989586621679436086"><span id="local-6989586621679436089"><span id="local-6989586621679436092"><span id="local-6989586621679436097"><span id="local-6989586621679436102"><span class="annot"><span class="annottext">IPBind l -&gt; IPBind l -&gt; Bool
IPBind l -&gt; IPBind l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (IPBind l)
forall l. Ord l =&gt; IPBind l -&gt; IPBind l -&gt; Bool
forall l. Ord l =&gt; IPBind l -&gt; IPBind l -&gt; Ordering
forall l. Ord l =&gt; IPBind l -&gt; IPBind l -&gt; IPBind l
min :: IPBind l -&gt; IPBind l -&gt; IPBind l
$cmin :: forall l. Ord l =&gt; IPBind l -&gt; IPBind l -&gt; IPBind l
max :: IPBind l -&gt; IPBind l -&gt; IPBind l
$cmax :: forall l. Ord l =&gt; IPBind l -&gt; IPBind l -&gt; IPBind l
&gt;= :: IPBind l -&gt; IPBind l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; IPBind l -&gt; IPBind l -&gt; Bool
&gt; :: IPBind l -&gt; IPBind l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; IPBind l -&gt; IPBind l -&gt; Bool
&lt;= :: IPBind l -&gt; IPBind l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; IPBind l -&gt; IPBind l -&gt; Bool
&lt; :: IPBind l -&gt; IPBind l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; IPBind l -&gt; IPBind l -&gt; Bool
compare :: IPBind l -&gt; IPBind l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; IPBind l -&gt; IPBind l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679436071"><span id="local-6989586621679436073"><span id="local-6989586621679436079"><span class="annot"><span class="annottext">Int -&gt; IPBind l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; IPBind l -&gt; ShowS
forall l. Show l =&gt; [IPBind l] -&gt; ShowS
forall l. Show l =&gt; IPBind l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [IPBind l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [IPBind l] -&gt; ShowS
show :: IPBind l -&gt; String
$cshow :: forall l. Show l =&gt; IPBind l -&gt; String
showsPrec :: Int -&gt; IPBind l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; IPBind l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679436030"><span id="local-6989586621679436032"><span id="local-6989586621679436034"><span id="local-6989586621679436036"><span id="local-6989586621679436038"><span id="local-6989586621679436040"><span id="local-6989586621679436042"><span id="local-6989586621679436044"><span id="local-6989586621679436046"><span id="local-6989586621679436052"><span id="local-6989586621679436054"><span id="local-6989586621679436056"><span id="local-6989586621679436061"><span id="local-6989586621679436066"><span class="annot"><span class="annottext">IPBind l -&gt; DataType
IPBind l -&gt; Constr
forall {l}. Data l =&gt; Typeable (IPBind l)
forall l. Data l =&gt; IPBind l -&gt; DataType
forall l. Data l =&gt; IPBind l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; IPBind l -&gt; IPBind l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; IPBind l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; IPBind l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPBind l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPBind l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPBind l -&gt; m (IPBind l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPBind l -&gt; m (IPBind l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (IPBind l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; IPBind l -&gt; c (IPBind l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (IPBind l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (IPBind l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (IPBind l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; IPBind l -&gt; c (IPBind l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (IPBind l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPBind l -&gt; m (IPBind l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPBind l -&gt; m (IPBind l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPBind l -&gt; m (IPBind l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPBind l -&gt; m (IPBind l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPBind l -&gt; m (IPBind l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; IPBind l -&gt; m (IPBind l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; IPBind l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; IPBind l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; IPBind l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; IPBind l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPBind l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPBind l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPBind l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; IPBind l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; IPBind l -&gt; IPBind l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; IPBind l -&gt; IPBind l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (IPBind l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (IPBind l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (IPBind l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (IPBind l))
dataTypeOf :: IPBind l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; IPBind l -&gt; DataType
toConstr :: IPBind l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; IPBind l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (IPBind l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (IPBind l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; IPBind l -&gt; c (IPBind l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; IPBind l -&gt; c (IPBind l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435987"><span id="local-6989586621679435989"><span id="local-6989586621679435991"><span id="local-6989586621679435993"><span id="local-6989586621679435995"><span id="local-6989586621679435997"><span id="local-6989586621679435999"><span id="local-6989586621679436001"><span id="local-6989586621679436003"><span id="local-6989586621679436005"><span id="local-6989586621679436007"><span id="local-6989586621679436009"><span id="local-6989586621679436011"><span id="local-6989586621679436015"><span id="local-6989586621679436017"><span id="local-6989586621679436026"><span id="local-6989586621679436028"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; IPBind a -&gt; Bool
forall a. Num a =&gt; IPBind a -&gt; a
forall a. Ord a =&gt; IPBind a -&gt; a
forall m. Monoid m =&gt; IPBind m -&gt; m
forall a. IPBind a -&gt; Bool
forall a. IPBind a -&gt; Int
forall a. IPBind a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; IPBind a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; IPBind a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; IPBind a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; IPBind a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; IPBind a -&gt; a
$cproduct :: forall a. Num a =&gt; IPBind a -&gt; a
sum :: forall a. Num a =&gt; IPBind a -&gt; a
$csum :: forall a. Num a =&gt; IPBind a -&gt; a
minimum :: forall a. Ord a =&gt; IPBind a -&gt; a
$cminimum :: forall a. Ord a =&gt; IPBind a -&gt; a
maximum :: forall a. Ord a =&gt; IPBind a -&gt; a
$cmaximum :: forall a. Ord a =&gt; IPBind a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; IPBind a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; IPBind a -&gt; Bool
length :: forall a. IPBind a -&gt; Int
$clength :: forall a. IPBind a -&gt; Int
null :: forall a. IPBind a -&gt; Bool
$cnull :: forall a. IPBind a -&gt; Bool
toList :: forall a. IPBind a -&gt; [a]
$ctoList :: forall a. IPBind a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; IPBind a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; IPBind a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; IPBind a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; IPBind a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; IPBind a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; IPBind a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; IPBind a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; IPBind a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; IPBind a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; IPBind a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; IPBind a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; IPBind a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; IPBind a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; IPBind a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; IPBind a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; IPBind a -&gt; m
fold :: forall m. Monoid m =&gt; IPBind m -&gt; m
$cfold :: forall m. Monoid m =&gt; IPBind m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435968"><span id="local-6989586621679435970"><span id="local-6989586621679435972"><span id="local-6989586621679435981"><span class="annot"><span class="annottext">Functor IPBind
Foldable IPBind
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; IPBind (m a) -&gt; m (IPBind a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
IPBind (f a) -&gt; f (IPBind a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; IPBind a -&gt; m (IPBind b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; IPBind a -&gt; f (IPBind b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; IPBind (m a) -&gt; m (IPBind a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; IPBind (m a) -&gt; m (IPBind a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; IPBind a -&gt; m (IPBind b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; IPBind a -&gt; m (IPBind b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
IPBind (f a) -&gt; f (IPBind a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
IPBind (f a) -&gt; f (IPBind a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; IPBind a -&gt; f (IPBind b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; IPBind a -&gt; f (IPBind b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435962"><span id="local-6989586621679435966"><span class="annot"><span class="annottext">forall a b. a -&gt; IPBind b -&gt; IPBind a
forall a b. (a -&gt; b) -&gt; IPBind a -&gt; IPBind b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; IPBind b -&gt; IPBind a
$c&lt;$ :: forall a b. a -&gt; IPBind b -&gt; IPBind a
fmap :: forall a b. (a -&gt; b) -&gt; IPBind a -&gt; IPBind b
$cfmap :: forall a b. (a -&gt; b) -&gt; IPBind a -&gt; IPBind b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (IPBind l) x -&gt; IPBind l
forall l x. IPBind l -&gt; Rep (IPBind l) x
$cto :: forall l x. Rep (IPBind l) x -&gt; IPBind l
$cfrom :: forall l x. IPBind l -&gt; Rep (IPBind l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-510"></span><span>
</span><span id="line-511"></span><span class="hs-comment">-- | Clauses of a function binding.</span><span>
</span><span id="line-512"></span><span id="local-6989586621679435955"><span id="local-6989586621679435956"></span></span><span class="hs-keyword">data</span><span> </span><span id="Match"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Match"><span class="hs-identifier hs-var">Match</span></a></span></span><span> </span><span id="local-6989586621679452730"><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-513"></span><span>     </span><span class="hs-glyph">=</span><span> </span><span id="Match"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Match"><span class="hs-identifier hs-var">Match</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>         </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rhs"><span class="hs-identifier hs-type">Rhs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">{-where-}</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Binds"><span class="hs-identifier hs-type">Binds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-514"></span><span>        </span><span class="hs-comment">-- ^ A clause defined with prefix notation, i.e. the function name</span><span>
</span><span id="line-515"></span><span>        </span><span class="hs-comment">--  followed by its argument patterns, the right-hand side and an</span><span>
</span><span id="line-516"></span><span>        </span><span class="hs-comment">--  optional where clause.</span><span>
</span><span id="line-517"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="InfixMatch"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixMatch"><span class="hs-identifier hs-var">InfixMatch</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rhs"><span class="hs-identifier hs-type">Rhs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">{-where-}</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Binds"><span class="hs-identifier hs-type">Binds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452730"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-518"></span><span>        </span><span class="hs-comment">-- ^ A clause defined with infix notation, i.e. first its first argument</span><span>
</span><span id="line-519"></span><span>        </span><span class="hs-comment">--  pattern, then the function name, then its following argument(s),</span><span>
</span><span id="line-520"></span><span>        </span><span class="hs-comment">--  the right-hand side and an optional where clause.</span><span>
</span><span id="line-521"></span><span>        </span><span class="hs-comment">--  Note that there can be more than two arguments to a function declared</span><span>
</span><span id="line-522"></span><span>        </span><span class="hs-comment">--  infix, hence the list of pattern arguments.</span><span>
</span><span id="line-523"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679435936"><span id="local-6989586621679435951"><span class="annot"><span class="annottext">Match l -&gt; Match l -&gt; Bool
forall l. Eq l =&gt; Match l -&gt; Match l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Match l -&gt; Match l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Match l -&gt; Match l -&gt; Bool
== :: Match l -&gt; Match l -&gt; Bool
$c== :: forall l. Eq l =&gt; Match l -&gt; Match l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435891"><span id="local-6989586621679435893"><span id="local-6989586621679435896"><span id="local-6989586621679435899"><span id="local-6989586621679435902"><span id="local-6989586621679435917"><span id="local-6989586621679435932"><span class="annot"><span class="annottext">Match l -&gt; Match l -&gt; Bool
Match l -&gt; Match l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Match l)
forall l. Ord l =&gt; Match l -&gt; Match l -&gt; Bool
forall l. Ord l =&gt; Match l -&gt; Match l -&gt; Ordering
forall l. Ord l =&gt; Match l -&gt; Match l -&gt; Match l
min :: Match l -&gt; Match l -&gt; Match l
$cmin :: forall l. Ord l =&gt; Match l -&gt; Match l -&gt; Match l
max :: Match l -&gt; Match l -&gt; Match l
$cmax :: forall l. Ord l =&gt; Match l -&gt; Match l -&gt; Match l
&gt;= :: Match l -&gt; Match l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Match l -&gt; Match l -&gt; Bool
&gt; :: Match l -&gt; Match l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Match l -&gt; Match l -&gt; Bool
&lt;= :: Match l -&gt; Match l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Match l -&gt; Match l -&gt; Bool
&lt; :: Match l -&gt; Match l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Match l -&gt; Match l -&gt; Bool
compare :: Match l -&gt; Match l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Match l -&gt; Match l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435870"><span id="local-6989586621679435872"><span id="local-6989586621679435889"><span class="annot"><span class="annottext">Int -&gt; Match l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Match l -&gt; ShowS
forall l. Show l =&gt; [Match l] -&gt; ShowS
forall l. Show l =&gt; Match l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Match l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Match l] -&gt; ShowS
show :: Match l -&gt; String
$cshow :: forall l. Show l =&gt; Match l -&gt; String
showsPrec :: Int -&gt; Match l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Match l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679435809"><span id="local-6989586621679435811"><span id="local-6989586621679435813"><span id="local-6989586621679435815"><span id="local-6989586621679435817"><span id="local-6989586621679435819"><span id="local-6989586621679435821"><span id="local-6989586621679435823"><span id="local-6989586621679435825"><span id="local-6989586621679435831"><span id="local-6989586621679435833"><span id="local-6989586621679435835"><span id="local-6989586621679435850"><span id="local-6989586621679435865"><span class="annot"><span class="annottext">Match l -&gt; DataType
Match l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Match l)
forall l. Data l =&gt; Match l -&gt; DataType
forall l. Data l =&gt; Match l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Match l -&gt; Match l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Match l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Match l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match l -&gt; m (Match l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match l -&gt; m (Match l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Match l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Match l -&gt; c (Match l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Match l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Match l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Match l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Match l -&gt; c (Match l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Match l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match l -&gt; m (Match l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match l -&gt; m (Match l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match l -&gt; m (Match l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match l -&gt; m (Match l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match l -&gt; m (Match l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Match l -&gt; m (Match l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Match l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Match l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Match l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Match l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Match l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Match l -&gt; Match l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Match l -&gt; Match l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Match l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Match l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Match l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Match l))
dataTypeOf :: Match l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Match l -&gt; DataType
toConstr :: Match l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Match l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Match l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Match l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Match l -&gt; c (Match l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Match l -&gt; c (Match l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435726"><span id="local-6989586621679435728"><span id="local-6989586621679435730"><span id="local-6989586621679435732"><span id="local-6989586621679435734"><span id="local-6989586621679435736"><span id="local-6989586621679435738"><span id="local-6989586621679435740"><span id="local-6989586621679435742"><span id="local-6989586621679435744"><span id="local-6989586621679435746"><span id="local-6989586621679435748"><span id="local-6989586621679435750"><span id="local-6989586621679435765"><span id="local-6989586621679435767"><span id="local-6989586621679435805"><span id="local-6989586621679435807"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Match a -&gt; Bool
forall a. Num a =&gt; Match a -&gt; a
forall a. Ord a =&gt; Match a -&gt; a
forall m. Monoid m =&gt; Match m -&gt; m
forall a. Match a -&gt; Bool
forall a. Match a -&gt; Int
forall a. Match a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Match a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Match a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Match a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Match a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Match a -&gt; a
$cproduct :: forall a. Num a =&gt; Match a -&gt; a
sum :: forall a. Num a =&gt; Match a -&gt; a
$csum :: forall a. Num a =&gt; Match a -&gt; a
minimum :: forall a. Ord a =&gt; Match a -&gt; a
$cminimum :: forall a. Ord a =&gt; Match a -&gt; a
maximum :: forall a. Ord a =&gt; Match a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Match a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Match a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Match a -&gt; Bool
length :: forall a. Match a -&gt; Int
$clength :: forall a. Match a -&gt; Int
null :: forall a. Match a -&gt; Bool
$cnull :: forall a. Match a -&gt; Bool
toList :: forall a. Match a -&gt; [a]
$ctoList :: forall a. Match a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Match a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Match a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Match a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Match a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Match a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Match a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Match a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Match a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Match a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Match a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Match a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Match a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Match a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Match a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Match a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Match a -&gt; m
fold :: forall m. Monoid m =&gt; Match m -&gt; m
$cfold :: forall m. Monoid m =&gt; Match m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435678"><span id="local-6989586621679435680"><span id="local-6989586621679435682"><span id="local-6989586621679435720"><span class="annot"><span class="annottext">Functor Match
Foldable Match
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Match (m a) -&gt; m (Match a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Match (f a) -&gt; f (Match a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Match a -&gt; m (Match b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Match a -&gt; f (Match b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Match (m a) -&gt; m (Match a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Match (m a) -&gt; m (Match a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Match a -&gt; m (Match b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Match a -&gt; m (Match b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Match (f a) -&gt; f (Match a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Match (f a) -&gt; f (Match a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Match a -&gt; f (Match b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Match a -&gt; f (Match b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435661"><span id="local-6989586621679435676"><span class="annot"><span class="annottext">forall a b. a -&gt; Match b -&gt; Match a
forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Match b -&gt; Match a
$c&lt;$ :: forall a b. a -&gt; Match b -&gt; Match a
fmap :: forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
$cfmap :: forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Match l) x -&gt; Match l
forall l x. Match l -&gt; Rep (Match l) x
$cto :: forall l x. Rep (Match l) x -&gt; Match l
$cfrom :: forall l x. Match l -&gt; Rep (Match l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-524"></span><span>
</span><span id="line-525"></span><span class="hs-comment">-- | A single constructor declaration within a data type declaration,</span><span>
</span><span id="line-526"></span><span class="hs-comment">--   which may have an existential quantification binding.</span><span>
</span><span id="line-527"></span><span id="local-6989586621679435643"><span id="local-6989586621679435644"></span></span><span class="hs-keyword">data</span><span> </span><span id="QualConDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualConDecl"><span class="hs-identifier hs-var">QualConDecl</span></a></span></span><span> </span><span id="local-6989586621679452738"><span class="annot"><a href="#local-6989586621679452738"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-528"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="QualConDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualConDecl"><span class="hs-identifier hs-var">QualConDecl</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452738"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-529"></span><span>        </span><span class="hs-comment">{-forall-}</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier hs-type">TyVarBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452738"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-comment">{- . -}</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452738"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-530"></span><span>        </span><span class="hs-comment">{- =&gt; -}</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConDecl"><span class="hs-identifier hs-type">ConDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452738"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-531"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679435632"><span id="local-6989586621679435640"><span class="annot"><span class="annottext">QualConDecl l -&gt; QualConDecl l -&gt; Bool
forall l. Eq l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: QualConDecl l -&gt; QualConDecl l -&gt; Bool
$c/= :: forall l. Eq l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; Bool
== :: QualConDecl l -&gt; QualConDecl l -&gt; Bool
$c== :: forall l. Eq l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435600"><span id="local-6989586621679435602"><span id="local-6989586621679435605"><span id="local-6989586621679435608"><span id="local-6989586621679435611"><span id="local-6989586621679435619"><span id="local-6989586621679435627"><span class="annot"><span class="annottext">QualConDecl l -&gt; QualConDecl l -&gt; Bool
QualConDecl l -&gt; QualConDecl l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (QualConDecl l)
forall l. Ord l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; Bool
forall l. Ord l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; Ordering
forall l. Ord l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; QualConDecl l
min :: QualConDecl l -&gt; QualConDecl l -&gt; QualConDecl l
$cmin :: forall l. Ord l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; QualConDecl l
max :: QualConDecl l -&gt; QualConDecl l -&gt; QualConDecl l
$cmax :: forall l. Ord l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; QualConDecl l
&gt;= :: QualConDecl l -&gt; QualConDecl l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; Bool
&gt; :: QualConDecl l -&gt; QualConDecl l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; Bool
&lt;= :: QualConDecl l -&gt; QualConDecl l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; Bool
&lt; :: QualConDecl l -&gt; QualConDecl l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; Bool
compare :: QualConDecl l -&gt; QualConDecl l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; QualConDecl l -&gt; QualConDecl l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435585"><span id="local-6989586621679435587"><span id="local-6989586621679435596"><span class="annot"><span class="annottext">Int -&gt; QualConDecl l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; QualConDecl l -&gt; ShowS
forall l. Show l =&gt; [QualConDecl l] -&gt; ShowS
forall l. Show l =&gt; QualConDecl l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [QualConDecl l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [QualConDecl l] -&gt; ShowS
show :: QualConDecl l -&gt; String
$cshow :: forall l. Show l =&gt; QualConDecl l -&gt; String
showsPrec :: Int -&gt; QualConDecl l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; QualConDecl l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679435537"><span id="local-6989586621679435539"><span id="local-6989586621679435541"><span id="local-6989586621679435543"><span id="local-6989586621679435545"><span id="local-6989586621679435547"><span id="local-6989586621679435549"><span id="local-6989586621679435551"><span id="local-6989586621679435553"><span id="local-6989586621679435559"><span id="local-6989586621679435561"><span id="local-6989586621679435563"><span id="local-6989586621679435571"><span id="local-6989586621679435579"><span class="annot"><span class="annottext">QualConDecl l -&gt; DataType
QualConDecl l -&gt; Constr
forall {l}. Data l =&gt; Typeable (QualConDecl l)
forall l. Data l =&gt; QualConDecl l -&gt; DataType
forall l. Data l =&gt; QualConDecl l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; QualConDecl l -&gt; QualConDecl l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QualConDecl l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; QualConDecl l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualConDecl l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualConDecl l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; QualConDecl l -&gt; m (QualConDecl l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; QualConDecl l -&gt; m (QualConDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QualConDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QualConDecl l -&gt; c (QualConDecl l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QualConDecl l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (QualConDecl l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QualConDecl l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QualConDecl l -&gt; c (QualConDecl l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QualConDecl l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; QualConDecl l -&gt; m (QualConDecl l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; QualConDecl l -&gt; m (QualConDecl l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; QualConDecl l -&gt; m (QualConDecl l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; QualConDecl l -&gt; m (QualConDecl l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; QualConDecl l -&gt; m (QualConDecl l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; QualConDecl l -&gt; m (QualConDecl l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QualConDecl l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QualConDecl l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; QualConDecl l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; QualConDecl l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualConDecl l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualConDecl l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualConDecl l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualConDecl l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; QualConDecl l -&gt; QualConDecl l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; QualConDecl l -&gt; QualConDecl l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (QualConDecl l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (QualConDecl l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QualConDecl l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QualConDecl l))
dataTypeOf :: QualConDecl l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; QualConDecl l -&gt; DataType
toConstr :: QualConDecl l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; QualConDecl l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QualConDecl l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QualConDecl l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QualConDecl l -&gt; c (QualConDecl l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QualConDecl l -&gt; c (QualConDecl l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435479"><span id="local-6989586621679435481"><span id="local-6989586621679435483"><span id="local-6989586621679435485"><span id="local-6989586621679435487"><span id="local-6989586621679435489"><span id="local-6989586621679435491"><span id="local-6989586621679435493"><span id="local-6989586621679435495"><span id="local-6989586621679435497"><span id="local-6989586621679435499"><span id="local-6989586621679435501"><span id="local-6989586621679435503"><span id="local-6989586621679435511"><span id="local-6989586621679435513"><span id="local-6989586621679435531"><span id="local-6989586621679435533"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; QualConDecl a -&gt; Bool
forall a. Num a =&gt; QualConDecl a -&gt; a
forall a. Ord a =&gt; QualConDecl a -&gt; a
forall m. Monoid m =&gt; QualConDecl m -&gt; m
forall a. QualConDecl a -&gt; Bool
forall a. QualConDecl a -&gt; Int
forall a. QualConDecl a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; QualConDecl a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QualConDecl a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QualConDecl a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QualConDecl a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; QualConDecl a -&gt; a
$cproduct :: forall a. Num a =&gt; QualConDecl a -&gt; a
sum :: forall a. Num a =&gt; QualConDecl a -&gt; a
$csum :: forall a. Num a =&gt; QualConDecl a -&gt; a
minimum :: forall a. Ord a =&gt; QualConDecl a -&gt; a
$cminimum :: forall a. Ord a =&gt; QualConDecl a -&gt; a
maximum :: forall a. Ord a =&gt; QualConDecl a -&gt; a
$cmaximum :: forall a. Ord a =&gt; QualConDecl a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; QualConDecl a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; QualConDecl a -&gt; Bool
length :: forall a. QualConDecl a -&gt; Int
$clength :: forall a. QualConDecl a -&gt; Int
null :: forall a. QualConDecl a -&gt; Bool
$cnull :: forall a. QualConDecl a -&gt; Bool
toList :: forall a. QualConDecl a -&gt; [a]
$ctoList :: forall a. QualConDecl a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; QualConDecl a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; QualConDecl a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; QualConDecl a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; QualConDecl a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QualConDecl a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QualConDecl a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QualConDecl a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QualConDecl a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QualConDecl a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QualConDecl a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QualConDecl a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QualConDecl a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QualConDecl a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QualConDecl a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QualConDecl a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QualConDecl a -&gt; m
fold :: forall m. Monoid m =&gt; QualConDecl m -&gt; m
$cfold :: forall m. Monoid m =&gt; QualConDecl m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435451"><span id="local-6989586621679435453"><span id="local-6989586621679435455"><span id="local-6989586621679435473"><span class="annot"><span class="annottext">Functor QualConDecl
Foldable QualConDecl
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
QualConDecl (m a) -&gt; m (QualConDecl a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
QualConDecl (f a) -&gt; f (QualConDecl a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QualConDecl a -&gt; m (QualConDecl b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QualConDecl a -&gt; f (QualConDecl b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
QualConDecl (m a) -&gt; m (QualConDecl a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
QualConDecl (m a) -&gt; m (QualConDecl a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QualConDecl a -&gt; m (QualConDecl b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QualConDecl a -&gt; m (QualConDecl b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
QualConDecl (f a) -&gt; f (QualConDecl a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
QualConDecl (f a) -&gt; f (QualConDecl a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QualConDecl a -&gt; f (QualConDecl b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QualConDecl a -&gt; f (QualConDecl b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435440"><span id="local-6989586621679435449"><span class="annot"><span class="annottext">forall a b. a -&gt; QualConDecl b -&gt; QualConDecl a
forall a b. (a -&gt; b) -&gt; QualConDecl a -&gt; QualConDecl b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; QualConDecl b -&gt; QualConDecl a
$c&lt;$ :: forall a b. a -&gt; QualConDecl b -&gt; QualConDecl a
fmap :: forall a b. (a -&gt; b) -&gt; QualConDecl a -&gt; QualConDecl b
$cfmap :: forall a b. (a -&gt; b) -&gt; QualConDecl a -&gt; QualConDecl b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (QualConDecl l) x -&gt; QualConDecl l
forall l x. QualConDecl l -&gt; Rep (QualConDecl l) x
$cto :: forall l x. Rep (QualConDecl l) x -&gt; QualConDecl l
$cfrom :: forall l x. QualConDecl l -&gt; Rep (QualConDecl l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-532"></span><span>
</span><span id="line-533"></span><span class="hs-comment">-- | Declaration of an ordinary data constructor.</span><span>
</span><span id="line-534"></span><span id="local-6989586621679435429"><span id="local-6989586621679435430"></span></span><span class="hs-keyword">data</span><span> </span><span id="ConDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConDecl"><span class="hs-identifier hs-var">ConDecl</span></a></span></span><span> </span><span id="local-6989586621679452640"><span class="annot"><a href="#local-6989586621679452640"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-535"></span><span>     </span><span class="hs-glyph">=</span><span> </span><span id="ConDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConDecl"><span class="hs-identifier hs-var">ConDecl</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452640"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452640"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452640"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-536"></span><span>                </span><span class="hs-comment">-- ^ ordinary data constructor</span><span>
</span><span id="line-537"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="InfixConDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixConDecl"><span class="hs-identifier hs-var">InfixConDecl</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452640"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452640"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452640"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452640"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-538"></span><span>                </span><span class="hs-comment">-- ^ infix data constructor</span><span>
</span><span id="line-539"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="RecDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecDecl"><span class="hs-identifier hs-var">RecDecl</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452640"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452640"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldDecl"><span class="hs-identifier hs-type">FieldDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452640"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-540"></span><span>                </span><span class="hs-comment">-- ^ record constructor</span><span>
</span><span id="line-541"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679435410"><span id="local-6989586621679435424"><span class="annot"><span class="annottext">ConDecl l -&gt; ConDecl l -&gt; Bool
forall l. Eq l =&gt; ConDecl l -&gt; ConDecl l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ConDecl l -&gt; ConDecl l -&gt; Bool
$c/= :: forall l. Eq l =&gt; ConDecl l -&gt; ConDecl l -&gt; Bool
== :: ConDecl l -&gt; ConDecl l -&gt; Bool
$c== :: forall l. Eq l =&gt; ConDecl l -&gt; ConDecl l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435367"><span id="local-6989586621679435369"><span id="local-6989586621679435372"><span id="local-6989586621679435375"><span id="local-6989586621679435378"><span id="local-6989586621679435392"><span id="local-6989586621679435406"><span class="annot"><span class="annottext">ConDecl l -&gt; ConDecl l -&gt; Bool
ConDecl l -&gt; ConDecl l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (ConDecl l)
forall l. Ord l =&gt; ConDecl l -&gt; ConDecl l -&gt; Bool
forall l. Ord l =&gt; ConDecl l -&gt; ConDecl l -&gt; Ordering
forall l. Ord l =&gt; ConDecl l -&gt; ConDecl l -&gt; ConDecl l
min :: ConDecl l -&gt; ConDecl l -&gt; ConDecl l
$cmin :: forall l. Ord l =&gt; ConDecl l -&gt; ConDecl l -&gt; ConDecl l
max :: ConDecl l -&gt; ConDecl l -&gt; ConDecl l
$cmax :: forall l. Ord l =&gt; ConDecl l -&gt; ConDecl l -&gt; ConDecl l
&gt;= :: ConDecl l -&gt; ConDecl l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; ConDecl l -&gt; ConDecl l -&gt; Bool
&gt; :: ConDecl l -&gt; ConDecl l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; ConDecl l -&gt; ConDecl l -&gt; Bool
&lt;= :: ConDecl l -&gt; ConDecl l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; ConDecl l -&gt; ConDecl l -&gt; Bool
&lt; :: ConDecl l -&gt; ConDecl l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; ConDecl l -&gt; ConDecl l -&gt; Bool
compare :: ConDecl l -&gt; ConDecl l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; ConDecl l -&gt; ConDecl l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435346"><span id="local-6989586621679435348"><span id="local-6989586621679435365"><span class="annot"><span class="annottext">Int -&gt; ConDecl l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; ConDecl l -&gt; ShowS
forall l. Show l =&gt; [ConDecl l] -&gt; ShowS
forall l. Show l =&gt; ConDecl l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ConDecl l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [ConDecl l] -&gt; ShowS
show :: ConDecl l -&gt; String
$cshow :: forall l. Show l =&gt; ConDecl l -&gt; String
showsPrec :: Int -&gt; ConDecl l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; ConDecl l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679435287"><span id="local-6989586621679435289"><span id="local-6989586621679435291"><span id="local-6989586621679435293"><span id="local-6989586621679435295"><span id="local-6989586621679435297"><span id="local-6989586621679435299"><span id="local-6989586621679435301"><span id="local-6989586621679435303"><span id="local-6989586621679435309"><span id="local-6989586621679435311"><span id="local-6989586621679435313"><span id="local-6989586621679435327"><span id="local-6989586621679435341"><span class="annot"><span class="annottext">ConDecl l -&gt; DataType
ConDecl l -&gt; Constr
forall {l}. Data l =&gt; Typeable (ConDecl l)
forall l. Data l =&gt; ConDecl l -&gt; DataType
forall l. Data l =&gt; ConDecl l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ConDecl l -&gt; ConDecl l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConDecl l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ConDecl l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConDecl l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConDecl l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ConDecl l -&gt; m (ConDecl l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ConDecl l -&gt; m (ConDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ConDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ConDecl l -&gt; c (ConDecl l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ConDecl l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ConDecl l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ConDecl l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ConDecl l -&gt; c (ConDecl l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ConDecl l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ConDecl l -&gt; m (ConDecl l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ConDecl l -&gt; m (ConDecl l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ConDecl l -&gt; m (ConDecl l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ConDecl l -&gt; m (ConDecl l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ConDecl l -&gt; m (ConDecl l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ConDecl l -&gt; m (ConDecl l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConDecl l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConDecl l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ConDecl l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ConDecl l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConDecl l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConDecl l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConDecl l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConDecl l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ConDecl l -&gt; ConDecl l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ConDecl l -&gt; ConDecl l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ConDecl l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ConDecl l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ConDecl l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ConDecl l))
dataTypeOf :: ConDecl l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; ConDecl l -&gt; DataType
toConstr :: ConDecl l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; ConDecl l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ConDecl l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ConDecl l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ConDecl l -&gt; c (ConDecl l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ConDecl l -&gt; c (ConDecl l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435218"><span id="local-6989586621679435220"><span id="local-6989586621679435222"><span id="local-6989586621679435224"><span id="local-6989586621679435226"><span id="local-6989586621679435228"><span id="local-6989586621679435230"><span id="local-6989586621679435232"><span id="local-6989586621679435234"><span id="local-6989586621679435236"><span id="local-6989586621679435238"><span id="local-6989586621679435240"><span id="local-6989586621679435242"><span id="local-6989586621679435253"><span id="local-6989586621679435255"><span id="local-6989586621679435283"><span id="local-6989586621679435285"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; ConDecl a -&gt; Bool
forall a. Num a =&gt; ConDecl a -&gt; a
forall a. Ord a =&gt; ConDecl a -&gt; a
forall m. Monoid m =&gt; ConDecl m -&gt; m
forall a. ConDecl a -&gt; Bool
forall a. ConDecl a -&gt; Int
forall a. ConDecl a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; ConDecl a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ConDecl a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ConDecl a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ConDecl a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; ConDecl a -&gt; a
$cproduct :: forall a. Num a =&gt; ConDecl a -&gt; a
sum :: forall a. Num a =&gt; ConDecl a -&gt; a
$csum :: forall a. Num a =&gt; ConDecl a -&gt; a
minimum :: forall a. Ord a =&gt; ConDecl a -&gt; a
$cminimum :: forall a. Ord a =&gt; ConDecl a -&gt; a
maximum :: forall a. Ord a =&gt; ConDecl a -&gt; a
$cmaximum :: forall a. Ord a =&gt; ConDecl a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; ConDecl a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; ConDecl a -&gt; Bool
length :: forall a. ConDecl a -&gt; Int
$clength :: forall a. ConDecl a -&gt; Int
null :: forall a. ConDecl a -&gt; Bool
$cnull :: forall a. ConDecl a -&gt; Bool
toList :: forall a. ConDecl a -&gt; [a]
$ctoList :: forall a. ConDecl a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ConDecl a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ConDecl a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ConDecl a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ConDecl a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ConDecl a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ConDecl a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ConDecl a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ConDecl a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ConDecl a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ConDecl a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ConDecl a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ConDecl a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ConDecl a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ConDecl a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ConDecl a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ConDecl a -&gt; m
fold :: forall m. Monoid m =&gt; ConDecl m -&gt; m
$cfold :: forall m. Monoid m =&gt; ConDecl m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435180"><span id="local-6989586621679435182"><span id="local-6989586621679435184"><span id="local-6989586621679435212"><span class="annot"><span class="annottext">Functor ConDecl
Foldable ConDecl
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; ConDecl (m a) -&gt; m (ConDecl a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
ConDecl (f a) -&gt; f (ConDecl a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ConDecl a -&gt; m (ConDecl b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ConDecl a -&gt; f (ConDecl b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; ConDecl (m a) -&gt; m (ConDecl a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; ConDecl (m a) -&gt; m (ConDecl a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ConDecl a -&gt; m (ConDecl b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ConDecl a -&gt; m (ConDecl b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ConDecl (f a) -&gt; f (ConDecl a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ConDecl (f a) -&gt; f (ConDecl a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ConDecl a -&gt; f (ConDecl b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ConDecl a -&gt; f (ConDecl b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435166"><span id="local-6989586621679435178"><span class="annot"><span class="annottext">forall a b. a -&gt; ConDecl b -&gt; ConDecl a
forall a b. (a -&gt; b) -&gt; ConDecl a -&gt; ConDecl b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; ConDecl b -&gt; ConDecl a
$c&lt;$ :: forall a b. a -&gt; ConDecl b -&gt; ConDecl a
fmap :: forall a b. (a -&gt; b) -&gt; ConDecl a -&gt; ConDecl b
$cfmap :: forall a b. (a -&gt; b) -&gt; ConDecl a -&gt; ConDecl b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (ConDecl l) x -&gt; ConDecl l
forall l x. ConDecl l -&gt; Rep (ConDecl l) x
$cto :: forall l x. Rep (ConDecl l) x -&gt; ConDecl l
$cfrom :: forall l x. ConDecl l -&gt; Rep (ConDecl l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-542"></span><span>
</span><span id="line-543"></span><span class="hs-comment">-- | Declaration of a (list of) named field(s).</span><span>
</span><span id="line-544"></span><span id="local-6989586621679435152"><span id="local-6989586621679435153"></span></span><span class="hs-keyword">data</span><span> </span><span id="FieldDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldDecl"><span class="hs-identifier hs-var">FieldDecl</span></a></span></span><span> </span><span id="local-6989586621679452635"><span class="annot"><a href="#local-6989586621679452635"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="FieldDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldDecl"><span class="hs-identifier hs-var">FieldDecl</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452635"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452635"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452635"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-545"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679435143"><span id="local-6989586621679435149"><span class="annot"><span class="annottext">FieldDecl l -&gt; FieldDecl l -&gt; Bool
forall l. Eq l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: FieldDecl l -&gt; FieldDecl l -&gt; Bool
$c/= :: forall l. Eq l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; Bool
== :: FieldDecl l -&gt; FieldDecl l -&gt; Bool
$c== :: forall l. Eq l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435116"><span id="local-6989586621679435118"><span id="local-6989586621679435121"><span id="local-6989586621679435124"><span id="local-6989586621679435127"><span id="local-6989586621679435133"><span id="local-6989586621679435139"><span class="annot"><span class="annottext">FieldDecl l -&gt; FieldDecl l -&gt; Bool
FieldDecl l -&gt; FieldDecl l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (FieldDecl l)
forall l. Ord l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; Bool
forall l. Ord l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; Ordering
forall l. Ord l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; FieldDecl l
min :: FieldDecl l -&gt; FieldDecl l -&gt; FieldDecl l
$cmin :: forall l. Ord l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; FieldDecl l
max :: FieldDecl l -&gt; FieldDecl l -&gt; FieldDecl l
$cmax :: forall l. Ord l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; FieldDecl l
&gt;= :: FieldDecl l -&gt; FieldDecl l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; Bool
&gt; :: FieldDecl l -&gt; FieldDecl l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; Bool
&lt;= :: FieldDecl l -&gt; FieldDecl l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; Bool
&lt; :: FieldDecl l -&gt; FieldDecl l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; Bool
compare :: FieldDecl l -&gt; FieldDecl l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; FieldDecl l -&gt; FieldDecl l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435105"><span id="local-6989586621679435107"><span id="local-6989586621679435114"><span class="annot"><span class="annottext">Int -&gt; FieldDecl l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; FieldDecl l -&gt; ShowS
forall l. Show l =&gt; [FieldDecl l] -&gt; ShowS
forall l. Show l =&gt; FieldDecl l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [FieldDecl l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [FieldDecl l] -&gt; ShowS
show :: FieldDecl l -&gt; String
$cshow :: forall l. Show l =&gt; FieldDecl l -&gt; String
showsPrec :: Int -&gt; FieldDecl l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; FieldDecl l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679435062"><span id="local-6989586621679435064"><span id="local-6989586621679435066"><span id="local-6989586621679435068"><span id="local-6989586621679435070"><span id="local-6989586621679435072"><span id="local-6989586621679435074"><span id="local-6989586621679435076"><span id="local-6989586621679435078"><span id="local-6989586621679435084"><span id="local-6989586621679435086"><span id="local-6989586621679435088"><span id="local-6989586621679435094"><span id="local-6989586621679435100"><span class="annot"><span class="annottext">FieldDecl l -&gt; DataType
FieldDecl l -&gt; Constr
forall {l}. Data l =&gt; Typeable (FieldDecl l)
forall l. Data l =&gt; FieldDecl l -&gt; DataType
forall l. Data l =&gt; FieldDecl l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; FieldDecl l -&gt; FieldDecl l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldDecl l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; FieldDecl l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldDecl l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldDecl l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FieldDecl l -&gt; m (FieldDecl l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FieldDecl l -&gt; m (FieldDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FieldDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldDecl l -&gt; c (FieldDecl l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FieldDecl l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (FieldDecl l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FieldDecl l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldDecl l -&gt; c (FieldDecl l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FieldDecl l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FieldDecl l -&gt; m (FieldDecl l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FieldDecl l -&gt; m (FieldDecl l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FieldDecl l -&gt; m (FieldDecl l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FieldDecl l -&gt; m (FieldDecl l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FieldDecl l -&gt; m (FieldDecl l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FieldDecl l -&gt; m (FieldDecl l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldDecl l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldDecl l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FieldDecl l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; FieldDecl l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldDecl l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldDecl l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldDecl l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldDecl l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FieldDecl l -&gt; FieldDecl l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; FieldDecl l -&gt; FieldDecl l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (FieldDecl l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (FieldDecl l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FieldDecl l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FieldDecl l))
dataTypeOf :: FieldDecl l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; FieldDecl l -&gt; DataType
toConstr :: FieldDecl l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; FieldDecl l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FieldDecl l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FieldDecl l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldDecl l -&gt; c (FieldDecl l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldDecl l -&gt; c (FieldDecl l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679435016"><span id="local-6989586621679435018"><span id="local-6989586621679435020"><span id="local-6989586621679435022"><span id="local-6989586621679435024"><span id="local-6989586621679435026"><span id="local-6989586621679435028"><span id="local-6989586621679435030"><span id="local-6989586621679435032"><span id="local-6989586621679435034"><span id="local-6989586621679435036"><span id="local-6989586621679435038"><span id="local-6989586621679435040"><span id="local-6989586621679435045"><span id="local-6989586621679435047"><span id="local-6989586621679435058"><span id="local-6989586621679435060"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; FieldDecl a -&gt; Bool
forall a. Num a =&gt; FieldDecl a -&gt; a
forall a. Ord a =&gt; FieldDecl a -&gt; a
forall m. Monoid m =&gt; FieldDecl m -&gt; m
forall a. FieldDecl a -&gt; Bool
forall a. FieldDecl a -&gt; Int
forall a. FieldDecl a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; FieldDecl a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FieldDecl a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FieldDecl a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FieldDecl a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; FieldDecl a -&gt; a
$cproduct :: forall a. Num a =&gt; FieldDecl a -&gt; a
sum :: forall a. Num a =&gt; FieldDecl a -&gt; a
$csum :: forall a. Num a =&gt; FieldDecl a -&gt; a
minimum :: forall a. Ord a =&gt; FieldDecl a -&gt; a
$cminimum :: forall a. Ord a =&gt; FieldDecl a -&gt; a
maximum :: forall a. Ord a =&gt; FieldDecl a -&gt; a
$cmaximum :: forall a. Ord a =&gt; FieldDecl a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; FieldDecl a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; FieldDecl a -&gt; Bool
length :: forall a. FieldDecl a -&gt; Int
$clength :: forall a. FieldDecl a -&gt; Int
null :: forall a. FieldDecl a -&gt; Bool
$cnull :: forall a. FieldDecl a -&gt; Bool
toList :: forall a. FieldDecl a -&gt; [a]
$ctoList :: forall a. FieldDecl a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; FieldDecl a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; FieldDecl a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; FieldDecl a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; FieldDecl a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FieldDecl a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FieldDecl a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FieldDecl a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FieldDecl a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FieldDecl a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FieldDecl a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FieldDecl a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FieldDecl a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FieldDecl a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FieldDecl a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FieldDecl a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FieldDecl a -&gt; m
fold :: forall m. Monoid m =&gt; FieldDecl m -&gt; m
$cfold :: forall m. Monoid m =&gt; FieldDecl m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434995"><span id="local-6989586621679434997"><span id="local-6989586621679434999"><span id="local-6989586621679435010"><span class="annot"><span class="annottext">Functor FieldDecl
Foldable FieldDecl
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
FieldDecl (m a) -&gt; m (FieldDecl a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
FieldDecl (f a) -&gt; f (FieldDecl a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; FieldDecl a -&gt; m (FieldDecl b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; FieldDecl a -&gt; f (FieldDecl b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
FieldDecl (m a) -&gt; m (FieldDecl a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
FieldDecl (m a) -&gt; m (FieldDecl a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; FieldDecl a -&gt; m (FieldDecl b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; FieldDecl a -&gt; m (FieldDecl b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
FieldDecl (f a) -&gt; f (FieldDecl a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
FieldDecl (f a) -&gt; f (FieldDecl a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; FieldDecl a -&gt; f (FieldDecl b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; FieldDecl a -&gt; f (FieldDecl b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434988"><span id="local-6989586621679434993"><span class="annot"><span class="annottext">forall a b. a -&gt; FieldDecl b -&gt; FieldDecl a
forall a b. (a -&gt; b) -&gt; FieldDecl a -&gt; FieldDecl b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; FieldDecl b -&gt; FieldDecl a
$c&lt;$ :: forall a b. a -&gt; FieldDecl b -&gt; FieldDecl a
fmap :: forall a b. (a -&gt; b) -&gt; FieldDecl a -&gt; FieldDecl b
$cfmap :: forall a b. (a -&gt; b) -&gt; FieldDecl a -&gt; FieldDecl b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (FieldDecl l) x -&gt; FieldDecl l
forall l x. FieldDecl l -&gt; Rep (FieldDecl l) x
$cto :: forall l x. Rep (FieldDecl l) x -&gt; FieldDecl l
$cfrom :: forall l x. FieldDecl l -&gt; Rep (FieldDecl l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-546"></span><span>
</span><span id="line-547"></span><span>
</span><span id="line-548"></span><span class="hs-comment">-- | A single constructor declaration in a GADT data type declaration.</span><span>
</span><span id="line-549"></span><span class="hs-comment">--</span><span>
</span><span id="line-550"></span><span class="hs-comment">-- If the GADT is declared using the record syntax, e.g.</span><span>
</span><span id="line-551"></span><span class="hs-comment">--</span><span>
</span><span id="line-552"></span><span class="hs-comment">-- &gt;data Ty where</span><span>
</span><span id="line-553"></span><span class="hs-comment">-- &gt;  TCon :: { field1 :: Int, field2 :: Bool } -&gt; Ty</span><span>
</span><span id="line-554"></span><span class="hs-comment">--</span><span>
</span><span id="line-555"></span><span class="hs-comment">-- then the fields are stored as a list of 'FieldDecl's, and the final type</span><span>
</span><span id="line-556"></span><span class="hs-comment">-- (@Ty@ in the above example) is stored in the last 'Type' field.</span><span>
</span><span id="line-557"></span><span class="hs-comment">--</span><span>
</span><span id="line-558"></span><span class="hs-comment">-- If the GADT is declared using the ordinary syntax, e.g.</span><span>
</span><span id="line-559"></span><span class="hs-comment">--</span><span>
</span><span id="line-560"></span><span class="hs-comment">-- &gt;data Ty where</span><span>
</span><span id="line-561"></span><span class="hs-comment">-- &gt;  TCon :: Int -&gt; Bool -&gt; Ty</span><span>
</span><span id="line-562"></span><span class="hs-comment">--</span><span>
</span><span id="line-563"></span><span class="hs-comment">-- then @'Maybe' ['FieldDecl' l]@ is 'Nothing', and the whole constructor's</span><span>
</span><span id="line-564"></span><span class="hs-comment">-- type (such as @Int -&gt; Bool -&gt; Ty@) is stored in the last 'Type' field.</span><span>
</span><span id="line-565"></span><span id="local-6989586621679434980"><span id="local-6989586621679434981"></span></span><span class="hs-keyword">data</span><span> </span><span id="GadtDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GadtDecl"><span class="hs-identifier hs-var">GadtDecl</span></a></span></span><span> </span><span id="local-6989586621679452739"><span class="annot"><a href="#local-6989586621679452739"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-566"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="GadtDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GadtDecl"><span class="hs-identifier hs-var">GadtDecl</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452739"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452739"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-567"></span><span>        </span><span class="hs-comment">{-forall-}</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier hs-type">TyVarBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452739"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-comment">{- . -}</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452739"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-568"></span><span>        </span><span class="hs-comment">{- =&gt; -}</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldDecl"><span class="hs-identifier hs-type">FieldDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452739"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452739"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-569"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679434966"><span id="local-6989586621679434977"><span class="annot"><span class="annottext">GadtDecl l -&gt; GadtDecl l -&gt; Bool
forall l. Eq l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: GadtDecl l -&gt; GadtDecl l -&gt; Bool
$c/= :: forall l. Eq l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; Bool
== :: GadtDecl l -&gt; GadtDecl l -&gt; Bool
$c== :: forall l. Eq l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434927"><span id="local-6989586621679434929"><span id="local-6989586621679434932"><span id="local-6989586621679434935"><span id="local-6989586621679434938"><span id="local-6989586621679434949"><span id="local-6989586621679434960"><span class="annot"><span class="annottext">GadtDecl l -&gt; GadtDecl l -&gt; Bool
GadtDecl l -&gt; GadtDecl l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (GadtDecl l)
forall l. Ord l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; Bool
forall l. Ord l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; Ordering
forall l. Ord l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; GadtDecl l
min :: GadtDecl l -&gt; GadtDecl l -&gt; GadtDecl l
$cmin :: forall l. Ord l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; GadtDecl l
max :: GadtDecl l -&gt; GadtDecl l -&gt; GadtDecl l
$cmax :: forall l. Ord l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; GadtDecl l
&gt;= :: GadtDecl l -&gt; GadtDecl l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; Bool
&gt; :: GadtDecl l -&gt; GadtDecl l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; Bool
&lt;= :: GadtDecl l -&gt; GadtDecl l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; Bool
&lt; :: GadtDecl l -&gt; GadtDecl l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; Bool
compare :: GadtDecl l -&gt; GadtDecl l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; GadtDecl l -&gt; GadtDecl l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434907"><span id="local-6989586621679434909"><span id="local-6989586621679434921"><span class="annot"><span class="annottext">Int -&gt; GadtDecl l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; GadtDecl l -&gt; ShowS
forall l. Show l =&gt; [GadtDecl l] -&gt; ShowS
forall l. Show l =&gt; GadtDecl l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [GadtDecl l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [GadtDecl l] -&gt; ShowS
show :: GadtDecl l -&gt; String
$cshow :: forall l. Show l =&gt; GadtDecl l -&gt; String
showsPrec :: Int -&gt; GadtDecl l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; GadtDecl l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679434852"><span id="local-6989586621679434854"><span id="local-6989586621679434856"><span id="local-6989586621679434858"><span id="local-6989586621679434860"><span id="local-6989586621679434862"><span id="local-6989586621679434864"><span id="local-6989586621679434866"><span id="local-6989586621679434868"><span id="local-6989586621679434874"><span id="local-6989586621679434876"><span id="local-6989586621679434878"><span id="local-6989586621679434889"><span id="local-6989586621679434900"><span class="annot"><span class="annottext">GadtDecl l -&gt; DataType
GadtDecl l -&gt; Constr
forall {l}. Data l =&gt; Typeable (GadtDecl l)
forall l. Data l =&gt; GadtDecl l -&gt; DataType
forall l. Data l =&gt; GadtDecl l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; GadtDecl l -&gt; GadtDecl l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; GadtDecl l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; GadtDecl l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GadtDecl l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GadtDecl l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GadtDecl l -&gt; m (GadtDecl l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GadtDecl l -&gt; m (GadtDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (GadtDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; GadtDecl l -&gt; c (GadtDecl l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (GadtDecl l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (GadtDecl l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (GadtDecl l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; GadtDecl l -&gt; c (GadtDecl l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (GadtDecl l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GadtDecl l -&gt; m (GadtDecl l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GadtDecl l -&gt; m (GadtDecl l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GadtDecl l -&gt; m (GadtDecl l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GadtDecl l -&gt; m (GadtDecl l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GadtDecl l -&gt; m (GadtDecl l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GadtDecl l -&gt; m (GadtDecl l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; GadtDecl l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; GadtDecl l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; GadtDecl l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; GadtDecl l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GadtDecl l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GadtDecl l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GadtDecl l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GadtDecl l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; GadtDecl l -&gt; GadtDecl l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; GadtDecl l -&gt; GadtDecl l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (GadtDecl l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (GadtDecl l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (GadtDecl l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (GadtDecl l))
dataTypeOf :: GadtDecl l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; GadtDecl l -&gt; DataType
toConstr :: GadtDecl l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; GadtDecl l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (GadtDecl l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (GadtDecl l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; GadtDecl l -&gt; c (GadtDecl l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; GadtDecl l -&gt; c (GadtDecl l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434778"><span id="local-6989586621679434780"><span id="local-6989586621679434782"><span id="local-6989586621679434784"><span id="local-6989586621679434786"><span id="local-6989586621679434788"><span id="local-6989586621679434790"><span id="local-6989586621679434792"><span id="local-6989586621679434794"><span id="local-6989586621679434796"><span id="local-6989586621679434798"><span id="local-6989586621679434800"><span id="local-6989586621679434802"><span id="local-6989586621679434814"><span id="local-6989586621679434816"><span id="local-6989586621679434844"><span id="local-6989586621679434846"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; GadtDecl a -&gt; Bool
forall a. Num a =&gt; GadtDecl a -&gt; a
forall a. Ord a =&gt; GadtDecl a -&gt; a
forall m. Monoid m =&gt; GadtDecl m -&gt; m
forall a. GadtDecl a -&gt; Bool
forall a. GadtDecl a -&gt; Int
forall a. GadtDecl a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; GadtDecl a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; GadtDecl a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; GadtDecl a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; GadtDecl a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; GadtDecl a -&gt; a
$cproduct :: forall a. Num a =&gt; GadtDecl a -&gt; a
sum :: forall a. Num a =&gt; GadtDecl a -&gt; a
$csum :: forall a. Num a =&gt; GadtDecl a -&gt; a
minimum :: forall a. Ord a =&gt; GadtDecl a -&gt; a
$cminimum :: forall a. Ord a =&gt; GadtDecl a -&gt; a
maximum :: forall a. Ord a =&gt; GadtDecl a -&gt; a
$cmaximum :: forall a. Ord a =&gt; GadtDecl a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; GadtDecl a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; GadtDecl a -&gt; Bool
length :: forall a. GadtDecl a -&gt; Int
$clength :: forall a. GadtDecl a -&gt; Int
null :: forall a. GadtDecl a -&gt; Bool
$cnull :: forall a. GadtDecl a -&gt; Bool
toList :: forall a. GadtDecl a -&gt; [a]
$ctoList :: forall a. GadtDecl a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; GadtDecl a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; GadtDecl a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; GadtDecl a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; GadtDecl a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; GadtDecl a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; GadtDecl a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; GadtDecl a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; GadtDecl a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; GadtDecl a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; GadtDecl a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; GadtDecl a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; GadtDecl a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; GadtDecl a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; GadtDecl a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; GadtDecl a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; GadtDecl a -&gt; m
fold :: forall m. Monoid m =&gt; GadtDecl m -&gt; m
$cfold :: forall m. Monoid m =&gt; GadtDecl m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434740"><span id="local-6989586621679434742"><span id="local-6989586621679434744"><span id="local-6989586621679434772"><span class="annot"><span class="annottext">Functor GadtDecl
Foldable GadtDecl
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; GadtDecl (m a) -&gt; m (GadtDecl a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
GadtDecl (f a) -&gt; f (GadtDecl a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; GadtDecl a -&gt; m (GadtDecl b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; GadtDecl a -&gt; f (GadtDecl b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; GadtDecl (m a) -&gt; m (GadtDecl a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; GadtDecl (m a) -&gt; m (GadtDecl a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; GadtDecl a -&gt; m (GadtDecl b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; GadtDecl a -&gt; m (GadtDecl b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
GadtDecl (f a) -&gt; f (GadtDecl a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
GadtDecl (f a) -&gt; f (GadtDecl a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; GadtDecl a -&gt; f (GadtDecl b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; GadtDecl a -&gt; f (GadtDecl b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434726"><span id="local-6989586621679434738"><span class="annot"><span class="annottext">forall a b. a -&gt; GadtDecl b -&gt; GadtDecl a
forall a b. (a -&gt; b) -&gt; GadtDecl a -&gt; GadtDecl b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; GadtDecl b -&gt; GadtDecl a
$c&lt;$ :: forall a b. a -&gt; GadtDecl b -&gt; GadtDecl a
fmap :: forall a b. (a -&gt; b) -&gt; GadtDecl a -&gt; GadtDecl b
$cfmap :: forall a b. (a -&gt; b) -&gt; GadtDecl a -&gt; GadtDecl b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (GadtDecl l) x -&gt; GadtDecl l
forall l x. GadtDecl l -&gt; Rep (GadtDecl l) x
$cto :: forall l x. Rep (GadtDecl l) x -&gt; GadtDecl l
$cfrom :: forall l x. GadtDecl l -&gt; Rep (GadtDecl l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-570"></span><span>
</span><span id="line-571"></span><span class="hs-comment">-- | Declarations inside a class declaration.</span><span>
</span><span id="line-572"></span><span id="local-6989586621679434711"><span id="local-6989586621679434712"></span></span><span class="hs-keyword">data</span><span> </span><span id="ClassDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClassDecl"><span class="hs-identifier hs-var">ClassDecl</span></a></span></span><span> </span><span id="local-6989586621679452734"><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-573"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="ClsDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsDecl"><span class="hs-identifier hs-var">ClsDecl</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-574"></span><span>            </span><span class="hs-comment">-- ^ ordinary declaration</span><span>
</span><span id="line-575"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ClsDataFam"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsDataFam"><span class="hs-identifier hs-var">ClsDataFam</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ResultSig"><span class="hs-identifier hs-type">ResultSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-576"></span><span>            </span><span class="hs-comment">-- ^ declaration of an associated data type</span><span>
</span><span id="line-577"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ClsTyFam"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsTyFam"><span class="hs-identifier hs-var">ClsTyFam</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span>                     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ResultSig"><span class="hs-identifier hs-type">ResultSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InjectivityInfo"><span class="hs-identifier hs-type">InjectivityInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-578"></span><span>            </span><span class="hs-comment">-- ^ declaration of an associated type synonym</span><span>
</span><span id="line-579"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ClsTyDef"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsTyDef"><span class="hs-identifier hs-var">ClsTyDef</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeEqn"><span class="hs-identifier hs-type">TypeEqn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-580"></span><span>            </span><span class="hs-comment">-- ^ default choice for an associated type synonym</span><span>
</span><span id="line-581"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ClsDefSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsDefSig"><span class="hs-identifier hs-var">ClsDefSig</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452734"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-582"></span><span>            </span><span class="hs-comment">-- ^ default signature</span><span>
</span><span id="line-583"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679434684"><span id="local-6989586621679434704"><span class="annot"><span class="annottext">ClassDecl l -&gt; ClassDecl l -&gt; Bool
forall l. Eq l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ClassDecl l -&gt; ClassDecl l -&gt; Bool
$c/= :: forall l. Eq l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; Bool
== :: ClassDecl l -&gt; ClassDecl l -&gt; Bool
$c== :: forall l. Eq l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434650"><span id="local-6989586621679434652"><span id="local-6989586621679434654"><span id="local-6989586621679434656"><span id="local-6989586621679434658"><span id="local-6989586621679434660"><span id="local-6989586621679434680"><span class="annot"><span class="annottext">ClassDecl l -&gt; ClassDecl l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (ClassDecl l)
forall l. Ord l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; Bool
forall l. Ord l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; Ordering
forall l. Ord l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; ClassDecl l
min :: ClassDecl l -&gt; ClassDecl l -&gt; ClassDecl l
$cmin :: forall l. Ord l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; ClassDecl l
max :: ClassDecl l -&gt; ClassDecl l -&gt; ClassDecl l
$cmax :: forall l. Ord l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; ClassDecl l
&gt;= :: ClassDecl l -&gt; ClassDecl l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; Bool
&gt; :: ClassDecl l -&gt; ClassDecl l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; Bool
&lt;= :: ClassDecl l -&gt; ClassDecl l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; Bool
&lt; :: ClassDecl l -&gt; ClassDecl l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; Bool
compare :: ClassDecl l -&gt; ClassDecl l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; ClassDecl l -&gt; ClassDecl l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434621"><span id="local-6989586621679434623"><span id="local-6989586621679434648"><span class="annot"><span class="annottext">Int -&gt; ClassDecl l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; ClassDecl l -&gt; ShowS
forall l. Show l =&gt; [ClassDecl l] -&gt; ShowS
forall l. Show l =&gt; ClassDecl l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ClassDecl l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [ClassDecl l] -&gt; ShowS
show :: ClassDecl l -&gt; String
$cshow :: forall l. Show l =&gt; ClassDecl l -&gt; String
showsPrec :: Int -&gt; ClassDecl l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; ClassDecl l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679434550"><span id="local-6989586621679434552"><span id="local-6989586621679434554"><span id="local-6989586621679434556"><span id="local-6989586621679434558"><span id="local-6989586621679434560"><span id="local-6989586621679434562"><span id="local-6989586621679434564"><span id="local-6989586621679434566"><span id="local-6989586621679434572"><span id="local-6989586621679434574"><span id="local-6989586621679434576"><span id="local-6989586621679434596"><span id="local-6989586621679434616"><span class="annot"><span class="annottext">ClassDecl l -&gt; DataType
ClassDecl l -&gt; Constr
forall {l}. Data l =&gt; Typeable (ClassDecl l)
forall l. Data l =&gt; ClassDecl l -&gt; DataType
forall l. Data l =&gt; ClassDecl l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ClassDecl l -&gt; ClassDecl l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ClassDecl l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ClassDecl l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ClassDecl l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ClassDecl l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ClassDecl l -&gt; m (ClassDecl l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ClassDecl l -&gt; m (ClassDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ClassDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ClassDecl l -&gt; c (ClassDecl l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ClassDecl l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ClassDecl l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ClassDecl l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ClassDecl l -&gt; c (ClassDecl l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ClassDecl l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ClassDecl l -&gt; m (ClassDecl l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ClassDecl l -&gt; m (ClassDecl l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ClassDecl l -&gt; m (ClassDecl l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ClassDecl l -&gt; m (ClassDecl l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ClassDecl l -&gt; m (ClassDecl l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; ClassDecl l -&gt; m (ClassDecl l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ClassDecl l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ClassDecl l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ClassDecl l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ClassDecl l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ClassDecl l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ClassDecl l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ClassDecl l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ClassDecl l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ClassDecl l -&gt; ClassDecl l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ClassDecl l -&gt; ClassDecl l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ClassDecl l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ClassDecl l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ClassDecl l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ClassDecl l))
dataTypeOf :: ClassDecl l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; ClassDecl l -&gt; DataType
toConstr :: ClassDecl l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; ClassDecl l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ClassDecl l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ClassDecl l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ClassDecl l -&gt; c (ClassDecl l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ClassDecl l -&gt; c (ClassDecl l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434463"><span id="local-6989586621679434465"><span id="local-6989586621679434467"><span id="local-6989586621679434469"><span id="local-6989586621679434471"><span id="local-6989586621679434473"><span id="local-6989586621679434475"><span id="local-6989586621679434477"><span id="local-6989586621679434479"><span id="local-6989586621679434481"><span id="local-6989586621679434483"><span id="local-6989586621679434485"><span id="local-6989586621679434487"><span id="local-6989586621679434503"><span id="local-6989586621679434505"><span id="local-6989586621679434546"><span id="local-6989586621679434548"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; ClassDecl a -&gt; Bool
forall a. Num a =&gt; ClassDecl a -&gt; a
forall a. Ord a =&gt; ClassDecl a -&gt; a
forall m. Monoid m =&gt; ClassDecl m -&gt; m
forall a. ClassDecl a -&gt; Bool
forall a. ClassDecl a -&gt; Int
forall a. ClassDecl a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; ClassDecl a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ClassDecl a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ClassDecl a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ClassDecl a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; ClassDecl a -&gt; a
$cproduct :: forall a. Num a =&gt; ClassDecl a -&gt; a
sum :: forall a. Num a =&gt; ClassDecl a -&gt; a
$csum :: forall a. Num a =&gt; ClassDecl a -&gt; a
minimum :: forall a. Ord a =&gt; ClassDecl a -&gt; a
$cminimum :: forall a. Ord a =&gt; ClassDecl a -&gt; a
maximum :: forall a. Ord a =&gt; ClassDecl a -&gt; a
$cmaximum :: forall a. Ord a =&gt; ClassDecl a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; ClassDecl a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; ClassDecl a -&gt; Bool
length :: forall a. ClassDecl a -&gt; Int
$clength :: forall a. ClassDecl a -&gt; Int
null :: forall a. ClassDecl a -&gt; Bool
$cnull :: forall a. ClassDecl a -&gt; Bool
toList :: forall a. ClassDecl a -&gt; [a]
$ctoList :: forall a. ClassDecl a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ClassDecl a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ClassDecl a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ClassDecl a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ClassDecl a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ClassDecl a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ClassDecl a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ClassDecl a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ClassDecl a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ClassDecl a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ClassDecl a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ClassDecl a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ClassDecl a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ClassDecl a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ClassDecl a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ClassDecl a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ClassDecl a -&gt; m
fold :: forall m. Monoid m =&gt; ClassDecl m -&gt; m
$cfold :: forall m. Monoid m =&gt; ClassDecl m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434412"><span id="local-6989586621679434414"><span id="local-6989586621679434416"><span id="local-6989586621679434457"><span class="annot"><span class="annottext">Functor ClassDecl
Foldable ClassDecl
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
ClassDecl (m a) -&gt; m (ClassDecl a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
ClassDecl (f a) -&gt; f (ClassDecl a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ClassDecl a -&gt; m (ClassDecl b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ClassDecl a -&gt; f (ClassDecl b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ClassDecl (m a) -&gt; m (ClassDecl a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ClassDecl (m a) -&gt; m (ClassDecl a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ClassDecl a -&gt; m (ClassDecl b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ClassDecl a -&gt; m (ClassDecl b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ClassDecl (f a) -&gt; f (ClassDecl a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ClassDecl (f a) -&gt; f (ClassDecl a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ClassDecl a -&gt; f (ClassDecl b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ClassDecl a -&gt; f (ClassDecl b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434394"><span id="local-6989586621679434410"><span class="annot"><span class="annottext">forall a b. a -&gt; ClassDecl b -&gt; ClassDecl a
forall a b. (a -&gt; b) -&gt; ClassDecl a -&gt; ClassDecl b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; ClassDecl b -&gt; ClassDecl a
$c&lt;$ :: forall a b. a -&gt; ClassDecl b -&gt; ClassDecl a
fmap :: forall a b. (a -&gt; b) -&gt; ClassDecl a -&gt; ClassDecl b
$cfmap :: forall a b. (a -&gt; b) -&gt; ClassDecl a -&gt; ClassDecl b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (ClassDecl l) x -&gt; ClassDecl l
forall l x. ClassDecl l -&gt; Rep (ClassDecl l) x
$cto :: forall l x. Rep (ClassDecl l) x -&gt; ClassDecl l
$cfrom :: forall l x. ClassDecl l -&gt; Rep (ClassDecl l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-584"></span><span>
</span><span id="line-585"></span><span class="hs-comment">-- | Declarations inside an instance declaration.</span><span>
</span><span id="line-586"></span><span id="local-6989586621679434375"><span id="local-6989586621679434376"></span></span><span class="hs-keyword">data</span><span> </span><span id="InstDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstDecl"><span class="hs-identifier hs-var">InstDecl</span></a></span></span><span> </span><span id="local-6989586621679452740"><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-587"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="InsDecl"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsDecl"><span class="hs-identifier hs-var">InsDecl</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-588"></span><span>            </span><span class="hs-comment">-- ^ ordinary declaration</span><span>
</span><span id="line-589"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="InsType"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsType"><span class="hs-identifier hs-var">InsType</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-590"></span><span>            </span><span class="hs-comment">-- ^ an associated type definition</span><span>
</span><span id="line-591"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="InsData"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsData"><span class="hs-identifier hs-var">InsData</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataOrNew"><span class="hs-identifier hs-type">DataOrNew</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualConDecl"><span class="hs-identifier hs-type">QualConDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-type">Deriving</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-592"></span><span>            </span><span class="hs-comment">-- ^ an associated data type implementation</span><span>
</span><span id="line-593"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="InsGData"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsGData"><span class="hs-identifier hs-var">InsGData</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataOrNew"><span class="hs-identifier hs-type">DataOrNew</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GadtDecl"><span class="hs-identifier hs-type">GadtDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-type">Deriving</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452740"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-594"></span><span>            </span><span class="hs-comment">-- ^ an associated data type implemented using GADT style</span><span>
</span><span id="line-595"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679434348"><span id="local-6989586621679434369"><span class="annot"><span class="annottext">InstDecl l -&gt; InstDecl l -&gt; Bool
forall l. Eq l =&gt; InstDecl l -&gt; InstDecl l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: InstDecl l -&gt; InstDecl l -&gt; Bool
$c/= :: forall l. Eq l =&gt; InstDecl l -&gt; InstDecl l -&gt; Bool
== :: InstDecl l -&gt; InstDecl l -&gt; Bool
$c== :: forall l. Eq l =&gt; InstDecl l -&gt; InstDecl l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434313"><span id="local-6989586621679434315"><span id="local-6989586621679434317"><span id="local-6989586621679434319"><span id="local-6989586621679434321"><span id="local-6989586621679434323"><span id="local-6989586621679434344"><span class="annot"><span class="annottext">InstDecl l -&gt; InstDecl l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (InstDecl l)
forall l. Ord l =&gt; InstDecl l -&gt; InstDecl l -&gt; Bool
forall l. Ord l =&gt; InstDecl l -&gt; InstDecl l -&gt; Ordering
forall l. Ord l =&gt; InstDecl l -&gt; InstDecl l -&gt; InstDecl l
min :: InstDecl l -&gt; InstDecl l -&gt; InstDecl l
$cmin :: forall l. Ord l =&gt; InstDecl l -&gt; InstDecl l -&gt; InstDecl l
max :: InstDecl l -&gt; InstDecl l -&gt; InstDecl l
$cmax :: forall l. Ord l =&gt; InstDecl l -&gt; InstDecl l -&gt; InstDecl l
&gt;= :: InstDecl l -&gt; InstDecl l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; InstDecl l -&gt; InstDecl l -&gt; Bool
&gt; :: InstDecl l -&gt; InstDecl l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; InstDecl l -&gt; InstDecl l -&gt; Bool
&lt;= :: InstDecl l -&gt; InstDecl l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; InstDecl l -&gt; InstDecl l -&gt; Bool
&lt; :: InstDecl l -&gt; InstDecl l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; InstDecl l -&gt; InstDecl l -&gt; Bool
compare :: InstDecl l -&gt; InstDecl l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; InstDecl l -&gt; InstDecl l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434284"><span id="local-6989586621679434286"><span id="local-6989586621679434311"><span class="annot"><span class="annottext">Int -&gt; InstDecl l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; InstDecl l -&gt; ShowS
forall l. Show l =&gt; [InstDecl l] -&gt; ShowS
forall l. Show l =&gt; InstDecl l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [InstDecl l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [InstDecl l] -&gt; ShowS
show :: InstDecl l -&gt; String
$cshow :: forall l. Show l =&gt; InstDecl l -&gt; String
showsPrec :: Int -&gt; InstDecl l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; InstDecl l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679434211"><span id="local-6989586621679434213"><span id="local-6989586621679434215"><span id="local-6989586621679434217"><span id="local-6989586621679434219"><span id="local-6989586621679434221"><span id="local-6989586621679434223"><span id="local-6989586621679434225"><span id="local-6989586621679434227"><span id="local-6989586621679434233"><span id="local-6989586621679434235"><span id="local-6989586621679434237"><span id="local-6989586621679434258"><span id="local-6989586621679434279"><span class="annot"><span class="annottext">InstDecl l -&gt; DataType
InstDecl l -&gt; Constr
forall {l}. Data l =&gt; Typeable (InstDecl l)
forall l. Data l =&gt; InstDecl l -&gt; DataType
forall l. Data l =&gt; InstDecl l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; InstDecl l -&gt; InstDecl l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InstDecl l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; InstDecl l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstDecl l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstDecl l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstDecl l -&gt; m (InstDecl l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstDecl l -&gt; m (InstDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstDecl l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstDecl l -&gt; c (InstDecl l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstDecl l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InstDecl l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstDecl l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstDecl l -&gt; c (InstDecl l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstDecl l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstDecl l -&gt; m (InstDecl l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstDecl l -&gt; m (InstDecl l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstDecl l -&gt; m (InstDecl l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstDecl l -&gt; m (InstDecl l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstDecl l -&gt; m (InstDecl l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; InstDecl l -&gt; m (InstDecl l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InstDecl l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; InstDecl l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; InstDecl l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; InstDecl l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstDecl l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstDecl l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstDecl l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; InstDecl l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; InstDecl l -&gt; InstDecl l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; InstDecl l -&gt; InstDecl l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InstDecl l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (InstDecl l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstDecl l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (InstDecl l))
dataTypeOf :: InstDecl l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; InstDecl l -&gt; DataType
toConstr :: InstDecl l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; InstDecl l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstDecl l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (InstDecl l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstDecl l -&gt; c (InstDecl l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; InstDecl l -&gt; c (InstDecl l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434113"><span id="local-6989586621679434115"><span id="local-6989586621679434117"><span id="local-6989586621679434119"><span id="local-6989586621679434121"><span id="local-6989586621679434123"><span id="local-6989586621679434125"><span id="local-6989586621679434127"><span id="local-6989586621679434129"><span id="local-6989586621679434131"><span id="local-6989586621679434133"><span id="local-6989586621679434135"><span id="local-6989586621679434137"><span id="local-6989586621679434156"><span id="local-6989586621679434158"><span id="local-6989586621679434207"><span id="local-6989586621679434209"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; InstDecl a -&gt; Bool
forall a. Num a =&gt; InstDecl a -&gt; a
forall a. Ord a =&gt; InstDecl a -&gt; a
forall m. Monoid m =&gt; InstDecl m -&gt; m
forall a. InstDecl a -&gt; Bool
forall a. InstDecl a -&gt; Int
forall a. InstDecl a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; InstDecl a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstDecl a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstDecl a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstDecl a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; InstDecl a -&gt; a
$cproduct :: forall a. Num a =&gt; InstDecl a -&gt; a
sum :: forall a. Num a =&gt; InstDecl a -&gt; a
$csum :: forall a. Num a =&gt; InstDecl a -&gt; a
minimum :: forall a. Ord a =&gt; InstDecl a -&gt; a
$cminimum :: forall a. Ord a =&gt; InstDecl a -&gt; a
maximum :: forall a. Ord a =&gt; InstDecl a -&gt; a
$cmaximum :: forall a. Ord a =&gt; InstDecl a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; InstDecl a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; InstDecl a -&gt; Bool
length :: forall a. InstDecl a -&gt; Int
$clength :: forall a. InstDecl a -&gt; Int
null :: forall a. InstDecl a -&gt; Bool
$cnull :: forall a. InstDecl a -&gt; Bool
toList :: forall a. InstDecl a -&gt; [a]
$ctoList :: forall a. InstDecl a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstDecl a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstDecl a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstDecl a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; InstDecl a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstDecl a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstDecl a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstDecl a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; InstDecl a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstDecl a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstDecl a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstDecl a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; InstDecl a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstDecl a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstDecl a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstDecl a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; InstDecl a -&gt; m
fold :: forall m. Monoid m =&gt; InstDecl m -&gt; m
$cfold :: forall m. Monoid m =&gt; InstDecl m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434054"><span id="local-6989586621679434056"><span id="local-6989586621679434058"><span id="local-6989586621679434107"><span class="annot"><span class="annottext">Functor InstDecl
Foldable InstDecl
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; InstDecl (m a) -&gt; m (InstDecl a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
InstDecl (f a) -&gt; f (InstDecl a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InstDecl a -&gt; m (InstDecl b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InstDecl a -&gt; f (InstDecl b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; InstDecl (m a) -&gt; m (InstDecl a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; InstDecl (m a) -&gt; m (InstDecl a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InstDecl a -&gt; m (InstDecl b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; InstDecl a -&gt; m (InstDecl b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
InstDecl (f a) -&gt; f (InstDecl a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
InstDecl (f a) -&gt; f (InstDecl a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InstDecl a -&gt; f (InstDecl b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; InstDecl a -&gt; f (InstDecl b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679434033"><span id="local-6989586621679434052"><span class="annot"><span class="annottext">forall a b. a -&gt; InstDecl b -&gt; InstDecl a
forall a b. (a -&gt; b) -&gt; InstDecl a -&gt; InstDecl b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; InstDecl b -&gt; InstDecl a
$c&lt;$ :: forall a b. a -&gt; InstDecl b -&gt; InstDecl a
fmap :: forall a b. (a -&gt; b) -&gt; InstDecl a -&gt; InstDecl b
$cfmap :: forall a b. (a -&gt; b) -&gt; InstDecl a -&gt; InstDecl b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (InstDecl l) x -&gt; InstDecl l
forall l x. InstDecl l -&gt; Rep (InstDecl l) x
$cto :: forall l x. Rep (InstDecl l) x -&gt; InstDecl l
$cfrom :: forall l x. InstDecl l -&gt; Rep (InstDecl l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-596"></span><span>
</span><span id="line-597"></span><span class="hs-comment">-- | The type of a constructor argument or field, optionally including</span><span>
</span><span id="line-598"></span><span class="hs-comment">--   a strictness annotation.</span><span>
</span><span id="line-599"></span><span id="local-6989586621679434011"><span id="local-6989586621679434012"></span></span><span class="hs-keyword">data</span><span> </span><span id="BangType"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BangType"><span class="hs-identifier hs-var">BangType</span></a></span></span><span> </span><span id="local-6989586621679452614"><span class="annot"><a href="#local-6989586621679452614"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-600"></span><span>     </span><span class="hs-glyph">=</span><span> </span><span id="BangedTy"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BangedTy"><span class="hs-identifier hs-var">BangedTy</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452614"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-comment">-- ^ strict component, marked with \&quot;@!@\&quot;</span><span>
</span><span id="line-601"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="LazyTy"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LazyTy"><span class="hs-identifier hs-var">LazyTy</span></a></span></span><span>     </span><span class="annot"><a href="#local-6989586621679452614"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-comment">-- ^ lazy component, marked with \&quot;@~@\&quot;</span><span>
</span><span id="line-602"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="NoStrictAnnot"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoStrictAnnot"><span class="hs-identifier hs-var">NoStrictAnnot</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452614"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-comment">-- ^ No strictness information</span><span>
</span><span id="line-603"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679434001"><span id="local-6989586621679434006"><span class="annot"><span class="annottext">BangType l -&gt; BangType l -&gt; Bool
forall l. Eq l =&gt; BangType l -&gt; BangType l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: BangType l -&gt; BangType l -&gt; Bool
$c/= :: forall l. Eq l =&gt; BangType l -&gt; BangType l -&gt; Bool
== :: BangType l -&gt; BangType l -&gt; Bool
$c== :: forall l. Eq l =&gt; BangType l -&gt; BangType l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433976"><span id="local-6989586621679433978"><span id="local-6989586621679433981"><span id="local-6989586621679433984"><span id="local-6989586621679433987"><span id="local-6989586621679433992"><span id="local-6989586621679433997"><span class="annot"><span class="annottext">BangType l -&gt; BangType l -&gt; Bool
BangType l -&gt; BangType l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (BangType l)
forall l. Ord l =&gt; BangType l -&gt; BangType l -&gt; Bool
forall l. Ord l =&gt; BangType l -&gt; BangType l -&gt; Ordering
forall l. Ord l =&gt; BangType l -&gt; BangType l -&gt; BangType l
min :: BangType l -&gt; BangType l -&gt; BangType l
$cmin :: forall l. Ord l =&gt; BangType l -&gt; BangType l -&gt; BangType l
max :: BangType l -&gt; BangType l -&gt; BangType l
$cmax :: forall l. Ord l =&gt; BangType l -&gt; BangType l -&gt; BangType l
&gt;= :: BangType l -&gt; BangType l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; BangType l -&gt; BangType l -&gt; Bool
&gt; :: BangType l -&gt; BangType l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; BangType l -&gt; BangType l -&gt; Bool
&lt;= :: BangType l -&gt; BangType l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; BangType l -&gt; BangType l -&gt; Bool
&lt; :: BangType l -&gt; BangType l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; BangType l -&gt; BangType l -&gt; Bool
compare :: BangType l -&gt; BangType l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; BangType l -&gt; BangType l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433964"><span id="local-6989586621679433966"><span id="local-6989586621679433974"><span class="annot"><span class="annottext">Int -&gt; BangType l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; BangType l -&gt; ShowS
forall l. Show l =&gt; [BangType l] -&gt; ShowS
forall l. Show l =&gt; BangType l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [BangType l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [BangType l] -&gt; ShowS
show :: BangType l -&gt; String
$cshow :: forall l. Show l =&gt; BangType l -&gt; String
showsPrec :: Int -&gt; BangType l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; BangType l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679433923"><span id="local-6989586621679433925"><span id="local-6989586621679433927"><span id="local-6989586621679433929"><span id="local-6989586621679433931"><span id="local-6989586621679433933"><span id="local-6989586621679433935"><span id="local-6989586621679433937"><span id="local-6989586621679433939"><span id="local-6989586621679433945"><span id="local-6989586621679433947"><span id="local-6989586621679433949"><span id="local-6989586621679433954"><span id="local-6989586621679433959"><span class="annot"><span class="annottext">BangType l -&gt; DataType
BangType l -&gt; Constr
forall {l}. Data l =&gt; Typeable (BangType l)
forall l. Data l =&gt; BangType l -&gt; DataType
forall l. Data l =&gt; BangType l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; BangType l -&gt; BangType l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BangType l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; BangType l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BangType l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BangType l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BangType l -&gt; m (BangType l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BangType l -&gt; m (BangType l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (BangType l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BangType l -&gt; c (BangType l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (BangType l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (BangType l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (BangType l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BangType l -&gt; c (BangType l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (BangType l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BangType l -&gt; m (BangType l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BangType l -&gt; m (BangType l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BangType l -&gt; m (BangType l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BangType l -&gt; m (BangType l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BangType l -&gt; m (BangType l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; BangType l -&gt; m (BangType l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BangType l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; BangType l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; BangType l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; BangType l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BangType l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BangType l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BangType l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; BangType l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; BangType l -&gt; BangType l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; BangType l -&gt; BangType l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (BangType l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (BangType l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (BangType l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (BangType l))
dataTypeOf :: BangType l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; BangType l -&gt; DataType
toConstr :: BangType l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; BangType l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (BangType l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (BangType l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BangType l -&gt; c (BangType l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; BangType l -&gt; c (BangType l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433888"><span id="local-6989586621679433890"><span id="local-6989586621679433892"><span id="local-6989586621679433894"><span id="local-6989586621679433896"><span id="local-6989586621679433898"><span id="local-6989586621679433900"><span id="local-6989586621679433902"><span id="local-6989586621679433904"><span id="local-6989586621679433906"><span id="local-6989586621679433908"><span id="local-6989586621679433910"><span id="local-6989586621679433912"><span id="local-6989586621679433914"><span id="local-6989586621679433916"><span id="local-6989586621679433919"><span id="local-6989586621679433921"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; BangType a -&gt; Bool
forall a. Num a =&gt; BangType a -&gt; a
forall a. Ord a =&gt; BangType a -&gt; a
forall m. Monoid m =&gt; BangType m -&gt; m
forall a. BangType a -&gt; Bool
forall a. BangType a -&gt; Int
forall a. BangType a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; BangType a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; BangType a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; BangType a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; BangType a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; BangType a -&gt; a
$cproduct :: forall a. Num a =&gt; BangType a -&gt; a
sum :: forall a. Num a =&gt; BangType a -&gt; a
$csum :: forall a. Num a =&gt; BangType a -&gt; a
minimum :: forall a. Ord a =&gt; BangType a -&gt; a
$cminimum :: forall a. Ord a =&gt; BangType a -&gt; a
maximum :: forall a. Ord a =&gt; BangType a -&gt; a
$cmaximum :: forall a. Ord a =&gt; BangType a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; BangType a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; BangType a -&gt; Bool
length :: forall a. BangType a -&gt; Int
$clength :: forall a. BangType a -&gt; Int
null :: forall a. BangType a -&gt; Bool
$cnull :: forall a. BangType a -&gt; Bool
toList :: forall a. BangType a -&gt; [a]
$ctoList :: forall a. BangType a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; BangType a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; BangType a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; BangType a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; BangType a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; BangType a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; BangType a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; BangType a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; BangType a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; BangType a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; BangType a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; BangType a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; BangType a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; BangType a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; BangType a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; BangType a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; BangType a -&gt; m
fold :: forall m. Monoid m =&gt; BangType m -&gt; m
$cfold :: forall m. Monoid m =&gt; BangType m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433870"><span id="local-6989586621679433872"><span id="local-6989586621679433874"><span id="local-6989586621679433881"><span class="annot"><span class="annottext">Functor BangType
Foldable BangType
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; BangType (m a) -&gt; m (BangType a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
BangType (f a) -&gt; f (BangType a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; BangType a -&gt; m (BangType b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; BangType a -&gt; f (BangType b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; BangType (m a) -&gt; m (BangType a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; BangType (m a) -&gt; m (BangType a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; BangType a -&gt; m (BangType b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; BangType a -&gt; m (BangType b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
BangType (f a) -&gt; f (BangType a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
BangType (f a) -&gt; f (BangType a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; BangType a -&gt; f (BangType b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; BangType a -&gt; f (BangType b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433866"><span id="local-6989586621679433868"><span class="annot"><span class="annottext">forall a b. a -&gt; BangType b -&gt; BangType a
forall a b. (a -&gt; b) -&gt; BangType a -&gt; BangType b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; BangType b -&gt; BangType a
$c&lt;$ :: forall a b. a -&gt; BangType b -&gt; BangType a
fmap :: forall a b. (a -&gt; b) -&gt; BangType a -&gt; BangType b
$cfmap :: forall a b. (a -&gt; b) -&gt; BangType a -&gt; BangType b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (BangType l) x -&gt; BangType l
forall l x. BangType l -&gt; Rep (BangType l) x
$cto :: forall l x. Rep (BangType l) x -&gt; BangType l
$cfrom :: forall l x. BangType l -&gt; Rep (BangType l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-604"></span><span>
</span><span id="line-605"></span><span id="local-6989586621679433861"><span id="local-6989586621679433862"></span></span><span class="hs-keyword">data</span><span> </span><span id="Unpackedness"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Unpackedness"><span class="hs-identifier hs-var">Unpackedness</span></a></span></span><span> </span><span id="local-6989586621679452609"><span class="annot"><a href="#local-6989586621679452609"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-606"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="Unpack"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452609"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-comment">-- ^ \&quot;@{-\# UNPACK \#-}@\&quot;</span><span>
</span><span id="line-607"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="NoUnpack"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoUnpack"><span class="hs-identifier hs-var">NoUnpack</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452609"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-comment">-- ^ \&quot;@{-\# NOUNPACK \#-}@\&quot;</span><span>
</span><span id="line-608"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="NoUnpackPragma"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoUnpackPragma"><span class="hs-identifier hs-var">NoUnpackPragma</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452609"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-comment">-- ^ No unpack pragma</span><span>
</span><span id="line-609"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679433851"><span id="local-6989586621679433856"><span class="annot"><span class="annottext">Unpackedness l -&gt; Unpackedness l -&gt; Bool
forall l. Eq l =&gt; Unpackedness l -&gt; Unpackedness l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Unpackedness l -&gt; Unpackedness l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Unpackedness l -&gt; Unpackedness l -&gt; Bool
== :: Unpackedness l -&gt; Unpackedness l -&gt; Bool
$c== :: forall l. Eq l =&gt; Unpackedness l -&gt; Unpackedness l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433826"><span id="local-6989586621679433828"><span id="local-6989586621679433831"><span id="local-6989586621679433834"><span id="local-6989586621679433837"><span id="local-6989586621679433842"><span id="local-6989586621679433847"><span class="annot"><span class="annottext">Unpackedness l -&gt; Unpackedness l -&gt; Bool
Unpackedness l -&gt; Unpackedness l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Unpackedness l)
forall l. Ord l =&gt; Unpackedness l -&gt; Unpackedness l -&gt; Bool
forall l. Ord l =&gt; Unpackedness l -&gt; Unpackedness l -&gt; Ordering
forall l.
Ord l =&gt;
Unpackedness l -&gt; Unpackedness l -&gt; Unpackedness l
min :: Unpackedness l -&gt; Unpackedness l -&gt; Unpackedness l
$cmin :: forall l.
Ord l =&gt;
Unpackedness l -&gt; Unpackedness l -&gt; Unpackedness l
max :: Unpackedness l -&gt; Unpackedness l -&gt; Unpackedness l
$cmax :: forall l.
Ord l =&gt;
Unpackedness l -&gt; Unpackedness l -&gt; Unpackedness l
&gt;= :: Unpackedness l -&gt; Unpackedness l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Unpackedness l -&gt; Unpackedness l -&gt; Bool
&gt; :: Unpackedness l -&gt; Unpackedness l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Unpackedness l -&gt; Unpackedness l -&gt; Bool
&lt;= :: Unpackedness l -&gt; Unpackedness l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Unpackedness l -&gt; Unpackedness l -&gt; Bool
&lt; :: Unpackedness l -&gt; Unpackedness l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Unpackedness l -&gt; Unpackedness l -&gt; Bool
compare :: Unpackedness l -&gt; Unpackedness l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Unpackedness l -&gt; Unpackedness l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433814"><span id="local-6989586621679433816"><span id="local-6989586621679433824"><span class="annot"><span class="annottext">Int -&gt; Unpackedness l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Unpackedness l -&gt; ShowS
forall l. Show l =&gt; [Unpackedness l] -&gt; ShowS
forall l. Show l =&gt; Unpackedness l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Unpackedness l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Unpackedness l] -&gt; ShowS
show :: Unpackedness l -&gt; String
$cshow :: forall l. Show l =&gt; Unpackedness l -&gt; String
showsPrec :: Int -&gt; Unpackedness l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Unpackedness l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679433773"><span id="local-6989586621679433775"><span id="local-6989586621679433777"><span id="local-6989586621679433779"><span id="local-6989586621679433781"><span id="local-6989586621679433783"><span id="local-6989586621679433785"><span id="local-6989586621679433787"><span id="local-6989586621679433789"><span id="local-6989586621679433795"><span id="local-6989586621679433797"><span id="local-6989586621679433799"><span id="local-6989586621679433804"><span id="local-6989586621679433809"><span class="annot"><span class="annottext">Unpackedness l -&gt; DataType
Unpackedness l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Unpackedness l)
forall l. Data l =&gt; Unpackedness l -&gt; DataType
forall l. Data l =&gt; Unpackedness l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Unpackedness l -&gt; Unpackedness l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Unpackedness l -&gt; m (Unpackedness l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Unpackedness l -&gt; m (Unpackedness l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Unpackedness l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Unpackedness l -&gt; c (Unpackedness l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Unpackedness l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Unpackedness l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Unpackedness l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Unpackedness l -&gt; c (Unpackedness l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Unpackedness l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Unpackedness l -&gt; m (Unpackedness l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Unpackedness l -&gt; m (Unpackedness l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Unpackedness l -&gt; m (Unpackedness l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Unpackedness l -&gt; m (Unpackedness l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Unpackedness l -&gt; m (Unpackedness l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; Unpackedness l -&gt; m (Unpackedness l)
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Unpackedness l -&gt; Unpackedness l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Unpackedness l -&gt; Unpackedness l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Unpackedness l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Unpackedness l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Unpackedness l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Unpackedness l))
dataTypeOf :: Unpackedness l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Unpackedness l -&gt; DataType
toConstr :: Unpackedness l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Unpackedness l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Unpackedness l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Unpackedness l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Unpackedness l -&gt; c (Unpackedness l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Unpackedness l -&gt; c (Unpackedness l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433738"><span id="local-6989586621679433740"><span id="local-6989586621679433742"><span id="local-6989586621679433744"><span id="local-6989586621679433746"><span id="local-6989586621679433748"><span id="local-6989586621679433750"><span id="local-6989586621679433752"><span id="local-6989586621679433754"><span id="local-6989586621679433756"><span id="local-6989586621679433758"><span id="local-6989586621679433760"><span id="local-6989586621679433762"><span id="local-6989586621679433764"><span id="local-6989586621679433766"><span id="local-6989586621679433769"><span id="local-6989586621679433771"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Unpackedness a -&gt; Bool
forall a. Num a =&gt; Unpackedness a -&gt; a
forall a. Ord a =&gt; Unpackedness a -&gt; a
forall m. Monoid m =&gt; Unpackedness m -&gt; m
forall a. Unpackedness a -&gt; Bool
forall a. Unpackedness a -&gt; Int
forall a. Unpackedness a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Unpackedness a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Unpackedness a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Unpackedness a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Unpackedness a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Unpackedness a -&gt; a
$cproduct :: forall a. Num a =&gt; Unpackedness a -&gt; a
sum :: forall a. Num a =&gt; Unpackedness a -&gt; a
$csum :: forall a. Num a =&gt; Unpackedness a -&gt; a
minimum :: forall a. Ord a =&gt; Unpackedness a -&gt; a
$cminimum :: forall a. Ord a =&gt; Unpackedness a -&gt; a
maximum :: forall a. Ord a =&gt; Unpackedness a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Unpackedness a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Unpackedness a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Unpackedness a -&gt; Bool
length :: forall a. Unpackedness a -&gt; Int
$clength :: forall a. Unpackedness a -&gt; Int
null :: forall a. Unpackedness a -&gt; Bool
$cnull :: forall a. Unpackedness a -&gt; Bool
toList :: forall a. Unpackedness a -&gt; [a]
$ctoList :: forall a. Unpackedness a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Unpackedness a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Unpackedness a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Unpackedness a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Unpackedness a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Unpackedness a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Unpackedness a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Unpackedness a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Unpackedness a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Unpackedness a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Unpackedness a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Unpackedness a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Unpackedness a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Unpackedness a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Unpackedness a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Unpackedness a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Unpackedness a -&gt; m
fold :: forall m. Monoid m =&gt; Unpackedness m -&gt; m
$cfold :: forall m. Monoid m =&gt; Unpackedness m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433720"><span id="local-6989586621679433722"><span id="local-6989586621679433724"><span id="local-6989586621679433731"><span class="annot"><span class="annottext">Functor Unpackedness
Foldable Unpackedness
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
Unpackedness (m a) -&gt; m (Unpackedness a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Unpackedness (f a) -&gt; f (Unpackedness a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Unpackedness a -&gt; m (Unpackedness b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Unpackedness a -&gt; f (Unpackedness b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
Unpackedness (m a) -&gt; m (Unpackedness a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
Unpackedness (m a) -&gt; m (Unpackedness a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Unpackedness a -&gt; m (Unpackedness b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Unpackedness a -&gt; m (Unpackedness b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Unpackedness (f a) -&gt; f (Unpackedness a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Unpackedness (f a) -&gt; f (Unpackedness a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Unpackedness a -&gt; f (Unpackedness b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Unpackedness a -&gt; f (Unpackedness b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433716"><span id="local-6989586621679433718"><span class="annot"><span class="annottext">forall a b. a -&gt; Unpackedness b -&gt; Unpackedness a
forall a b. (a -&gt; b) -&gt; Unpackedness a -&gt; Unpackedness b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Unpackedness b -&gt; Unpackedness a
$c&lt;$ :: forall a b. a -&gt; Unpackedness b -&gt; Unpackedness a
fmap :: forall a b. (a -&gt; b) -&gt; Unpackedness a -&gt; Unpackedness b
$cfmap :: forall a b. (a -&gt; b) -&gt; Unpackedness a -&gt; Unpackedness b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Unpackedness l) x -&gt; Unpackedness l
forall l x. Unpackedness l -&gt; Rep (Unpackedness l) x
$cto :: forall l x. Rep (Unpackedness l) x -&gt; Unpackedness l
$cfrom :: forall l x. Unpackedness l -&gt; Rep (Unpackedness l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-610"></span><span>
</span><span id="line-611"></span><span class="hs-comment">-- | The right hand side of a function binding, pattern binding, or a case</span><span>
</span><span id="line-612"></span><span class="hs-comment">--   alternative.</span><span>
</span><span id="line-613"></span><span id="local-6989586621679433711"><span id="local-6989586621679433712"></span></span><span class="hs-keyword">data</span><span> </span><span id="Rhs"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rhs"><span class="hs-identifier hs-var">Rhs</span></a></span></span><span> </span><span id="local-6989586621679452741"><span class="annot"><a href="#local-6989586621679452741"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-614"></span><span>     </span><span class="hs-glyph">=</span><span> </span><span id="UnGuardedRhs"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnGuardedRhs"><span class="hs-identifier hs-var">UnGuardedRhs</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452741"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452741"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ unguarded right hand side (/exp/)</span><span>
</span><span id="line-615"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="GuardedRhss"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GuardedRhss"><span class="hs-identifier hs-var">GuardedRhss</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452741"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GuardedRhs"><span class="hs-identifier hs-type">GuardedRhs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452741"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-616"></span><span>                </span><span class="hs-comment">-- ^ guarded right hand side (/gdrhs/)</span><span>
</span><span id="line-617"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679433700"><span id="local-6989586621679433707"><span class="annot"><span class="annottext">Rhs l -&gt; Rhs l -&gt; Bool
forall l. Eq l =&gt; Rhs l -&gt; Rhs l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Rhs l -&gt; Rhs l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Rhs l -&gt; Rhs l -&gt; Bool
== :: Rhs l -&gt; Rhs l -&gt; Bool
$c== :: forall l. Eq l =&gt; Rhs l -&gt; Rhs l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433671"><span id="local-6989586621679433673"><span id="local-6989586621679433676"><span id="local-6989586621679433679"><span id="local-6989586621679433682"><span id="local-6989586621679433689"><span id="local-6989586621679433696"><span class="annot"><span class="annottext">Rhs l -&gt; Rhs l -&gt; Bool
Rhs l -&gt; Rhs l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Rhs l)
forall l. Ord l =&gt; Rhs l -&gt; Rhs l -&gt; Bool
forall l. Ord l =&gt; Rhs l -&gt; Rhs l -&gt; Ordering
forall l. Ord l =&gt; Rhs l -&gt; Rhs l -&gt; Rhs l
min :: Rhs l -&gt; Rhs l -&gt; Rhs l
$cmin :: forall l. Ord l =&gt; Rhs l -&gt; Rhs l -&gt; Rhs l
max :: Rhs l -&gt; Rhs l -&gt; Rhs l
$cmax :: forall l. Ord l =&gt; Rhs l -&gt; Rhs l -&gt; Rhs l
&gt;= :: Rhs l -&gt; Rhs l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Rhs l -&gt; Rhs l -&gt; Bool
&gt; :: Rhs l -&gt; Rhs l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Rhs l -&gt; Rhs l -&gt; Bool
&lt;= :: Rhs l -&gt; Rhs l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Rhs l -&gt; Rhs l -&gt; Bool
&lt; :: Rhs l -&gt; Rhs l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Rhs l -&gt; Rhs l -&gt; Bool
compare :: Rhs l -&gt; Rhs l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Rhs l -&gt; Rhs l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433658"><span id="local-6989586621679433660"><span id="local-6989586621679433669"><span class="annot"><span class="annottext">Int -&gt; Rhs l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Rhs l -&gt; ShowS
forall l. Show l =&gt; [Rhs l] -&gt; ShowS
forall l. Show l =&gt; Rhs l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Rhs l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Rhs l] -&gt; ShowS
show :: Rhs l -&gt; String
$cshow :: forall l. Show l =&gt; Rhs l -&gt; String
showsPrec :: Int -&gt; Rhs l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Rhs l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679433613"><span id="local-6989586621679433615"><span id="local-6989586621679433617"><span id="local-6989586621679433619"><span id="local-6989586621679433621"><span id="local-6989586621679433623"><span id="local-6989586621679433625"><span id="local-6989586621679433627"><span id="local-6989586621679433629"><span id="local-6989586621679433635"><span id="local-6989586621679433637"><span id="local-6989586621679433639"><span id="local-6989586621679433646"><span id="local-6989586621679433653"><span class="annot"><span class="annottext">Rhs l -&gt; DataType
Rhs l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Rhs l)
forall l. Data l =&gt; Rhs l -&gt; DataType
forall l. Data l =&gt; Rhs l -&gt; Constr
forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; Rhs l -&gt; Rhs l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Rhs l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Rhs l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rhs l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rhs l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rhs l -&gt; m (Rhs l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rhs l -&gt; m (Rhs l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Rhs l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Rhs l -&gt; c (Rhs l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Rhs l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Rhs l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Rhs l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Rhs l -&gt; c (Rhs l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Rhs l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rhs l -&gt; m (Rhs l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rhs l -&gt; m (Rhs l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rhs l -&gt; m (Rhs l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rhs l -&gt; m (Rhs l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rhs l -&gt; m (Rhs l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rhs l -&gt; m (Rhs l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Rhs l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Rhs l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Rhs l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Rhs l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rhs l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rhs l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rhs l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rhs l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Rhs l -&gt; Rhs l
$cgmapT :: forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; Rhs l -&gt; Rhs l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Rhs l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Rhs l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Rhs l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Rhs l))
dataTypeOf :: Rhs l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Rhs l -&gt; DataType
toConstr :: Rhs l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Rhs l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Rhs l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Rhs l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Rhs l -&gt; c (Rhs l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Rhs l -&gt; c (Rhs l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433567"><span id="local-6989586621679433569"><span id="local-6989586621679433571"><span id="local-6989586621679433573"><span id="local-6989586621679433575"><span id="local-6989586621679433577"><span id="local-6989586621679433579"><span id="local-6989586621679433581"><span id="local-6989586621679433583"><span id="local-6989586621679433585"><span id="local-6989586621679433587"><span id="local-6989586621679433589"><span id="local-6989586621679433591"><span id="local-6989586621679433596"><span id="local-6989586621679433598"><span id="local-6989586621679433609"><span id="local-6989586621679433611"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Rhs a -&gt; Bool
forall a. Num a =&gt; Rhs a -&gt; a
forall a. Ord a =&gt; Rhs a -&gt; a
forall m. Monoid m =&gt; Rhs m -&gt; m
forall a. Rhs a -&gt; Bool
forall a. Rhs a -&gt; Int
forall a. Rhs a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Rhs a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Rhs a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Rhs a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Rhs a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Rhs a -&gt; a
$cproduct :: forall a. Num a =&gt; Rhs a -&gt; a
sum :: forall a. Num a =&gt; Rhs a -&gt; a
$csum :: forall a. Num a =&gt; Rhs a -&gt; a
minimum :: forall a. Ord a =&gt; Rhs a -&gt; a
$cminimum :: forall a. Ord a =&gt; Rhs a -&gt; a
maximum :: forall a. Ord a =&gt; Rhs a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Rhs a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Rhs a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Rhs a -&gt; Bool
length :: forall a. Rhs a -&gt; Int
$clength :: forall a. Rhs a -&gt; Int
null :: forall a. Rhs a -&gt; Bool
$cnull :: forall a. Rhs a -&gt; Bool
toList :: forall a. Rhs a -&gt; [a]
$ctoList :: forall a. Rhs a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Rhs a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Rhs a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Rhs a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Rhs a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Rhs a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Rhs a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Rhs a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Rhs a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Rhs a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Rhs a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Rhs a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Rhs a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Rhs a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Rhs a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Rhs a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Rhs a -&gt; m
fold :: forall m. Monoid m =&gt; Rhs m -&gt; m
$cfold :: forall m. Monoid m =&gt; Rhs m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433546"><span id="local-6989586621679433548"><span id="local-6989586621679433550"><span id="local-6989586621679433561"><span class="annot"><span class="annottext">Functor Rhs
Foldable Rhs
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Rhs (m a) -&gt; m (Rhs a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Rhs (f a) -&gt; f (Rhs a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Rhs a -&gt; m (Rhs b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Rhs a -&gt; f (Rhs b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Rhs (m a) -&gt; m (Rhs a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Rhs (m a) -&gt; m (Rhs a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Rhs a -&gt; m (Rhs b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Rhs a -&gt; m (Rhs b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Rhs (f a) -&gt; f (Rhs a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Rhs (f a) -&gt; f (Rhs a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Rhs a -&gt; f (Rhs b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Rhs a -&gt; f (Rhs b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433538"><span id="local-6989586621679433544"><span class="annot"><span class="annottext">forall a b. a -&gt; Rhs b -&gt; Rhs a
forall a b. (a -&gt; b) -&gt; Rhs a -&gt; Rhs b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Rhs b -&gt; Rhs a
$c&lt;$ :: forall a b. a -&gt; Rhs b -&gt; Rhs a
fmap :: forall a b. (a -&gt; b) -&gt; Rhs a -&gt; Rhs b
$cfmap :: forall a b. (a -&gt; b) -&gt; Rhs a -&gt; Rhs b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Rhs l) x -&gt; Rhs l
forall l x. Rhs l -&gt; Rep (Rhs l) x
$cto :: forall l x. Rep (Rhs l) x -&gt; Rhs l
$cfrom :: forall l x. Rhs l -&gt; Rep (Rhs l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-618"></span><span>
</span><span id="line-619"></span><span class="hs-comment">-- | A guarded right hand side @|@ /stmts/ @=@ /exp/, or @|@ /stmts/ @-&gt;@ /exp/</span><span>
</span><span id="line-620"></span><span class="hs-comment">--   for case alternatives.</span><span>
</span><span id="line-621"></span><span class="hs-comment">--   The guard is a series of statements when using pattern guards,</span><span>
</span><span id="line-622"></span><span class="hs-comment">--   otherwise it will be a single qualifier expression.</span><span>
</span><span id="line-623"></span><span id="local-6989586621679433530"><span id="local-6989586621679433531"></span></span><span class="hs-keyword">data</span><span> </span><span id="GuardedRhs"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GuardedRhs"><span class="hs-identifier hs-var">GuardedRhs</span></a></span></span><span> </span><span id="local-6989586621679452604"><span class="annot"><a href="#local-6989586621679452604"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-624"></span><span>     </span><span class="hs-glyph">=</span><span> </span><span id="GuardedRhs"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GuardedRhs"><span class="hs-identifier hs-var">GuardedRhs</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452604"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452604"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452604"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-625"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679433521"><span id="local-6989586621679433527"><span class="annot"><span class="annottext">GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
forall l. Eq l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
$c/= :: forall l. Eq l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
== :: GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
$c== :: forall l. Eq l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433494"><span id="local-6989586621679433496"><span id="local-6989586621679433499"><span id="local-6989586621679433502"><span id="local-6989586621679433505"><span id="local-6989586621679433511"><span id="local-6989586621679433517"><span class="annot"><span class="annottext">GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
GuardedRhs l -&gt; GuardedRhs l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (GuardedRhs l)
forall l. Ord l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
forall l. Ord l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; Ordering
forall l. Ord l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; GuardedRhs l
min :: GuardedRhs l -&gt; GuardedRhs l -&gt; GuardedRhs l
$cmin :: forall l. Ord l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; GuardedRhs l
max :: GuardedRhs l -&gt; GuardedRhs l -&gt; GuardedRhs l
$cmax :: forall l. Ord l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; GuardedRhs l
&gt;= :: GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
&gt; :: GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
&lt;= :: GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
&lt; :: GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; Bool
compare :: GuardedRhs l -&gt; GuardedRhs l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; GuardedRhs l -&gt; GuardedRhs l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433483"><span id="local-6989586621679433485"><span id="local-6989586621679433492"><span class="annot"><span class="annottext">Int -&gt; GuardedRhs l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; GuardedRhs l -&gt; ShowS
forall l. Show l =&gt; [GuardedRhs l] -&gt; ShowS
forall l. Show l =&gt; GuardedRhs l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [GuardedRhs l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [GuardedRhs l] -&gt; ShowS
show :: GuardedRhs l -&gt; String
$cshow :: forall l. Show l =&gt; GuardedRhs l -&gt; String
showsPrec :: Int -&gt; GuardedRhs l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; GuardedRhs l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679433440"><span id="local-6989586621679433442"><span id="local-6989586621679433444"><span id="local-6989586621679433446"><span id="local-6989586621679433448"><span id="local-6989586621679433450"><span id="local-6989586621679433452"><span id="local-6989586621679433454"><span id="local-6989586621679433456"><span id="local-6989586621679433462"><span id="local-6989586621679433464"><span id="local-6989586621679433466"><span id="local-6989586621679433472"><span id="local-6989586621679433478"><span class="annot"><span class="annottext">GuardedRhs l -&gt; DataType
GuardedRhs l -&gt; Constr
forall {l}. Data l =&gt; Typeable (GuardedRhs l)
forall l. Data l =&gt; GuardedRhs l -&gt; DataType
forall l. Data l =&gt; GuardedRhs l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; GuardedRhs l -&gt; GuardedRhs l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; GuardedRhs l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; GuardedRhs l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GuardedRhs l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GuardedRhs l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GuardedRhs l -&gt; m (GuardedRhs l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GuardedRhs l -&gt; m (GuardedRhs l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (GuardedRhs l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; GuardedRhs l -&gt; c (GuardedRhs l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (GuardedRhs l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (GuardedRhs l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (GuardedRhs l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; GuardedRhs l -&gt; c (GuardedRhs l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (GuardedRhs l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GuardedRhs l -&gt; m (GuardedRhs l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GuardedRhs l -&gt; m (GuardedRhs l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GuardedRhs l -&gt; m (GuardedRhs l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GuardedRhs l -&gt; m (GuardedRhs l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GuardedRhs l -&gt; m (GuardedRhs l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; GuardedRhs l -&gt; m (GuardedRhs l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; GuardedRhs l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; GuardedRhs l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; GuardedRhs l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; GuardedRhs l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GuardedRhs l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GuardedRhs l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GuardedRhs l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; GuardedRhs l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; GuardedRhs l -&gt; GuardedRhs l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; GuardedRhs l -&gt; GuardedRhs l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (GuardedRhs l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (GuardedRhs l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (GuardedRhs l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (GuardedRhs l))
dataTypeOf :: GuardedRhs l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; GuardedRhs l -&gt; DataType
toConstr :: GuardedRhs l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; GuardedRhs l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (GuardedRhs l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (GuardedRhs l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; GuardedRhs l -&gt; c (GuardedRhs l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; GuardedRhs l -&gt; c (GuardedRhs l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433394"><span id="local-6989586621679433396"><span id="local-6989586621679433398"><span id="local-6989586621679433400"><span id="local-6989586621679433402"><span id="local-6989586621679433404"><span id="local-6989586621679433406"><span id="local-6989586621679433408"><span id="local-6989586621679433410"><span id="local-6989586621679433412"><span id="local-6989586621679433414"><span id="local-6989586621679433416"><span id="local-6989586621679433418"><span id="local-6989586621679433423"><span id="local-6989586621679433425"><span id="local-6989586621679433436"><span id="local-6989586621679433438"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; GuardedRhs a -&gt; Bool
forall a. Num a =&gt; GuardedRhs a -&gt; a
forall a. Ord a =&gt; GuardedRhs a -&gt; a
forall m. Monoid m =&gt; GuardedRhs m -&gt; m
forall a. GuardedRhs a -&gt; Bool
forall a. GuardedRhs a -&gt; Int
forall a. GuardedRhs a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; GuardedRhs a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; GuardedRhs a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; GuardedRhs a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; GuardedRhs a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; GuardedRhs a -&gt; a
$cproduct :: forall a. Num a =&gt; GuardedRhs a -&gt; a
sum :: forall a. Num a =&gt; GuardedRhs a -&gt; a
$csum :: forall a. Num a =&gt; GuardedRhs a -&gt; a
minimum :: forall a. Ord a =&gt; GuardedRhs a -&gt; a
$cminimum :: forall a. Ord a =&gt; GuardedRhs a -&gt; a
maximum :: forall a. Ord a =&gt; GuardedRhs a -&gt; a
$cmaximum :: forall a. Ord a =&gt; GuardedRhs a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; GuardedRhs a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; GuardedRhs a -&gt; Bool
length :: forall a. GuardedRhs a -&gt; Int
$clength :: forall a. GuardedRhs a -&gt; Int
null :: forall a. GuardedRhs a -&gt; Bool
$cnull :: forall a. GuardedRhs a -&gt; Bool
toList :: forall a. GuardedRhs a -&gt; [a]
$ctoList :: forall a. GuardedRhs a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; GuardedRhs a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; GuardedRhs a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; GuardedRhs a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; GuardedRhs a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; GuardedRhs a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; GuardedRhs a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; GuardedRhs a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; GuardedRhs a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; GuardedRhs a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; GuardedRhs a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; GuardedRhs a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; GuardedRhs a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; GuardedRhs a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; GuardedRhs a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; GuardedRhs a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; GuardedRhs a -&gt; m
fold :: forall m. Monoid m =&gt; GuardedRhs m -&gt; m
$cfold :: forall m. Monoid m =&gt; GuardedRhs m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433373"><span id="local-6989586621679433375"><span id="local-6989586621679433377"><span id="local-6989586621679433388"><span class="annot"><span class="annottext">Functor GuardedRhs
Foldable GuardedRhs
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
GuardedRhs (m a) -&gt; m (GuardedRhs a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
GuardedRhs (f a) -&gt; f (GuardedRhs a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; GuardedRhs a -&gt; m (GuardedRhs b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; GuardedRhs a -&gt; f (GuardedRhs b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
GuardedRhs (m a) -&gt; m (GuardedRhs a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
GuardedRhs (m a) -&gt; m (GuardedRhs a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; GuardedRhs a -&gt; m (GuardedRhs b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; GuardedRhs a -&gt; m (GuardedRhs b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
GuardedRhs (f a) -&gt; f (GuardedRhs a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
GuardedRhs (f a) -&gt; f (GuardedRhs a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; GuardedRhs a -&gt; f (GuardedRhs b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; GuardedRhs a -&gt; f (GuardedRhs b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433365"><span id="local-6989586621679433371"><span class="annot"><span class="annottext">forall a b. a -&gt; GuardedRhs b -&gt; GuardedRhs a
forall a b. (a -&gt; b) -&gt; GuardedRhs a -&gt; GuardedRhs b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; GuardedRhs b -&gt; GuardedRhs a
$c&lt;$ :: forall a b. a -&gt; GuardedRhs b -&gt; GuardedRhs a
fmap :: forall a b. (a -&gt; b) -&gt; GuardedRhs a -&gt; GuardedRhs b
$cfmap :: forall a b. (a -&gt; b) -&gt; GuardedRhs a -&gt; GuardedRhs b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (GuardedRhs l) x -&gt; GuardedRhs l
forall l x. GuardedRhs l -&gt; Rep (GuardedRhs l) x
$cto :: forall l x. Rep (GuardedRhs l) x -&gt; GuardedRhs l
$cfrom :: forall l x. GuardedRhs l -&gt; Rep (GuardedRhs l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-626"></span><span>
</span><span id="line-627"></span><span class="hs-comment">-- | A type qualified with a context.</span><span>
</span><span id="line-628"></span><span class="hs-comment">--   An unqualified type has an empty context.</span><span>
</span><span id="line-629"></span><span id="local-6989586621679433357"><span id="local-6989586621679433358"></span></span><span class="hs-keyword">data</span><span> </span><span id="Type"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-var">Type</span></a></span></span><span> </span><span id="local-6989586621679452745"><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-630"></span><span>     </span><span class="hs-glyph">=</span><span> </span><span id="TyForall"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyForall"><span class="hs-identifier hs-var">TyForall</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-631"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier hs-type">TyVarBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-632"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-633"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                                </span><span class="hs-comment">-- ^ qualified type</span><span>
</span><span id="line-634"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyStar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyStar"><span class="hs-identifier hs-var">TyStar</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span>                                </span><span class="hs-comment">-- ^ @*@, the type of types</span><span>
</span><span id="line-635"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyFun"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyFun"><span class="hs-identifier hs-var">TyFun</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>              </span><span class="hs-comment">-- ^ function type</span><span>
</span><span id="line-636"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyTuple"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyTuple"><span class="hs-identifier hs-var">TyTuple</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier hs-type">Boxed</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                 </span><span class="hs-comment">-- ^ tuple type, possibly boxed</span><span>
</span><span id="line-637"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyUnboxedSum"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyUnboxedSum"><span class="hs-identifier hs-var">TyUnboxedSum</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                  </span><span class="hs-comment">-- ^ unboxed tuple type</span><span>
</span><span id="line-638"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyList"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyList"><span class="hs-identifier hs-var">TyList</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                       </span><span class="hs-comment">-- ^ list syntax, e.g. [a], as opposed to [] a</span><span>
</span><span id="line-639"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyParArray"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyParArray"><span class="hs-identifier hs-var">TyParArray</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                   </span><span class="hs-comment">-- ^ parallel array syntax, e.g. [:a:]</span><span>
</span><span id="line-640"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyApp"><span class="hs-identifier hs-var">TyApp</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>              </span><span class="hs-comment">-- ^ application of a type constructor</span><span>
</span><span id="line-641"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyVar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVar"><span class="hs-identifier hs-var">TyVar</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                       </span><span class="hs-comment">-- ^ type variable</span><span>
</span><span id="line-642"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyCon"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyCon"><span class="hs-identifier hs-var">TyCon</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                      </span><span class="hs-comment">-- ^ named type or type constructor</span><span>
</span><span id="line-643"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyParen"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyParen"><span class="hs-identifier hs-var">TyParen</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                       </span><span class="hs-comment">-- ^ type surrounded by parentheses</span><span>
</span><span id="line-644"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyInfix"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyInfix"><span class="hs-identifier hs-var">TyInfix</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MaybePromotedName"><span class="hs-identifier hs-type">MaybePromotedName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-645"></span><span>                          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>              </span><span class="hs-comment">-- ^ infix type constructor</span><span>
</span><span id="line-646"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyKind"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyKind"><span class="hs-identifier hs-var">TyKind</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>              </span><span class="hs-comment">-- ^ type with explicit kind signature</span><span>
</span><span id="line-647"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyPromoted"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyPromoted"><span class="hs-identifier hs-var">TyPromoted</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Promoted"><span class="hs-identifier hs-type">Promoted</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                </span><span class="hs-comment">-- ^ @'K@, a promoted data type (-XDataKinds).</span><span>
</span><span id="line-648"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyEquals"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyEquals"><span class="hs-identifier hs-var">TyEquals</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- ^ type equality predicate enabled by ConstraintKinds</span><span>
</span><span id="line-649"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TySplice"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TySplice"><span class="hs-identifier hs-var">TySplice</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                    </span><span class="hs-comment">-- ^ template haskell splice type</span><span>
</span><span id="line-650"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyBang"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyBang"><span class="hs-identifier hs-var">TyBang</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BangType"><span class="hs-identifier hs-type">BangType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Unpackedness"><span class="hs-identifier hs-type">Unpackedness</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>           </span><span class="hs-comment">-- ^ Strict type marked with \&quot;@!@\&quot; or type marked with UNPACK pragma.</span><span>
</span><span id="line-651"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyWildCard"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyWildCard"><span class="hs-identifier hs-var">TyWildCard</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>            </span><span class="hs-comment">-- ^ Either an anonymous of named type wildcard</span><span>
</span><span id="line-652"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span id="TyQuasiQuote"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyQuasiQuote"><span class="hs-identifier hs-var">TyQuasiQuote</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452745"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>             </span><span class="hs-comment">-- ^ @[$/name/| /string/ |]@</span><span>
</span><span id="line-653"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679433282"><span id="local-6989586621679433336"><span class="annot"><span class="annottext">Type l -&gt; Type l -&gt; Bool
forall l. Eq l =&gt; Type l -&gt; Type l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Type l -&gt; Type l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Type l -&gt; Type l -&gt; Bool
== :: Type l -&gt; Type l -&gt; Bool
$c== :: forall l. Eq l =&gt; Type l -&gt; Type l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433213"><span id="local-6989586621679433215"><span id="local-6989586621679433217"><span id="local-6989586621679433219"><span id="local-6989586621679433221"><span id="local-6989586621679433223"><span id="local-6989586621679433277"><span class="annot"><span class="annottext">Type l -&gt; Type l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Type l)
forall l. Ord l =&gt; Type l -&gt; Type l -&gt; Bool
forall l. Ord l =&gt; Type l -&gt; Type l -&gt; Ordering
forall l. Ord l =&gt; Type l -&gt; Type l -&gt; Type l
min :: Type l -&gt; Type l -&gt; Type l
$cmin :: forall l. Ord l =&gt; Type l -&gt; Type l -&gt; Type l
max :: Type l -&gt; Type l -&gt; Type l
$cmax :: forall l. Ord l =&gt; Type l -&gt; Type l -&gt; Type l
&gt;= :: Type l -&gt; Type l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Type l -&gt; Type l -&gt; Bool
&gt; :: Type l -&gt; Type l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Type l -&gt; Type l -&gt; Bool
&lt;= :: Type l -&gt; Type l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Type l -&gt; Type l -&gt; Bool
&lt; :: Type l -&gt; Type l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Type l -&gt; Type l -&gt; Bool
compare :: Type l -&gt; Type l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Type l -&gt; Type l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679433135"><span id="local-6989586621679433137"><span id="local-6989586621679433210"><span class="annot"><span class="annottext">Int -&gt; Type l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Type l -&gt; ShowS
forall l. Show l =&gt; [Type l] -&gt; ShowS
forall l. Show l =&gt; Type l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Type l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Type l] -&gt; ShowS
show :: Type l -&gt; String
$cshow :: forall l. Show l =&gt; Type l -&gt; String
showsPrec :: Int -&gt; Type l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Type l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679432995"><span id="local-6989586621679432997"><span id="local-6989586621679432999"><span id="local-6989586621679433001"><span id="local-6989586621679433003"><span id="local-6989586621679433005"><span id="local-6989586621679433007"><span id="local-6989586621679433009"><span id="local-6989586621679433011"><span id="local-6989586621679433017"><span id="local-6989586621679433019"><span id="local-6989586621679433021"><span id="local-6989586621679433075"><span id="local-6989586621679433129"><span class="annot"><span class="annottext">Type l -&gt; DataType
Type l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Type l)
forall l. Data l =&gt; Type l -&gt; DataType
forall l. Data l =&gt; Type l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Type l -&gt; Type l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Type l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Type l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type l -&gt; m (Type l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type l -&gt; m (Type l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Type l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Type l -&gt; c (Type l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Type l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Type l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Type l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Type l -&gt; c (Type l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Type l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type l -&gt; m (Type l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type l -&gt; m (Type l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type l -&gt; m (Type l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type l -&gt; m (Type l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type l -&gt; m (Type l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Type l -&gt; m (Type l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Type l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Type l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Type l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Type l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Type l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Type l -&gt; Type l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Type l -&gt; Type l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Type l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Type l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Type l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Type l))
dataTypeOf :: Type l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Type l -&gt; DataType
toConstr :: Type l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Type l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Type l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Type l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Type l -&gt; c (Type l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Type l -&gt; c (Type l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432832"><span id="local-6989586621679432834"><span id="local-6989586621679432836"><span id="local-6989586621679432838"><span id="local-6989586621679432840"><span id="local-6989586621679432842"><span id="local-6989586621679432844"><span id="local-6989586621679432846"><span id="local-6989586621679432848"><span id="local-6989586621679432850"><span id="local-6989586621679432852"><span id="local-6989586621679432854"><span id="local-6989586621679432856"><span id="local-6989586621679432891"><span id="local-6989586621679432893"><span id="local-6989586621679432989"><span id="local-6989586621679432991"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Type a -&gt; Bool
forall a. Num a =&gt; Type a -&gt; a
forall a. Ord a =&gt; Type a -&gt; a
forall m. Monoid m =&gt; Type m -&gt; m
forall a. Type a -&gt; Bool
forall a. Type a -&gt; Int
forall a. Type a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Type a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Type a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Type a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Type a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Type a -&gt; a
$cproduct :: forall a. Num a =&gt; Type a -&gt; a
sum :: forall a. Num a =&gt; Type a -&gt; a
$csum :: forall a. Num a =&gt; Type a -&gt; a
minimum :: forall a. Ord a =&gt; Type a -&gt; a
$cminimum :: forall a. Ord a =&gt; Type a -&gt; a
maximum :: forall a. Ord a =&gt; Type a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Type a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Type a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Type a -&gt; Bool
length :: forall a. Type a -&gt; Int
$clength :: forall a. Type a -&gt; Int
null :: forall a. Type a -&gt; Bool
$cnull :: forall a. Type a -&gt; Bool
toList :: forall a. Type a -&gt; [a]
$ctoList :: forall a. Type a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Type a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Type a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Type a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Type a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Type a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Type a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Type a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Type a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Type a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Type a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Type a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Type a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Type a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Type a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Type a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Type a -&gt; m
fold :: forall m. Monoid m =&gt; Type m -&gt; m
$cfold :: forall m. Monoid m =&gt; Type m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432723"><span id="local-6989586621679432725"><span id="local-6989586621679432727"><span id="local-6989586621679432826"><span class="annot"><span class="annottext">Functor Type
Foldable Type
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Type (m a) -&gt; m (Type a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Type (f a) -&gt; f (Type a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Type a -&gt; m (Type b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Type a -&gt; f (Type b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Type (m a) -&gt; m (Type a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Type (m a) -&gt; m (Type a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Type a -&gt; m (Type b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Type a -&gt; m (Type b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Type (f a) -&gt; f (Type a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Type (f a) -&gt; f (Type a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Type a -&gt; f (Type b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Type a -&gt; f (Type b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432683"><span id="local-6989586621679432721"><span class="annot"><span class="annottext">forall a b. a -&gt; Type b -&gt; Type a
forall a b. (a -&gt; b) -&gt; Type a -&gt; Type b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Type b -&gt; Type a
$c&lt;$ :: forall a b. a -&gt; Type b -&gt; Type a
fmap :: forall a b. (a -&gt; b) -&gt; Type a -&gt; Type b
$cfmap :: forall a b. (a -&gt; b) -&gt; Type a -&gt; Type b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Type l) x -&gt; Type l
forall l x. Type l -&gt; Rep (Type l) x
$cto :: forall l x. Rep (Type l) x -&gt; Type l
$cfrom :: forall l x. Type l -&gt; Rep (Type l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-654"></span><span>
</span><span id="line-655"></span><span id="local-6989586621679432645"><span id="local-6989586621679432646"></span></span><span class="hs-keyword">data</span><span> </span><span id="MaybePromotedName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MaybePromotedName"><span class="hs-identifier hs-var">MaybePromotedName</span></a></span></span><span> </span><span id="local-6989586621679452592"><span class="annot"><a href="#local-6989586621679452592"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="PromotedName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedName"><span class="hs-identifier hs-var">PromotedName</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452592"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452592"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="UnpromotedName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnpromotedName"><span class="hs-identifier hs-var">UnpromotedName</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452592"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452592"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-656"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679432635"><span id="local-6989586621679432641"><span class="annot"><span class="annottext">MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
forall l.
Eq l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
$c/= :: forall l.
Eq l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
== :: MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
$c== :: forall l.
Eq l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432608"><span id="local-6989586621679432610"><span id="local-6989586621679432613"><span id="local-6989586621679432616"><span id="local-6989586621679432619"><span id="local-6989586621679432625"><span id="local-6989586621679432631"><span class="annot"><span class="annottext">MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
MaybePromotedName l -&gt; MaybePromotedName l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (MaybePromotedName l)
forall l.
Ord l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
forall l.
Ord l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; Ordering
forall l.
Ord l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; MaybePromotedName l
min :: MaybePromotedName l -&gt; MaybePromotedName l -&gt; MaybePromotedName l
$cmin :: forall l.
Ord l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; MaybePromotedName l
max :: MaybePromotedName l -&gt; MaybePromotedName l -&gt; MaybePromotedName l
$cmax :: forall l.
Ord l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; MaybePromotedName l
&gt;= :: MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
$c&gt;= :: forall l.
Ord l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
&gt; :: MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
$c&gt; :: forall l.
Ord l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
&lt;= :: MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
$c&lt;= :: forall l.
Ord l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
&lt; :: MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
$c&lt; :: forall l.
Ord l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; Bool
compare :: MaybePromotedName l -&gt; MaybePromotedName l -&gt; Ordering
$ccompare :: forall l.
Ord l =&gt;
MaybePromotedName l -&gt; MaybePromotedName l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432596"><span id="local-6989586621679432598"><span id="local-6989586621679432606"><span class="annot"><span class="annottext">Int -&gt; MaybePromotedName l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; MaybePromotedName l -&gt; ShowS
forall l. Show l =&gt; [MaybePromotedName l] -&gt; ShowS
forall l. Show l =&gt; MaybePromotedName l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [MaybePromotedName l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [MaybePromotedName l] -&gt; ShowS
show :: MaybePromotedName l -&gt; String
$cshow :: forall l. Show l =&gt; MaybePromotedName l -&gt; String
showsPrec :: Int -&gt; MaybePromotedName l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; MaybePromotedName l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679432553"><span id="local-6989586621679432555"><span id="local-6989586621679432557"><span id="local-6989586621679432559"><span id="local-6989586621679432561"><span id="local-6989586621679432563"><span id="local-6989586621679432565"><span id="local-6989586621679432567"><span id="local-6989586621679432569"><span id="local-6989586621679432575"><span id="local-6989586621679432577"><span id="local-6989586621679432579"><span id="local-6989586621679432585"><span id="local-6989586621679432591"><span class="annot"><span class="annottext">MaybePromotedName l -&gt; DataType
MaybePromotedName l -&gt; Constr
forall {l}. Data l =&gt; Typeable (MaybePromotedName l)
forall l. Data l =&gt; MaybePromotedName l -&gt; DataType
forall l. Data l =&gt; MaybePromotedName l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; MaybePromotedName l -&gt; MaybePromotedName l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; MaybePromotedName l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; MaybePromotedName l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MaybePromotedName l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MaybePromotedName l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MaybePromotedName l -&gt; m (MaybePromotedName l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MaybePromotedName l -&gt; m (MaybePromotedName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (MaybePromotedName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; MaybePromotedName l
-&gt; c (MaybePromotedName l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (MaybePromotedName l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (MaybePromotedName l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (MaybePromotedName l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; MaybePromotedName l
-&gt; c (MaybePromotedName l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (MaybePromotedName l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MaybePromotedName l -&gt; m (MaybePromotedName l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MaybePromotedName l -&gt; m (MaybePromotedName l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MaybePromotedName l -&gt; m (MaybePromotedName l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MaybePromotedName l -&gt; m (MaybePromotedName l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MaybePromotedName l -&gt; m (MaybePromotedName l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; MaybePromotedName l -&gt; m (MaybePromotedName l)
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; MaybePromotedName l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; MaybePromotedName l -&gt; u
gmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; MaybePromotedName l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; MaybePromotedName l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MaybePromotedName l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MaybePromotedName l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MaybePromotedName l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MaybePromotedName l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; MaybePromotedName l -&gt; MaybePromotedName l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b)
-&gt; MaybePromotedName l -&gt; MaybePromotedName l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (MaybePromotedName l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (MaybePromotedName l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (MaybePromotedName l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (MaybePromotedName l))
dataTypeOf :: MaybePromotedName l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; MaybePromotedName l -&gt; DataType
toConstr :: MaybePromotedName l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; MaybePromotedName l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (MaybePromotedName l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (MaybePromotedName l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; MaybePromotedName l
-&gt; c (MaybePromotedName l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; MaybePromotedName l
-&gt; c (MaybePromotedName l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432510"><span id="local-6989586621679432512"><span id="local-6989586621679432514"><span id="local-6989586621679432516"><span id="local-6989586621679432518"><span id="local-6989586621679432520"><span id="local-6989586621679432522"><span id="local-6989586621679432524"><span id="local-6989586621679432526"><span id="local-6989586621679432528"><span id="local-6989586621679432530"><span id="local-6989586621679432532"><span id="local-6989586621679432534"><span id="local-6989586621679432538"><span id="local-6989586621679432540"><span id="local-6989586621679432549"><span id="local-6989586621679432551"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; MaybePromotedName a -&gt; Bool
forall a. Num a =&gt; MaybePromotedName a -&gt; a
forall a. Ord a =&gt; MaybePromotedName a -&gt; a
forall m. Monoid m =&gt; MaybePromotedName m -&gt; m
forall a. MaybePromotedName a -&gt; Bool
forall a. MaybePromotedName a -&gt; Int
forall a. MaybePromotedName a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; MaybePromotedName a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; MaybePromotedName a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; MaybePromotedName a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; MaybePromotedName a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; MaybePromotedName a -&gt; a
$cproduct :: forall a. Num a =&gt; MaybePromotedName a -&gt; a
sum :: forall a. Num a =&gt; MaybePromotedName a -&gt; a
$csum :: forall a. Num a =&gt; MaybePromotedName a -&gt; a
minimum :: forall a. Ord a =&gt; MaybePromotedName a -&gt; a
$cminimum :: forall a. Ord a =&gt; MaybePromotedName a -&gt; a
maximum :: forall a. Ord a =&gt; MaybePromotedName a -&gt; a
$cmaximum :: forall a. Ord a =&gt; MaybePromotedName a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; MaybePromotedName a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; MaybePromotedName a -&gt; Bool
length :: forall a. MaybePromotedName a -&gt; Int
$clength :: forall a. MaybePromotedName a -&gt; Int
null :: forall a. MaybePromotedName a -&gt; Bool
$cnull :: forall a. MaybePromotedName a -&gt; Bool
toList :: forall a. MaybePromotedName a -&gt; [a]
$ctoList :: forall a. MaybePromotedName a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; MaybePromotedName a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; MaybePromotedName a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; MaybePromotedName a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; MaybePromotedName a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; MaybePromotedName a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; MaybePromotedName a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; MaybePromotedName a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; MaybePromotedName a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; MaybePromotedName a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; MaybePromotedName a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; MaybePromotedName a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; MaybePromotedName a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; MaybePromotedName a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; MaybePromotedName a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; MaybePromotedName a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; MaybePromotedName a -&gt; m
fold :: forall m. Monoid m =&gt; MaybePromotedName m -&gt; m
$cfold :: forall m. Monoid m =&gt; MaybePromotedName m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432491"><span id="local-6989586621679432493"><span id="local-6989586621679432495"><span id="local-6989586621679432504"><span class="annot"><span class="annottext">Functor MaybePromotedName
Foldable MaybePromotedName
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
MaybePromotedName (m a) -&gt; m (MaybePromotedName a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
MaybePromotedName (f a) -&gt; f (MaybePromotedName a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; MaybePromotedName a -&gt; m (MaybePromotedName b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; MaybePromotedName a -&gt; f (MaybePromotedName b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
MaybePromotedName (m a) -&gt; m (MaybePromotedName a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
MaybePromotedName (m a) -&gt; m (MaybePromotedName a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; MaybePromotedName a -&gt; m (MaybePromotedName b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; MaybePromotedName a -&gt; m (MaybePromotedName b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
MaybePromotedName (f a) -&gt; f (MaybePromotedName a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
MaybePromotedName (f a) -&gt; f (MaybePromotedName a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; MaybePromotedName a -&gt; f (MaybePromotedName b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; MaybePromotedName a -&gt; f (MaybePromotedName b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432485"><span id="local-6989586621679432489"><span class="annot"><span class="annottext">forall a b. a -&gt; MaybePromotedName b -&gt; MaybePromotedName a
forall a b. (a -&gt; b) -&gt; MaybePromotedName a -&gt; MaybePromotedName b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; MaybePromotedName b -&gt; MaybePromotedName a
$c&lt;$ :: forall a b. a -&gt; MaybePromotedName b -&gt; MaybePromotedName a
fmap :: forall a b. (a -&gt; b) -&gt; MaybePromotedName a -&gt; MaybePromotedName b
$cfmap :: forall a b. (a -&gt; b) -&gt; MaybePromotedName a -&gt; MaybePromotedName b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (MaybePromotedName l) x -&gt; MaybePromotedName l
forall l x. MaybePromotedName l -&gt; Rep (MaybePromotedName l) x
$cto :: forall l x. Rep (MaybePromotedName l) x -&gt; MaybePromotedName l
$cfrom :: forall l x. MaybePromotedName l -&gt; Rep (MaybePromotedName l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-657"></span><span>
</span><span id="line-658"></span><span class="hs-comment">-- | Bools here are True if there was a leading quote which may be</span><span>
</span><span id="line-659"></span><span class="hs-comment">-- left out. For example @'[k1,k2]@ means the same thing as @[k1,k2]@.</span><span>
</span><span id="line-660"></span><span id="local-6989586621679432478"><span id="local-6989586621679432479"></span></span><span class="hs-keyword">data</span><span> </span><span id="Promoted"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Promoted"><span class="hs-identifier hs-var">Promoted</span></a></span></span><span> </span><span id="local-6989586621679452593"><span class="annot"><a href="#local-6989586621679452593"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-661"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span id="PromotedInteger"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedInteger"><span class="hs-identifier hs-var">PromotedInteger</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452593"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-comment">-- ^ parsed value and raw string</span><span>
</span><span id="line-662"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span id="PromotedString"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedString"><span class="hs-identifier hs-var">PromotedString</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452593"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-comment">-- ^ parsed value and raw string</span><span>
</span><span id="line-663"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span id="PromotedCon"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedCon"><span class="hs-identifier hs-var">PromotedCon</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452593"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452593"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-664"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span id="PromotedList"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedList"><span class="hs-identifier hs-var">PromotedList</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452593"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452593"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-665"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span id="PromotedTuple"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedTuple"><span class="hs-identifier hs-var">PromotedTuple</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452593"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452593"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-666"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span id="PromotedUnit"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedUnit"><span class="hs-identifier hs-var">PromotedUnit</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452593"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-667"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679432450"><span id="local-6989586621679432470"><span class="annot"><span class="annottext">Promoted l -&gt; Promoted l -&gt; Bool
forall l. Eq l =&gt; Promoted l -&gt; Promoted l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Promoted l -&gt; Promoted l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Promoted l -&gt; Promoted l -&gt; Bool
== :: Promoted l -&gt; Promoted l -&gt; Bool
$c== :: forall l. Eq l =&gt; Promoted l -&gt; Promoted l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432416"><span id="local-6989586621679432418"><span id="local-6989586621679432420"><span id="local-6989586621679432422"><span id="local-6989586621679432424"><span id="local-6989586621679432426"><span id="local-6989586621679432446"><span class="annot"><span class="annottext">Promoted l -&gt; Promoted l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Promoted l)
forall l. Ord l =&gt; Promoted l -&gt; Promoted l -&gt; Bool
forall l. Ord l =&gt; Promoted l -&gt; Promoted l -&gt; Ordering
forall l. Ord l =&gt; Promoted l -&gt; Promoted l -&gt; Promoted l
min :: Promoted l -&gt; Promoted l -&gt; Promoted l
$cmin :: forall l. Ord l =&gt; Promoted l -&gt; Promoted l -&gt; Promoted l
max :: Promoted l -&gt; Promoted l -&gt; Promoted l
$cmax :: forall l. Ord l =&gt; Promoted l -&gt; Promoted l -&gt; Promoted l
&gt;= :: Promoted l -&gt; Promoted l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Promoted l -&gt; Promoted l -&gt; Bool
&gt; :: Promoted l -&gt; Promoted l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Promoted l -&gt; Promoted l -&gt; Bool
&lt;= :: Promoted l -&gt; Promoted l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Promoted l -&gt; Promoted l -&gt; Bool
&lt; :: Promoted l -&gt; Promoted l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Promoted l -&gt; Promoted l -&gt; Bool
compare :: Promoted l -&gt; Promoted l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Promoted l -&gt; Promoted l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432386"><span id="local-6989586621679432388"><span id="local-6989586621679432414"><span class="annot"><span class="annottext">Int -&gt; Promoted l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Promoted l -&gt; ShowS
forall l. Show l =&gt; [Promoted l] -&gt; ShowS
forall l. Show l =&gt; Promoted l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Promoted l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Promoted l] -&gt; ShowS
show :: Promoted l -&gt; String
$cshow :: forall l. Show l =&gt; Promoted l -&gt; String
showsPrec :: Int -&gt; Promoted l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Promoted l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679432316"><span id="local-6989586621679432318"><span id="local-6989586621679432320"><span id="local-6989586621679432322"><span id="local-6989586621679432324"><span id="local-6989586621679432326"><span id="local-6989586621679432328"><span id="local-6989586621679432330"><span id="local-6989586621679432332"><span id="local-6989586621679432338"><span id="local-6989586621679432340"><span id="local-6989586621679432342"><span id="local-6989586621679432361"><span id="local-6989586621679432381"><span class="annot"><span class="annottext">Promoted l -&gt; DataType
Promoted l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Promoted l)
forall l. Data l =&gt; Promoted l -&gt; DataType
forall l. Data l =&gt; Promoted l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Promoted l -&gt; Promoted l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Promoted l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Promoted l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Promoted l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Promoted l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Promoted l -&gt; m (Promoted l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Promoted l -&gt; m (Promoted l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Promoted l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Promoted l -&gt; c (Promoted l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Promoted l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Promoted l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Promoted l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Promoted l -&gt; c (Promoted l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Promoted l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Promoted l -&gt; m (Promoted l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Promoted l -&gt; m (Promoted l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Promoted l -&gt; m (Promoted l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Promoted l -&gt; m (Promoted l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Promoted l -&gt; m (Promoted l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Promoted l -&gt; m (Promoted l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Promoted l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Promoted l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Promoted l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Promoted l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Promoted l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Promoted l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Promoted l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Promoted l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Promoted l -&gt; Promoted l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Promoted l -&gt; Promoted l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Promoted l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Promoted l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Promoted l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Promoted l))
dataTypeOf :: Promoted l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Promoted l -&gt; DataType
toConstr :: Promoted l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Promoted l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Promoted l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Promoted l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Promoted l -&gt; c (Promoted l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Promoted l -&gt; c (Promoted l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432263"><span id="local-6989586621679432265"><span id="local-6989586621679432267"><span id="local-6989586621679432269"><span id="local-6989586621679432271"><span id="local-6989586621679432273"><span id="local-6989586621679432275"><span id="local-6989586621679432277"><span id="local-6989586621679432279"><span id="local-6989586621679432281"><span id="local-6989586621679432283"><span id="local-6989586621679432285"><span id="local-6989586621679432287"><span id="local-6989586621679432294"><span id="local-6989586621679432296"><span id="local-6989586621679432312"><span id="local-6989586621679432314"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Promoted a -&gt; Bool
forall a. Num a =&gt; Promoted a -&gt; a
forall a. Ord a =&gt; Promoted a -&gt; a
forall m. Monoid m =&gt; Promoted m -&gt; m
forall a. Promoted a -&gt; Bool
forall a. Promoted a -&gt; Int
forall a. Promoted a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Promoted a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Promoted a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Promoted a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Promoted a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Promoted a -&gt; a
$cproduct :: forall a. Num a =&gt; Promoted a -&gt; a
sum :: forall a. Num a =&gt; Promoted a -&gt; a
$csum :: forall a. Num a =&gt; Promoted a -&gt; a
minimum :: forall a. Ord a =&gt; Promoted a -&gt; a
$cminimum :: forall a. Ord a =&gt; Promoted a -&gt; a
maximum :: forall a. Ord a =&gt; Promoted a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Promoted a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Promoted a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Promoted a -&gt; Bool
length :: forall a. Promoted a -&gt; Int
$clength :: forall a. Promoted a -&gt; Int
null :: forall a. Promoted a -&gt; Bool
$cnull :: forall a. Promoted a -&gt; Bool
toList :: forall a. Promoted a -&gt; [a]
$ctoList :: forall a. Promoted a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Promoted a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Promoted a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Promoted a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Promoted a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Promoted a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Promoted a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Promoted a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Promoted a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Promoted a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Promoted a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Promoted a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Promoted a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Promoted a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Promoted a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Promoted a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Promoted a -&gt; m
fold :: forall m. Monoid m =&gt; Promoted m -&gt; m
$cfold :: forall m. Monoid m =&gt; Promoted m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432233"><span id="local-6989586621679432235"><span id="local-6989586621679432237"><span id="local-6989586621679432257"><span class="annot"><span class="annottext">Functor Promoted
Foldable Promoted
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Promoted (m a) -&gt; m (Promoted a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Promoted (f a) -&gt; f (Promoted a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Promoted a -&gt; m (Promoted b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Promoted a -&gt; f (Promoted b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Promoted (m a) -&gt; m (Promoted a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Promoted (m a) -&gt; m (Promoted a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Promoted a -&gt; m (Promoted b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Promoted a -&gt; m (Promoted b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Promoted (f a) -&gt; f (Promoted a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Promoted (f a) -&gt; f (Promoted a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Promoted a -&gt; f (Promoted b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Promoted a -&gt; f (Promoted b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432224"><span id="local-6989586621679432231"><span class="annot"><span class="annottext">forall a b. a -&gt; Promoted b -&gt; Promoted a
forall a b. (a -&gt; b) -&gt; Promoted a -&gt; Promoted b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Promoted b -&gt; Promoted a
$c&lt;$ :: forall a b. a -&gt; Promoted b -&gt; Promoted a
fmap :: forall a b. (a -&gt; b) -&gt; Promoted a -&gt; Promoted b
$cfmap :: forall a b. (a -&gt; b) -&gt; Promoted a -&gt; Promoted b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Promoted l) x -&gt; Promoted l
forall l x. Promoted l -&gt; Rep (Promoted l) x
$cto :: forall l x. Rep (Promoted l) x -&gt; Promoted l
$cfrom :: forall l x. Promoted l -&gt; Rep (Promoted l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-668"></span><span>
</span><span id="line-669"></span><span class="hs-comment">-- | Flag denoting whether a tuple is boxed or unboxed.</span><span>
</span><span id="line-670"></span><span id="local-6989586621679432214"><span id="local-6989586621679432215"></span></span><span class="hs-keyword">data</span><span> </span><span id="Boxed"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier hs-var">Boxed</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Boxed"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier hs-var">Boxed</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="Unboxed"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Unboxed"><span class="hs-identifier hs-var">Unboxed</span></a></span></span><span>
</span><span id="line-671"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679432208"><span id="local-6989586621679432210"><span class="annot"><span class="annottext">Boxed -&gt; Boxed -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Boxed -&gt; Boxed -&gt; Bool
$c/= :: Boxed -&gt; Boxed -&gt; Bool
== :: Boxed -&gt; Boxed -&gt; Bool
$c== :: Boxed -&gt; Boxed -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432189"><span id="local-6989586621679432191"><span id="local-6989586621679432194"><span id="local-6989586621679432197"><span id="local-6989586621679432200"><span id="local-6989586621679432202"><span id="local-6989586621679432204"><span class="annot"><span class="annottext">Eq Boxed
Boxed -&gt; Boxed -&gt; Bool
Boxed -&gt; Boxed -&gt; Ordering
Boxed -&gt; Boxed -&gt; Boxed
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
min :: Boxed -&gt; Boxed -&gt; Boxed
$cmin :: Boxed -&gt; Boxed -&gt; Boxed
max :: Boxed -&gt; Boxed -&gt; Boxed
$cmax :: Boxed -&gt; Boxed -&gt; Boxed
&gt;= :: Boxed -&gt; Boxed -&gt; Bool
$c&gt;= :: Boxed -&gt; Boxed -&gt; Bool
&gt; :: Boxed -&gt; Boxed -&gt; Bool
$c&gt; :: Boxed -&gt; Boxed -&gt; Bool
&lt;= :: Boxed -&gt; Boxed -&gt; Bool
$c&lt;= :: Boxed -&gt; Boxed -&gt; Bool
&lt; :: Boxed -&gt; Boxed -&gt; Bool
$c&lt; :: Boxed -&gt; Boxed -&gt; Bool
compare :: Boxed -&gt; Boxed -&gt; Ordering
$ccompare :: Boxed -&gt; Boxed -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432183"><span id="local-6989586621679432185"><span id="local-6989586621679432187"><span class="annot"><span class="annottext">Int -&gt; Boxed -&gt; ShowS
[Boxed] -&gt; ShowS
Boxed -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Boxed] -&gt; ShowS
$cshowList :: [Boxed] -&gt; ShowS
show :: Boxed -&gt; String
$cshow :: Boxed -&gt; String
showsPrec :: Int -&gt; Boxed -&gt; ShowS
$cshowsPrec :: Int -&gt; Boxed -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679432153"><span id="local-6989586621679432155"><span id="local-6989586621679432157"><span id="local-6989586621679432159"><span id="local-6989586621679432161"><span id="local-6989586621679432163"><span id="local-6989586621679432165"><span id="local-6989586621679432167"><span id="local-6989586621679432169"><span id="local-6989586621679432171"><span id="local-6989586621679432173"><span id="local-6989586621679432175"><span id="local-6989586621679432177"><span id="local-6989586621679432179"><span class="annot"><span class="annottext">Typeable Boxed
Boxed -&gt; DataType
Boxed -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Boxed -&gt; Boxed
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Boxed -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Boxed -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Boxed -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Boxed -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Boxed -&gt; m Boxed
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Boxed -&gt; m Boxed
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Boxed
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Boxed -&gt; c Boxed
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Boxed)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Boxed)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Boxed -&gt; m Boxed
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Boxed -&gt; m Boxed
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Boxed -&gt; m Boxed
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Boxed -&gt; m Boxed
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Boxed -&gt; m Boxed
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Boxed -&gt; m Boxed
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Boxed -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Boxed -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Boxed -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Boxed -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Boxed -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Boxed -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Boxed -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Boxed -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Boxed -&gt; Boxed
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Boxed -&gt; Boxed
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Boxed)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Boxed)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Boxed)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Boxed)
dataTypeOf :: Boxed -&gt; DataType
$cdataTypeOf :: Boxed -&gt; DataType
toConstr :: Boxed -&gt; Constr
$ctoConstr :: Boxed -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Boxed
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Boxed
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Boxed -&gt; c Boxed
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Boxed -&gt; c Boxed
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall x. Rep Boxed x -&gt; Boxed
forall x. Boxed -&gt; Rep Boxed x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep Boxed x -&gt; Boxed
$cfrom :: forall x. Boxed -&gt; Rep Boxed x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-672"></span><span>
</span><span id="line-673"></span><span class="hs-comment">-- | A type variable declaration, optionally with an explicit kind annotation.</span><span>
</span><span id="line-674"></span><span id="local-6989586621679432148"><span id="local-6989586621679432149"></span></span><span class="hs-keyword">data</span><span> </span><span id="TyVarBind"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier hs-var">TyVarBind</span></a></span></span><span> </span><span id="local-6989586621679452743"><span class="annot"><a href="#local-6989586621679452743"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-675"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="KindedVar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#KindedVar"><span class="hs-identifier hs-var">KindedVar</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452743"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452743"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Kind"><span class="hs-identifier hs-type">Kind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452743"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- ^ variable binding with kind annotation</span><span>
</span><span id="line-676"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="UnkindedVar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnkindedVar"><span class="hs-identifier hs-var">UnkindedVar</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452743"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452743"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>           </span><span class="hs-comment">-- ^ ordinary variable binding</span><span>
</span><span id="line-677"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679432137"><span id="local-6989586621679432144"><span class="annot"><span class="annottext">TyVarBind l -&gt; TyVarBind l -&gt; Bool
forall l. Eq l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: TyVarBind l -&gt; TyVarBind l -&gt; Bool
$c/= :: forall l. Eq l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; Bool
== :: TyVarBind l -&gt; TyVarBind l -&gt; Bool
$c== :: forall l. Eq l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432108"><span id="local-6989586621679432110"><span id="local-6989586621679432113"><span id="local-6989586621679432116"><span id="local-6989586621679432119"><span id="local-6989586621679432126"><span id="local-6989586621679432133"><span class="annot"><span class="annottext">TyVarBind l -&gt; TyVarBind l -&gt; Bool
TyVarBind l -&gt; TyVarBind l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (TyVarBind l)
forall l. Ord l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; Bool
forall l. Ord l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; Ordering
forall l. Ord l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; TyVarBind l
min :: TyVarBind l -&gt; TyVarBind l -&gt; TyVarBind l
$cmin :: forall l. Ord l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; TyVarBind l
max :: TyVarBind l -&gt; TyVarBind l -&gt; TyVarBind l
$cmax :: forall l. Ord l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; TyVarBind l
&gt;= :: TyVarBind l -&gt; TyVarBind l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; Bool
&gt; :: TyVarBind l -&gt; TyVarBind l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; Bool
&lt;= :: TyVarBind l -&gt; TyVarBind l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; Bool
&lt; :: TyVarBind l -&gt; TyVarBind l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; Bool
compare :: TyVarBind l -&gt; TyVarBind l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; TyVarBind l -&gt; TyVarBind l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432095"><span id="local-6989586621679432097"><span id="local-6989586621679432106"><span class="annot"><span class="annottext">Int -&gt; TyVarBind l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; TyVarBind l -&gt; ShowS
forall l. Show l =&gt; [TyVarBind l] -&gt; ShowS
forall l. Show l =&gt; TyVarBind l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [TyVarBind l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [TyVarBind l] -&gt; ShowS
show :: TyVarBind l -&gt; String
$cshow :: forall l. Show l =&gt; TyVarBind l -&gt; String
showsPrec :: Int -&gt; TyVarBind l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; TyVarBind l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679432050"><span id="local-6989586621679432052"><span id="local-6989586621679432054"><span id="local-6989586621679432056"><span id="local-6989586621679432058"><span id="local-6989586621679432060"><span id="local-6989586621679432062"><span id="local-6989586621679432064"><span id="local-6989586621679432066"><span id="local-6989586621679432072"><span id="local-6989586621679432074"><span id="local-6989586621679432076"><span id="local-6989586621679432083"><span id="local-6989586621679432090"><span class="annot"><span class="annottext">TyVarBind l -&gt; DataType
TyVarBind l -&gt; Constr
forall {l}. Data l =&gt; Typeable (TyVarBind l)
forall l. Data l =&gt; TyVarBind l -&gt; DataType
forall l. Data l =&gt; TyVarBind l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; TyVarBind l -&gt; TyVarBind l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBind l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBind l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBind l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBind l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyVarBind l -&gt; m (TyVarBind l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyVarBind l -&gt; m (TyVarBind l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TyVarBind l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TyVarBind l -&gt; c (TyVarBind l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TyVarBind l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (TyVarBind l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TyVarBind l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TyVarBind l -&gt; c (TyVarBind l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TyVarBind l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyVarBind l -&gt; m (TyVarBind l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyVarBind l -&gt; m (TyVarBind l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyVarBind l -&gt; m (TyVarBind l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyVarBind l -&gt; m (TyVarBind l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyVarBind l -&gt; m (TyVarBind l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TyVarBind l -&gt; m (TyVarBind l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBind l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBind l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBind l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; TyVarBind l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBind l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBind l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBind l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TyVarBind l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TyVarBind l -&gt; TyVarBind l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; TyVarBind l -&gt; TyVarBind l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (TyVarBind l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (TyVarBind l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TyVarBind l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (TyVarBind l))
dataTypeOf :: TyVarBind l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; TyVarBind l -&gt; DataType
toConstr :: TyVarBind l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; TyVarBind l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TyVarBind l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (TyVarBind l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TyVarBind l -&gt; c (TyVarBind l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TyVarBind l -&gt; c (TyVarBind l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679432003"><span id="local-6989586621679432005"><span id="local-6989586621679432007"><span id="local-6989586621679432009"><span id="local-6989586621679432011"><span id="local-6989586621679432013"><span id="local-6989586621679432015"><span id="local-6989586621679432017"><span id="local-6989586621679432019"><span id="local-6989586621679432021"><span id="local-6989586621679432023"><span id="local-6989586621679432025"><span id="local-6989586621679432027"><span id="local-6989586621679432032"><span id="local-6989586621679432034"><span id="local-6989586621679432046"><span id="local-6989586621679432048"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; TyVarBind a -&gt; Bool
forall a. Num a =&gt; TyVarBind a -&gt; a
forall a. Ord a =&gt; TyVarBind a -&gt; a
forall m. Monoid m =&gt; TyVarBind m -&gt; m
forall a. TyVarBind a -&gt; Bool
forall a. TyVarBind a -&gt; Int
forall a. TyVarBind a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; TyVarBind a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBind a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBind a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBind a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; TyVarBind a -&gt; a
$cproduct :: forall a. Num a =&gt; TyVarBind a -&gt; a
sum :: forall a. Num a =&gt; TyVarBind a -&gt; a
$csum :: forall a. Num a =&gt; TyVarBind a -&gt; a
minimum :: forall a. Ord a =&gt; TyVarBind a -&gt; a
$cminimum :: forall a. Ord a =&gt; TyVarBind a -&gt; a
maximum :: forall a. Ord a =&gt; TyVarBind a -&gt; a
$cmaximum :: forall a. Ord a =&gt; TyVarBind a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; TyVarBind a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; TyVarBind a -&gt; Bool
length :: forall a. TyVarBind a -&gt; Int
$clength :: forall a. TyVarBind a -&gt; Int
null :: forall a. TyVarBind a -&gt; Bool
$cnull :: forall a. TyVarBind a -&gt; Bool
toList :: forall a. TyVarBind a -&gt; [a]
$ctoList :: forall a. TyVarBind a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; TyVarBind a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; TyVarBind a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; TyVarBind a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; TyVarBind a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBind a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBind a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBind a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; TyVarBind a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBind a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBind a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBind a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; TyVarBind a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBind a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBind a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBind a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; TyVarBind a -&gt; m
fold :: forall m. Monoid m =&gt; TyVarBind m -&gt; m
$cfold :: forall m. Monoid m =&gt; TyVarBind m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431981"><span id="local-6989586621679431983"><span id="local-6989586621679431985"><span id="local-6989586621679431997"><span class="annot"><span class="annottext">Functor TyVarBind
Foldable TyVarBind
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
TyVarBind (m a) -&gt; m (TyVarBind a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
TyVarBind (f a) -&gt; f (TyVarBind a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; TyVarBind a -&gt; m (TyVarBind b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; TyVarBind a -&gt; f (TyVarBind b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
TyVarBind (m a) -&gt; m (TyVarBind a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
TyVarBind (m a) -&gt; m (TyVarBind a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; TyVarBind a -&gt; m (TyVarBind b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; TyVarBind a -&gt; m (TyVarBind b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
TyVarBind (f a) -&gt; f (TyVarBind a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
TyVarBind (f a) -&gt; f (TyVarBind a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; TyVarBind a -&gt; f (TyVarBind b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; TyVarBind a -&gt; f (TyVarBind b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431974"><span id="local-6989586621679431979"><span class="annot"><span class="annottext">forall a b. a -&gt; TyVarBind b -&gt; TyVarBind a
forall a b. (a -&gt; b) -&gt; TyVarBind a -&gt; TyVarBind b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; TyVarBind b -&gt; TyVarBind a
$c&lt;$ :: forall a b. a -&gt; TyVarBind b -&gt; TyVarBind a
fmap :: forall a b. (a -&gt; b) -&gt; TyVarBind a -&gt; TyVarBind b
$cfmap :: forall a b. (a -&gt; b) -&gt; TyVarBind a -&gt; TyVarBind b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (TyVarBind l) x -&gt; TyVarBind l
forall l x. TyVarBind l -&gt; Rep (TyVarBind l) x
$cto :: forall l x. Rep (TyVarBind l) x -&gt; TyVarBind l
$cfrom :: forall l x. TyVarBind l -&gt; Rep (TyVarBind l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-678"></span><span>
</span><span id="line-679"></span><span class="hs-comment">-- | An explicit kind annotation.</span><span>
</span><span id="line-680"></span><span class="hs-keyword">type</span><span> </span><span id="Kind"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Kind"><span class="hs-identifier hs-var">Kind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-681"></span><span>
</span><span id="line-682"></span><span>
</span><span id="line-683"></span><span class="hs-comment">-- | A functional dependency, given on the form</span><span>
</span><span id="line-684"></span><span class="hs-comment">--   l1 l2 ... ln -&gt; r2 r3 .. rn</span><span>
</span><span id="line-685"></span><span id="local-6989586621679431966"><span id="local-6989586621679431967"></span></span><span class="hs-keyword">data</span><span> </span><span id="FunDep"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunDep"><span class="hs-identifier hs-var">FunDep</span></a></span></span><span> </span><span id="local-6989586621679452722"><span class="annot"><a href="#local-6989586621679452722"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-686"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="FunDep"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunDep"><span class="hs-identifier hs-var">FunDep</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452722"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452722"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452722"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-687"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679431957"><span id="local-6989586621679431963"><span class="annot"><span class="annottext">FunDep l -&gt; FunDep l -&gt; Bool
forall l. Eq l =&gt; FunDep l -&gt; FunDep l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: FunDep l -&gt; FunDep l -&gt; Bool
$c/= :: forall l. Eq l =&gt; FunDep l -&gt; FunDep l -&gt; Bool
== :: FunDep l -&gt; FunDep l -&gt; Bool
$c== :: forall l. Eq l =&gt; FunDep l -&gt; FunDep l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431930"><span id="local-6989586621679431932"><span id="local-6989586621679431935"><span id="local-6989586621679431938"><span id="local-6989586621679431941"><span id="local-6989586621679431947"><span id="local-6989586621679431953"><span class="annot"><span class="annottext">FunDep l -&gt; FunDep l -&gt; Bool
FunDep l -&gt; FunDep l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (FunDep l)
forall l. Ord l =&gt; FunDep l -&gt; FunDep l -&gt; Bool
forall l. Ord l =&gt; FunDep l -&gt; FunDep l -&gt; Ordering
forall l. Ord l =&gt; FunDep l -&gt; FunDep l -&gt; FunDep l
min :: FunDep l -&gt; FunDep l -&gt; FunDep l
$cmin :: forall l. Ord l =&gt; FunDep l -&gt; FunDep l -&gt; FunDep l
max :: FunDep l -&gt; FunDep l -&gt; FunDep l
$cmax :: forall l. Ord l =&gt; FunDep l -&gt; FunDep l -&gt; FunDep l
&gt;= :: FunDep l -&gt; FunDep l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; FunDep l -&gt; FunDep l -&gt; Bool
&gt; :: FunDep l -&gt; FunDep l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; FunDep l -&gt; FunDep l -&gt; Bool
&lt;= :: FunDep l -&gt; FunDep l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; FunDep l -&gt; FunDep l -&gt; Bool
&lt; :: FunDep l -&gt; FunDep l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; FunDep l -&gt; FunDep l -&gt; Bool
compare :: FunDep l -&gt; FunDep l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; FunDep l -&gt; FunDep l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431919"><span id="local-6989586621679431921"><span id="local-6989586621679431928"><span class="annot"><span class="annottext">Int -&gt; FunDep l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; FunDep l -&gt; ShowS
forall l. Show l =&gt; [FunDep l] -&gt; ShowS
forall l. Show l =&gt; FunDep l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [FunDep l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [FunDep l] -&gt; ShowS
show :: FunDep l -&gt; String
$cshow :: forall l. Show l =&gt; FunDep l -&gt; String
showsPrec :: Int -&gt; FunDep l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; FunDep l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679431876"><span id="local-6989586621679431878"><span id="local-6989586621679431880"><span id="local-6989586621679431882"><span id="local-6989586621679431884"><span id="local-6989586621679431886"><span id="local-6989586621679431888"><span id="local-6989586621679431890"><span id="local-6989586621679431892"><span id="local-6989586621679431898"><span id="local-6989586621679431900"><span id="local-6989586621679431902"><span id="local-6989586621679431908"><span id="local-6989586621679431914"><span class="annot"><span class="annottext">FunDep l -&gt; DataType
FunDep l -&gt; Constr
forall {l}. Data l =&gt; Typeable (FunDep l)
forall l. Data l =&gt; FunDep l -&gt; DataType
forall l. Data l =&gt; FunDep l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; FunDep l -&gt; FunDep l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; FunDep l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep l -&gt; m (FunDep l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep l -&gt; m (FunDep l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FunDep l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FunDep l -&gt; c (FunDep l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FunDep l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (FunDep l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FunDep l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FunDep l -&gt; c (FunDep l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FunDep l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep l -&gt; m (FunDep l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep l -&gt; m (FunDep l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep l -&gt; m (FunDep l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep l -&gt; m (FunDep l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep l -&gt; m (FunDep l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; FunDep l -&gt; m (FunDep l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FunDep l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; FunDep l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FunDep l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FunDep l -&gt; FunDep l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; FunDep l -&gt; FunDep l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (FunDep l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (FunDep l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FunDep l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FunDep l))
dataTypeOf :: FunDep l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; FunDep l -&gt; DataType
toConstr :: FunDep l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; FunDep l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FunDep l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FunDep l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FunDep l -&gt; c (FunDep l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FunDep l -&gt; c (FunDep l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431827"><span id="local-6989586621679431829"><span id="local-6989586621679431831"><span id="local-6989586621679431833"><span id="local-6989586621679431835"><span id="local-6989586621679431837"><span id="local-6989586621679431839"><span id="local-6989586621679431841"><span id="local-6989586621679431843"><span id="local-6989586621679431845"><span id="local-6989586621679431847"><span id="local-6989586621679431849"><span id="local-6989586621679431851"><span id="local-6989586621679431857"><span id="local-6989586621679431859"><span id="local-6989586621679431872"><span id="local-6989586621679431874"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; FunDep a -&gt; Bool
forall a. Num a =&gt; FunDep a -&gt; a
forall a. Ord a =&gt; FunDep a -&gt; a
forall m. Monoid m =&gt; FunDep m -&gt; m
forall a. FunDep a -&gt; Bool
forall a. FunDep a -&gt; Int
forall a. FunDep a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; FunDep a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FunDep a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FunDep a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FunDep a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; FunDep a -&gt; a
$cproduct :: forall a. Num a =&gt; FunDep a -&gt; a
sum :: forall a. Num a =&gt; FunDep a -&gt; a
$csum :: forall a. Num a =&gt; FunDep a -&gt; a
minimum :: forall a. Ord a =&gt; FunDep a -&gt; a
$cminimum :: forall a. Ord a =&gt; FunDep a -&gt; a
maximum :: forall a. Ord a =&gt; FunDep a -&gt; a
$cmaximum :: forall a. Ord a =&gt; FunDep a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; FunDep a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; FunDep a -&gt; Bool
length :: forall a. FunDep a -&gt; Int
$clength :: forall a. FunDep a -&gt; Int
null :: forall a. FunDep a -&gt; Bool
$cnull :: forall a. FunDep a -&gt; Bool
toList :: forall a. FunDep a -&gt; [a]
$ctoList :: forall a. FunDep a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; FunDep a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; FunDep a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; FunDep a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; FunDep a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FunDep a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FunDep a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FunDep a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FunDep a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FunDep a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FunDep a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FunDep a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FunDep a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FunDep a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FunDep a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FunDep a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FunDep a -&gt; m
fold :: forall m. Monoid m =&gt; FunDep m -&gt; m
$cfold :: forall m. Monoid m =&gt; FunDep m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431804"><span id="local-6989586621679431806"><span id="local-6989586621679431808"><span id="local-6989586621679431821"><span class="annot"><span class="annottext">Functor FunDep
Foldable FunDep
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; FunDep (m a) -&gt; m (FunDep a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
FunDep (f a) -&gt; f (FunDep a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; FunDep a -&gt; m (FunDep b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; FunDep a -&gt; f (FunDep b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; FunDep (m a) -&gt; m (FunDep a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; FunDep (m a) -&gt; m (FunDep a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; FunDep a -&gt; m (FunDep b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; FunDep a -&gt; m (FunDep b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
FunDep (f a) -&gt; f (FunDep a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
FunDep (f a) -&gt; f (FunDep a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; FunDep a -&gt; f (FunDep b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; FunDep a -&gt; f (FunDep b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431796"><span id="local-6989586621679431802"><span class="annot"><span class="annottext">forall a b. a -&gt; FunDep b -&gt; FunDep a
forall a b. (a -&gt; b) -&gt; FunDep a -&gt; FunDep b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; FunDep b -&gt; FunDep a
$c&lt;$ :: forall a b. a -&gt; FunDep b -&gt; FunDep a
fmap :: forall a b. (a -&gt; b) -&gt; FunDep a -&gt; FunDep b
$cfmap :: forall a b. (a -&gt; b) -&gt; FunDep a -&gt; FunDep b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (FunDep l) x -&gt; FunDep l
forall l x. FunDep l -&gt; Rep (FunDep l) x
$cto :: forall l x. Rep (FunDep l) x -&gt; FunDep l
$cfrom :: forall l x. FunDep l -&gt; Rep (FunDep l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-688"></span><span>
</span><span id="line-689"></span><span class="hs-comment">-- | A context is a set of assertions</span><span>
</span><span id="line-690"></span><span id="local-6989586621679431787"><span id="local-6989586621679431788"></span></span><span class="hs-keyword">data</span><span> </span><span id="Context"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-var">Context</span></a></span></span><span> </span><span id="local-6989586621679452744"><span class="annot"><a href="#local-6989586621679452744"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-691"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="CxSingle"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CxSingle"><span class="hs-identifier hs-var">CxSingle</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452744"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Asst"><span class="hs-identifier hs-type">Asst</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452744"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-692"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="CxTuple"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CxTuple"><span class="hs-identifier hs-var">CxTuple</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452744"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Asst"><span class="hs-identifier hs-type">Asst</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452744"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-693"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="CxEmpty"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CxEmpty"><span class="hs-identifier hs-var">CxEmpty</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452744"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-694"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679431775"><span id="local-6989586621679431782"><span class="annot"><span class="annottext">Context l -&gt; Context l -&gt; Bool
forall l. Eq l =&gt; Context l -&gt; Context l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Context l -&gt; Context l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Context l -&gt; Context l -&gt; Bool
== :: Context l -&gt; Context l -&gt; Bool
$c== :: forall l. Eq l =&gt; Context l -&gt; Context l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431746"><span id="local-6989586621679431748"><span id="local-6989586621679431751"><span id="local-6989586621679431754"><span id="local-6989586621679431757"><span id="local-6989586621679431764"><span id="local-6989586621679431771"><span class="annot"><span class="annottext">Context l -&gt; Context l -&gt; Bool
Context l -&gt; Context l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Context l)
forall l. Ord l =&gt; Context l -&gt; Context l -&gt; Bool
forall l. Ord l =&gt; Context l -&gt; Context l -&gt; Ordering
forall l. Ord l =&gt; Context l -&gt; Context l -&gt; Context l
min :: Context l -&gt; Context l -&gt; Context l
$cmin :: forall l. Ord l =&gt; Context l -&gt; Context l -&gt; Context l
max :: Context l -&gt; Context l -&gt; Context l
$cmax :: forall l. Ord l =&gt; Context l -&gt; Context l -&gt; Context l
&gt;= :: Context l -&gt; Context l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Context l -&gt; Context l -&gt; Bool
&gt; :: Context l -&gt; Context l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Context l -&gt; Context l -&gt; Bool
&lt;= :: Context l -&gt; Context l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Context l -&gt; Context l -&gt; Bool
&lt; :: Context l -&gt; Context l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Context l -&gt; Context l -&gt; Bool
compare :: Context l -&gt; Context l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Context l -&gt; Context l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431732"><span id="local-6989586621679431734"><span id="local-6989586621679431744"><span class="annot"><span class="annottext">Int -&gt; Context l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Context l -&gt; ShowS
forall l. Show l =&gt; [Context l] -&gt; ShowS
forall l. Show l =&gt; Context l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Context l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Context l] -&gt; ShowS
show :: Context l -&gt; String
$cshow :: forall l. Show l =&gt; Context l -&gt; String
showsPrec :: Int -&gt; Context l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Context l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679431687"><span id="local-6989586621679431689"><span id="local-6989586621679431691"><span id="local-6989586621679431693"><span id="local-6989586621679431695"><span id="local-6989586621679431697"><span id="local-6989586621679431699"><span id="local-6989586621679431701"><span id="local-6989586621679431703"><span id="local-6989586621679431709"><span id="local-6989586621679431711"><span id="local-6989586621679431713"><span id="local-6989586621679431720"><span id="local-6989586621679431727"><span class="annot"><span class="annottext">Context l -&gt; DataType
Context l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Context l)
forall l. Data l =&gt; Context l -&gt; DataType
forall l. Data l =&gt; Context l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Context l -&gt; Context l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Context l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Context l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Context l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Context l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Context l -&gt; m (Context l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Context l -&gt; m (Context l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Context l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Context l -&gt; c (Context l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Context l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Context l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Context l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Context l -&gt; c (Context l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Context l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Context l -&gt; m (Context l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Context l -&gt; m (Context l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Context l -&gt; m (Context l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Context l -&gt; m (Context l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Context l -&gt; m (Context l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Context l -&gt; m (Context l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Context l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Context l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Context l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Context l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Context l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Context l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Context l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Context l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Context l -&gt; Context l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Context l -&gt; Context l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Context l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Context l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Context l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Context l))
dataTypeOf :: Context l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Context l -&gt; DataType
toConstr :: Context l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Context l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Context l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Context l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Context l -&gt; c (Context l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Context l -&gt; c (Context l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431641"><span id="local-6989586621679431643"><span id="local-6989586621679431645"><span id="local-6989586621679431647"><span id="local-6989586621679431649"><span id="local-6989586621679431651"><span id="local-6989586621679431653"><span id="local-6989586621679431655"><span id="local-6989586621679431657"><span id="local-6989586621679431659"><span id="local-6989586621679431661"><span id="local-6989586621679431663"><span id="local-6989586621679431665"><span id="local-6989586621679431670"><span id="local-6989586621679431672"><span id="local-6989586621679431683"><span id="local-6989586621679431685"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Context a -&gt; Bool
forall a. Num a =&gt; Context a -&gt; a
forall a. Ord a =&gt; Context a -&gt; a
forall m. Monoid m =&gt; Context m -&gt; m
forall a. Context a -&gt; Bool
forall a. Context a -&gt; Int
forall a. Context a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Context a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Context a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Context a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Context a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Context a -&gt; a
$cproduct :: forall a. Num a =&gt; Context a -&gt; a
sum :: forall a. Num a =&gt; Context a -&gt; a
$csum :: forall a. Num a =&gt; Context a -&gt; a
minimum :: forall a. Ord a =&gt; Context a -&gt; a
$cminimum :: forall a. Ord a =&gt; Context a -&gt; a
maximum :: forall a. Ord a =&gt; Context a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Context a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Context a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Context a -&gt; Bool
length :: forall a. Context a -&gt; Int
$clength :: forall a. Context a -&gt; Int
null :: forall a. Context a -&gt; Bool
$cnull :: forall a. Context a -&gt; Bool
toList :: forall a. Context a -&gt; [a]
$ctoList :: forall a. Context a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Context a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Context a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Context a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Context a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Context a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Context a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Context a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Context a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Context a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Context a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Context a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Context a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Context a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Context a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Context a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Context a -&gt; m
fold :: forall m. Monoid m =&gt; Context m -&gt; m
$cfold :: forall m. Monoid m =&gt; Context m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431618"><span id="local-6989586621679431620"><span id="local-6989586621679431622"><span id="local-6989586621679431635"><span class="annot"><span class="annottext">Functor Context
Foldable Context
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Context (m a) -&gt; m (Context a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Context (f a) -&gt; f (Context a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Context a -&gt; m (Context b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Context a -&gt; f (Context b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Context (m a) -&gt; m (Context a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Context (m a) -&gt; m (Context a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Context a -&gt; m (Context b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Context a -&gt; m (Context b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Context (f a) -&gt; f (Context a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Context (f a) -&gt; f (Context a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Context a -&gt; f (Context b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Context a -&gt; f (Context b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431610"><span id="local-6989586621679431616"><span class="annot"><span class="annottext">forall a b. a -&gt; Context b -&gt; Context a
forall a b. (a -&gt; b) -&gt; Context a -&gt; Context b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Context b -&gt; Context a
$c&lt;$ :: forall a b. a -&gt; Context b -&gt; Context a
fmap :: forall a b. (a -&gt; b) -&gt; Context a -&gt; Context b
$cfmap :: forall a b. (a -&gt; b) -&gt; Context a -&gt; Context b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Context l) x -&gt; Context l
forall l x. Context l -&gt; Rep (Context l) x
$cto :: forall l x. Rep (Context l) x -&gt; Context l
$cfrom :: forall l x. Context l -&gt; Rep (Context l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-695"></span><span>
</span><span id="line-696"></span><span class="hs-comment">-- | Class assertions.</span><span>
</span><span id="line-697"></span><span id="local-6989586621679431602"><span id="local-6989586621679431603"></span></span><span class="hs-keyword">data</span><span> </span><span id="Asst"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Asst"><span class="hs-identifier hs-var">Asst</span></a></span></span><span> </span><span id="local-6989586621679452571"><span class="annot"><a href="#local-6989586621679452571"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-698"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span id="TypeA"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeA"><span class="hs-identifier hs-var">TypeA</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452571"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452571"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                      </span><span class="hs-comment">-- ^ type assertion</span><span>
</span><span id="line-699"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span id="IParam"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IParam"><span class="hs-identifier hs-var">IParam</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452571"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPName"><span class="hs-identifier hs-type">IPName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452571"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452571"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>          </span><span class="hs-comment">-- ^ implicit parameter assertion</span><span>
</span><span id="line-700"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span id="ParenA"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParenA"><span class="hs-identifier hs-var">ParenA</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452571"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Asst"><span class="hs-identifier hs-type">Asst</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452571"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                     </span><span class="hs-comment">-- ^ parenthesised class assertion</span><span>
</span><span id="line-701"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679431588"><span id="local-6989586621679431597"><span class="annot"><span class="annottext">Asst l -&gt; Asst l -&gt; Bool
forall l. Eq l =&gt; Asst l -&gt; Asst l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Asst l -&gt; Asst l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Asst l -&gt; Asst l -&gt; Bool
== :: Asst l -&gt; Asst l -&gt; Bool
$c== :: forall l. Eq l =&gt; Asst l -&gt; Asst l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431555"><span id="local-6989586621679431557"><span id="local-6989586621679431560"><span id="local-6989586621679431563"><span id="local-6989586621679431566"><span id="local-6989586621679431575"><span id="local-6989586621679431584"><span class="annot"><span class="annottext">Asst l -&gt; Asst l -&gt; Bool
Asst l -&gt; Asst l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Asst l)
forall l. Ord l =&gt; Asst l -&gt; Asst l -&gt; Bool
forall l. Ord l =&gt; Asst l -&gt; Asst l -&gt; Ordering
forall l. Ord l =&gt; Asst l -&gt; Asst l -&gt; Asst l
min :: Asst l -&gt; Asst l -&gt; Asst l
$cmin :: forall l. Ord l =&gt; Asst l -&gt; Asst l -&gt; Asst l
max :: Asst l -&gt; Asst l -&gt; Asst l
$cmax :: forall l. Ord l =&gt; Asst l -&gt; Asst l -&gt; Asst l
&gt;= :: Asst l -&gt; Asst l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Asst l -&gt; Asst l -&gt; Bool
&gt; :: Asst l -&gt; Asst l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Asst l -&gt; Asst l -&gt; Bool
&lt;= :: Asst l -&gt; Asst l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Asst l -&gt; Asst l -&gt; Bool
&lt; :: Asst l -&gt; Asst l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Asst l -&gt; Asst l -&gt; Bool
compare :: Asst l -&gt; Asst l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Asst l -&gt; Asst l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431539"><span id="local-6989586621679431541"><span id="local-6989586621679431553"><span class="annot"><span class="annottext">Int -&gt; Asst l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Asst l -&gt; ShowS
forall l. Show l =&gt; [Asst l] -&gt; ShowS
forall l. Show l =&gt; Asst l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Asst l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Asst l] -&gt; ShowS
show :: Asst l -&gt; String
$cshow :: forall l. Show l =&gt; Asst l -&gt; String
showsPrec :: Int -&gt; Asst l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Asst l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679431490"><span id="local-6989586621679431492"><span id="local-6989586621679431494"><span id="local-6989586621679431496"><span id="local-6989586621679431498"><span id="local-6989586621679431500"><span id="local-6989586621679431502"><span id="local-6989586621679431504"><span id="local-6989586621679431506"><span id="local-6989586621679431512"><span id="local-6989586621679431514"><span id="local-6989586621679431516"><span id="local-6989586621679431525"><span id="local-6989586621679431534"><span class="annot"><span class="annottext">Asst l -&gt; DataType
Asst l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Asst l)
forall l. Data l =&gt; Asst l -&gt; DataType
forall l. Data l =&gt; Asst l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Asst l -&gt; Asst l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Asst l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Asst l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Asst l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Asst l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Asst l -&gt; m (Asst l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Asst l -&gt; m (Asst l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Asst l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Asst l -&gt; c (Asst l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Asst l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Asst l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Asst l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Asst l -&gt; c (Asst l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Asst l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Asst l -&gt; m (Asst l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Asst l -&gt; m (Asst l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Asst l -&gt; m (Asst l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Asst l -&gt; m (Asst l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Asst l -&gt; m (Asst l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Asst l -&gt; m (Asst l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Asst l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Asst l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Asst l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Asst l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Asst l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Asst l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Asst l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Asst l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Asst l -&gt; Asst l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Asst l -&gt; Asst l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Asst l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Asst l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Asst l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Asst l))
dataTypeOf :: Asst l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Asst l -&gt; DataType
toConstr :: Asst l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Asst l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Asst l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Asst l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Asst l -&gt; c (Asst l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Asst l -&gt; c (Asst l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431439"><span id="local-6989586621679431441"><span id="local-6989586621679431443"><span id="local-6989586621679431445"><span id="local-6989586621679431447"><span id="local-6989586621679431449"><span id="local-6989586621679431451"><span id="local-6989586621679431453"><span id="local-6989586621679431455"><span id="local-6989586621679431457"><span id="local-6989586621679431459"><span id="local-6989586621679431461"><span id="local-6989586621679431463"><span id="local-6989586621679431469"><span id="local-6989586621679431471"><span id="local-6989586621679431486"><span id="local-6989586621679431488"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Asst a -&gt; Bool
forall a. Num a =&gt; Asst a -&gt; a
forall a. Ord a =&gt; Asst a -&gt; a
forall m. Monoid m =&gt; Asst m -&gt; m
forall a. Asst a -&gt; Bool
forall a. Asst a -&gt; Int
forall a. Asst a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Asst a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Asst a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Asst a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Asst a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Asst a -&gt; a
$cproduct :: forall a. Num a =&gt; Asst a -&gt; a
sum :: forall a. Num a =&gt; Asst a -&gt; a
$csum :: forall a. Num a =&gt; Asst a -&gt; a
minimum :: forall a. Ord a =&gt; Asst a -&gt; a
$cminimum :: forall a. Ord a =&gt; Asst a -&gt; a
maximum :: forall a. Ord a =&gt; Asst a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Asst a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Asst a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Asst a -&gt; Bool
length :: forall a. Asst a -&gt; Int
$clength :: forall a. Asst a -&gt; Int
null :: forall a. Asst a -&gt; Bool
$cnull :: forall a. Asst a -&gt; Bool
toList :: forall a. Asst a -&gt; [a]
$ctoList :: forall a. Asst a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Asst a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Asst a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Asst a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Asst a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Asst a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Asst a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Asst a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Asst a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Asst a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Asst a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Asst a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Asst a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Asst a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Asst a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Asst a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Asst a -&gt; m
fold :: forall m. Monoid m =&gt; Asst m -&gt; m
$cfold :: forall m. Monoid m =&gt; Asst m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431414"><span id="local-6989586621679431416"><span id="local-6989586621679431418"><span id="local-6989586621679431433"><span class="annot"><span class="annottext">Functor Asst
Foldable Asst
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Asst (m a) -&gt; m (Asst a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Asst (f a) -&gt; f (Asst a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Asst a -&gt; m (Asst b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Asst a -&gt; f (Asst b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Asst (m a) -&gt; m (Asst a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Asst (m a) -&gt; m (Asst a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Asst a -&gt; m (Asst b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Asst a -&gt; m (Asst b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Asst (f a) -&gt; f (Asst a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Asst (f a) -&gt; f (Asst a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Asst a -&gt; f (Asst b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Asst a -&gt; f (Asst b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431406"><span id="local-6989586621679431412"><span class="annot"><span class="annottext">forall a b. a -&gt; Asst b -&gt; Asst a
forall a b. (a -&gt; b) -&gt; Asst a -&gt; Asst b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Asst b -&gt; Asst a
$c&lt;$ :: forall a b. a -&gt; Asst b -&gt; Asst a
fmap :: forall a b. (a -&gt; b) -&gt; Asst a -&gt; Asst b
$cfmap :: forall a b. (a -&gt; b) -&gt; Asst a -&gt; Asst b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Asst l) x -&gt; Asst l
forall l x. Asst l -&gt; Rep (Asst l) x
$cto :: forall l x. Rep (Asst l) x -&gt; Asst l
$cfrom :: forall l x. Asst l -&gt; Rep (Asst l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-702"></span><span>
</span><span id="line-703"></span><span class="hs-comment">-- | /literal/</span><span>
</span><span id="line-704"></span><span class="hs-comment">-- Values of this type hold the abstract value of the literal, along with the</span><span>
</span><span id="line-705"></span><span class="hs-comment">-- precise string representation used.  For example, @10@, @0o12@ and @0xa@</span><span>
</span><span id="line-706"></span><span class="hs-comment">-- have the same value representation, but each carry a different string representation.</span><span>
</span><span id="line-707"></span><span id="local-6989586621679431397"><span id="local-6989586621679431398"></span></span><span class="hs-keyword">data</span><span> </span><span id="Literal"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Literal"><span class="hs-identifier hs-var">Literal</span></a></span></span><span> </span><span id="local-6989586621679452561"><span class="annot"><a href="#local-6989586621679452561"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-708"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="Char"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Char"><span class="hs-identifier hs-var">Char</span></a></span></span><span>       </span><span class="annot"><a href="#local-6989586621679452561"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>     </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>     </span><span class="hs-comment">-- ^ character literal</span><span>
</span><span id="line-709"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="String"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#String"><span class="hs-identifier hs-var">String</span></a></span></span><span>     </span><span class="annot"><a href="#local-6989586621679452561"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>   </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>     </span><span class="hs-comment">-- ^ string literal</span><span>
</span><span id="line-710"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Int"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Int"><span class="hs-identifier hs-var">Int</span></a></span></span><span>        </span><span class="annot"><a href="#local-6989586621679452561"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>     </span><span class="hs-comment">-- ^ integer literal</span><span>
</span><span id="line-711"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Frac"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Frac"><span class="hs-identifier hs-var">Frac</span></a></span></span><span>       </span><span class="annot"><a href="#local-6989586621679452561"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Rational</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>     </span><span class="hs-comment">-- ^ floating point literal</span><span>
</span><span id="line-712"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PrimInt"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimInt"><span class="hs-identifier hs-var">PrimInt</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452561"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>     </span><span class="hs-comment">-- ^ unboxed integer literal</span><span>
</span><span id="line-713"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PrimWord"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimWord"><span class="hs-identifier hs-var">PrimWord</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452561"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>     </span><span class="hs-comment">-- ^ unboxed word literal</span><span>
</span><span id="line-714"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PrimFloat"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimFloat"><span class="hs-identifier hs-var">PrimFloat</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452561"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Rational</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>     </span><span class="hs-comment">-- ^ unboxed float literal</span><span>
</span><span id="line-715"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PrimDouble"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimDouble"><span class="hs-identifier hs-var">PrimDouble</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452561"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Rational</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>     </span><span class="hs-comment">-- ^ unboxed double literal</span><span>
</span><span id="line-716"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PrimChar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimChar"><span class="hs-identifier hs-var">PrimChar</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452561"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>     </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>     </span><span class="hs-comment">-- ^ unboxed character literal</span><span>
</span><span id="line-717"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PrimString"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimString"><span class="hs-identifier hs-var">PrimString</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452561"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>   </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>     </span><span class="hs-comment">-- ^ unboxed string literal</span><span>
</span><span id="line-718"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679431352"><span id="local-6989586621679431385"><span class="annot"><span class="annottext">Literal l -&gt; Literal l -&gt; Bool
forall l. Eq l =&gt; Literal l -&gt; Literal l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Literal l -&gt; Literal l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Literal l -&gt; Literal l -&gt; Bool
== :: Literal l -&gt; Literal l -&gt; Bool
$c== :: forall l. Eq l =&gt; Literal l -&gt; Literal l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431304"><span id="local-6989586621679431306"><span id="local-6989586621679431308"><span id="local-6989586621679431310"><span id="local-6989586621679431312"><span id="local-6989586621679431314"><span id="local-6989586621679431348"><span class="annot"><span class="annottext">Literal l -&gt; Literal l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Literal l)
forall l. Ord l =&gt; Literal l -&gt; Literal l -&gt; Bool
forall l. Ord l =&gt; Literal l -&gt; Literal l -&gt; Ordering
forall l. Ord l =&gt; Literal l -&gt; Literal l -&gt; Literal l
min :: Literal l -&gt; Literal l -&gt; Literal l
$cmin :: forall l. Ord l =&gt; Literal l -&gt; Literal l -&gt; Literal l
max :: Literal l -&gt; Literal l -&gt; Literal l
$cmax :: forall l. Ord l =&gt; Literal l -&gt; Literal l -&gt; Literal l
&gt;= :: Literal l -&gt; Literal l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Literal l -&gt; Literal l -&gt; Bool
&gt; :: Literal l -&gt; Literal l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Literal l -&gt; Literal l -&gt; Bool
&lt;= :: Literal l -&gt; Literal l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Literal l -&gt; Literal l -&gt; Bool
&lt; :: Literal l -&gt; Literal l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Literal l -&gt; Literal l -&gt; Bool
compare :: Literal l -&gt; Literal l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Literal l -&gt; Literal l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431256"><span id="local-6989586621679431258"><span id="local-6989586621679431301"><span class="annot"><span class="annottext">Int -&gt; Literal l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Literal l -&gt; ShowS
forall l. Show l =&gt; [Literal l] -&gt; ShowS
forall l. Show l =&gt; Literal l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Literal l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Literal l] -&gt; ShowS
show :: Literal l -&gt; String
$cshow :: forall l. Show l =&gt; Literal l -&gt; String
showsPrec :: Int -&gt; Literal l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Literal l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679431156"><span id="local-6989586621679431158"><span id="local-6989586621679431160"><span id="local-6989586621679431162"><span id="local-6989586621679431164"><span id="local-6989586621679431166"><span id="local-6989586621679431168"><span id="local-6989586621679431170"><span id="local-6989586621679431172"><span id="local-6989586621679431178"><span id="local-6989586621679431180"><span id="local-6989586621679431182"><span id="local-6989586621679431216"><span id="local-6989586621679431251"><span class="annot"><span class="annottext">Literal l -&gt; DataType
Literal l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Literal l)
forall l. Data l =&gt; Literal l -&gt; DataType
forall l. Data l =&gt; Literal l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Literal l -&gt; Literal l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Literal l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Literal l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Literal l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Literal l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Literal l -&gt; m (Literal l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Literal l -&gt; m (Literal l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Literal l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Literal l -&gt; c (Literal l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Literal l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Literal l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Literal l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Literal l -&gt; c (Literal l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Literal l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Literal l -&gt; m (Literal l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Literal l -&gt; m (Literal l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Literal l -&gt; m (Literal l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Literal l -&gt; m (Literal l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Literal l -&gt; m (Literal l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Literal l -&gt; m (Literal l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Literal l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Literal l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Literal l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Literal l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Literal l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Literal l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Literal l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Literal l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Literal l -&gt; Literal l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Literal l -&gt; Literal l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Literal l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Literal l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Literal l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Literal l))
dataTypeOf :: Literal l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Literal l -&gt; DataType
toConstr :: Literal l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Literal l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Literal l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Literal l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Literal l -&gt; c (Literal l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Literal l -&gt; c (Literal l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431121"><span id="local-6989586621679431123"><span id="local-6989586621679431125"><span id="local-6989586621679431127"><span id="local-6989586621679431129"><span id="local-6989586621679431131"><span id="local-6989586621679431133"><span id="local-6989586621679431135"><span id="local-6989586621679431137"><span id="local-6989586621679431139"><span id="local-6989586621679431141"><span id="local-6989586621679431143"><span id="local-6989586621679431145"><span id="local-6989586621679431147"><span id="local-6989586621679431149"><span id="local-6989586621679431152"><span id="local-6989586621679431154"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Literal a -&gt; Bool
forall a. Num a =&gt; Literal a -&gt; a
forall a. Ord a =&gt; Literal a -&gt; a
forall m. Monoid m =&gt; Literal m -&gt; m
forall a. Literal a -&gt; Bool
forall a. Literal a -&gt; Int
forall a. Literal a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Literal a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Literal a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Literal a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Literal a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Literal a -&gt; a
$cproduct :: forall a. Num a =&gt; Literal a -&gt; a
sum :: forall a. Num a =&gt; Literal a -&gt; a
$csum :: forall a. Num a =&gt; Literal a -&gt; a
minimum :: forall a. Ord a =&gt; Literal a -&gt; a
$cminimum :: forall a. Ord a =&gt; Literal a -&gt; a
maximum :: forall a. Ord a =&gt; Literal a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Literal a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Literal a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Literal a -&gt; Bool
length :: forall a. Literal a -&gt; Int
$clength :: forall a. Literal a -&gt; Int
null :: forall a. Literal a -&gt; Bool
$cnull :: forall a. Literal a -&gt; Bool
toList :: forall a. Literal a -&gt; [a]
$ctoList :: forall a. Literal a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Literal a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Literal a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Literal a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Literal a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Literal a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Literal a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Literal a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Literal a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Literal a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Literal a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Literal a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Literal a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Literal a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Literal a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Literal a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Literal a -&gt; m
fold :: forall m. Monoid m =&gt; Literal m -&gt; m
$cfold :: forall m. Monoid m =&gt; Literal m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431096"><span id="local-6989586621679431098"><span id="local-6989586621679431100"><span id="local-6989586621679431114"><span class="annot"><span class="annottext">Functor Literal
Foldable Literal
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Literal (m a) -&gt; m (Literal a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Literal (f a) -&gt; f (Literal a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Literal a -&gt; m (Literal b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Literal a -&gt; f (Literal b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Literal (m a) -&gt; m (Literal a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Literal (m a) -&gt; m (Literal a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Literal a -&gt; m (Literal b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Literal a -&gt; m (Literal b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Literal (f a) -&gt; f (Literal a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Literal (f a) -&gt; f (Literal a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Literal a -&gt; f (Literal b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Literal a -&gt; f (Literal b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431092"><span id="local-6989586621679431094"><span class="annot"><span class="annottext">forall a b. a -&gt; Literal b -&gt; Literal a
forall a b. (a -&gt; b) -&gt; Literal a -&gt; Literal b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Literal b -&gt; Literal a
$c&lt;$ :: forall a b. a -&gt; Literal b -&gt; Literal a
fmap :: forall a b. (a -&gt; b) -&gt; Literal a -&gt; Literal b
$cfmap :: forall a b. (a -&gt; b) -&gt; Literal a -&gt; Literal b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Literal l) x -&gt; Literal l
forall l x. Literal l -&gt; Rep (Literal l) x
$cto :: forall l x. Rep (Literal l) x -&gt; Literal l
$cfrom :: forall l x. Literal l -&gt; Rep (Literal l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-719"></span><span>
</span><span id="line-720"></span><span class="hs-comment">-- | An indication whether a literal pattern has been negated or not.</span><span>
</span><span id="line-721"></span><span id="local-6989586621679431087"><span id="local-6989586621679431088"></span></span><span class="hs-keyword">data</span><span> </span><span id="Sign"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Sign"><span class="hs-identifier hs-var">Sign</span></a></span></span><span> </span><span id="local-6989586621679452553"><span class="annot"><a href="#local-6989586621679452553"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-722"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="Signless"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Signless"><span class="hs-identifier hs-var">Signless</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452553"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-723"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Negative"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Negative"><span class="hs-identifier hs-var">Negative</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452553"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-724"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679431079"><span id="local-6989586621679431083"><span class="annot"><span class="annottext">Sign l -&gt; Sign l -&gt; Bool
forall l. Eq l =&gt; Sign l -&gt; Sign l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Sign l -&gt; Sign l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Sign l -&gt; Sign l -&gt; Bool
== :: Sign l -&gt; Sign l -&gt; Bool
$c== :: forall l. Eq l =&gt; Sign l -&gt; Sign l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431056"><span id="local-6989586621679431058"><span id="local-6989586621679431061"><span id="local-6989586621679431064"><span id="local-6989586621679431067"><span id="local-6989586621679431071"><span id="local-6989586621679431075"><span class="annot"><span class="annottext">Sign l -&gt; Sign l -&gt; Bool
Sign l -&gt; Sign l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Sign l)
forall l. Ord l =&gt; Sign l -&gt; Sign l -&gt; Bool
forall l. Ord l =&gt; Sign l -&gt; Sign l -&gt; Ordering
forall l. Ord l =&gt; Sign l -&gt; Sign l -&gt; Sign l
min :: Sign l -&gt; Sign l -&gt; Sign l
$cmin :: forall l. Ord l =&gt; Sign l -&gt; Sign l -&gt; Sign l
max :: Sign l -&gt; Sign l -&gt; Sign l
$cmax :: forall l. Ord l =&gt; Sign l -&gt; Sign l -&gt; Sign l
&gt;= :: Sign l -&gt; Sign l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Sign l -&gt; Sign l -&gt; Bool
&gt; :: Sign l -&gt; Sign l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Sign l -&gt; Sign l -&gt; Bool
&lt;= :: Sign l -&gt; Sign l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Sign l -&gt; Sign l -&gt; Bool
&lt; :: Sign l -&gt; Sign l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Sign l -&gt; Sign l -&gt; Bool
compare :: Sign l -&gt; Sign l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Sign l -&gt; Sign l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679431046"><span id="local-6989586621679431048"><span id="local-6989586621679431054"><span class="annot"><span class="annottext">Int -&gt; Sign l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Sign l -&gt; ShowS
forall l. Show l =&gt; [Sign l] -&gt; ShowS
forall l. Show l =&gt; Sign l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Sign l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Sign l] -&gt; ShowS
show :: Sign l -&gt; String
$cshow :: forall l. Show l =&gt; Sign l -&gt; String
showsPrec :: Int -&gt; Sign l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Sign l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679431007"><span id="local-6989586621679431009"><span id="local-6989586621679431011"><span id="local-6989586621679431013"><span id="local-6989586621679431015"><span id="local-6989586621679431017"><span id="local-6989586621679431019"><span id="local-6989586621679431021"><span id="local-6989586621679431023"><span id="local-6989586621679431029"><span id="local-6989586621679431031"><span id="local-6989586621679431033"><span id="local-6989586621679431037"><span id="local-6989586621679431041"><span class="annot"><span class="annottext">Sign l -&gt; DataType
Sign l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Sign l)
forall l. Data l =&gt; Sign l -&gt; DataType
forall l. Data l =&gt; Sign l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Sign l -&gt; Sign l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Sign l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Sign l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Sign l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Sign l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Sign l -&gt; m (Sign l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Sign l -&gt; m (Sign l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Sign l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Sign l -&gt; c (Sign l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Sign l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Sign l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Sign l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Sign l -&gt; c (Sign l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Sign l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Sign l -&gt; m (Sign l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Sign l -&gt; m (Sign l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Sign l -&gt; m (Sign l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Sign l -&gt; m (Sign l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Sign l -&gt; m (Sign l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Sign l -&gt; m (Sign l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Sign l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Sign l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Sign l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Sign l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Sign l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Sign l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Sign l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Sign l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Sign l -&gt; Sign l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Sign l -&gt; Sign l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Sign l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Sign l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Sign l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Sign l))
dataTypeOf :: Sign l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Sign l -&gt; DataType
toConstr :: Sign l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Sign l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Sign l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Sign l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Sign l -&gt; c (Sign l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Sign l -&gt; c (Sign l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679430972"><span id="local-6989586621679430974"><span id="local-6989586621679430976"><span id="local-6989586621679430978"><span id="local-6989586621679430980"><span id="local-6989586621679430982"><span id="local-6989586621679430984"><span id="local-6989586621679430986"><span id="local-6989586621679430988"><span id="local-6989586621679430990"><span id="local-6989586621679430992"><span id="local-6989586621679430994"><span id="local-6989586621679430996"><span id="local-6989586621679430998"><span id="local-6989586621679431000"><span id="local-6989586621679431003"><span id="local-6989586621679431005"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Sign a -&gt; Bool
forall a. Num a =&gt; Sign a -&gt; a
forall a. Ord a =&gt; Sign a -&gt; a
forall m. Monoid m =&gt; Sign m -&gt; m
forall a. Sign a -&gt; Bool
forall a. Sign a -&gt; Int
forall a. Sign a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Sign a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Sign a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Sign a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Sign a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Sign a -&gt; a
$cproduct :: forall a. Num a =&gt; Sign a -&gt; a
sum :: forall a. Num a =&gt; Sign a -&gt; a
$csum :: forall a. Num a =&gt; Sign a -&gt; a
minimum :: forall a. Ord a =&gt; Sign a -&gt; a
$cminimum :: forall a. Ord a =&gt; Sign a -&gt; a
maximum :: forall a. Ord a =&gt; Sign a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Sign a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Sign a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Sign a -&gt; Bool
length :: forall a. Sign a -&gt; Int
$clength :: forall a. Sign a -&gt; Int
null :: forall a. Sign a -&gt; Bool
$cnull :: forall a. Sign a -&gt; Bool
toList :: forall a. Sign a -&gt; [a]
$ctoList :: forall a. Sign a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Sign a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Sign a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Sign a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Sign a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Sign a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Sign a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Sign a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Sign a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Sign a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Sign a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Sign a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Sign a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Sign a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Sign a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Sign a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Sign a -&gt; m
fold :: forall m. Monoid m =&gt; Sign m -&gt; m
$cfold :: forall m. Monoid m =&gt; Sign m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679430955"><span id="local-6989586621679430957"><span id="local-6989586621679430959"><span id="local-6989586621679430965"><span class="annot"><span class="annottext">Functor Sign
Foldable Sign
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Sign (m a) -&gt; m (Sign a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Sign (f a) -&gt; f (Sign a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Sign a -&gt; m (Sign b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Sign a -&gt; f (Sign b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Sign (m a) -&gt; m (Sign a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Sign (m a) -&gt; m (Sign a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Sign a -&gt; m (Sign b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Sign a -&gt; m (Sign b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Sign (f a) -&gt; f (Sign a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Sign (f a) -&gt; f (Sign a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Sign a -&gt; f (Sign b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Sign a -&gt; f (Sign b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679430951"><span id="local-6989586621679430953"><span class="annot"><span class="annottext">forall a b. a -&gt; Sign b -&gt; Sign a
forall a b. (a -&gt; b) -&gt; Sign a -&gt; Sign b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Sign b -&gt; Sign a
$c&lt;$ :: forall a b. a -&gt; Sign b -&gt; Sign a
fmap :: forall a b. (a -&gt; b) -&gt; Sign a -&gt; Sign b
$cfmap :: forall a b. (a -&gt; b) -&gt; Sign a -&gt; Sign b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Sign l) x -&gt; Sign l
forall l x. Sign l -&gt; Rep (Sign l) x
$cto :: forall l x. Rep (Sign l) x -&gt; Sign l
$cfrom :: forall l x. Sign l -&gt; Rep (Sign l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-725"></span><span>
</span><span id="line-726"></span><span class="hs-comment">-- | Haskell expressions.</span><span>
</span><span id="line-727"></span><span id="local-6989586621679430946"><span id="local-6989586621679430947"></span></span><span class="hs-keyword">data</span><span> </span><span id="Exp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-var">Exp</span></a></span></span><span> </span><span id="local-6989586621679452813"><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-728"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="Var"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Var"><span class="hs-identifier hs-var">Var</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                       </span><span class="hs-comment">-- ^ variable</span><span>
</span><span id="line-729"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="OverloadedLabel"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#OverloadedLabel"><span class="hs-identifier hs-var">OverloadedLabel</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>              </span><span class="hs-comment">-- ^ Overloaded label #foo</span><span>
</span><span id="line-730"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="IPVar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPVar"><span class="hs-identifier hs-var">IPVar</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPName"><span class="hs-identifier hs-type">IPName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                    </span><span class="hs-comment">-- ^ implicit parameter variable</span><span>
</span><span id="line-731"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Con"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Con"><span class="hs-identifier hs-var">Con</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                       </span><span class="hs-comment">-- ^ data constructor</span><span>
</span><span id="line-732"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Lit"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Lit"><span class="hs-identifier hs-var">Lit</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Literal"><span class="hs-identifier hs-type">Literal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                     </span><span class="hs-comment">-- ^ literal constant</span><span>
</span><span id="line-733"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="InfixApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixApp"><span class="hs-identifier hs-var">InfixApp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QOp"><span class="hs-identifier hs-type">QOp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ infix application</span><span>
</span><span id="line-734"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="App"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#App"><span class="hs-identifier hs-var">App</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                 </span><span class="hs-comment">-- ^ ordinary application</span><span>
</span><span id="line-735"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="NegApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NegApp"><span class="hs-identifier hs-var">NegApp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                      </span><span class="hs-comment">-- ^ negation expression @-/exp/@ (unary minus)</span><span>
</span><span id="line-736"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Lambda"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Lambda"><span class="hs-identifier hs-var">Lambda</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>              </span><span class="hs-comment">-- ^ lambda expression</span><span>
</span><span id="line-737"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Let"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Let"><span class="hs-identifier hs-var">Let</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Binds"><span class="hs-identifier hs-type">Binds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>               </span><span class="hs-comment">-- ^ local declarations with @let@ ... @in@ ...</span><span>
</span><span id="line-738"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="If"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#If"><span class="hs-identifier hs-var">If</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>          </span><span class="hs-comment">-- ^ @if@ /exp/ @then@ /exp/ @else@ /exp/</span><span>
</span><span id="line-739"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="MultiIf"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MultiIf"><span class="hs-identifier hs-var">MultiIf</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GuardedRhs"><span class="hs-identifier hs-type">GuardedRhs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>              </span><span class="hs-comment">-- ^ @if@ @|@ /stmts/ @-&gt;@ /exp/ ...</span><span>
</span><span id="line-740"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Case"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Case"><span class="hs-identifier hs-var">Case</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Alt"><span class="hs-identifier hs-type">Alt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                </span><span class="hs-comment">-- ^ @case@ /exp/ @of@ /alts/</span><span>
</span><span id="line-741"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Do"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Do"><span class="hs-identifier hs-var">Do</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                         </span><span class="hs-comment">-- ^ @do@-expression:</span><span>
</span><span id="line-742"></span><span>                                            </span><span class="hs-comment">--   the last statement in the list</span><span>
</span><span id="line-743"></span><span>                                            </span><span class="hs-comment">--   should be an expression.</span><span>
</span><span id="line-744"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="MDo"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MDo"><span class="hs-identifier hs-var">MDo</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                        </span><span class="hs-comment">-- ^ @mdo@-expression</span><span>
</span><span id="line-745"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Tuple"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Tuple"><span class="hs-identifier hs-var">Tuple</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier hs-type">Boxed</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                 </span><span class="hs-comment">-- ^ tuple expression</span><span>
</span><span id="line-746"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="UnboxedSum"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnboxedSum"><span class="hs-identifier hs-var">UnboxedSum</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>          </span><span class="hs-comment">-- ^ unboxed sum</span><span>
</span><span id="line-747"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="TupleSection"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TupleSection"><span class="hs-identifier hs-var">TupleSection</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier hs-type">Boxed</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- ^ tuple section expression, e.g. @(,,3)@</span><span>
</span><span id="line-748"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="List"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#List"><span class="hs-identifier hs-var">List</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                        </span><span class="hs-comment">-- ^ list expression</span><span>
</span><span id="line-749"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ParArray"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArray"><span class="hs-identifier hs-var">ParArray</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                    </span><span class="hs-comment">-- ^ parallel array expression</span><span>
</span><span id="line-750"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Paren"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Paren"><span class="hs-identifier hs-var">Paren</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                       </span><span class="hs-comment">-- ^ parenthesised expression</span><span>
</span><span id="line-751"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="LeftSection"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LeftSection"><span class="hs-identifier hs-var">LeftSection</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QOp"><span class="hs-identifier hs-type">QOp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- ^ left section @(@/exp/ /qop/@)@</span><span>
</span><span id="line-752"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RightSection"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RightSection"><span class="hs-identifier hs-var">RightSection</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QOp"><span class="hs-identifier hs-type">QOp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- ^ right section @(@/qop/ /exp/@)@</span><span>
</span><span id="line-753"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RecConstr"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecConstr"><span class="hs-identifier hs-var">RecConstr</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldUpdate"><span class="hs-identifier hs-type">FieldUpdate</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ record construction expression</span><span>
</span><span id="line-754"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RecUpdate"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecUpdate"><span class="hs-identifier hs-var">RecUpdate</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldUpdate"><span class="hs-identifier hs-type">FieldUpdate</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ record update expression</span><span>
</span><span id="line-755"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="EnumFrom"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFrom"><span class="hs-identifier hs-var">EnumFrom</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                    </span><span class="hs-comment">-- ^ unbounded arithmetic sequence,</span><span>
</span><span id="line-756"></span><span>                                            </span><span class="hs-comment">--   incrementing by 1: @[from ..]@</span><span>
</span><span id="line-757"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="EnumFromTo"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFromTo"><span class="hs-identifier hs-var">EnumFromTo</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>          </span><span class="hs-comment">-- ^ bounded arithmetic sequence,</span><span>
</span><span id="line-758"></span><span>                                            </span><span class="hs-comment">--   incrementing by 1 @[from .. to]@</span><span>
</span><span id="line-759"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="EnumFromThen"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFromThen"><span class="hs-identifier hs-var">EnumFromThen</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- ^ unbounded arithmetic sequence,</span><span>
</span><span id="line-760"></span><span>                                            </span><span class="hs-comment">--   with first two elements given @[from, then ..]@</span><span>
</span><span id="line-761"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="EnumFromThenTo"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFromThenTo"><span class="hs-identifier hs-var">EnumFromThenTo</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-762"></span><span>                                            </span><span class="hs-comment">-- ^ bounded arithmetic sequence,</span><span>
</span><span id="line-763"></span><span>                                            </span><span class="hs-comment">--   with first two elements given @[from, then .. to]@</span><span>
</span><span id="line-764"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ParArrayFromTo"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArrayFromTo"><span class="hs-identifier hs-var">ParArrayFromTo</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- ^ Parallel array bounded arithmetic sequence,</span><span>
</span><span id="line-765"></span><span>                                            </span><span class="hs-comment">--   incrementing by 1 @[:from .. to:]@</span><span>
</span><span id="line-766"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ParArrayFromThenTo"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArrayFromThenTo"><span class="hs-identifier hs-var">ParArrayFromThenTo</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-767"></span><span>                                            </span><span class="hs-comment">-- ^ bounded arithmetic sequence,</span><span>
</span><span id="line-768"></span><span>                                            </span><span class="hs-comment">--   with first two elements given @[:from, then .. to:]@</span><span>
</span><span id="line-769"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ListComp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ListComp"><span class="hs-identifier hs-var">ListComp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualStmt"><span class="hs-identifier hs-type">QualStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>       </span><span class="hs-comment">-- ^ ordinary list comprehension</span><span>
</span><span id="line-770"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ParComp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParComp"><span class="hs-identifier hs-var">ParComp</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualStmt"><span class="hs-identifier hs-type">QualStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">]</span><span>     </span><span class="hs-comment">-- ^ parallel list comprehension</span><span>
</span><span id="line-771"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ParArrayComp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArrayComp"><span class="hs-identifier hs-var">ParArrayComp</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualStmt"><span class="hs-identifier hs-type">QualStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ parallel array comprehension</span><span>
</span><span id="line-772"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ExpTypeSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExpTypeSig"><span class="hs-identifier hs-var">ExpTypeSig</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- ^ expression with explicit type signature</span><span>
</span><span id="line-773"></span><span>
</span><span id="line-774"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="VarQuote"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarQuote"><span class="hs-identifier hs-var">VarQuote</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                  </span><span class="hs-comment">-- ^ @'x@ for template haskell reifying of expressions</span><span>
</span><span id="line-775"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="TypQuote"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypQuote"><span class="hs-identifier hs-var">TypQuote</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                  </span><span class="hs-comment">-- ^ @''T@ for template haskell reifying of types</span><span>
</span><span id="line-776"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="BracketExp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BracketExp"><span class="hs-identifier hs-var">BracketExp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Bracket"><span class="hs-identifier hs-type">Bracket</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>              </span><span class="hs-comment">-- ^ template haskell bracket expression</span><span>
</span><span id="line-777"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="SpliceExp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpliceExp"><span class="hs-identifier hs-var">SpliceExp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                </span><span class="hs-comment">-- ^ template haskell splice expression</span><span>
</span><span id="line-778"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="QuasiQuote"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QuasiQuote"><span class="hs-identifier hs-var">QuasiQuote</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>            </span><span class="hs-comment">-- ^ quasi-quotaion: @[$/name/| /string/ |]@</span><span>
</span><span id="line-779"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="TypeApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeApp"><span class="hs-identifier hs-var">TypeApp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                    </span><span class="hs-comment">-- ^ Visible type application</span><span>
</span><span id="line-780"></span><span>
</span><span id="line-781"></span><span class="hs-comment">-- Hsx</span><span>
</span><span id="line-782"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="XTag"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XTag"><span class="hs-identifier hs-var">XTag</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-type">XName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XAttr"><span class="hs-identifier hs-type">XAttr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-783"></span><span>                                            </span><span class="hs-comment">-- ^ xml element, with attributes and children</span><span>
</span><span id="line-784"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="XETag"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XETag"><span class="hs-identifier hs-var">XETag</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-type">XName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XAttr"><span class="hs-identifier hs-type">XAttr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-785"></span><span>                                            </span><span class="hs-comment">-- ^ empty xml element, with attributes</span><span>
</span><span id="line-786"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="XPcdata"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XPcdata"><span class="hs-identifier hs-var">XPcdata</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>                      </span><span class="hs-comment">-- ^ PCDATA child element</span><span>
</span><span id="line-787"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="XExpTag"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XExpTag"><span class="hs-identifier hs-var">XExpTag</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                     </span><span class="hs-comment">-- ^ escaped haskell expression inside xml</span><span>
</span><span id="line-788"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="XChildTag"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XChildTag"><span class="hs-identifier hs-var">XChildTag</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                   </span><span class="hs-comment">-- ^ children of an xml element</span><span>
</span><span id="line-789"></span><span>
</span><span id="line-790"></span><span>
</span><span id="line-791"></span><span class="hs-comment">-- Pragmas</span><span>
</span><span id="line-792"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="CorePragma"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CorePragma"><span class="hs-identifier hs-var">CorePragma</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- ^ CORE pragma</span><span>
</span><span id="line-793"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="SCCPragma"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SCCPragma"><span class="hs-identifier hs-var">SCCPragma</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- ^ SCC pragma</span><span>
</span><span id="line-794"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="GenPragma"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GenPragma"><span class="hs-identifier hs-var">GenPragma</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-795"></span><span>                                            </span><span class="hs-comment">-- ^ GENERATED pragma</span><span>
</span><span id="line-796"></span><span>
</span><span id="line-797"></span><span class="hs-comment">-- Arrows</span><span>
</span><span id="line-798"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Proc"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Proc"><span class="hs-identifier hs-var">Proc</span></a></span></span><span>            </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- ^ arrows proc: @proc@ /pat/ @-&gt;@ /exp/</span><span>
</span><span id="line-799"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="LeftArrApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LeftArrApp"><span class="hs-identifier hs-var">LeftArrApp</span></a></span></span><span>      </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- ^ arrow application (from left): /exp/ @-&lt;@ /exp/</span><span>
</span><span id="line-800"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RightArrApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RightArrApp"><span class="hs-identifier hs-var">RightArrApp</span></a></span></span><span>     </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- ^ arrow application (from right): /exp/ @&gt;-@ /exp/</span><span>
</span><span id="line-801"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="LeftArrHighApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LeftArrHighApp"><span class="hs-identifier hs-var">LeftArrHighApp</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- ^ higher-order arrow application (from left): /exp/ @-&lt;&lt;@ /exp/</span><span>
</span><span id="line-802"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RightArrHighApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RightArrHighApp"><span class="hs-identifier hs-var">RightArrHighApp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- ^ higher-order arrow application (from right): /exp/ @&gt;&gt;-@ /exp/</span><span>
</span><span id="line-803"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ArrOp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ArrOp"><span class="hs-identifier hs-var">ArrOp</span></a></span></span><span>           </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- ^ arrow control operators: @(| /exp/ |)@</span><span>
</span><span id="line-804"></span><span>
</span><span id="line-805"></span><span class="hs-comment">-- LambdaCase</span><span>
</span><span id="line-806"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="LCase"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LCase"><span class="hs-identifier hs-var">LCase</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Alt"><span class="hs-identifier hs-type">Alt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452813"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                       </span><span class="hs-comment">-- ^ @\case@ /alts/</span><span>
</span><span id="line-807"></span><span>
</span><span id="line-808"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679430722"><span id="local-6989586621679430888"><span class="annot"><span class="annottext">Exp l -&gt; Exp l -&gt; Bool
forall l. Eq l =&gt; Exp l -&gt; Exp l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Exp l -&gt; Exp l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Exp l -&gt; Exp l -&gt; Bool
== :: Exp l -&gt; Exp l -&gt; Bool
$c== :: forall l. Eq l =&gt; Exp l -&gt; Exp l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679430542"><span id="local-6989586621679430544"><span id="local-6989586621679430546"><span id="local-6989586621679430548"><span id="local-6989586621679430550"><span id="local-6989586621679430552"><span id="local-6989586621679430718"><span class="annot"><span class="annottext">Exp l -&gt; Exp l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Exp l)
forall l. Ord l =&gt; Exp l -&gt; Exp l -&gt; Bool
forall l. Ord l =&gt; Exp l -&gt; Exp l -&gt; Ordering
forall l. Ord l =&gt; Exp l -&gt; Exp l -&gt; Exp l
min :: Exp l -&gt; Exp l -&gt; Exp l
$cmin :: forall l. Ord l =&gt; Exp l -&gt; Exp l -&gt; Exp l
max :: Exp l -&gt; Exp l -&gt; Exp l
$cmax :: forall l. Ord l =&gt; Exp l -&gt; Exp l -&gt; Exp l
&gt;= :: Exp l -&gt; Exp l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Exp l -&gt; Exp l -&gt; Bool
&gt; :: Exp l -&gt; Exp l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Exp l -&gt; Exp l -&gt; Bool
&lt;= :: Exp l -&gt; Exp l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Exp l -&gt; Exp l -&gt; Bool
&lt; :: Exp l -&gt; Exp l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Exp l -&gt; Exp l -&gt; Bool
compare :: Exp l -&gt; Exp l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Exp l -&gt; Exp l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679430316"><span id="local-6989586621679430318"><span id="local-6989586621679430540"><span class="annot"><span class="annottext">Int -&gt; Exp l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Exp l -&gt; ShowS
forall l. Show l =&gt; [Exp l] -&gt; ShowS
forall l. Show l =&gt; Exp l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Exp l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Exp l] -&gt; ShowS
show :: Exp l -&gt; String
$cshow :: forall l. Show l =&gt; Exp l -&gt; String
showsPrec :: Int -&gt; Exp l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Exp l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679429953"><span id="local-6989586621679429955"><span id="local-6989586621679429957"><span id="local-6989586621679429959"><span id="local-6989586621679429961"><span id="local-6989586621679429963"><span id="local-6989586621679429965"><span id="local-6989586621679429967"><span id="local-6989586621679429969"><span id="local-6989586621679429975"><span id="local-6989586621679429977"><span id="local-6989586621679429979"><span id="local-6989586621679430145"><span id="local-6989586621679430311"><span class="annot"><span class="annottext">Exp l -&gt; DataType
Exp l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Exp l)
forall l. Data l =&gt; Exp l -&gt; DataType
forall l. Data l =&gt; Exp l -&gt; Constr
forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; Exp l -&gt; Exp l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Exp l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Exp l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp l -&gt; m (Exp l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp l -&gt; m (Exp l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Exp l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Exp l -&gt; c (Exp l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Exp l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Exp l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Exp l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Exp l -&gt; c (Exp l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Exp l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp l -&gt; m (Exp l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp l -&gt; m (Exp l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp l -&gt; m (Exp l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp l -&gt; m (Exp l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp l -&gt; m (Exp l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Exp l -&gt; m (Exp l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Exp l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Exp l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Exp l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Exp l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Exp l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Exp l -&gt; Exp l
$cgmapT :: forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; Exp l -&gt; Exp l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Exp l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Exp l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Exp l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Exp l))
dataTypeOf :: Exp l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Exp l -&gt; DataType
toConstr :: Exp l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Exp l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Exp l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Exp l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Exp l -&gt; c (Exp l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Exp l -&gt; c (Exp l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679429502"><span id="local-6989586621679429504"><span id="local-6989586621679429506"><span id="local-6989586621679429508"><span id="local-6989586621679429510"><span id="local-6989586621679429512"><span id="local-6989586621679429514"><span id="local-6989586621679429516"><span id="local-6989586621679429518"><span id="local-6989586621679429520"><span id="local-6989586621679429522"><span id="local-6989586621679429524"><span id="local-6989586621679429526"><span id="local-6989586621679429638"><span id="local-6989586621679429640"><span id="local-6989586621679429949"><span id="local-6989586621679429951"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Exp a -&gt; Bool
forall a. Num a =&gt; Exp a -&gt; a
forall a. Ord a =&gt; Exp a -&gt; a
forall m. Monoid m =&gt; Exp m -&gt; m
forall a. Exp a -&gt; Bool
forall a. Exp a -&gt; Int
forall a. Exp a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Exp a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Exp a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Exp a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Exp a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Exp a -&gt; a
$cproduct :: forall a. Num a =&gt; Exp a -&gt; a
sum :: forall a. Num a =&gt; Exp a -&gt; a
$csum :: forall a. Num a =&gt; Exp a -&gt; a
minimum :: forall a. Ord a =&gt; Exp a -&gt; a
$cminimum :: forall a. Ord a =&gt; Exp a -&gt; a
maximum :: forall a. Ord a =&gt; Exp a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Exp a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Exp a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Exp a -&gt; Bool
length :: forall a. Exp a -&gt; Int
$clength :: forall a. Exp a -&gt; Int
null :: forall a. Exp a -&gt; Bool
$cnull :: forall a. Exp a -&gt; Bool
toList :: forall a. Exp a -&gt; [a]
$ctoList :: forall a. Exp a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Exp a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Exp a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Exp a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Exp a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Exp a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Exp a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Exp a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Exp a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Exp a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Exp a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Exp a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Exp a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Exp a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Exp a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Exp a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Exp a -&gt; m
fold :: forall m. Monoid m =&gt; Exp m -&gt; m
$cfold :: forall m. Monoid m =&gt; Exp m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679429179"><span id="local-6989586621679429181"><span id="local-6989586621679429183"><span id="local-6989586621679429496"><span class="annot"><span class="annottext">Functor Exp
Foldable Exp
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Exp (m a) -&gt; m (Exp a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Exp (f a) -&gt; f (Exp a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Exp a -&gt; m (Exp b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Exp a -&gt; f (Exp b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Exp (m a) -&gt; m (Exp a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Exp (m a) -&gt; m (Exp a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Exp a -&gt; m (Exp b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Exp a -&gt; m (Exp b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Exp (f a) -&gt; f (Exp a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Exp (f a) -&gt; f (Exp a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Exp a -&gt; f (Exp b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Exp a -&gt; f (Exp b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679429061"><span id="local-6989586621679429177"><span class="annot"><span class="annottext">forall a b. a -&gt; Exp b -&gt; Exp a
forall a b. (a -&gt; b) -&gt; Exp a -&gt; Exp b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Exp b -&gt; Exp a
$c&lt;$ :: forall a b. a -&gt; Exp b -&gt; Exp a
fmap :: forall a b. (a -&gt; b) -&gt; Exp a -&gt; Exp b
$cfmap :: forall a b. (a -&gt; b) -&gt; Exp a -&gt; Exp b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Exp l) x -&gt; Exp l
forall l x. Exp l -&gt; Rep (Exp l) x
$cto :: forall l x. Rep (Exp l) x -&gt; Exp l
$cfrom :: forall l x. Exp l -&gt; Rep (Exp l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-809"></span><span>
</span><span id="line-810"></span><span class="hs-comment">-- | The name of an xml element or attribute,</span><span>
</span><span id="line-811"></span><span class="hs-comment">--   possibly qualified with a namespace.</span><span>
</span><span id="line-812"></span><span id="local-6989586621679428946"><span id="local-6989586621679428947"></span></span><span class="hs-keyword">data</span><span> </span><span id="XName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-var">XName</span></a></span></span><span> </span><span id="local-6989586621679452809"><span class="annot"><a href="#local-6989586621679452809"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-813"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="XName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-var">XName</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452809"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>              </span><span class="hs-comment">-- &lt;name ...</span><span>
</span><span id="line-814"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="XDomName"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XDomName"><span class="hs-identifier hs-var">XDomName</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452809"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>    </span><span class="hs-comment">-- &lt;dom:name ...</span><span>
</span><span id="line-815"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679428934"><span id="local-6989586621679428942"><span class="annot"><span class="annottext">XName l -&gt; XName l -&gt; Bool
forall l. Eq l =&gt; XName l -&gt; XName l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: XName l -&gt; XName l -&gt; Bool
$c/= :: forall l. Eq l =&gt; XName l -&gt; XName l -&gt; Bool
== :: XName l -&gt; XName l -&gt; Bool
$c== :: forall l. Eq l =&gt; XName l -&gt; XName l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428903"><span id="local-6989586621679428905"><span id="local-6989586621679428908"><span id="local-6989586621679428911"><span id="local-6989586621679428914"><span id="local-6989586621679428922"><span id="local-6989586621679428930"><span class="annot"><span class="annottext">XName l -&gt; XName l -&gt; Bool
XName l -&gt; XName l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (XName l)
forall l. Ord l =&gt; XName l -&gt; XName l -&gt; Bool
forall l. Ord l =&gt; XName l -&gt; XName l -&gt; Ordering
forall l. Ord l =&gt; XName l -&gt; XName l -&gt; XName l
min :: XName l -&gt; XName l -&gt; XName l
$cmin :: forall l. Ord l =&gt; XName l -&gt; XName l -&gt; XName l
max :: XName l -&gt; XName l -&gt; XName l
$cmax :: forall l. Ord l =&gt; XName l -&gt; XName l -&gt; XName l
&gt;= :: XName l -&gt; XName l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; XName l -&gt; XName l -&gt; Bool
&gt; :: XName l -&gt; XName l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; XName l -&gt; XName l -&gt; Bool
&lt;= :: XName l -&gt; XName l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; XName l -&gt; XName l -&gt; Bool
&lt; :: XName l -&gt; XName l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; XName l -&gt; XName l -&gt; Bool
compare :: XName l -&gt; XName l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; XName l -&gt; XName l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428889"><span id="local-6989586621679428891"><span id="local-6989586621679428901"><span class="annot"><span class="annottext">Int -&gt; XName l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; XName l -&gt; ShowS
forall l. Show l =&gt; [XName l] -&gt; ShowS
forall l. Show l =&gt; XName l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [XName l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [XName l] -&gt; ShowS
show :: XName l -&gt; String
$cshow :: forall l. Show l =&gt; XName l -&gt; String
showsPrec :: Int -&gt; XName l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; XName l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679428842"><span id="local-6989586621679428844"><span id="local-6989586621679428846"><span id="local-6989586621679428848"><span id="local-6989586621679428850"><span id="local-6989586621679428852"><span id="local-6989586621679428854"><span id="local-6989586621679428856"><span id="local-6989586621679428858"><span id="local-6989586621679428864"><span id="local-6989586621679428866"><span id="local-6989586621679428868"><span id="local-6989586621679428876"><span id="local-6989586621679428884"><span class="annot"><span class="annottext">XName l -&gt; DataType
XName l -&gt; Constr
forall {l}. Data l =&gt; Typeable (XName l)
forall l. Data l =&gt; XName l -&gt; DataType
forall l. Data l =&gt; XName l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; XName l -&gt; XName l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; XName l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; XName l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XName l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XName l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XName l -&gt; m (XName l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XName l -&gt; m (XName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (XName l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; XName l -&gt; c (XName l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (XName l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (XName l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (XName l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; XName l -&gt; c (XName l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (XName l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XName l -&gt; m (XName l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XName l -&gt; m (XName l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XName l -&gt; m (XName l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XName l -&gt; m (XName l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XName l -&gt; m (XName l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XName l -&gt; m (XName l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; XName l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; XName l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; XName l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; XName l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XName l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XName l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XName l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XName l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; XName l -&gt; XName l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; XName l -&gt; XName l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (XName l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (XName l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (XName l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (XName l))
dataTypeOf :: XName l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; XName l -&gt; DataType
toConstr :: XName l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; XName l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (XName l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (XName l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; XName l -&gt; c (XName l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; XName l -&gt; c (XName l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428807"><span id="local-6989586621679428809"><span id="local-6989586621679428811"><span id="local-6989586621679428813"><span id="local-6989586621679428815"><span id="local-6989586621679428817"><span id="local-6989586621679428819"><span id="local-6989586621679428821"><span id="local-6989586621679428823"><span id="local-6989586621679428825"><span id="local-6989586621679428827"><span id="local-6989586621679428829"><span id="local-6989586621679428831"><span id="local-6989586621679428833"><span id="local-6989586621679428835"><span id="local-6989586621679428838"><span id="local-6989586621679428840"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; XName a -&gt; Bool
forall a. Num a =&gt; XName a -&gt; a
forall a. Ord a =&gt; XName a -&gt; a
forall m. Monoid m =&gt; XName m -&gt; m
forall a. XName a -&gt; Bool
forall a. XName a -&gt; Int
forall a. XName a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; XName a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; XName a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; XName a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; XName a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; XName a -&gt; a
$cproduct :: forall a. Num a =&gt; XName a -&gt; a
sum :: forall a. Num a =&gt; XName a -&gt; a
$csum :: forall a. Num a =&gt; XName a -&gt; a
minimum :: forall a. Ord a =&gt; XName a -&gt; a
$cminimum :: forall a. Ord a =&gt; XName a -&gt; a
maximum :: forall a. Ord a =&gt; XName a -&gt; a
$cmaximum :: forall a. Ord a =&gt; XName a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; XName a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; XName a -&gt; Bool
length :: forall a. XName a -&gt; Int
$clength :: forall a. XName a -&gt; Int
null :: forall a. XName a -&gt; Bool
$cnull :: forall a. XName a -&gt; Bool
toList :: forall a. XName a -&gt; [a]
$ctoList :: forall a. XName a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; XName a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; XName a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; XName a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; XName a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; XName a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; XName a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; XName a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; XName a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; XName a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; XName a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; XName a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; XName a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; XName a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; XName a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; XName a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; XName a -&gt; m
fold :: forall m. Monoid m =&gt; XName m -&gt; m
$cfold :: forall m. Monoid m =&gt; XName m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428791"><span id="local-6989586621679428793"><span id="local-6989586621679428795"><span id="local-6989586621679428801"><span class="annot"><span class="annottext">Functor XName
Foldable XName
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; XName (m a) -&gt; m (XName a)
forall (f :: * -&gt; *) a. Applicative f =&gt; XName (f a) -&gt; f (XName a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; XName a -&gt; m (XName b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; XName a -&gt; f (XName b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; XName (m a) -&gt; m (XName a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; XName (m a) -&gt; m (XName a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; XName a -&gt; m (XName b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; XName a -&gt; m (XName b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; XName (f a) -&gt; f (XName a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; XName (f a) -&gt; f (XName a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; XName a -&gt; f (XName b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; XName a -&gt; f (XName b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428787"><span id="local-6989586621679428789"><span class="annot"><span class="annottext">forall a b. a -&gt; XName b -&gt; XName a
forall a b. (a -&gt; b) -&gt; XName a -&gt; XName b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; XName b -&gt; XName a
$c&lt;$ :: forall a b. a -&gt; XName b -&gt; XName a
fmap :: forall a b. (a -&gt; b) -&gt; XName a -&gt; XName b
$cfmap :: forall a b. (a -&gt; b) -&gt; XName a -&gt; XName b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (XName l) x -&gt; XName l
forall l x. XName l -&gt; Rep (XName l) x
$cto :: forall l x. Rep (XName l) x -&gt; XName l
$cfrom :: forall l x. XName l -&gt; Rep (XName l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-816"></span><span>
</span><span id="line-817"></span><span class="hs-comment">-- | An xml attribute, which is a name-expression pair.</span><span>
</span><span id="line-818"></span><span id="local-6989586621679428782"><span id="local-6989586621679428783"></span></span><span class="hs-keyword">data</span><span> </span><span id="XAttr"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XAttr"><span class="hs-identifier hs-var">XAttr</span></a></span></span><span> </span><span id="local-6989586621679452811"><span class="annot"><a href="#local-6989586621679452811"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="XAttr"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XAttr"><span class="hs-identifier hs-var">XAttr</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452811"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-type">XName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452811"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452811"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-819"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679428774"><span id="local-6989586621679428779"><span class="annot"><span class="annottext">XAttr l -&gt; XAttr l -&gt; Bool
forall l. Eq l =&gt; XAttr l -&gt; XAttr l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: XAttr l -&gt; XAttr l -&gt; Bool
$c/= :: forall l. Eq l =&gt; XAttr l -&gt; XAttr l -&gt; Bool
== :: XAttr l -&gt; XAttr l -&gt; Bool
$c== :: forall l. Eq l =&gt; XAttr l -&gt; XAttr l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428749"><span id="local-6989586621679428751"><span id="local-6989586621679428754"><span id="local-6989586621679428757"><span id="local-6989586621679428760"><span id="local-6989586621679428765"><span id="local-6989586621679428770"><span class="annot"><span class="annottext">XAttr l -&gt; XAttr l -&gt; Bool
XAttr l -&gt; XAttr l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (XAttr l)
forall l. Ord l =&gt; XAttr l -&gt; XAttr l -&gt; Bool
forall l. Ord l =&gt; XAttr l -&gt; XAttr l -&gt; Ordering
forall l. Ord l =&gt; XAttr l -&gt; XAttr l -&gt; XAttr l
min :: XAttr l -&gt; XAttr l -&gt; XAttr l
$cmin :: forall l. Ord l =&gt; XAttr l -&gt; XAttr l -&gt; XAttr l
max :: XAttr l -&gt; XAttr l -&gt; XAttr l
$cmax :: forall l. Ord l =&gt; XAttr l -&gt; XAttr l -&gt; XAttr l
&gt;= :: XAttr l -&gt; XAttr l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; XAttr l -&gt; XAttr l -&gt; Bool
&gt; :: XAttr l -&gt; XAttr l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; XAttr l -&gt; XAttr l -&gt; Bool
&lt;= :: XAttr l -&gt; XAttr l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; XAttr l -&gt; XAttr l -&gt; Bool
&lt; :: XAttr l -&gt; XAttr l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; XAttr l -&gt; XAttr l -&gt; Bool
compare :: XAttr l -&gt; XAttr l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; XAttr l -&gt; XAttr l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428739"><span id="local-6989586621679428741"><span id="local-6989586621679428747"><span class="annot"><span class="annottext">Int -&gt; XAttr l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; XAttr l -&gt; ShowS
forall l. Show l =&gt; [XAttr l] -&gt; ShowS
forall l. Show l =&gt; XAttr l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [XAttr l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [XAttr l] -&gt; ShowS
show :: XAttr l -&gt; String
$cshow :: forall l. Show l =&gt; XAttr l -&gt; String
showsPrec :: Int -&gt; XAttr l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; XAttr l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679428698"><span id="local-6989586621679428700"><span id="local-6989586621679428702"><span id="local-6989586621679428704"><span id="local-6989586621679428706"><span id="local-6989586621679428708"><span id="local-6989586621679428710"><span id="local-6989586621679428712"><span id="local-6989586621679428714"><span id="local-6989586621679428720"><span id="local-6989586621679428722"><span id="local-6989586621679428724"><span id="local-6989586621679428729"><span id="local-6989586621679428734"><span class="annot"><span class="annottext">XAttr l -&gt; DataType
XAttr l -&gt; Constr
forall {l}. Data l =&gt; Typeable (XAttr l)
forall l. Data l =&gt; XAttr l -&gt; DataType
forall l. Data l =&gt; XAttr l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; XAttr l -&gt; XAttr l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; XAttr l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; XAttr l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XAttr l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XAttr l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XAttr l -&gt; m (XAttr l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XAttr l -&gt; m (XAttr l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (XAttr l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; XAttr l -&gt; c (XAttr l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (XAttr l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (XAttr l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (XAttr l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; XAttr l -&gt; c (XAttr l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (XAttr l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XAttr l -&gt; m (XAttr l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XAttr l -&gt; m (XAttr l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XAttr l -&gt; m (XAttr l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XAttr l -&gt; m (XAttr l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XAttr l -&gt; m (XAttr l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; XAttr l -&gt; m (XAttr l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; XAttr l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; XAttr l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; XAttr l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; XAttr l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XAttr l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XAttr l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XAttr l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; XAttr l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; XAttr l -&gt; XAttr l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; XAttr l -&gt; XAttr l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (XAttr l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (XAttr l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (XAttr l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (XAttr l))
dataTypeOf :: XAttr l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; XAttr l -&gt; DataType
toConstr :: XAttr l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; XAttr l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (XAttr l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (XAttr l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; XAttr l -&gt; c (XAttr l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; XAttr l -&gt; c (XAttr l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428655"><span id="local-6989586621679428657"><span id="local-6989586621679428659"><span id="local-6989586621679428661"><span id="local-6989586621679428663"><span id="local-6989586621679428665"><span id="local-6989586621679428667"><span id="local-6989586621679428669"><span id="local-6989586621679428671"><span id="local-6989586621679428673"><span id="local-6989586621679428675"><span id="local-6989586621679428677"><span id="local-6989586621679428679"><span id="local-6989586621679428683"><span id="local-6989586621679428685"><span id="local-6989586621679428694"><span id="local-6989586621679428696"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; XAttr a -&gt; Bool
forall a. Num a =&gt; XAttr a -&gt; a
forall a. Ord a =&gt; XAttr a -&gt; a
forall m. Monoid m =&gt; XAttr m -&gt; m
forall a. XAttr a -&gt; Bool
forall a. XAttr a -&gt; Int
forall a. XAttr a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; XAttr a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; XAttr a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; XAttr a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; XAttr a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; XAttr a -&gt; a
$cproduct :: forall a. Num a =&gt; XAttr a -&gt; a
sum :: forall a. Num a =&gt; XAttr a -&gt; a
$csum :: forall a. Num a =&gt; XAttr a -&gt; a
minimum :: forall a. Ord a =&gt; XAttr a -&gt; a
$cminimum :: forall a. Ord a =&gt; XAttr a -&gt; a
maximum :: forall a. Ord a =&gt; XAttr a -&gt; a
$cmaximum :: forall a. Ord a =&gt; XAttr a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; XAttr a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; XAttr a -&gt; Bool
length :: forall a. XAttr a -&gt; Int
$clength :: forall a. XAttr a -&gt; Int
null :: forall a. XAttr a -&gt; Bool
$cnull :: forall a. XAttr a -&gt; Bool
toList :: forall a. XAttr a -&gt; [a]
$ctoList :: forall a. XAttr a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; XAttr a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; XAttr a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; XAttr a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; XAttr a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; XAttr a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; XAttr a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; XAttr a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; XAttr a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; XAttr a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; XAttr a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; XAttr a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; XAttr a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; XAttr a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; XAttr a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; XAttr a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; XAttr a -&gt; m
fold :: forall m. Monoid m =&gt; XAttr m -&gt; m
$cfold :: forall m. Monoid m =&gt; XAttr m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428636"><span id="local-6989586621679428638"><span id="local-6989586621679428640"><span id="local-6989586621679428649"><span class="annot"><span class="annottext">Functor XAttr
Foldable XAttr
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; XAttr (m a) -&gt; m (XAttr a)
forall (f :: * -&gt; *) a. Applicative f =&gt; XAttr (f a) -&gt; f (XAttr a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; XAttr a -&gt; m (XAttr b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; XAttr a -&gt; f (XAttr b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; XAttr (m a) -&gt; m (XAttr a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; XAttr (m a) -&gt; m (XAttr a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; XAttr a -&gt; m (XAttr b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; XAttr a -&gt; m (XAttr b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; XAttr (f a) -&gt; f (XAttr a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; XAttr (f a) -&gt; f (XAttr a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; XAttr a -&gt; f (XAttr b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; XAttr a -&gt; f (XAttr b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428630"><span id="local-6989586621679428634"><span class="annot"><span class="annottext">forall a b. a -&gt; XAttr b -&gt; XAttr a
forall a b. (a -&gt; b) -&gt; XAttr a -&gt; XAttr b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; XAttr b -&gt; XAttr a
$c&lt;$ :: forall a b. a -&gt; XAttr b -&gt; XAttr a
fmap :: forall a b. (a -&gt; b) -&gt; XAttr a -&gt; XAttr b
$cfmap :: forall a b. (a -&gt; b) -&gt; XAttr a -&gt; XAttr b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (XAttr l) x -&gt; XAttr l
forall l x. XAttr l -&gt; Rep (XAttr l) x
$cto :: forall l x. Rep (XAttr l) x -&gt; XAttr l
$cfrom :: forall l x. XAttr l -&gt; Rep (XAttr l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-820"></span><span>
</span><span id="line-821"></span><span class="hs-comment">-- | A template haskell bracket expression.</span><span>
</span><span id="line-822"></span><span id="local-6989586621679428623"><span id="local-6989586621679428624"></span></span><span class="hs-keyword">data</span><span> </span><span id="Bracket"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Bracket"><span class="hs-identifier hs-var">Bracket</span></a></span></span><span> </span><span id="local-6989586621679452545"><span class="annot"><a href="#local-6989586621679452545"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-823"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="ExpBracket"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExpBracket"><span class="hs-identifier hs-var">ExpBracket</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452545"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452545"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- ^ expression bracket: @[| ... |]@</span><span>
</span><span id="line-824"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="TExpBracket"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TExpBracket"><span class="hs-identifier hs-var">TExpBracket</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452545"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452545"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- ^ typed expression bracket: @[|| ... ||]@</span><span>
</span><span id="line-825"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PatBracket"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatBracket"><span class="hs-identifier hs-var">PatBracket</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452545"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452545"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- ^ pattern bracket: @[p| ... |]@</span><span>
</span><span id="line-826"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="TypeBracket"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeBracket"><span class="hs-identifier hs-var">TypeBracket</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452545"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452545"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- ^ type bracket: @[t| ... |]@</span><span>
</span><span id="line-827"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="DeclBracket"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclBracket"><span class="hs-identifier hs-var">DeclBracket</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452545"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452545"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>      </span><span class="hs-comment">-- ^ declaration bracket: @[d| ... |]@</span><span>
</span><span id="line-828"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679428603"><span id="local-6989586621679428616"><span class="annot"><span class="annottext">Bracket l -&gt; Bracket l -&gt; Bool
forall l. Eq l =&gt; Bracket l -&gt; Bracket l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Bracket l -&gt; Bracket l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Bracket l -&gt; Bracket l -&gt; Bool
== :: Bracket l -&gt; Bracket l -&gt; Bool
$c== :: forall l. Eq l =&gt; Bracket l -&gt; Bracket l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428576"><span id="local-6989586621679428578"><span id="local-6989586621679428580"><span id="local-6989586621679428582"><span id="local-6989586621679428584"><span id="local-6989586621679428586"><span id="local-6989586621679428599"><span class="annot"><span class="annottext">Bracket l -&gt; Bracket l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Bracket l)
forall l. Ord l =&gt; Bracket l -&gt; Bracket l -&gt; Bool
forall l. Ord l =&gt; Bracket l -&gt; Bracket l -&gt; Ordering
forall l. Ord l =&gt; Bracket l -&gt; Bracket l -&gt; Bracket l
min :: Bracket l -&gt; Bracket l -&gt; Bracket l
$cmin :: forall l. Ord l =&gt; Bracket l -&gt; Bracket l -&gt; Bracket l
max :: Bracket l -&gt; Bracket l -&gt; Bracket l
$cmax :: forall l. Ord l =&gt; Bracket l -&gt; Bracket l -&gt; Bracket l
&gt;= :: Bracket l -&gt; Bracket l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Bracket l -&gt; Bracket l -&gt; Bool
&gt; :: Bracket l -&gt; Bracket l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Bracket l -&gt; Bracket l -&gt; Bool
&lt;= :: Bracket l -&gt; Bracket l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Bracket l -&gt; Bracket l -&gt; Bool
&lt; :: Bracket l -&gt; Bracket l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Bracket l -&gt; Bracket l -&gt; Bool
compare :: Bracket l -&gt; Bracket l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Bracket l -&gt; Bracket l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428554"><span id="local-6989586621679428556"><span id="local-6989586621679428574"><span class="annot"><span class="annottext">Int -&gt; Bracket l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Bracket l -&gt; ShowS
forall l. Show l =&gt; [Bracket l] -&gt; ShowS
forall l. Show l =&gt; Bracket l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Bracket l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Bracket l] -&gt; ShowS
show :: Bracket l -&gt; String
$cshow :: forall l. Show l =&gt; Bracket l -&gt; String
showsPrec :: Int -&gt; Bracket l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Bracket l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679428497"><span id="local-6989586621679428499"><span id="local-6989586621679428501"><span id="local-6989586621679428503"><span id="local-6989586621679428505"><span id="local-6989586621679428507"><span id="local-6989586621679428509"><span id="local-6989586621679428511"><span id="local-6989586621679428513"><span id="local-6989586621679428519"><span id="local-6989586621679428521"><span id="local-6989586621679428523"><span id="local-6989586621679428536"><span id="local-6989586621679428549"><span class="annot"><span class="annottext">Bracket l -&gt; DataType
Bracket l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Bracket l)
forall l. Data l =&gt; Bracket l -&gt; DataType
forall l. Data l =&gt; Bracket l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Bracket l -&gt; Bracket l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Bracket l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Bracket l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bracket l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bracket l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bracket l -&gt; m (Bracket l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bracket l -&gt; m (Bracket l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Bracket l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Bracket l -&gt; c (Bracket l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Bracket l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Bracket l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Bracket l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Bracket l -&gt; c (Bracket l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Bracket l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bracket l -&gt; m (Bracket l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bracket l -&gt; m (Bracket l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bracket l -&gt; m (Bracket l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bracket l -&gt; m (Bracket l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bracket l -&gt; m (Bracket l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Bracket l -&gt; m (Bracket l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Bracket l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Bracket l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Bracket l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Bracket l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bracket l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bracket l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bracket l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Bracket l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Bracket l -&gt; Bracket l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Bracket l -&gt; Bracket l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Bracket l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Bracket l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Bracket l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Bracket l))
dataTypeOf :: Bracket l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Bracket l -&gt; DataType
toConstr :: Bracket l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Bracket l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Bracket l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Bracket l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Bracket l -&gt; c (Bracket l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Bracket l -&gt; c (Bracket l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428439"><span id="local-6989586621679428441"><span id="local-6989586621679428443"><span id="local-6989586621679428445"><span id="local-6989586621679428447"><span id="local-6989586621679428449"><span id="local-6989586621679428451"><span id="local-6989586621679428453"><span id="local-6989586621679428455"><span id="local-6989586621679428457"><span id="local-6989586621679428459"><span id="local-6989586621679428461"><span id="local-6989586621679428463"><span id="local-6989586621679428471"><span id="local-6989586621679428473"><span id="local-6989586621679428493"><span id="local-6989586621679428495"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Bracket a -&gt; Bool
forall a. Num a =&gt; Bracket a -&gt; a
forall a. Ord a =&gt; Bracket a -&gt; a
forall m. Monoid m =&gt; Bracket m -&gt; m
forall a. Bracket a -&gt; Bool
forall a. Bracket a -&gt; Int
forall a. Bracket a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Bracket a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Bracket a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Bracket a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Bracket a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Bracket a -&gt; a
$cproduct :: forall a. Num a =&gt; Bracket a -&gt; a
sum :: forall a. Num a =&gt; Bracket a -&gt; a
$csum :: forall a. Num a =&gt; Bracket a -&gt; a
minimum :: forall a. Ord a =&gt; Bracket a -&gt; a
$cminimum :: forall a. Ord a =&gt; Bracket a -&gt; a
maximum :: forall a. Ord a =&gt; Bracket a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Bracket a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Bracket a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Bracket a -&gt; Bool
length :: forall a. Bracket a -&gt; Int
$clength :: forall a. Bracket a -&gt; Int
null :: forall a. Bracket a -&gt; Bool
$cnull :: forall a. Bracket a -&gt; Bool
toList :: forall a. Bracket a -&gt; [a]
$ctoList :: forall a. Bracket a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Bracket a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Bracket a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Bracket a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Bracket a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Bracket a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Bracket a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Bracket a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Bracket a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Bracket a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Bracket a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Bracket a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Bracket a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Bracket a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Bracket a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Bracket a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Bracket a -&gt; m
fold :: forall m. Monoid m =&gt; Bracket m -&gt; m
$cfold :: forall m. Monoid m =&gt; Bracket m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428409"><span id="local-6989586621679428411"><span id="local-6989586621679428413"><span id="local-6989586621679428433"><span class="annot"><span class="annottext">Functor Bracket
Foldable Bracket
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Bracket (m a) -&gt; m (Bracket a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Bracket (f a) -&gt; f (Bracket a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Bracket a -&gt; m (Bracket b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Bracket a -&gt; f (Bracket b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Bracket (m a) -&gt; m (Bracket a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Bracket (m a) -&gt; m (Bracket a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Bracket a -&gt; m (Bracket b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Bracket a -&gt; m (Bracket b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Bracket (f a) -&gt; f (Bracket a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Bracket (f a) -&gt; f (Bracket a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Bracket a -&gt; f (Bracket b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Bracket a -&gt; f (Bracket b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428399"><span id="local-6989586621679428407"><span class="annot"><span class="annottext">forall a b. a -&gt; Bracket b -&gt; Bracket a
forall a b. (a -&gt; b) -&gt; Bracket a -&gt; Bracket b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Bracket b -&gt; Bracket a
$c&lt;$ :: forall a b. a -&gt; Bracket b -&gt; Bracket a
fmap :: forall a b. (a -&gt; b) -&gt; Bracket a -&gt; Bracket b
$cfmap :: forall a b. (a -&gt; b) -&gt; Bracket a -&gt; Bracket b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Bracket l) x -&gt; Bracket l
forall l x. Bracket l -&gt; Rep (Bracket l) x
$cto :: forall l x. Rep (Bracket l) x -&gt; Bracket l
$cfrom :: forall l x. Bracket l -&gt; Rep (Bracket l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-829"></span><span>
</span><span id="line-830"></span><span class="hs-comment">-- | A template haskell splice expression</span><span>
</span><span id="line-831"></span><span id="local-6989586621679428388"><span id="local-6989586621679428389"></span></span><span class="hs-keyword">data</span><span> </span><span id="Splice"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Splice"><span class="hs-identifier hs-var">Splice</span></a></span></span><span> </span><span id="local-6989586621679452594"><span class="annot"><a href="#local-6989586621679452594"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-832"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="IdSplice"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IdSplice"><span class="hs-identifier hs-var">IdSplice</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452594"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>           </span><span class="hs-comment">-- ^ variable splice: @$var@</span><span>
</span><span id="line-833"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="TIdSplice"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TIdSplice"><span class="hs-identifier hs-var">TIdSplice</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452594"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>          </span><span class="hs-comment">-- ^ typed variable splice: @$$var@</span><span>
</span><span id="line-834"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ParenSplice"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParenSplice"><span class="hs-identifier hs-var">ParenSplice</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452594"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452594"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- ^ parenthesised expression splice: @$(/exp/)@</span><span>
</span><span id="line-835"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="TParenSplice"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TParenSplice"><span class="hs-identifier hs-var">TParenSplice</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452594"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452594"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- ^ parenthesised typed expression splice: @$$(/exp/)@</span><span>
</span><span id="line-836"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679428371"><span id="local-6989586621679428382"><span class="annot"><span class="annottext">Splice l -&gt; Splice l -&gt; Bool
forall l. Eq l =&gt; Splice l -&gt; Splice l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Splice l -&gt; Splice l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Splice l -&gt; Splice l -&gt; Bool
== :: Splice l -&gt; Splice l -&gt; Bool
$c== :: forall l. Eq l =&gt; Splice l -&gt; Splice l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428346"><span id="local-6989586621679428348"><span id="local-6989586621679428350"><span id="local-6989586621679428352"><span id="local-6989586621679428354"><span id="local-6989586621679428356"><span id="local-6989586621679428367"><span class="annot"><span class="annottext">Splice l -&gt; Splice l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Splice l)
forall l. Ord l =&gt; Splice l -&gt; Splice l -&gt; Bool
forall l. Ord l =&gt; Splice l -&gt; Splice l -&gt; Ordering
forall l. Ord l =&gt; Splice l -&gt; Splice l -&gt; Splice l
min :: Splice l -&gt; Splice l -&gt; Splice l
$cmin :: forall l. Ord l =&gt; Splice l -&gt; Splice l -&gt; Splice l
max :: Splice l -&gt; Splice l -&gt; Splice l
$cmax :: forall l. Ord l =&gt; Splice l -&gt; Splice l -&gt; Splice l
&gt;= :: Splice l -&gt; Splice l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Splice l -&gt; Splice l -&gt; Bool
&gt; :: Splice l -&gt; Splice l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Splice l -&gt; Splice l -&gt; Bool
&lt;= :: Splice l -&gt; Splice l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Splice l -&gt; Splice l -&gt; Bool
&lt; :: Splice l -&gt; Splice l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Splice l -&gt; Splice l -&gt; Bool
compare :: Splice l -&gt; Splice l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Splice l -&gt; Splice l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428327"><span id="local-6989586621679428329"><span id="local-6989586621679428344"><span class="annot"><span class="annottext">Int -&gt; Splice l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Splice l -&gt; ShowS
forall l. Show l =&gt; [Splice l] -&gt; ShowS
forall l. Show l =&gt; Splice l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Splice l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Splice l] -&gt; ShowS
show :: Splice l -&gt; String
$cshow :: forall l. Show l =&gt; Splice l -&gt; String
showsPrec :: Int -&gt; Splice l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Splice l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679428274"><span id="local-6989586621679428276"><span id="local-6989586621679428278"><span id="local-6989586621679428280"><span id="local-6989586621679428282"><span id="local-6989586621679428284"><span id="local-6989586621679428286"><span id="local-6989586621679428288"><span id="local-6989586621679428290"><span id="local-6989586621679428296"><span id="local-6989586621679428298"><span id="local-6989586621679428300"><span id="local-6989586621679428311"><span id="local-6989586621679428322"><span class="annot"><span class="annottext">Splice l -&gt; DataType
Splice l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Splice l)
forall l. Data l =&gt; Splice l -&gt; DataType
forall l. Data l =&gt; Splice l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Splice l -&gt; Splice l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Splice l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Splice l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Splice l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Splice l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Splice l -&gt; m (Splice l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Splice l -&gt; m (Splice l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Splice l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Splice l -&gt; c (Splice l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Splice l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Splice l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Splice l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Splice l -&gt; c (Splice l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Splice l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Splice l -&gt; m (Splice l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Splice l -&gt; m (Splice l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Splice l -&gt; m (Splice l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Splice l -&gt; m (Splice l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Splice l -&gt; m (Splice l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Splice l -&gt; m (Splice l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Splice l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Splice l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Splice l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Splice l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Splice l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Splice l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Splice l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Splice l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Splice l -&gt; Splice l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Splice l -&gt; Splice l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Splice l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Splice l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Splice l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Splice l))
dataTypeOf :: Splice l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Splice l -&gt; DataType
toConstr :: Splice l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Splice l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Splice l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Splice l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Splice l -&gt; c (Splice l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Splice l -&gt; c (Splice l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428231"><span id="local-6989586621679428233"><span id="local-6989586621679428235"><span id="local-6989586621679428237"><span id="local-6989586621679428239"><span id="local-6989586621679428241"><span id="local-6989586621679428243"><span id="local-6989586621679428245"><span id="local-6989586621679428247"><span id="local-6989586621679428249"><span id="local-6989586621679428251"><span id="local-6989586621679428253"><span id="local-6989586621679428255"><span id="local-6989586621679428259"><span id="local-6989586621679428261"><span id="local-6989586621679428270"><span id="local-6989586621679428272"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Splice a -&gt; Bool
forall a. Num a =&gt; Splice a -&gt; a
forall a. Ord a =&gt; Splice a -&gt; a
forall m. Monoid m =&gt; Splice m -&gt; m
forall a. Splice a -&gt; Bool
forall a. Splice a -&gt; Int
forall a. Splice a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Splice a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Splice a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Splice a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Splice a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Splice a -&gt; a
$cproduct :: forall a. Num a =&gt; Splice a -&gt; a
sum :: forall a. Num a =&gt; Splice a -&gt; a
$csum :: forall a. Num a =&gt; Splice a -&gt; a
minimum :: forall a. Ord a =&gt; Splice a -&gt; a
$cminimum :: forall a. Ord a =&gt; Splice a -&gt; a
maximum :: forall a. Ord a =&gt; Splice a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Splice a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Splice a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Splice a -&gt; Bool
length :: forall a. Splice a -&gt; Int
$clength :: forall a. Splice a -&gt; Int
null :: forall a. Splice a -&gt; Bool
$cnull :: forall a. Splice a -&gt; Bool
toList :: forall a. Splice a -&gt; [a]
$ctoList :: forall a. Splice a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Splice a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Splice a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Splice a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Splice a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Splice a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Splice a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Splice a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Splice a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Splice a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Splice a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Splice a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Splice a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Splice a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Splice a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Splice a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Splice a -&gt; m
fold :: forall m. Monoid m =&gt; Splice m -&gt; m
$cfold :: forall m. Monoid m =&gt; Splice m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428209"><span id="local-6989586621679428211"><span id="local-6989586621679428213"><span id="local-6989586621679428225"><span class="annot"><span class="annottext">Functor Splice
Foldable Splice
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Splice (m a) -&gt; m (Splice a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Splice (f a) -&gt; f (Splice a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Splice a -&gt; m (Splice b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Splice a -&gt; f (Splice b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Splice (m a) -&gt; m (Splice a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Splice (m a) -&gt; m (Splice a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Splice a -&gt; m (Splice b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Splice a -&gt; m (Splice b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Splice (f a) -&gt; f (Splice a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Splice (f a) -&gt; f (Splice a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Splice a -&gt; f (Splice b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Splice a -&gt; f (Splice b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428203"><span id="local-6989586621679428207"><span class="annot"><span class="annottext">forall a b. a -&gt; Splice b -&gt; Splice a
forall a b. (a -&gt; b) -&gt; Splice a -&gt; Splice b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Splice b -&gt; Splice a
$c&lt;$ :: forall a b. a -&gt; Splice b -&gt; Splice a
fmap :: forall a b. (a -&gt; b) -&gt; Splice a -&gt; Splice b
$cfmap :: forall a b. (a -&gt; b) -&gt; Splice a -&gt; Splice b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Splice l) x -&gt; Splice l
forall l x. Splice l -&gt; Rep (Splice l) x
$cto :: forall l x. Rep (Splice l) x -&gt; Splice l
$cfrom :: forall l x. Splice l -&gt; Rep (Splice l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-837"></span><span>
</span><span id="line-838"></span><span class="hs-comment">-- | The safety of a foreign function call.</span><span>
</span><span id="line-839"></span><span id="local-6989586621679428196"><span id="local-6989586621679428197"></span></span><span class="hs-keyword">data</span><span> </span><span id="Safety"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Safety"><span class="hs-identifier hs-var">Safety</span></a></span></span><span> </span><span id="local-6989586621679452723"><span class="annot"><a href="#local-6989586621679452723"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-840"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="PlayRisky"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PlayRisky"><span class="hs-identifier hs-var">PlayRisky</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452723"><span class="hs-identifier hs-type">l</span></a></span><span>         </span><span class="hs-comment">-- ^ unsafe</span><span>
</span><span id="line-841"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PlaySafe"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PlaySafe"><span class="hs-identifier hs-var">PlaySafe</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452723"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>     </span><span class="hs-comment">-- ^ safe ('False') or threadsafe ('True')</span><span>
</span><span id="line-842"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PlayInterruptible"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PlayInterruptible"><span class="hs-identifier hs-var">PlayInterruptible</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452723"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-comment">-- ^ interruptible</span><span>
</span><span id="line-843"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679428185"><span id="local-6989586621679428191"><span class="annot"><span class="annottext">Safety l -&gt; Safety l -&gt; Bool
forall l. Eq l =&gt; Safety l -&gt; Safety l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Safety l -&gt; Safety l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Safety l -&gt; Safety l -&gt; Bool
== :: Safety l -&gt; Safety l -&gt; Bool
$c== :: forall l. Eq l =&gt; Safety l -&gt; Safety l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428158"><span id="local-6989586621679428160"><span id="local-6989586621679428163"><span id="local-6989586621679428166"><span id="local-6989586621679428169"><span id="local-6989586621679428175"><span id="local-6989586621679428181"><span class="annot"><span class="annottext">Safety l -&gt; Safety l -&gt; Bool
Safety l -&gt; Safety l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Safety l)
forall l. Ord l =&gt; Safety l -&gt; Safety l -&gt; Bool
forall l. Ord l =&gt; Safety l -&gt; Safety l -&gt; Ordering
forall l. Ord l =&gt; Safety l -&gt; Safety l -&gt; Safety l
min :: Safety l -&gt; Safety l -&gt; Safety l
$cmin :: forall l. Ord l =&gt; Safety l -&gt; Safety l -&gt; Safety l
max :: Safety l -&gt; Safety l -&gt; Safety l
$cmax :: forall l. Ord l =&gt; Safety l -&gt; Safety l -&gt; Safety l
&gt;= :: Safety l -&gt; Safety l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Safety l -&gt; Safety l -&gt; Bool
&gt; :: Safety l -&gt; Safety l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Safety l -&gt; Safety l -&gt; Bool
&lt;= :: Safety l -&gt; Safety l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Safety l -&gt; Safety l -&gt; Bool
&lt; :: Safety l -&gt; Safety l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Safety l -&gt; Safety l -&gt; Bool
compare :: Safety l -&gt; Safety l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Safety l -&gt; Safety l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428145"><span id="local-6989586621679428147"><span id="local-6989586621679428156"><span class="annot"><span class="annottext">Int -&gt; Safety l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Safety l -&gt; ShowS
forall l. Show l =&gt; [Safety l] -&gt; ShowS
forall l. Show l =&gt; Safety l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Safety l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Safety l] -&gt; ShowS
show :: Safety l -&gt; String
$cshow :: forall l. Show l =&gt; Safety l -&gt; String
showsPrec :: Int -&gt; Safety l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Safety l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679428102"><span id="local-6989586621679428104"><span id="local-6989586621679428106"><span id="local-6989586621679428108"><span id="local-6989586621679428110"><span id="local-6989586621679428112"><span id="local-6989586621679428114"><span id="local-6989586621679428116"><span id="local-6989586621679428118"><span id="local-6989586621679428124"><span id="local-6989586621679428126"><span id="local-6989586621679428128"><span id="local-6989586621679428134"><span id="local-6989586621679428140"><span class="annot"><span class="annottext">Safety l -&gt; DataType
Safety l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Safety l)
forall l. Data l =&gt; Safety l -&gt; DataType
forall l. Data l =&gt; Safety l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Safety l -&gt; Safety l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Safety l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Safety l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety l -&gt; m (Safety l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety l -&gt; m (Safety l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Safety l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Safety l -&gt; c (Safety l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Safety l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Safety l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Safety l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Safety l -&gt; c (Safety l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Safety l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety l -&gt; m (Safety l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety l -&gt; m (Safety l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety l -&gt; m (Safety l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety l -&gt; m (Safety l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety l -&gt; m (Safety l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Safety l -&gt; m (Safety l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Safety l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Safety l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Safety l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Safety l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Safety l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Safety l -&gt; Safety l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Safety l -&gt; Safety l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Safety l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Safety l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Safety l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Safety l))
dataTypeOf :: Safety l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Safety l -&gt; DataType
toConstr :: Safety l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Safety l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Safety l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Safety l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Safety l -&gt; c (Safety l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Safety l -&gt; c (Safety l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428067"><span id="local-6989586621679428069"><span id="local-6989586621679428071"><span id="local-6989586621679428073"><span id="local-6989586621679428075"><span id="local-6989586621679428077"><span id="local-6989586621679428079"><span id="local-6989586621679428081"><span id="local-6989586621679428083"><span id="local-6989586621679428085"><span id="local-6989586621679428087"><span id="local-6989586621679428089"><span id="local-6989586621679428091"><span id="local-6989586621679428093"><span id="local-6989586621679428095"><span id="local-6989586621679428098"><span id="local-6989586621679428100"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Safety a -&gt; Bool
forall a. Num a =&gt; Safety a -&gt; a
forall a. Ord a =&gt; Safety a -&gt; a
forall m. Monoid m =&gt; Safety m -&gt; m
forall a. Safety a -&gt; Bool
forall a. Safety a -&gt; Int
forall a. Safety a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Safety a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Safety a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Safety a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Safety a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Safety a -&gt; a
$cproduct :: forall a. Num a =&gt; Safety a -&gt; a
sum :: forall a. Num a =&gt; Safety a -&gt; a
$csum :: forall a. Num a =&gt; Safety a -&gt; a
minimum :: forall a. Ord a =&gt; Safety a -&gt; a
$cminimum :: forall a. Ord a =&gt; Safety a -&gt; a
maximum :: forall a. Ord a =&gt; Safety a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Safety a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Safety a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Safety a -&gt; Bool
length :: forall a. Safety a -&gt; Int
$clength :: forall a. Safety a -&gt; Int
null :: forall a. Safety a -&gt; Bool
$cnull :: forall a. Safety a -&gt; Bool
toList :: forall a. Safety a -&gt; [a]
$ctoList :: forall a. Safety a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Safety a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Safety a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Safety a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Safety a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Safety a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Safety a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Safety a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Safety a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Safety a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Safety a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Safety a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Safety a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Safety a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Safety a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Safety a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Safety a -&gt; m
fold :: forall m. Monoid m =&gt; Safety m -&gt; m
$cfold :: forall m. Monoid m =&gt; Safety m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428050"><span id="local-6989586621679428052"><span id="local-6989586621679428054"><span id="local-6989586621679428061"><span class="annot"><span class="annottext">Functor Safety
Foldable Safety
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Safety (m a) -&gt; m (Safety a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Safety (f a) -&gt; f (Safety a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Safety a -&gt; m (Safety b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Safety a -&gt; f (Safety b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Safety (m a) -&gt; m (Safety a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Safety (m a) -&gt; m (Safety a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Safety a -&gt; m (Safety b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Safety a -&gt; m (Safety b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Safety (f a) -&gt; f (Safety a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Safety (f a) -&gt; f (Safety a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Safety a -&gt; f (Safety b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Safety a -&gt; f (Safety b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679428046"><span id="local-6989586621679428048"><span class="annot"><span class="annottext">forall a b. a -&gt; Safety b -&gt; Safety a
forall a b. (a -&gt; b) -&gt; Safety a -&gt; Safety b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Safety b -&gt; Safety a
$c&lt;$ :: forall a b. a -&gt; Safety b -&gt; Safety a
fmap :: forall a b. (a -&gt; b) -&gt; Safety a -&gt; Safety b
$cfmap :: forall a b. (a -&gt; b) -&gt; Safety a -&gt; Safety b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Safety l) x -&gt; Safety l
forall l x. Safety l -&gt; Rep (Safety l) x
$cto :: forall l x. Rep (Safety l) x -&gt; Safety l
$cfrom :: forall l x. Safety l -&gt; Rep (Safety l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-844"></span><span>
</span><span id="line-845"></span><span class="hs-comment">-- | The calling convention of a foreign function call.</span><span>
</span><span id="line-846"></span><span id="local-6989586621679428041"><span id="local-6989586621679428042"></span></span><span class="hs-keyword">data</span><span> </span><span id="CallConv"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CallConv"><span class="hs-identifier hs-var">CallConv</span></a></span></span><span> </span><span id="local-6989586621679452724"><span class="annot"><a href="#local-6989586621679452724"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-847"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="StdCall"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#StdCall"><span class="hs-identifier hs-var">StdCall</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452724"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-848"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="CCall"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CCall"><span class="hs-identifier hs-var">CCall</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452724"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-849"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="CPlusPlus"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CPlusPlus"><span class="hs-identifier hs-var">CPlusPlus</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452724"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-850"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="DotNet"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DotNet"><span class="hs-identifier hs-var">DotNet</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452724"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-851"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Jvm"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Jvm"><span class="hs-identifier hs-var">Jvm</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452724"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-852"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Js"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Js"><span class="hs-identifier hs-var">Js</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452724"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-853"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="JavaScript"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#JavaScript"><span class="hs-identifier hs-var">JavaScript</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452724"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-854"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="CApi"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CApi"><span class="hs-identifier hs-var">CApi</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452724"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-855"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679428021"><span id="local-6989586621679428031"><span class="annot"><span class="annottext">CallConv l -&gt; CallConv l -&gt; Bool
forall l. Eq l =&gt; CallConv l -&gt; CallConv l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: CallConv l -&gt; CallConv l -&gt; Bool
$c/= :: forall l. Eq l =&gt; CallConv l -&gt; CallConv l -&gt; Bool
== :: CallConv l -&gt; CallConv l -&gt; Bool
$c== :: forall l. Eq l =&gt; CallConv l -&gt; CallConv l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427997"><span id="local-6989586621679427999"><span id="local-6989586621679428001"><span id="local-6989586621679428003"><span id="local-6989586621679428005"><span id="local-6989586621679428007"><span id="local-6989586621679428017"><span class="annot"><span class="annottext">CallConv l -&gt; CallConv l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (CallConv l)
forall l. Ord l =&gt; CallConv l -&gt; CallConv l -&gt; Bool
forall l. Ord l =&gt; CallConv l -&gt; CallConv l -&gt; Ordering
forall l. Ord l =&gt; CallConv l -&gt; CallConv l -&gt; CallConv l
min :: CallConv l -&gt; CallConv l -&gt; CallConv l
$cmin :: forall l. Ord l =&gt; CallConv l -&gt; CallConv l -&gt; CallConv l
max :: CallConv l -&gt; CallConv l -&gt; CallConv l
$cmax :: forall l. Ord l =&gt; CallConv l -&gt; CallConv l -&gt; CallConv l
&gt;= :: CallConv l -&gt; CallConv l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; CallConv l -&gt; CallConv l -&gt; Bool
&gt; :: CallConv l -&gt; CallConv l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; CallConv l -&gt; CallConv l -&gt; Bool
&lt;= :: CallConv l -&gt; CallConv l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; CallConv l -&gt; CallConv l -&gt; Bool
&lt; :: CallConv l -&gt; CallConv l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; CallConv l -&gt; CallConv l -&gt; Bool
compare :: CallConv l -&gt; CallConv l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; CallConv l -&gt; CallConv l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427975"><span id="local-6989586621679427977"><span id="local-6989586621679427995"><span class="annot"><span class="annottext">Int -&gt; CallConv l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; CallConv l -&gt; ShowS
forall l. Show l =&gt; [CallConv l] -&gt; ShowS
forall l. Show l =&gt; CallConv l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [CallConv l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [CallConv l] -&gt; ShowS
show :: CallConv l -&gt; String
$cshow :: forall l. Show l =&gt; CallConv l -&gt; String
showsPrec :: Int -&gt; CallConv l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; CallConv l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679427924"><span id="local-6989586621679427926"><span id="local-6989586621679427928"><span id="local-6989586621679427930"><span id="local-6989586621679427932"><span id="local-6989586621679427934"><span id="local-6989586621679427936"><span id="local-6989586621679427938"><span id="local-6989586621679427940"><span id="local-6989586621679427946"><span id="local-6989586621679427948"><span id="local-6989586621679427950"><span id="local-6989586621679427960"><span id="local-6989586621679427970"><span class="annot"><span class="annottext">CallConv l -&gt; DataType
CallConv l -&gt; Constr
forall {l}. Data l =&gt; Typeable (CallConv l)
forall l. Data l =&gt; CallConv l -&gt; DataType
forall l. Data l =&gt; CallConv l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; CallConv l -&gt; CallConv l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; CallConv l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; CallConv l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CallConv l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CallConv l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CallConv l -&gt; m (CallConv l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CallConv l -&gt; m (CallConv l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (CallConv l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; CallConv l -&gt; c (CallConv l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (CallConv l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (CallConv l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (CallConv l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; CallConv l -&gt; c (CallConv l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (CallConv l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CallConv l -&gt; m (CallConv l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CallConv l -&gt; m (CallConv l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CallConv l -&gt; m (CallConv l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CallConv l -&gt; m (CallConv l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CallConv l -&gt; m (CallConv l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; CallConv l -&gt; m (CallConv l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; CallConv l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; CallConv l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; CallConv l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; CallConv l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CallConv l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CallConv l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CallConv l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; CallConv l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; CallConv l -&gt; CallConv l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; CallConv l -&gt; CallConv l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (CallConv l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (CallConv l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (CallConv l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (CallConv l))
dataTypeOf :: CallConv l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; CallConv l -&gt; DataType
toConstr :: CallConv l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; CallConv l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (CallConv l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (CallConv l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; CallConv l -&gt; c (CallConv l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; CallConv l -&gt; c (CallConv l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427889"><span id="local-6989586621679427891"><span id="local-6989586621679427893"><span id="local-6989586621679427895"><span id="local-6989586621679427897"><span id="local-6989586621679427899"><span id="local-6989586621679427901"><span id="local-6989586621679427903"><span id="local-6989586621679427905"><span id="local-6989586621679427907"><span id="local-6989586621679427909"><span id="local-6989586621679427911"><span id="local-6989586621679427913"><span id="local-6989586621679427915"><span id="local-6989586621679427917"><span id="local-6989586621679427920"><span id="local-6989586621679427922"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; CallConv a -&gt; Bool
forall a. Num a =&gt; CallConv a -&gt; a
forall a. Ord a =&gt; CallConv a -&gt; a
forall m. Monoid m =&gt; CallConv m -&gt; m
forall a. CallConv a -&gt; Bool
forall a. CallConv a -&gt; Int
forall a. CallConv a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; CallConv a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; CallConv a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; CallConv a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; CallConv a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; CallConv a -&gt; a
$cproduct :: forall a. Num a =&gt; CallConv a -&gt; a
sum :: forall a. Num a =&gt; CallConv a -&gt; a
$csum :: forall a. Num a =&gt; CallConv a -&gt; a
minimum :: forall a. Ord a =&gt; CallConv a -&gt; a
$cminimum :: forall a. Ord a =&gt; CallConv a -&gt; a
maximum :: forall a. Ord a =&gt; CallConv a -&gt; a
$cmaximum :: forall a. Ord a =&gt; CallConv a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; CallConv a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; CallConv a -&gt; Bool
length :: forall a. CallConv a -&gt; Int
$clength :: forall a. CallConv a -&gt; Int
null :: forall a. CallConv a -&gt; Bool
$cnull :: forall a. CallConv a -&gt; Bool
toList :: forall a. CallConv a -&gt; [a]
$ctoList :: forall a. CallConv a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; CallConv a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; CallConv a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; CallConv a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; CallConv a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; CallConv a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; CallConv a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; CallConv a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; CallConv a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; CallConv a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; CallConv a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; CallConv a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; CallConv a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; CallConv a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; CallConv a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; CallConv a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; CallConv a -&gt; m
fold :: forall m. Monoid m =&gt; CallConv m -&gt; m
$cfold :: forall m. Monoid m =&gt; CallConv m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427867"><span id="local-6989586621679427869"><span id="local-6989586621679427871"><span id="local-6989586621679427883"><span class="annot"><span class="annottext">Functor CallConv
Foldable CallConv
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; CallConv (m a) -&gt; m (CallConv a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
CallConv (f a) -&gt; f (CallConv a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; CallConv a -&gt; m (CallConv b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; CallConv a -&gt; f (CallConv b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; CallConv (m a) -&gt; m (CallConv a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; CallConv (m a) -&gt; m (CallConv a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; CallConv a -&gt; m (CallConv b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; CallConv a -&gt; m (CallConv b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
CallConv (f a) -&gt; f (CallConv a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
CallConv (f a) -&gt; f (CallConv a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; CallConv a -&gt; f (CallConv b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; CallConv a -&gt; f (CallConv b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427863"><span id="local-6989586621679427865"><span class="annot"><span class="annottext">forall a b. a -&gt; CallConv b -&gt; CallConv a
forall a b. (a -&gt; b) -&gt; CallConv a -&gt; CallConv b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; CallConv b -&gt; CallConv a
$c&lt;$ :: forall a b. a -&gt; CallConv b -&gt; CallConv a
fmap :: forall a b. (a -&gt; b) -&gt; CallConv a -&gt; CallConv b
$cfmap :: forall a b. (a -&gt; b) -&gt; CallConv a -&gt; CallConv b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (CallConv l) x -&gt; CallConv l
forall l x. CallConv l -&gt; Rep (CallConv l) x
$cto :: forall l x. Rep (CallConv l) x -&gt; CallConv l
$cfrom :: forall l x. CallConv l -&gt; Rep (CallConv l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-856"></span><span>
</span><span id="line-857"></span><span class="hs-comment">-- | A top level options pragma, preceding the module header.</span><span>
</span><span id="line-858"></span><span id="local-6989586621679427858"><span id="local-6989586621679427859"></span></span><span class="hs-keyword">data</span><span> </span><span id="ModulePragma"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModulePragma"><span class="hs-identifier hs-var">ModulePragma</span></a></span></span><span> </span><span id="local-6989586621679452814"><span class="annot"><a href="#local-6989586621679452814"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-859"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="LanguagePragma"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LanguagePragma"><span class="hs-identifier hs-var">LanguagePragma</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452814"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452814"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- ^ LANGUAGE pragma</span><span>
</span><span id="line-860"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="OptionsPragma"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#OptionsPragma"><span class="hs-identifier hs-var">OptionsPragma</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452814"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Tool"><span class="hs-identifier hs-type">Tool</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-861"></span><span>                        </span><span class="hs-comment">-- ^ OPTIONS pragma, possibly qualified with a tool, e.g. OPTIONS_GHC</span><span>
</span><span id="line-862"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="AnnModulePragma"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AnnModulePragma"><span class="hs-identifier hs-var">AnnModulePragma</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452814"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotation"><span class="hs-identifier hs-type">Annotation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452814"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-863"></span><span>                        </span><span class="hs-comment">-- ^ ANN pragma with module scope</span><span>
</span><span id="line-864"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679427841"><span id="local-6989586621679427853"><span class="annot"><span class="annottext">ModulePragma l -&gt; ModulePragma l -&gt; Bool
forall l. Eq l =&gt; ModulePragma l -&gt; ModulePragma l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ModulePragma l -&gt; ModulePragma l -&gt; Bool
$c/= :: forall l. Eq l =&gt; ModulePragma l -&gt; ModulePragma l -&gt; Bool
== :: ModulePragma l -&gt; ModulePragma l -&gt; Bool
$c== :: forall l. Eq l =&gt; ModulePragma l -&gt; ModulePragma l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427802"><span id="local-6989586621679427804"><span id="local-6989586621679427807"><span id="local-6989586621679427810"><span id="local-6989586621679427813"><span id="local-6989586621679427825"><span id="local-6989586621679427837"><span class="annot"><span class="annottext">ModulePragma l -&gt; ModulePragma l -&gt; Bool
ModulePragma l -&gt; ModulePragma l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (ModulePragma l)
forall l. Ord l =&gt; ModulePragma l -&gt; ModulePragma l -&gt; Bool
forall l. Ord l =&gt; ModulePragma l -&gt; ModulePragma l -&gt; Ordering
forall l.
Ord l =&gt;
ModulePragma l -&gt; ModulePragma l -&gt; ModulePragma l
min :: ModulePragma l -&gt; ModulePragma l -&gt; ModulePragma l
$cmin :: forall l.
Ord l =&gt;
ModulePragma l -&gt; ModulePragma l -&gt; ModulePragma l
max :: ModulePragma l -&gt; ModulePragma l -&gt; ModulePragma l
$cmax :: forall l.
Ord l =&gt;
ModulePragma l -&gt; ModulePragma l -&gt; ModulePragma l
&gt;= :: ModulePragma l -&gt; ModulePragma l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; ModulePragma l -&gt; ModulePragma l -&gt; Bool
&gt; :: ModulePragma l -&gt; ModulePragma l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; ModulePragma l -&gt; ModulePragma l -&gt; Bool
&lt;= :: ModulePragma l -&gt; ModulePragma l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; ModulePragma l -&gt; ModulePragma l -&gt; Bool
&lt; :: ModulePragma l -&gt; ModulePragma l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; ModulePragma l -&gt; ModulePragma l -&gt; Bool
compare :: ModulePragma l -&gt; ModulePragma l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; ModulePragma l -&gt; ModulePragma l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427783"><span id="local-6989586621679427785"><span id="local-6989586621679427800"><span class="annot"><span class="annottext">Int -&gt; ModulePragma l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; ModulePragma l -&gt; ShowS
forall l. Show l =&gt; [ModulePragma l] -&gt; ShowS
forall l. Show l =&gt; ModulePragma l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ModulePragma l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [ModulePragma l] -&gt; ShowS
show :: ModulePragma l -&gt; String
$cshow :: forall l. Show l =&gt; ModulePragma l -&gt; String
showsPrec :: Int -&gt; ModulePragma l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; ModulePragma l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679427728"><span id="local-6989586621679427730"><span id="local-6989586621679427732"><span id="local-6989586621679427734"><span id="local-6989586621679427736"><span id="local-6989586621679427738"><span id="local-6989586621679427740"><span id="local-6989586621679427742"><span id="local-6989586621679427744"><span id="local-6989586621679427750"><span id="local-6989586621679427752"><span id="local-6989586621679427754"><span id="local-6989586621679427766"><span id="local-6989586621679427778"><span class="annot"><span class="annottext">ModulePragma l -&gt; DataType
ModulePragma l -&gt; Constr
forall {l}. Data l =&gt; Typeable (ModulePragma l)
forall l. Data l =&gt; ModulePragma l -&gt; DataType
forall l. Data l =&gt; ModulePragma l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ModulePragma l -&gt; ModulePragma l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModulePragma l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ModulePragma l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModulePragma l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModulePragma l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ModulePragma l -&gt; m (ModulePragma l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ModulePragma l -&gt; m (ModulePragma l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModulePragma l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModulePragma l -&gt; c (ModulePragma l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModulePragma l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ModulePragma l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModulePragma l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModulePragma l -&gt; c (ModulePragma l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModulePragma l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ModulePragma l -&gt; m (ModulePragma l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ModulePragma l -&gt; m (ModulePragma l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ModulePragma l -&gt; m (ModulePragma l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ModulePragma l -&gt; m (ModulePragma l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ModulePragma l -&gt; m (ModulePragma l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ModulePragma l -&gt; m (ModulePragma l)
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModulePragma l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ModulePragma l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ModulePragma l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; ModulePragma l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModulePragma l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModulePragma l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModulePragma l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ModulePragma l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ModulePragma l -&gt; ModulePragma l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; ModulePragma l -&gt; ModulePragma l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ModulePragma l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (ModulePragma l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModulePragma l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (ModulePragma l))
dataTypeOf :: ModulePragma l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; ModulePragma l -&gt; DataType
toConstr :: ModulePragma l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; ModulePragma l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModulePragma l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (ModulePragma l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModulePragma l -&gt; c (ModulePragma l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ModulePragma l -&gt; c (ModulePragma l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427682"><span id="local-6989586621679427684"><span id="local-6989586621679427686"><span id="local-6989586621679427688"><span id="local-6989586621679427690"><span id="local-6989586621679427692"><span id="local-6989586621679427694"><span id="local-6989586621679427696"><span id="local-6989586621679427698"><span id="local-6989586621679427700"><span id="local-6989586621679427702"><span id="local-6989586621679427704"><span id="local-6989586621679427706"><span id="local-6989586621679427711"><span id="local-6989586621679427713"><span id="local-6989586621679427724"><span id="local-6989586621679427726"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; ModulePragma a -&gt; Bool
forall a. Num a =&gt; ModulePragma a -&gt; a
forall a. Ord a =&gt; ModulePragma a -&gt; a
forall m. Monoid m =&gt; ModulePragma m -&gt; m
forall a. ModulePragma a -&gt; Bool
forall a. ModulePragma a -&gt; Int
forall a. ModulePragma a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; ModulePragma a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModulePragma a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModulePragma a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModulePragma a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; ModulePragma a -&gt; a
$cproduct :: forall a. Num a =&gt; ModulePragma a -&gt; a
sum :: forall a. Num a =&gt; ModulePragma a -&gt; a
$csum :: forall a. Num a =&gt; ModulePragma a -&gt; a
minimum :: forall a. Ord a =&gt; ModulePragma a -&gt; a
$cminimum :: forall a. Ord a =&gt; ModulePragma a -&gt; a
maximum :: forall a. Ord a =&gt; ModulePragma a -&gt; a
$cmaximum :: forall a. Ord a =&gt; ModulePragma a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; ModulePragma a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; ModulePragma a -&gt; Bool
length :: forall a. ModulePragma a -&gt; Int
$clength :: forall a. ModulePragma a -&gt; Int
null :: forall a. ModulePragma a -&gt; Bool
$cnull :: forall a. ModulePragma a -&gt; Bool
toList :: forall a. ModulePragma a -&gt; [a]
$ctoList :: forall a. ModulePragma a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModulePragma a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModulePragma a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModulePragma a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; ModulePragma a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModulePragma a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModulePragma a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModulePragma a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; ModulePragma a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModulePragma a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModulePragma a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModulePragma a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; ModulePragma a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModulePragma a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModulePragma a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModulePragma a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; ModulePragma a -&gt; m
fold :: forall m. Monoid m =&gt; ModulePragma m -&gt; m
$cfold :: forall m. Monoid m =&gt; ModulePragma m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427659"><span id="local-6989586621679427661"><span id="local-6989586621679427663"><span id="local-6989586621679427676"><span class="annot"><span class="annottext">Functor ModulePragma
Foldable ModulePragma
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
ModulePragma (m a) -&gt; m (ModulePragma a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
ModulePragma (f a) -&gt; f (ModulePragma a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ModulePragma a -&gt; m (ModulePragma b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ModulePragma a -&gt; f (ModulePragma b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ModulePragma (m a) -&gt; m (ModulePragma a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
ModulePragma (m a) -&gt; m (ModulePragma a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ModulePragma a -&gt; m (ModulePragma b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ModulePragma a -&gt; m (ModulePragma b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ModulePragma (f a) -&gt; f (ModulePragma a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
ModulePragma (f a) -&gt; f (ModulePragma a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ModulePragma a -&gt; f (ModulePragma b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ModulePragma a -&gt; f (ModulePragma b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427652"><span id="local-6989586621679427657"><span class="annot"><span class="annottext">forall a b. a -&gt; ModulePragma b -&gt; ModulePragma a
forall a b. (a -&gt; b) -&gt; ModulePragma a -&gt; ModulePragma b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; ModulePragma b -&gt; ModulePragma a
$c&lt;$ :: forall a b. a -&gt; ModulePragma b -&gt; ModulePragma a
fmap :: forall a b. (a -&gt; b) -&gt; ModulePragma a -&gt; ModulePragma b
$cfmap :: forall a b. (a -&gt; b) -&gt; ModulePragma a -&gt; ModulePragma b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (ModulePragma l) x -&gt; ModulePragma l
forall l x. ModulePragma l -&gt; Rep (ModulePragma l) x
$cto :: forall l x. Rep (ModulePragma l) x -&gt; ModulePragma l
$cfrom :: forall l x. ModulePragma l -&gt; Rep (ModulePragma l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-865"></span><span>
</span><span id="line-866"></span><span class="hs-comment">-- | Recognised tools for OPTIONS pragmas.</span><span>
</span><span id="line-867"></span><span id="local-6989586621679427644"><span id="local-6989586621679427645"></span></span><span class="hs-keyword">data</span><span> </span><span id="Tool"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Tool"><span class="hs-identifier hs-var">Tool</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="GHC"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GHC"><span class="hs-identifier hs-var">GHC</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="HUGS"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#HUGS"><span class="hs-identifier hs-var">HUGS</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="NHC98"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NHC98"><span class="hs-identifier hs-var">NHC98</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="YHC"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#YHC"><span class="hs-identifier hs-var">YHC</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="HADDOCK"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#HADDOCK"><span class="hs-identifier hs-var">HADDOCK</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="UnknownTool"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnknownTool"><span class="hs-identifier hs-var">UnknownTool</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-868"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679427632"><span id="local-6989586621679427636"><span class="annot"><span class="annottext">Tool -&gt; Tool -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Tool -&gt; Tool -&gt; Bool
$c/= :: Tool -&gt; Tool -&gt; Bool
== :: Tool -&gt; Tool -&gt; Bool
$c== :: Tool -&gt; Tool -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427614"><span id="local-6989586621679427616"><span id="local-6989586621679427618"><span id="local-6989586621679427620"><span id="local-6989586621679427622"><span id="local-6989586621679427624"><span id="local-6989586621679427628"><span class="annot"><span class="annottext">Eq Tool
Tool -&gt; Tool -&gt; Bool
Tool -&gt; Tool -&gt; Ordering
Tool -&gt; Tool -&gt; Tool
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
min :: Tool -&gt; Tool -&gt; Tool
$cmin :: Tool -&gt; Tool -&gt; Tool
max :: Tool -&gt; Tool -&gt; Tool
$cmax :: Tool -&gt; Tool -&gt; Tool
&gt;= :: Tool -&gt; Tool -&gt; Bool
$c&gt;= :: Tool -&gt; Tool -&gt; Bool
&gt; :: Tool -&gt; Tool -&gt; Bool
$c&gt; :: Tool -&gt; Tool -&gt; Bool
&lt;= :: Tool -&gt; Tool -&gt; Bool
$c&lt;= :: Tool -&gt; Tool -&gt; Bool
&lt; :: Tool -&gt; Tool -&gt; Bool
$c&lt; :: Tool -&gt; Tool -&gt; Bool
compare :: Tool -&gt; Tool -&gt; Ordering
$ccompare :: Tool -&gt; Tool -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427605"><span id="local-6989586621679427607"><span id="local-6989586621679427612"><span class="annot"><span class="annottext">Int -&gt; Tool -&gt; ShowS
[Tool] -&gt; ShowS
Tool -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Tool] -&gt; ShowS
$cshowList :: [Tool] -&gt; ShowS
show :: Tool -&gt; String
$cshow :: Tool -&gt; String
showsPrec :: Int -&gt; Tool -&gt; ShowS
$cshowsPrec :: Int -&gt; Tool -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679427571"><span id="local-6989586621679427573"><span id="local-6989586621679427575"><span id="local-6989586621679427577"><span id="local-6989586621679427579"><span id="local-6989586621679427581"><span id="local-6989586621679427583"><span id="local-6989586621679427585"><span id="local-6989586621679427587"><span id="local-6989586621679427589"><span id="local-6989586621679427591"><span id="local-6989586621679427593"><span id="local-6989586621679427597"><span id="local-6989586621679427601"><span class="annot"><span class="annottext">Typeable Tool
Tool -&gt; DataType
Tool -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Tool -&gt; Tool
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Tool -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Tool -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Tool -&gt; r
forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Tool -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Tool -&gt; m Tool
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Tool -&gt; m Tool
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Tool
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Tool -&gt; c Tool
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Tool)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Tool)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Tool -&gt; m Tool
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Tool -&gt; m Tool
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Tool -&gt; m Tool
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Tool -&gt; m Tool
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Tool -&gt; m Tool
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Tool -&gt; m Tool
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Tool -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Tool -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Tool -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Tool -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Tool -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Tool -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Tool -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Tool -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Tool -&gt; Tool
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Tool -&gt; Tool
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Tool)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Tool)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Tool)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Tool)
dataTypeOf :: Tool -&gt; DataType
$cdataTypeOf :: Tool -&gt; DataType
toConstr :: Tool -&gt; Constr
$ctoConstr :: Tool -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Tool
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Tool
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Tool -&gt; c Tool
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Tool -&gt; c Tool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall x. Rep Tool x -&gt; Tool
forall x. Tool -&gt; Rep Tool x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep Tool x -&gt; Tool
$cfrom :: forall x. Tool -&gt; Rep Tool x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-869"></span><span>
</span><span id="line-870"></span><span class="hs-comment">-- | Recognised overlaps for overlap pragmas.</span><span>
</span><span id="line-871"></span><span id="local-6989586621679427566"><span id="local-6989586621679427567"></span></span><span class="hs-keyword">data</span><span> </span><span id="Overlap"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlap"><span class="hs-identifier hs-var">Overlap</span></a></span></span><span> </span><span id="local-6989586621679452725"><span class="annot"><a href="#local-6989586621679452725"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-872"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="NoOverlap"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoOverlap"><span class="hs-identifier hs-var">NoOverlap</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452725"><span class="hs-identifier hs-type">l</span></a></span><span>   </span><span class="hs-comment">-- ^ NO_OVERLAP pragma</span><span>
</span><span id="line-873"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Overlap"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlap"><span class="hs-identifier hs-var">Overlap</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452725"><span class="hs-identifier hs-type">l</span></a></span><span>     </span><span class="hs-comment">-- ^ OVERLAP pragma</span><span>
</span><span id="line-874"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Overlapping"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlapping"><span class="hs-identifier hs-var">Overlapping</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452725"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-875"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Overlaps"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlaps"><span class="hs-identifier hs-var">Overlaps</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452725"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-876"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Overlappable"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlappable"><span class="hs-identifier hs-var">Overlappable</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452725"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-877"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Incoherent"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Incoherent"><span class="hs-identifier hs-var">Incoherent</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452725"><span class="hs-identifier hs-type">l</span></a></span><span>  </span><span class="hs-comment">-- ^ INCOHERENT pragma</span><span>
</span><span id="line-878"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679427550"><span id="local-6989586621679427558"><span class="annot"><span class="annottext">Overlap l -&gt; Overlap l -&gt; Bool
forall l. Eq l =&gt; Overlap l -&gt; Overlap l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Overlap l -&gt; Overlap l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Overlap l -&gt; Overlap l -&gt; Bool
== :: Overlap l -&gt; Overlap l -&gt; Bool
$c== :: forall l. Eq l =&gt; Overlap l -&gt; Overlap l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427528"><span id="local-6989586621679427530"><span id="local-6989586621679427532"><span id="local-6989586621679427534"><span id="local-6989586621679427536"><span id="local-6989586621679427538"><span id="local-6989586621679427546"><span class="annot"><span class="annottext">Overlap l -&gt; Overlap l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Overlap l)
forall l. Ord l =&gt; Overlap l -&gt; Overlap l -&gt; Bool
forall l. Ord l =&gt; Overlap l -&gt; Overlap l -&gt; Ordering
forall l. Ord l =&gt; Overlap l -&gt; Overlap l -&gt; Overlap l
min :: Overlap l -&gt; Overlap l -&gt; Overlap l
$cmin :: forall l. Ord l =&gt; Overlap l -&gt; Overlap l -&gt; Overlap l
max :: Overlap l -&gt; Overlap l -&gt; Overlap l
$cmax :: forall l. Ord l =&gt; Overlap l -&gt; Overlap l -&gt; Overlap l
&gt;= :: Overlap l -&gt; Overlap l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Overlap l -&gt; Overlap l -&gt; Bool
&gt; :: Overlap l -&gt; Overlap l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Overlap l -&gt; Overlap l -&gt; Bool
&lt;= :: Overlap l -&gt; Overlap l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Overlap l -&gt; Overlap l -&gt; Bool
&lt; :: Overlap l -&gt; Overlap l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Overlap l -&gt; Overlap l -&gt; Bool
compare :: Overlap l -&gt; Overlap l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Overlap l -&gt; Overlap l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427510"><span id="local-6989586621679427512"><span id="local-6989586621679427526"><span class="annot"><span class="annottext">Int -&gt; Overlap l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Overlap l -&gt; ShowS
forall l. Show l =&gt; [Overlap l] -&gt; ShowS
forall l. Show l =&gt; Overlap l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Overlap l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Overlap l] -&gt; ShowS
show :: Overlap l -&gt; String
$cshow :: forall l. Show l =&gt; Overlap l -&gt; String
showsPrec :: Int -&gt; Overlap l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Overlap l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679427463"><span id="local-6989586621679427465"><span id="local-6989586621679427467"><span id="local-6989586621679427469"><span id="local-6989586621679427471"><span id="local-6989586621679427473"><span id="local-6989586621679427475"><span id="local-6989586621679427477"><span id="local-6989586621679427479"><span id="local-6989586621679427485"><span id="local-6989586621679427487"><span id="local-6989586621679427489"><span id="local-6989586621679427497"><span id="local-6989586621679427505"><span class="annot"><span class="annottext">Overlap l -&gt; DataType
Overlap l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Overlap l)
forall l. Data l =&gt; Overlap l -&gt; DataType
forall l. Data l =&gt; Overlap l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Overlap l -&gt; Overlap l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Overlap l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap l -&gt; m (Overlap l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap l -&gt; m (Overlap l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Overlap l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Overlap l -&gt; c (Overlap l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Overlap l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Overlap l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Overlap l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Overlap l -&gt; c (Overlap l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Overlap l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap l -&gt; m (Overlap l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap l -&gt; m (Overlap l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap l -&gt; m (Overlap l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap l -&gt; m (Overlap l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap l -&gt; m (Overlap l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Overlap l -&gt; m (Overlap l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Overlap l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Overlap l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Overlap l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Overlap l -&gt; Overlap l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Overlap l -&gt; Overlap l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Overlap l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Overlap l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Overlap l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Overlap l))
dataTypeOf :: Overlap l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Overlap l -&gt; DataType
toConstr :: Overlap l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Overlap l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Overlap l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Overlap l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Overlap l -&gt; c (Overlap l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Overlap l -&gt; c (Overlap l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427428"><span id="local-6989586621679427430"><span id="local-6989586621679427432"><span id="local-6989586621679427434"><span id="local-6989586621679427436"><span id="local-6989586621679427438"><span id="local-6989586621679427440"><span id="local-6989586621679427442"><span id="local-6989586621679427444"><span id="local-6989586621679427446"><span id="local-6989586621679427448"><span id="local-6989586621679427450"><span id="local-6989586621679427452"><span id="local-6989586621679427454"><span id="local-6989586621679427456"><span id="local-6989586621679427459"><span id="local-6989586621679427461"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Overlap a -&gt; Bool
forall a. Num a =&gt; Overlap a -&gt; a
forall a. Ord a =&gt; Overlap a -&gt; a
forall m. Monoid m =&gt; Overlap m -&gt; m
forall a. Overlap a -&gt; Bool
forall a. Overlap a -&gt; Int
forall a. Overlap a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Overlap a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Overlap a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Overlap a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Overlap a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Overlap a -&gt; a
$cproduct :: forall a. Num a =&gt; Overlap a -&gt; a
sum :: forall a. Num a =&gt; Overlap a -&gt; a
$csum :: forall a. Num a =&gt; Overlap a -&gt; a
minimum :: forall a. Ord a =&gt; Overlap a -&gt; a
$cminimum :: forall a. Ord a =&gt; Overlap a -&gt; a
maximum :: forall a. Ord a =&gt; Overlap a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Overlap a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Overlap a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Overlap a -&gt; Bool
length :: forall a. Overlap a -&gt; Int
$clength :: forall a. Overlap a -&gt; Int
null :: forall a. Overlap a -&gt; Bool
$cnull :: forall a. Overlap a -&gt; Bool
toList :: forall a. Overlap a -&gt; [a]
$ctoList :: forall a. Overlap a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Overlap a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Overlap a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Overlap a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Overlap a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Overlap a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Overlap a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Overlap a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Overlap a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Overlap a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Overlap a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Overlap a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Overlap a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Overlap a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Overlap a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Overlap a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Overlap a -&gt; m
fold :: forall m. Monoid m =&gt; Overlap m -&gt; m
$cfold :: forall m. Monoid m =&gt; Overlap m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427408"><span id="local-6989586621679427410"><span id="local-6989586621679427412"><span id="local-6989586621679427422"><span class="annot"><span class="annottext">Functor Overlap
Foldable Overlap
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Overlap (m a) -&gt; m (Overlap a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Overlap (f a) -&gt; f (Overlap a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Overlap a -&gt; m (Overlap b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Overlap a -&gt; f (Overlap b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Overlap (m a) -&gt; m (Overlap a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Overlap (m a) -&gt; m (Overlap a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Overlap a -&gt; m (Overlap b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Overlap a -&gt; m (Overlap b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Overlap (f a) -&gt; f (Overlap a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Overlap (f a) -&gt; f (Overlap a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Overlap a -&gt; f (Overlap b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Overlap a -&gt; f (Overlap b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427404"><span id="local-6989586621679427406"><span class="annot"><span class="annottext">forall a b. a -&gt; Overlap b -&gt; Overlap a
forall a b. (a -&gt; b) -&gt; Overlap a -&gt; Overlap b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Overlap b -&gt; Overlap a
$c&lt;$ :: forall a b. a -&gt; Overlap b -&gt; Overlap a
fmap :: forall a b. (a -&gt; b) -&gt; Overlap a -&gt; Overlap b
$cfmap :: forall a b. (a -&gt; b) -&gt; Overlap a -&gt; Overlap b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Overlap l) x -&gt; Overlap l
forall l x. Overlap l -&gt; Rep (Overlap l) x
$cto :: forall l x. Rep (Overlap l) x -&gt; Overlap l
$cfrom :: forall l x. Overlap l -&gt; Rep (Overlap l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-879"></span><span>
</span><span id="line-880"></span><span class="hs-comment">-- | Activation clause of a RULES pragma.</span><span>
</span><span id="line-881"></span><span id="local-6989586621679427399"><span id="local-6989586621679427400"></span></span><span class="hs-keyword">data</span><span> </span><span id="Activation"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Activation"><span class="hs-identifier hs-var">Activation</span></a></span></span><span> </span><span id="local-6989586621679452726"><span class="annot"><a href="#local-6989586621679452726"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-882"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="ActiveFrom"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ActiveFrom"><span class="hs-identifier hs-var">ActiveFrom</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452726"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-883"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ActiveUntil"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ActiveUntil"><span class="hs-identifier hs-var">ActiveUntil</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452726"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-884"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679427389"><span id="local-6989586621679427395"><span class="annot"><span class="annottext">Activation l -&gt; Activation l -&gt; Bool
forall l. Eq l =&gt; Activation l -&gt; Activation l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Activation l -&gt; Activation l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Activation l -&gt; Activation l -&gt; Bool
== :: Activation l -&gt; Activation l -&gt; Bool
$c== :: forall l. Eq l =&gt; Activation l -&gt; Activation l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427362"><span id="local-6989586621679427364"><span id="local-6989586621679427367"><span id="local-6989586621679427370"><span id="local-6989586621679427373"><span id="local-6989586621679427379"><span id="local-6989586621679427385"><span class="annot"><span class="annottext">Activation l -&gt; Activation l -&gt; Bool
Activation l -&gt; Activation l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Activation l)
forall l. Ord l =&gt; Activation l -&gt; Activation l -&gt; Bool
forall l. Ord l =&gt; Activation l -&gt; Activation l -&gt; Ordering
forall l. Ord l =&gt; Activation l -&gt; Activation l -&gt; Activation l
min :: Activation l -&gt; Activation l -&gt; Activation l
$cmin :: forall l. Ord l =&gt; Activation l -&gt; Activation l -&gt; Activation l
max :: Activation l -&gt; Activation l -&gt; Activation l
$cmax :: forall l. Ord l =&gt; Activation l -&gt; Activation l -&gt; Activation l
&gt;= :: Activation l -&gt; Activation l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Activation l -&gt; Activation l -&gt; Bool
&gt; :: Activation l -&gt; Activation l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Activation l -&gt; Activation l -&gt; Bool
&lt;= :: Activation l -&gt; Activation l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Activation l -&gt; Activation l -&gt; Bool
&lt; :: Activation l -&gt; Activation l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Activation l -&gt; Activation l -&gt; Bool
compare :: Activation l -&gt; Activation l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Activation l -&gt; Activation l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427350"><span id="local-6989586621679427352"><span id="local-6989586621679427360"><span class="annot"><span class="annottext">Int -&gt; Activation l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Activation l -&gt; ShowS
forall l. Show l =&gt; [Activation l] -&gt; ShowS
forall l. Show l =&gt; Activation l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Activation l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Activation l] -&gt; ShowS
show :: Activation l -&gt; String
$cshow :: forall l. Show l =&gt; Activation l -&gt; String
showsPrec :: Int -&gt; Activation l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Activation l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679427307"><span id="local-6989586621679427309"><span id="local-6989586621679427311"><span id="local-6989586621679427313"><span id="local-6989586621679427315"><span id="local-6989586621679427317"><span id="local-6989586621679427319"><span id="local-6989586621679427321"><span id="local-6989586621679427323"><span id="local-6989586621679427329"><span id="local-6989586621679427331"><span id="local-6989586621679427333"><span id="local-6989586621679427339"><span id="local-6989586621679427345"><span class="annot"><span class="annottext">Activation l -&gt; DataType
Activation l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Activation l)
forall l. Data l =&gt; Activation l -&gt; DataType
forall l. Data l =&gt; Activation l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Activation l -&gt; Activation l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Activation l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Activation l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Activation l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Activation l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Activation l -&gt; m (Activation l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Activation l -&gt; m (Activation l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Activation l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Activation l -&gt; c (Activation l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Activation l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Activation l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Activation l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Activation l -&gt; c (Activation l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Activation l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Activation l -&gt; m (Activation l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Activation l -&gt; m (Activation l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Activation l -&gt; m (Activation l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Activation l -&gt; m (Activation l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Activation l -&gt; m (Activation l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Activation l -&gt; m (Activation l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Activation l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Activation l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Activation l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; Activation l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Activation l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Activation l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Activation l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Activation l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Activation l -&gt; Activation l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Activation l -&gt; Activation l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Activation l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (Activation l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Activation l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Activation l))
dataTypeOf :: Activation l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Activation l -&gt; DataType
toConstr :: Activation l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Activation l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Activation l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Activation l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Activation l -&gt; c (Activation l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Activation l -&gt; c (Activation l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427272"><span id="local-6989586621679427274"><span id="local-6989586621679427276"><span id="local-6989586621679427278"><span id="local-6989586621679427280"><span id="local-6989586621679427282"><span id="local-6989586621679427284"><span id="local-6989586621679427286"><span id="local-6989586621679427288"><span id="local-6989586621679427290"><span id="local-6989586621679427292"><span id="local-6989586621679427294"><span id="local-6989586621679427296"><span id="local-6989586621679427298"><span id="local-6989586621679427300"><span id="local-6989586621679427303"><span id="local-6989586621679427305"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Activation a -&gt; Bool
forall a. Num a =&gt; Activation a -&gt; a
forall a. Ord a =&gt; Activation a -&gt; a
forall m. Monoid m =&gt; Activation m -&gt; m
forall a. Activation a -&gt; Bool
forall a. Activation a -&gt; Int
forall a. Activation a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Activation a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Activation a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Activation a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Activation a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Activation a -&gt; a
$cproduct :: forall a. Num a =&gt; Activation a -&gt; a
sum :: forall a. Num a =&gt; Activation a -&gt; a
$csum :: forall a. Num a =&gt; Activation a -&gt; a
minimum :: forall a. Ord a =&gt; Activation a -&gt; a
$cminimum :: forall a. Ord a =&gt; Activation a -&gt; a
maximum :: forall a. Ord a =&gt; Activation a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Activation a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Activation a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Activation a -&gt; Bool
length :: forall a. Activation a -&gt; Int
$clength :: forall a. Activation a -&gt; Int
null :: forall a. Activation a -&gt; Bool
$cnull :: forall a. Activation a -&gt; Bool
toList :: forall a. Activation a -&gt; [a]
$ctoList :: forall a. Activation a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Activation a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Activation a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Activation a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Activation a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Activation a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Activation a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Activation a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Activation a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Activation a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Activation a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Activation a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Activation a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Activation a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Activation a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Activation a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Activation a -&gt; m
fold :: forall m. Monoid m =&gt; Activation m -&gt; m
$cfold :: forall m. Monoid m =&gt; Activation m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427256"><span id="local-6989586621679427258"><span id="local-6989586621679427260"><span id="local-6989586621679427266"><span class="annot"><span class="annottext">Functor Activation
Foldable Activation
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
Activation (m a) -&gt; m (Activation a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
Activation (f a) -&gt; f (Activation a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Activation a -&gt; m (Activation b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Activation a -&gt; f (Activation b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
Activation (m a) -&gt; m (Activation a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
Activation (m a) -&gt; m (Activation a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Activation a -&gt; m (Activation b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Activation a -&gt; m (Activation b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Activation (f a) -&gt; f (Activation a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
Activation (f a) -&gt; f (Activation a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Activation a -&gt; f (Activation b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Activation a -&gt; f (Activation b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427252"><span id="local-6989586621679427254"><span class="annot"><span class="annottext">forall a b. a -&gt; Activation b -&gt; Activation a
forall a b. (a -&gt; b) -&gt; Activation a -&gt; Activation b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Activation b -&gt; Activation a
$c&lt;$ :: forall a b. a -&gt; Activation b -&gt; Activation a
fmap :: forall a b. (a -&gt; b) -&gt; Activation a -&gt; Activation b
$cfmap :: forall a b. (a -&gt; b) -&gt; Activation a -&gt; Activation b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Activation l) x -&gt; Activation l
forall l x. Activation l -&gt; Rep (Activation l) x
$cto :: forall l x. Rep (Activation l) x -&gt; Activation l
$cfrom :: forall l x. Activation l -&gt; Rep (Activation l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-885"></span><span>
</span><span id="line-886"></span><span class="hs-comment">-- | The body of a RULES pragma.</span><span>
</span><span id="line-887"></span><span id="local-6989586621679427247"><span id="local-6989586621679427248"></span></span><span class="hs-keyword">data</span><span> </span><span id="Rule"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rule"><span class="hs-identifier hs-var">Rule</span></a></span></span><span> </span><span id="local-6989586621679452742"><span class="annot"><a href="#local-6989586621679452742"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-888"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="Rule"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rule"><span class="hs-identifier hs-var">Rule</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452742"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Activation"><span class="hs-identifier hs-type">Activation</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452742"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RuleVar"><span class="hs-identifier hs-type">RuleVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452742"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452742"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452742"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-889"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679427233"><span id="local-6989586621679427244"><span class="annot"><span class="annottext">Rule l -&gt; Rule l -&gt; Bool
forall l. Eq l =&gt; Rule l -&gt; Rule l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Rule l -&gt; Rule l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Rule l -&gt; Rule l -&gt; Bool
== :: Rule l -&gt; Rule l -&gt; Bool
$c== :: forall l. Eq l =&gt; Rule l -&gt; Rule l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427195"><span id="local-6989586621679427197"><span id="local-6989586621679427200"><span id="local-6989586621679427203"><span id="local-6989586621679427206"><span id="local-6989586621679427217"><span id="local-6989586621679427228"><span class="annot"><span class="annottext">Rule l -&gt; Rule l -&gt; Bool
Rule l -&gt; Rule l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Rule l)
forall l. Ord l =&gt; Rule l -&gt; Rule l -&gt; Bool
forall l. Ord l =&gt; Rule l -&gt; Rule l -&gt; Ordering
forall l. Ord l =&gt; Rule l -&gt; Rule l -&gt; Rule l
min :: Rule l -&gt; Rule l -&gt; Rule l
$cmin :: forall l. Ord l =&gt; Rule l -&gt; Rule l -&gt; Rule l
max :: Rule l -&gt; Rule l -&gt; Rule l
$cmax :: forall l. Ord l =&gt; Rule l -&gt; Rule l -&gt; Rule l
&gt;= :: Rule l -&gt; Rule l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Rule l -&gt; Rule l -&gt; Bool
&gt; :: Rule l -&gt; Rule l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Rule l -&gt; Rule l -&gt; Bool
&lt;= :: Rule l -&gt; Rule l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Rule l -&gt; Rule l -&gt; Bool
&lt; :: Rule l -&gt; Rule l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Rule l -&gt; Rule l -&gt; Bool
compare :: Rule l -&gt; Rule l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Rule l -&gt; Rule l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427177"><span id="local-6989586621679427179"><span id="local-6989586621679427191"><span class="annot"><span class="annottext">Int -&gt; Rule l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Rule l -&gt; ShowS
forall l. Show l =&gt; [Rule l] -&gt; ShowS
forall l. Show l =&gt; Rule l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Rule l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Rule l] -&gt; ShowS
show :: Rule l -&gt; String
$cshow :: forall l. Show l =&gt; Rule l -&gt; String
showsPrec :: Int -&gt; Rule l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Rule l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679427123"><span id="local-6989586621679427125"><span id="local-6989586621679427127"><span id="local-6989586621679427129"><span id="local-6989586621679427131"><span id="local-6989586621679427133"><span id="local-6989586621679427135"><span id="local-6989586621679427137"><span id="local-6989586621679427139"><span id="local-6989586621679427145"><span id="local-6989586621679427147"><span id="local-6989586621679427149"><span id="local-6989586621679427160"><span id="local-6989586621679427171"><span class="annot"><span class="annottext">Rule l -&gt; DataType
Rule l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Rule l)
forall l. Data l =&gt; Rule l -&gt; DataType
forall l. Data l =&gt; Rule l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Rule l -&gt; Rule l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Rule l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Rule l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rule l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rule l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rule l -&gt; m (Rule l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rule l -&gt; m (Rule l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Rule l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Rule l -&gt; c (Rule l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Rule l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Rule l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Rule l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Rule l -&gt; c (Rule l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Rule l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rule l -&gt; m (Rule l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rule l -&gt; m (Rule l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rule l -&gt; m (Rule l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rule l -&gt; m (Rule l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rule l -&gt; m (Rule l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Rule l -&gt; m (Rule l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Rule l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Rule l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Rule l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Rule l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rule l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rule l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rule l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Rule l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Rule l -&gt; Rule l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Rule l -&gt; Rule l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Rule l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Rule l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Rule l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Rule l))
dataTypeOf :: Rule l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Rule l -&gt; DataType
toConstr :: Rule l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Rule l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Rule l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Rule l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Rule l -&gt; c (Rule l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Rule l -&gt; c (Rule l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427061"><span id="local-6989586621679427063"><span id="local-6989586621679427065"><span id="local-6989586621679427067"><span id="local-6989586621679427069"><span id="local-6989586621679427071"><span id="local-6989586621679427073"><span id="local-6989586621679427075"><span id="local-6989586621679427077"><span id="local-6989586621679427079"><span id="local-6989586621679427081"><span id="local-6989586621679427083"><span id="local-6989586621679427085"><span id="local-6989586621679427094"><span id="local-6989586621679427096"><span id="local-6989586621679427117"><span id="local-6989586621679427119"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Rule a -&gt; Bool
forall a. Num a =&gt; Rule a -&gt; a
forall a. Ord a =&gt; Rule a -&gt; a
forall m. Monoid m =&gt; Rule m -&gt; m
forall a. Rule a -&gt; Bool
forall a. Rule a -&gt; Int
forall a. Rule a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Rule a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Rule a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Rule a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Rule a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Rule a -&gt; a
$cproduct :: forall a. Num a =&gt; Rule a -&gt; a
sum :: forall a. Num a =&gt; Rule a -&gt; a
$csum :: forall a. Num a =&gt; Rule a -&gt; a
minimum :: forall a. Ord a =&gt; Rule a -&gt; a
$cminimum :: forall a. Ord a =&gt; Rule a -&gt; a
maximum :: forall a. Ord a =&gt; Rule a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Rule a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Rule a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Rule a -&gt; Bool
length :: forall a. Rule a -&gt; Int
$clength :: forall a. Rule a -&gt; Int
null :: forall a. Rule a -&gt; Bool
$cnull :: forall a. Rule a -&gt; Bool
toList :: forall a. Rule a -&gt; [a]
$ctoList :: forall a. Rule a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Rule a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Rule a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Rule a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Rule a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Rule a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Rule a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Rule a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Rule a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Rule a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Rule a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Rule a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Rule a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Rule a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Rule a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Rule a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Rule a -&gt; m
fold :: forall m. Monoid m =&gt; Rule m -&gt; m
$cfold :: forall m. Monoid m =&gt; Rule m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427030"><span id="local-6989586621679427032"><span id="local-6989586621679427034"><span id="local-6989586621679427055"><span class="annot"><span class="annottext">Functor Rule
Foldable Rule
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Rule (m a) -&gt; m (Rule a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Rule (f a) -&gt; f (Rule a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Rule a -&gt; m (Rule b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Rule a -&gt; f (Rule b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Rule (m a) -&gt; m (Rule a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Rule (m a) -&gt; m (Rule a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Rule a -&gt; m (Rule b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Rule a -&gt; m (Rule b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Rule (f a) -&gt; f (Rule a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Rule (f a) -&gt; f (Rule a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Rule a -&gt; f (Rule b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Rule a -&gt; f (Rule b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679427018"><span id="local-6989586621679427028"><span class="annot"><span class="annottext">forall a b. a -&gt; Rule b -&gt; Rule a
forall a b. (a -&gt; b) -&gt; Rule a -&gt; Rule b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Rule b -&gt; Rule a
$c&lt;$ :: forall a b. a -&gt; Rule b -&gt; Rule a
fmap :: forall a b. (a -&gt; b) -&gt; Rule a -&gt; Rule b
$cfmap :: forall a b. (a -&gt; b) -&gt; Rule a -&gt; Rule b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Rule l) x -&gt; Rule l
forall l x. Rule l -&gt; Rep (Rule l) x
$cto :: forall l x. Rep (Rule l) x -&gt; Rule l
$cfrom :: forall l x. Rule l -&gt; Rep (Rule l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-890"></span><span>
</span><span id="line-891"></span><span class="hs-comment">-- | Variables used in a RULES pragma, optionally annotated with types</span><span>
</span><span id="line-892"></span><span id="local-6989586621679427006"><span id="local-6989586621679427007"></span></span><span class="hs-keyword">data</span><span> </span><span id="RuleVar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RuleVar"><span class="hs-identifier hs-var">RuleVar</span></a></span></span><span> </span><span id="local-6989586621679452504"><span class="annot"><a href="#local-6989586621679452504"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-893"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="RuleVar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RuleVar"><span class="hs-identifier hs-var">RuleVar</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452504"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452504"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-894"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="TypedRuleVar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypedRuleVar"><span class="hs-identifier hs-var">TypedRuleVar</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452504"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452504"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452504"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-895"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679426995"><span id="local-6989586621679427002"><span class="annot"><span class="annottext">RuleVar l -&gt; RuleVar l -&gt; Bool
forall l. Eq l =&gt; RuleVar l -&gt; RuleVar l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: RuleVar l -&gt; RuleVar l -&gt; Bool
$c/= :: forall l. Eq l =&gt; RuleVar l -&gt; RuleVar l -&gt; Bool
== :: RuleVar l -&gt; RuleVar l -&gt; Bool
$c== :: forall l. Eq l =&gt; RuleVar l -&gt; RuleVar l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426966"><span id="local-6989586621679426968"><span id="local-6989586621679426971"><span id="local-6989586621679426974"><span id="local-6989586621679426977"><span id="local-6989586621679426984"><span id="local-6989586621679426991"><span class="annot"><span class="annottext">RuleVar l -&gt; RuleVar l -&gt; Bool
RuleVar l -&gt; RuleVar l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (RuleVar l)
forall l. Ord l =&gt; RuleVar l -&gt; RuleVar l -&gt; Bool
forall l. Ord l =&gt; RuleVar l -&gt; RuleVar l -&gt; Ordering
forall l. Ord l =&gt; RuleVar l -&gt; RuleVar l -&gt; RuleVar l
min :: RuleVar l -&gt; RuleVar l -&gt; RuleVar l
$cmin :: forall l. Ord l =&gt; RuleVar l -&gt; RuleVar l -&gt; RuleVar l
max :: RuleVar l -&gt; RuleVar l -&gt; RuleVar l
$cmax :: forall l. Ord l =&gt; RuleVar l -&gt; RuleVar l -&gt; RuleVar l
&gt;= :: RuleVar l -&gt; RuleVar l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; RuleVar l -&gt; RuleVar l -&gt; Bool
&gt; :: RuleVar l -&gt; RuleVar l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; RuleVar l -&gt; RuleVar l -&gt; Bool
&lt;= :: RuleVar l -&gt; RuleVar l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; RuleVar l -&gt; RuleVar l -&gt; Bool
&lt; :: RuleVar l -&gt; RuleVar l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; RuleVar l -&gt; RuleVar l -&gt; Bool
compare :: RuleVar l -&gt; RuleVar l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; RuleVar l -&gt; RuleVar l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426953"><span id="local-6989586621679426955"><span id="local-6989586621679426964"><span class="annot"><span class="annottext">Int -&gt; RuleVar l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; RuleVar l -&gt; ShowS
forall l. Show l =&gt; [RuleVar l] -&gt; ShowS
forall l. Show l =&gt; RuleVar l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [RuleVar l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [RuleVar l] -&gt; ShowS
show :: RuleVar l -&gt; String
$cshow :: forall l. Show l =&gt; RuleVar l -&gt; String
showsPrec :: Int -&gt; RuleVar l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; RuleVar l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679426908"><span id="local-6989586621679426910"><span id="local-6989586621679426912"><span id="local-6989586621679426914"><span id="local-6989586621679426916"><span id="local-6989586621679426918"><span id="local-6989586621679426920"><span id="local-6989586621679426922"><span id="local-6989586621679426924"><span id="local-6989586621679426930"><span id="local-6989586621679426932"><span id="local-6989586621679426934"><span id="local-6989586621679426941"><span id="local-6989586621679426948"><span class="annot"><span class="annottext">RuleVar l -&gt; DataType
RuleVar l -&gt; Constr
forall {l}. Data l =&gt; Typeable (RuleVar l)
forall l. Data l =&gt; RuleVar l -&gt; DataType
forall l. Data l =&gt; RuleVar l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; RuleVar l -&gt; RuleVar l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RuleVar l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; RuleVar l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleVar l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleVar l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleVar l -&gt; m (RuleVar l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleVar l -&gt; m (RuleVar l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RuleVar l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RuleVar l -&gt; c (RuleVar l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RuleVar l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (RuleVar l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RuleVar l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RuleVar l -&gt; c (RuleVar l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RuleVar l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleVar l -&gt; m (RuleVar l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleVar l -&gt; m (RuleVar l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleVar l -&gt; m (RuleVar l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleVar l -&gt; m (RuleVar l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleVar l -&gt; m (RuleVar l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RuleVar l -&gt; m (RuleVar l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RuleVar l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RuleVar l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RuleVar l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; RuleVar l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleVar l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleVar l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleVar l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RuleVar l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; RuleVar l -&gt; RuleVar l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; RuleVar l -&gt; RuleVar l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (RuleVar l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (RuleVar l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RuleVar l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RuleVar l))
dataTypeOf :: RuleVar l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; RuleVar l -&gt; DataType
toConstr :: RuleVar l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; RuleVar l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RuleVar l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RuleVar l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RuleVar l -&gt; c (RuleVar l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RuleVar l -&gt; c (RuleVar l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426861"><span id="local-6989586621679426863"><span id="local-6989586621679426865"><span id="local-6989586621679426867"><span id="local-6989586621679426869"><span id="local-6989586621679426871"><span id="local-6989586621679426873"><span id="local-6989586621679426875"><span id="local-6989586621679426877"><span id="local-6989586621679426879"><span id="local-6989586621679426881"><span id="local-6989586621679426883"><span id="local-6989586621679426885"><span id="local-6989586621679426890"><span id="local-6989586621679426892"><span id="local-6989586621679426904"><span id="local-6989586621679426906"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; RuleVar a -&gt; Bool
forall a. Num a =&gt; RuleVar a -&gt; a
forall a. Ord a =&gt; RuleVar a -&gt; a
forall m. Monoid m =&gt; RuleVar m -&gt; m
forall a. RuleVar a -&gt; Bool
forall a. RuleVar a -&gt; Int
forall a. RuleVar a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; RuleVar a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RuleVar a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RuleVar a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RuleVar a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; RuleVar a -&gt; a
$cproduct :: forall a. Num a =&gt; RuleVar a -&gt; a
sum :: forall a. Num a =&gt; RuleVar a -&gt; a
$csum :: forall a. Num a =&gt; RuleVar a -&gt; a
minimum :: forall a. Ord a =&gt; RuleVar a -&gt; a
$cminimum :: forall a. Ord a =&gt; RuleVar a -&gt; a
maximum :: forall a. Ord a =&gt; RuleVar a -&gt; a
$cmaximum :: forall a. Ord a =&gt; RuleVar a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; RuleVar a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; RuleVar a -&gt; Bool
length :: forall a. RuleVar a -&gt; Int
$clength :: forall a. RuleVar a -&gt; Int
null :: forall a. RuleVar a -&gt; Bool
$cnull :: forall a. RuleVar a -&gt; Bool
toList :: forall a. RuleVar a -&gt; [a]
$ctoList :: forall a. RuleVar a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; RuleVar a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; RuleVar a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; RuleVar a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; RuleVar a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RuleVar a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RuleVar a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RuleVar a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RuleVar a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RuleVar a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RuleVar a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RuleVar a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RuleVar a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RuleVar a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RuleVar a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RuleVar a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RuleVar a -&gt; m
fold :: forall m. Monoid m =&gt; RuleVar m -&gt; m
$cfold :: forall m. Monoid m =&gt; RuleVar m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426839"><span id="local-6989586621679426841"><span id="local-6989586621679426843"><span id="local-6989586621679426855"><span class="annot"><span class="annottext">Functor RuleVar
Foldable RuleVar
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; RuleVar (m a) -&gt; m (RuleVar a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
RuleVar (f a) -&gt; f (RuleVar a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; RuleVar a -&gt; m (RuleVar b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; RuleVar a -&gt; f (RuleVar b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; RuleVar (m a) -&gt; m (RuleVar a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; RuleVar (m a) -&gt; m (RuleVar a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; RuleVar a -&gt; m (RuleVar b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; RuleVar a -&gt; m (RuleVar b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
RuleVar (f a) -&gt; f (RuleVar a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
RuleVar (f a) -&gt; f (RuleVar a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; RuleVar a -&gt; f (RuleVar b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; RuleVar a -&gt; f (RuleVar b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426832"><span id="local-6989586621679426837"><span class="annot"><span class="annottext">forall a b. a -&gt; RuleVar b -&gt; RuleVar a
forall a b. (a -&gt; b) -&gt; RuleVar a -&gt; RuleVar b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; RuleVar b -&gt; RuleVar a
$c&lt;$ :: forall a b. a -&gt; RuleVar b -&gt; RuleVar a
fmap :: forall a b. (a -&gt; b) -&gt; RuleVar a -&gt; RuleVar b
$cfmap :: forall a b. (a -&gt; b) -&gt; RuleVar a -&gt; RuleVar b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (RuleVar l) x -&gt; RuleVar l
forall l x. RuleVar l -&gt; Rep (RuleVar l) x
$cto :: forall l x. Rep (RuleVar l) x -&gt; RuleVar l
$cfrom :: forall l x. RuleVar l -&gt; Rep (RuleVar l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-896"></span><span>
</span><span id="line-897"></span><span class="hs-comment">-- | Warning text to optionally use in the module header of e.g.</span><span>
</span><span id="line-898"></span><span class="hs-comment">--   a deprecated module.</span><span>
</span><span id="line-899"></span><span id="local-6989586621679426824"><span id="local-6989586621679426825"></span></span><span class="hs-keyword">data</span><span> </span><span id="WarningText"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#WarningText"><span class="hs-identifier hs-var">WarningText</span></a></span></span><span> </span><span id="local-6989586621679452800"><span class="annot"><a href="#local-6989586621679452800"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-900"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="DeprText"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeprText"><span class="hs-identifier hs-var">DeprText</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452800"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-901"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="WarnText"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#WarnText"><span class="hs-identifier hs-var">WarnText</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452800"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-902"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679426813"><span id="local-6989586621679426820"><span class="annot"><span class="annottext">WarningText l -&gt; WarningText l -&gt; Bool
forall l. Eq l =&gt; WarningText l -&gt; WarningText l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: WarningText l -&gt; WarningText l -&gt; Bool
$c/= :: forall l. Eq l =&gt; WarningText l -&gt; WarningText l -&gt; Bool
== :: WarningText l -&gt; WarningText l -&gt; Bool
$c== :: forall l. Eq l =&gt; WarningText l -&gt; WarningText l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426784"><span id="local-6989586621679426786"><span id="local-6989586621679426789"><span id="local-6989586621679426792"><span id="local-6989586621679426795"><span id="local-6989586621679426802"><span id="local-6989586621679426809"><span class="annot"><span class="annottext">WarningText l -&gt; WarningText l -&gt; Bool
WarningText l -&gt; WarningText l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (WarningText l)
forall l. Ord l =&gt; WarningText l -&gt; WarningText l -&gt; Bool
forall l. Ord l =&gt; WarningText l -&gt; WarningText l -&gt; Ordering
forall l. Ord l =&gt; WarningText l -&gt; WarningText l -&gt; WarningText l
min :: WarningText l -&gt; WarningText l -&gt; WarningText l
$cmin :: forall l. Ord l =&gt; WarningText l -&gt; WarningText l -&gt; WarningText l
max :: WarningText l -&gt; WarningText l -&gt; WarningText l
$cmax :: forall l. Ord l =&gt; WarningText l -&gt; WarningText l -&gt; WarningText l
&gt;= :: WarningText l -&gt; WarningText l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; WarningText l -&gt; WarningText l -&gt; Bool
&gt; :: WarningText l -&gt; WarningText l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; WarningText l -&gt; WarningText l -&gt; Bool
&lt;= :: WarningText l -&gt; WarningText l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; WarningText l -&gt; WarningText l -&gt; Bool
&lt; :: WarningText l -&gt; WarningText l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; WarningText l -&gt; WarningText l -&gt; Bool
compare :: WarningText l -&gt; WarningText l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; WarningText l -&gt; WarningText l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426771"><span id="local-6989586621679426773"><span id="local-6989586621679426782"><span class="annot"><span class="annottext">Int -&gt; WarningText l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; WarningText l -&gt; ShowS
forall l. Show l =&gt; [WarningText l] -&gt; ShowS
forall l. Show l =&gt; WarningText l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [WarningText l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [WarningText l] -&gt; ShowS
show :: WarningText l -&gt; String
$cshow :: forall l. Show l =&gt; WarningText l -&gt; String
showsPrec :: Int -&gt; WarningText l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; WarningText l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679426726"><span id="local-6989586621679426728"><span id="local-6989586621679426730"><span id="local-6989586621679426732"><span id="local-6989586621679426734"><span id="local-6989586621679426736"><span id="local-6989586621679426738"><span id="local-6989586621679426740"><span id="local-6989586621679426742"><span id="local-6989586621679426748"><span id="local-6989586621679426750"><span id="local-6989586621679426752"><span id="local-6989586621679426759"><span id="local-6989586621679426766"><span class="annot"><span class="annottext">WarningText l -&gt; DataType
WarningText l -&gt; Constr
forall {l}. Data l =&gt; Typeable (WarningText l)
forall l. Data l =&gt; WarningText l -&gt; DataType
forall l. Data l =&gt; WarningText l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; WarningText l -&gt; WarningText l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; WarningText l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; WarningText l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; WarningText l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; WarningText l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; WarningText l -&gt; m (WarningText l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; WarningText l -&gt; m (WarningText l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (WarningText l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; WarningText l -&gt; c (WarningText l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (WarningText l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (WarningText l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (WarningText l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; WarningText l -&gt; c (WarningText l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (WarningText l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; WarningText l -&gt; m (WarningText l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; WarningText l -&gt; m (WarningText l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; WarningText l -&gt; m (WarningText l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; WarningText l -&gt; m (WarningText l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; WarningText l -&gt; m (WarningText l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; WarningText l -&gt; m (WarningText l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; WarningText l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; WarningText l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; WarningText l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; WarningText l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; WarningText l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; WarningText l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; WarningText l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; WarningText l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; WarningText l -&gt; WarningText l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; WarningText l -&gt; WarningText l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (WarningText l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (WarningText l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (WarningText l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (WarningText l))
dataTypeOf :: WarningText l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; WarningText l -&gt; DataType
toConstr :: WarningText l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; WarningText l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (WarningText l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (WarningText l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; WarningText l -&gt; c (WarningText l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; WarningText l -&gt; c (WarningText l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426691"><span id="local-6989586621679426693"><span id="local-6989586621679426695"><span id="local-6989586621679426697"><span id="local-6989586621679426699"><span id="local-6989586621679426701"><span id="local-6989586621679426703"><span id="local-6989586621679426705"><span id="local-6989586621679426707"><span id="local-6989586621679426709"><span id="local-6989586621679426711"><span id="local-6989586621679426713"><span id="local-6989586621679426715"><span id="local-6989586621679426717"><span id="local-6989586621679426719"><span id="local-6989586621679426722"><span id="local-6989586621679426724"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; WarningText a -&gt; Bool
forall a. Num a =&gt; WarningText a -&gt; a
forall a. Ord a =&gt; WarningText a -&gt; a
forall m. Monoid m =&gt; WarningText m -&gt; m
forall a. WarningText a -&gt; Bool
forall a. WarningText a -&gt; Int
forall a. WarningText a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; WarningText a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; WarningText a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; WarningText a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; WarningText a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; WarningText a -&gt; a
$cproduct :: forall a. Num a =&gt; WarningText a -&gt; a
sum :: forall a. Num a =&gt; WarningText a -&gt; a
$csum :: forall a. Num a =&gt; WarningText a -&gt; a
minimum :: forall a. Ord a =&gt; WarningText a -&gt; a
$cminimum :: forall a. Ord a =&gt; WarningText a -&gt; a
maximum :: forall a. Ord a =&gt; WarningText a -&gt; a
$cmaximum :: forall a. Ord a =&gt; WarningText a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; WarningText a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; WarningText a -&gt; Bool
length :: forall a. WarningText a -&gt; Int
$clength :: forall a. WarningText a -&gt; Int
null :: forall a. WarningText a -&gt; Bool
$cnull :: forall a. WarningText a -&gt; Bool
toList :: forall a. WarningText a -&gt; [a]
$ctoList :: forall a. WarningText a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; WarningText a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; WarningText a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; WarningText a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; WarningText a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; WarningText a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; WarningText a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; WarningText a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; WarningText a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; WarningText a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; WarningText a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; WarningText a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; WarningText a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; WarningText a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; WarningText a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; WarningText a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; WarningText a -&gt; m
fold :: forall m. Monoid m =&gt; WarningText m -&gt; m
$cfold :: forall m. Monoid m =&gt; WarningText m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426675"><span id="local-6989586621679426677"><span id="local-6989586621679426679"><span id="local-6989586621679426685"><span class="annot"><span class="annottext">Functor WarningText
Foldable WarningText
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
WarningText (m a) -&gt; m (WarningText a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
WarningText (f a) -&gt; f (WarningText a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; WarningText a -&gt; m (WarningText b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; WarningText a -&gt; f (WarningText b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
WarningText (m a) -&gt; m (WarningText a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
WarningText (m a) -&gt; m (WarningText a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; WarningText a -&gt; m (WarningText b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; WarningText a -&gt; m (WarningText b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
WarningText (f a) -&gt; f (WarningText a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
WarningText (f a) -&gt; f (WarningText a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; WarningText a -&gt; f (WarningText b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; WarningText a -&gt; f (WarningText b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426671"><span id="local-6989586621679426673"><span class="annot"><span class="annottext">forall a b. a -&gt; WarningText b -&gt; WarningText a
forall a b. (a -&gt; b) -&gt; WarningText a -&gt; WarningText b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; WarningText b -&gt; WarningText a
$c&lt;$ :: forall a b. a -&gt; WarningText b -&gt; WarningText a
fmap :: forall a b. (a -&gt; b) -&gt; WarningText a -&gt; WarningText b
$cfmap :: forall a b. (a -&gt; b) -&gt; WarningText a -&gt; WarningText b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (WarningText l) x -&gt; WarningText l
forall l x. WarningText l -&gt; Rep (WarningText l) x
$cto :: forall l x. Rep (WarningText l) x -&gt; WarningText l
$cfrom :: forall l x. WarningText l -&gt; Rep (WarningText l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-903"></span><span>
</span><span id="line-904"></span><span>
</span><span id="line-905"></span><span class="hs-comment">-- | A pattern, to be matched against a value.</span><span>
</span><span id="line-906"></span><span id="local-6989586621679426666"><span id="local-6989586621679426667"></span></span><span class="hs-keyword">data</span><span> </span><span id="Pat"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-var">Pat</span></a></span></span><span> </span><span id="local-6989586621679452746"><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-907"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="PVar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PVar"><span class="hs-identifier hs-var">PVar</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                       </span><span class="hs-comment">-- ^ variable</span><span>
</span><span id="line-908"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PLit"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Sign"><span class="hs-identifier hs-type">Sign</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Literal"><span class="hs-identifier hs-type">Literal</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>           </span><span class="hs-comment">-- ^ literal constant</span><span>
</span><span id="line-909"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PNPlusK"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PNPlusK"><span class="hs-identifier hs-var">PNPlusK</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>            </span><span class="hs-comment">-- ^ n+k pattern</span><span>
</span><span id="line-910"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PInfixApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PInfixApp"><span class="hs-identifier hs-var">PInfixApp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ pattern with an infix data constructor</span><span>
</span><span id="line-911"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PApp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PApp"><span class="hs-identifier hs-var">PApp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>              </span><span class="hs-comment">-- ^ data constructor and argument patterns</span><span>
</span><span id="line-912"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PTuple"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PTuple"><span class="hs-identifier hs-var">PTuple</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier hs-type">Boxed</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                </span><span class="hs-comment">-- ^ tuple pattern</span><span>
</span><span id="line-913"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PUnboxedSum"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PUnboxedSum"><span class="hs-identifier hs-var">PUnboxedSum</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- ^ unboxed sum</span><span>
</span><span id="line-914"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PList"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PList"><span class="hs-identifier hs-var">PList</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                       </span><span class="hs-comment">-- ^ list pattern</span><span>
</span><span id="line-915"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PParen"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PParen"><span class="hs-identifier hs-var">PParen</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                      </span><span class="hs-comment">-- ^ parenthesized pattern</span><span>
</span><span id="line-916"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PRec"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PRec"><span class="hs-identifier hs-var">PRec</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatField"><span class="hs-identifier hs-type">PatField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>         </span><span class="hs-comment">-- ^ labelled pattern, record style</span><span>
</span><span id="line-917"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PAsPat"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PAsPat"><span class="hs-identifier hs-var">PAsPat</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- ^ @\@@-pattern</span><span>
</span><span id="line-918"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PWildCard"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PWildCard"><span class="hs-identifier hs-var">PWildCard</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span>                           </span><span class="hs-comment">-- ^ wildcard pattern: @_@</span><span>
</span><span id="line-919"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PIrrPat"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PIrrPat"><span class="hs-identifier hs-var">PIrrPat</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                     </span><span class="hs-comment">-- ^ irrefutable pattern: @~/pat/@</span><span>
</span><span id="line-920"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PatTypeSig"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatTypeSig"><span class="hs-identifier hs-var">PatTypeSig</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- ^ pattern with type signature</span><span>
</span><span id="line-921"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PViewPat"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PViewPat"><span class="hs-identifier hs-var">PViewPat</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>            </span><span class="hs-comment">-- ^ view patterns of the form @(/exp/ -&gt; /pat/)@</span><span>
</span><span id="line-922"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PRPat"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PRPat"><span class="hs-identifier hs-var">PRPat</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier hs-type">RPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                      </span><span class="hs-comment">-- ^ regular list pattern</span><span>
</span><span id="line-923"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PXTag"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXTag"><span class="hs-identifier hs-var">PXTag</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-type">XName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXAttr"><span class="hs-identifier hs-type">PXAttr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-924"></span><span>                                            </span><span class="hs-comment">-- ^ XML element pattern</span><span>
</span><span id="line-925"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PXETag"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXETag"><span class="hs-identifier hs-var">PXETag</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-type">XName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXAttr"><span class="hs-identifier hs-type">PXAttr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-926"></span><span>                                            </span><span class="hs-comment">-- ^ XML singleton element pattern</span><span>
</span><span id="line-927"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PXPcdata"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXPcdata"><span class="hs-identifier hs-var">PXPcdata</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>                     </span><span class="hs-comment">-- ^ XML PCDATA pattern</span><span>
</span><span id="line-928"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PXPatTag"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXPatTag"><span class="hs-identifier hs-var">PXPatTag</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                    </span><span class="hs-comment">-- ^ XML embedded pattern</span><span>
</span><span id="line-929"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PXRPats"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXRPats"><span class="hs-identifier hs-var">PXRPats</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier hs-type">RPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>                   </span><span class="hs-comment">-- ^ XML regular list pattern</span><span>
</span><span id="line-930"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PSplice"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PSplice"><span class="hs-identifier hs-var">PSplice</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                  </span><span class="hs-comment">-- ^ template haskell splice pattern</span><span>
</span><span id="line-931"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PQuasiQuote"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PQuasiQuote"><span class="hs-identifier hs-var">PQuasiQuote</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>           </span><span class="hs-comment">-- ^ quasi quote pattern: @[$/name/| /string/ |]@</span><span>
</span><span id="line-932"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PBangPat"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PBangPat"><span class="hs-identifier hs-var">PBangPat</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452746"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>                    </span><span class="hs-comment">-- ^ strict (bang) pattern: @f !x = ...@</span><span>
</span><span id="line-933"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679426569"><span id="local-6989586621679426640"><span class="annot"><span class="annottext">Pat l -&gt; Pat l -&gt; Bool
forall l. Eq l =&gt; Pat l -&gt; Pat l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Pat l -&gt; Pat l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Pat l -&gt; Pat l -&gt; Bool
== :: Pat l -&gt; Pat l -&gt; Bool
$c== :: forall l. Eq l =&gt; Pat l -&gt; Pat l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426484"><span id="local-6989586621679426486"><span id="local-6989586621679426488"><span id="local-6989586621679426490"><span id="local-6989586621679426492"><span id="local-6989586621679426494"><span id="local-6989586621679426565"><span class="annot"><span class="annottext">Pat l -&gt; Pat l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Pat l)
forall l. Ord l =&gt; Pat l -&gt; Pat l -&gt; Bool
forall l. Ord l =&gt; Pat l -&gt; Pat l -&gt; Ordering
forall l. Ord l =&gt; Pat l -&gt; Pat l -&gt; Pat l
min :: Pat l -&gt; Pat l -&gt; Pat l
$cmin :: forall l. Ord l =&gt; Pat l -&gt; Pat l -&gt; Pat l
max :: Pat l -&gt; Pat l -&gt; Pat l
$cmax :: forall l. Ord l =&gt; Pat l -&gt; Pat l -&gt; Pat l
&gt;= :: Pat l -&gt; Pat l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Pat l -&gt; Pat l -&gt; Bool
&gt; :: Pat l -&gt; Pat l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Pat l -&gt; Pat l -&gt; Bool
&lt;= :: Pat l -&gt; Pat l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Pat l -&gt; Pat l -&gt; Bool
&lt; :: Pat l -&gt; Pat l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Pat l -&gt; Pat l -&gt; Bool
compare :: Pat l -&gt; Pat l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Pat l -&gt; Pat l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426385"><span id="local-6989586621679426387"><span id="local-6989586621679426482"><span class="annot"><span class="annottext">Int -&gt; Pat l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Pat l -&gt; ShowS
forall l. Show l =&gt; [Pat l] -&gt; ShowS
forall l. Show l =&gt; Pat l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Pat l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Pat l] -&gt; ShowS
show :: Pat l -&gt; String
$cshow :: forall l. Show l =&gt; Pat l -&gt; String
showsPrec :: Int -&gt; Pat l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Pat l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679426212"><span id="local-6989586621679426214"><span id="local-6989586621679426216"><span id="local-6989586621679426218"><span id="local-6989586621679426220"><span id="local-6989586621679426222"><span id="local-6989586621679426224"><span id="local-6989586621679426226"><span id="local-6989586621679426228"><span id="local-6989586621679426234"><span id="local-6989586621679426236"><span id="local-6989586621679426238"><span id="local-6989586621679426309"><span id="local-6989586621679426380"><span class="annot"><span class="annottext">Pat l -&gt; DataType
Pat l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Pat l)
forall l. Data l =&gt; Pat l -&gt; DataType
forall l. Data l =&gt; Pat l -&gt; Constr
forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; Pat l -&gt; Pat l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pat l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pat l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat l -&gt; m (Pat l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat l -&gt; m (Pat l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Pat l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Pat l -&gt; c (Pat l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Pat l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Pat l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Pat l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Pat l -&gt; c (Pat l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Pat l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat l -&gt; m (Pat l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat l -&gt; m (Pat l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat l -&gt; m (Pat l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat l -&gt; m (Pat l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat l -&gt; m (Pat l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Pat l -&gt; m (Pat l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pat l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pat l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Pat l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Pat l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Pat l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Pat l -&gt; Pat l
$cgmapT :: forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; Pat l -&gt; Pat l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Pat l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Pat l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Pat l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Pat l))
dataTypeOf :: Pat l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Pat l -&gt; DataType
toConstr :: Pat l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Pat l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Pat l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Pat l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Pat l -&gt; c (Pat l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Pat l -&gt; c (Pat l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679426008"><span id="local-6989586621679426010"><span id="local-6989586621679426012"><span id="local-6989586621679426014"><span id="local-6989586621679426016"><span id="local-6989586621679426018"><span id="local-6989586621679426020"><span id="local-6989586621679426022"><span id="local-6989586621679426024"><span id="local-6989586621679426026"><span id="local-6989586621679426028"><span id="local-6989586621679426030"><span id="local-6989586621679426032"><span id="local-6989586621679426079"><span id="local-6989586621679426081"><span id="local-6989586621679426208"><span id="local-6989586621679426210"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Pat a -&gt; Bool
forall a. Num a =&gt; Pat a -&gt; a
forall a. Ord a =&gt; Pat a -&gt; a
forall m. Monoid m =&gt; Pat m -&gt; m
forall a. Pat a -&gt; Bool
forall a. Pat a -&gt; Int
forall a. Pat a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Pat a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Pat a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Pat a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Pat a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Pat a -&gt; a
$cproduct :: forall a. Num a =&gt; Pat a -&gt; a
sum :: forall a. Num a =&gt; Pat a -&gt; a
$csum :: forall a. Num a =&gt; Pat a -&gt; a
minimum :: forall a. Ord a =&gt; Pat a -&gt; a
$cminimum :: forall a. Ord a =&gt; Pat a -&gt; a
maximum :: forall a. Ord a =&gt; Pat a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Pat a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Pat a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Pat a -&gt; Bool
length :: forall a. Pat a -&gt; Int
$clength :: forall a. Pat a -&gt; Int
null :: forall a. Pat a -&gt; Bool
$cnull :: forall a. Pat a -&gt; Bool
toList :: forall a. Pat a -&gt; [a]
$ctoList :: forall a. Pat a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Pat a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Pat a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Pat a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Pat a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Pat a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Pat a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Pat a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Pat a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Pat a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Pat a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Pat a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Pat a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Pat a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Pat a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Pat a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Pat a -&gt; m
fold :: forall m. Monoid m =&gt; Pat m -&gt; m
$cfold :: forall m. Monoid m =&gt; Pat m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425867"><span id="local-6989586621679425869"><span id="local-6989586621679425871"><span id="local-6989586621679426002"><span class="annot"><span class="annottext">Functor Pat
Foldable Pat
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Pat (m a) -&gt; m (Pat a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Pat (f a) -&gt; f (Pat a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Pat a -&gt; m (Pat b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Pat a -&gt; f (Pat b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Pat (m a) -&gt; m (Pat a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Pat (m a) -&gt; m (Pat a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Pat a -&gt; m (Pat b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Pat a -&gt; m (Pat b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Pat (f a) -&gt; f (Pat a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Pat (f a) -&gt; f (Pat a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Pat a -&gt; f (Pat b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Pat a -&gt; f (Pat b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425815"><span id="local-6989586621679425865"><span class="annot"><span class="annottext">forall a b. a -&gt; Pat b -&gt; Pat a
forall a b. (a -&gt; b) -&gt; Pat a -&gt; Pat b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Pat b -&gt; Pat a
$c&lt;$ :: forall a b. a -&gt; Pat b -&gt; Pat a
fmap :: forall a b. (a -&gt; b) -&gt; Pat a -&gt; Pat b
$cfmap :: forall a b. (a -&gt; b) -&gt; Pat a -&gt; Pat b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Pat l) x -&gt; Pat l
forall l x. Pat l -&gt; Rep (Pat l) x
$cto :: forall l x. Rep (Pat l) x -&gt; Pat l
$cfrom :: forall l x. Pat l -&gt; Rep (Pat l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-934"></span><span>
</span><span id="line-935"></span><span class="hs-comment">-- | An XML attribute in a pattern.</span><span>
</span><span id="line-936"></span><span id="local-6989586621679425765"><span id="local-6989586621679425766"></span></span><span class="hs-keyword">data</span><span> </span><span id="PXAttr"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXAttr"><span class="hs-identifier hs-var">PXAttr</span></a></span></span><span> </span><span id="local-6989586621679452489"><span class="annot"><a href="#local-6989586621679452489"><span class="hs-identifier hs-type">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="PXAttr"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXAttr"><span class="hs-identifier hs-var">PXAttr</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452489"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-type">XName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452489"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452489"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-937"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679425757"><span id="local-6989586621679425762"><span class="annot"><span class="annottext">PXAttr l -&gt; PXAttr l -&gt; Bool
forall l. Eq l =&gt; PXAttr l -&gt; PXAttr l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: PXAttr l -&gt; PXAttr l -&gt; Bool
$c/= :: forall l. Eq l =&gt; PXAttr l -&gt; PXAttr l -&gt; Bool
== :: PXAttr l -&gt; PXAttr l -&gt; Bool
$c== :: forall l. Eq l =&gt; PXAttr l -&gt; PXAttr l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425732"><span id="local-6989586621679425734"><span id="local-6989586621679425737"><span id="local-6989586621679425740"><span id="local-6989586621679425743"><span id="local-6989586621679425748"><span id="local-6989586621679425753"><span class="annot"><span class="annottext">PXAttr l -&gt; PXAttr l -&gt; Bool
PXAttr l -&gt; PXAttr l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (PXAttr l)
forall l. Ord l =&gt; PXAttr l -&gt; PXAttr l -&gt; Bool
forall l. Ord l =&gt; PXAttr l -&gt; PXAttr l -&gt; Ordering
forall l. Ord l =&gt; PXAttr l -&gt; PXAttr l -&gt; PXAttr l
min :: PXAttr l -&gt; PXAttr l -&gt; PXAttr l
$cmin :: forall l. Ord l =&gt; PXAttr l -&gt; PXAttr l -&gt; PXAttr l
max :: PXAttr l -&gt; PXAttr l -&gt; PXAttr l
$cmax :: forall l. Ord l =&gt; PXAttr l -&gt; PXAttr l -&gt; PXAttr l
&gt;= :: PXAttr l -&gt; PXAttr l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; PXAttr l -&gt; PXAttr l -&gt; Bool
&gt; :: PXAttr l -&gt; PXAttr l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; PXAttr l -&gt; PXAttr l -&gt; Bool
&lt;= :: PXAttr l -&gt; PXAttr l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; PXAttr l -&gt; PXAttr l -&gt; Bool
&lt; :: PXAttr l -&gt; PXAttr l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; PXAttr l -&gt; PXAttr l -&gt; Bool
compare :: PXAttr l -&gt; PXAttr l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; PXAttr l -&gt; PXAttr l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425722"><span id="local-6989586621679425724"><span id="local-6989586621679425730"><span class="annot"><span class="annottext">Int -&gt; PXAttr l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; PXAttr l -&gt; ShowS
forall l. Show l =&gt; [PXAttr l] -&gt; ShowS
forall l. Show l =&gt; PXAttr l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [PXAttr l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [PXAttr l] -&gt; ShowS
show :: PXAttr l -&gt; String
$cshow :: forall l. Show l =&gt; PXAttr l -&gt; String
showsPrec :: Int -&gt; PXAttr l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; PXAttr l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679425681"><span id="local-6989586621679425683"><span id="local-6989586621679425685"><span id="local-6989586621679425687"><span id="local-6989586621679425689"><span id="local-6989586621679425691"><span id="local-6989586621679425693"><span id="local-6989586621679425695"><span id="local-6989586621679425697"><span id="local-6989586621679425703"><span id="local-6989586621679425705"><span id="local-6989586621679425707"><span id="local-6989586621679425712"><span id="local-6989586621679425717"><span class="annot"><span class="annottext">PXAttr l -&gt; DataType
PXAttr l -&gt; Constr
forall {l}. Data l =&gt; Typeable (PXAttr l)
forall l. Data l =&gt; PXAttr l -&gt; DataType
forall l. Data l =&gt; PXAttr l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; PXAttr l -&gt; PXAttr l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PXAttr l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; PXAttr l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PXAttr l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PXAttr l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PXAttr l -&gt; m (PXAttr l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PXAttr l -&gt; m (PXAttr l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PXAttr l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PXAttr l -&gt; c (PXAttr l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PXAttr l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (PXAttr l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PXAttr l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PXAttr l -&gt; c (PXAttr l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PXAttr l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PXAttr l -&gt; m (PXAttr l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PXAttr l -&gt; m (PXAttr l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PXAttr l -&gt; m (PXAttr l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PXAttr l -&gt; m (PXAttr l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PXAttr l -&gt; m (PXAttr l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PXAttr l -&gt; m (PXAttr l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PXAttr l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PXAttr l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PXAttr l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; PXAttr l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PXAttr l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PXAttr l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PXAttr l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PXAttr l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; PXAttr l -&gt; PXAttr l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; PXAttr l -&gt; PXAttr l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (PXAttr l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (PXAttr l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PXAttr l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PXAttr l))
dataTypeOf :: PXAttr l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; PXAttr l -&gt; DataType
toConstr :: PXAttr l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; PXAttr l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PXAttr l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PXAttr l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PXAttr l -&gt; c (PXAttr l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PXAttr l -&gt; c (PXAttr l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425638"><span id="local-6989586621679425640"><span id="local-6989586621679425642"><span id="local-6989586621679425644"><span id="local-6989586621679425646"><span id="local-6989586621679425648"><span id="local-6989586621679425650"><span id="local-6989586621679425652"><span id="local-6989586621679425654"><span id="local-6989586621679425656"><span id="local-6989586621679425658"><span id="local-6989586621679425660"><span id="local-6989586621679425662"><span id="local-6989586621679425666"><span id="local-6989586621679425668"><span id="local-6989586621679425677"><span id="local-6989586621679425679"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; PXAttr a -&gt; Bool
forall a. Num a =&gt; PXAttr a -&gt; a
forall a. Ord a =&gt; PXAttr a -&gt; a
forall m. Monoid m =&gt; PXAttr m -&gt; m
forall a. PXAttr a -&gt; Bool
forall a. PXAttr a -&gt; Int
forall a. PXAttr a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; PXAttr a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PXAttr a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PXAttr a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PXAttr a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; PXAttr a -&gt; a
$cproduct :: forall a. Num a =&gt; PXAttr a -&gt; a
sum :: forall a. Num a =&gt; PXAttr a -&gt; a
$csum :: forall a. Num a =&gt; PXAttr a -&gt; a
minimum :: forall a. Ord a =&gt; PXAttr a -&gt; a
$cminimum :: forall a. Ord a =&gt; PXAttr a -&gt; a
maximum :: forall a. Ord a =&gt; PXAttr a -&gt; a
$cmaximum :: forall a. Ord a =&gt; PXAttr a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; PXAttr a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; PXAttr a -&gt; Bool
length :: forall a. PXAttr a -&gt; Int
$clength :: forall a. PXAttr a -&gt; Int
null :: forall a. PXAttr a -&gt; Bool
$cnull :: forall a. PXAttr a -&gt; Bool
toList :: forall a. PXAttr a -&gt; [a]
$ctoList :: forall a. PXAttr a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; PXAttr a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; PXAttr a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; PXAttr a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; PXAttr a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PXAttr a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PXAttr a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PXAttr a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PXAttr a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PXAttr a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PXAttr a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PXAttr a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PXAttr a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PXAttr a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PXAttr a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PXAttr a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PXAttr a -&gt; m
fold :: forall m. Monoid m =&gt; PXAttr m -&gt; m
$cfold :: forall m. Monoid m =&gt; PXAttr m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425619"><span id="local-6989586621679425621"><span id="local-6989586621679425623"><span id="local-6989586621679425632"><span class="annot"><span class="annottext">Functor PXAttr
Foldable PXAttr
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; PXAttr (m a) -&gt; m (PXAttr a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
PXAttr (f a) -&gt; f (PXAttr a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PXAttr a -&gt; m (PXAttr b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PXAttr a -&gt; f (PXAttr b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; PXAttr (m a) -&gt; m (PXAttr a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; PXAttr (m a) -&gt; m (PXAttr a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PXAttr a -&gt; m (PXAttr b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PXAttr a -&gt; m (PXAttr b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
PXAttr (f a) -&gt; f (PXAttr a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
PXAttr (f a) -&gt; f (PXAttr a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PXAttr a -&gt; f (PXAttr b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PXAttr a -&gt; f (PXAttr b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425613"><span id="local-6989586621679425617"><span class="annot"><span class="annottext">forall a b. a -&gt; PXAttr b -&gt; PXAttr a
forall a b. (a -&gt; b) -&gt; PXAttr a -&gt; PXAttr b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; PXAttr b -&gt; PXAttr a
$c&lt;$ :: forall a b. a -&gt; PXAttr b -&gt; PXAttr a
fmap :: forall a b. (a -&gt; b) -&gt; PXAttr a -&gt; PXAttr b
$cfmap :: forall a b. (a -&gt; b) -&gt; PXAttr a -&gt; PXAttr b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (PXAttr l) x -&gt; PXAttr l
forall l x. PXAttr l -&gt; Rep (PXAttr l) x
$cto :: forall l x. Rep (PXAttr l) x -&gt; PXAttr l
$cfrom :: forall l x. PXAttr l -&gt; Rep (PXAttr l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-938"></span><span>
</span><span id="line-939"></span><span class="hs-comment">-- | A regular pattern operator.</span><span>
</span><span id="line-940"></span><span id="local-6989586621679425606"><span id="local-6989586621679425607"></span></span><span class="hs-keyword">data</span><span> </span><span id="RPatOp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPatOp"><span class="hs-identifier hs-var">RPatOp</span></a></span></span><span> </span><span id="local-6989586621679452480"><span class="annot"><a href="#local-6989586621679452480"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-941"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="RPStar"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPStar"><span class="hs-identifier hs-var">RPStar</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452480"><span class="hs-identifier hs-type">l</span></a></span><span>  </span><span class="hs-comment">-- ^ @*@ = 0 or more</span><span>
</span><span id="line-942"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPStarG"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPStarG"><span class="hs-identifier hs-var">RPStarG</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452480"><span class="hs-identifier hs-type">l</span></a></span><span>  </span><span class="hs-comment">-- ^ @*!@ = 0 or more, greedy</span><span>
</span><span id="line-943"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPPlus"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPPlus"><span class="hs-identifier hs-var">RPPlus</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452480"><span class="hs-identifier hs-type">l</span></a></span><span>  </span><span class="hs-comment">-- ^ @+@ = 1 or more</span><span>
</span><span id="line-944"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPPlusG"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPPlusG"><span class="hs-identifier hs-var">RPPlusG</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452480"><span class="hs-identifier hs-type">l</span></a></span><span>  </span><span class="hs-comment">-- ^ @+!@ = 1 or more, greedy</span><span>
</span><span id="line-945"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPOpt"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPOpt"><span class="hs-identifier hs-var">RPOpt</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452480"><span class="hs-identifier hs-type">l</span></a></span><span>  </span><span class="hs-comment">-- ^ @?@ = 0 or 1</span><span>
</span><span id="line-946"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPOptG"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPOptG"><span class="hs-identifier hs-var">RPOptG</span></a></span></span><span>  </span><span class="annot"><a href="#local-6989586621679452480"><span class="hs-identifier hs-type">l</span></a></span><span>  </span><span class="hs-comment">-- ^ @?!@ = 0 or 1, greedy</span><span>
</span><span id="line-947"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679425590"><span id="local-6989586621679425598"><span class="annot"><span class="annottext">RPatOp l -&gt; RPatOp l -&gt; Bool
forall l. Eq l =&gt; RPatOp l -&gt; RPatOp l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: RPatOp l -&gt; RPatOp l -&gt; Bool
$c/= :: forall l. Eq l =&gt; RPatOp l -&gt; RPatOp l -&gt; Bool
== :: RPatOp l -&gt; RPatOp l -&gt; Bool
$c== :: forall l. Eq l =&gt; RPatOp l -&gt; RPatOp l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425568"><span id="local-6989586621679425570"><span id="local-6989586621679425572"><span id="local-6989586621679425574"><span id="local-6989586621679425576"><span id="local-6989586621679425578"><span id="local-6989586621679425586"><span class="annot"><span class="annottext">RPatOp l -&gt; RPatOp l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (RPatOp l)
forall l. Ord l =&gt; RPatOp l -&gt; RPatOp l -&gt; Bool
forall l. Ord l =&gt; RPatOp l -&gt; RPatOp l -&gt; Ordering
forall l. Ord l =&gt; RPatOp l -&gt; RPatOp l -&gt; RPatOp l
min :: RPatOp l -&gt; RPatOp l -&gt; RPatOp l
$cmin :: forall l. Ord l =&gt; RPatOp l -&gt; RPatOp l -&gt; RPatOp l
max :: RPatOp l -&gt; RPatOp l -&gt; RPatOp l
$cmax :: forall l. Ord l =&gt; RPatOp l -&gt; RPatOp l -&gt; RPatOp l
&gt;= :: RPatOp l -&gt; RPatOp l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; RPatOp l -&gt; RPatOp l -&gt; Bool
&gt; :: RPatOp l -&gt; RPatOp l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; RPatOp l -&gt; RPatOp l -&gt; Bool
&lt;= :: RPatOp l -&gt; RPatOp l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; RPatOp l -&gt; RPatOp l -&gt; Bool
&lt; :: RPatOp l -&gt; RPatOp l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; RPatOp l -&gt; RPatOp l -&gt; Bool
compare :: RPatOp l -&gt; RPatOp l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; RPatOp l -&gt; RPatOp l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425550"><span id="local-6989586621679425552"><span id="local-6989586621679425566"><span class="annot"><span class="annottext">Int -&gt; RPatOp l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; RPatOp l -&gt; ShowS
forall l. Show l =&gt; [RPatOp l] -&gt; ShowS
forall l. Show l =&gt; RPatOp l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [RPatOp l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [RPatOp l] -&gt; ShowS
show :: RPatOp l -&gt; String
$cshow :: forall l. Show l =&gt; RPatOp l -&gt; String
showsPrec :: Int -&gt; RPatOp l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; RPatOp l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679425503"><span id="local-6989586621679425505"><span id="local-6989586621679425507"><span id="local-6989586621679425509"><span id="local-6989586621679425511"><span id="local-6989586621679425513"><span id="local-6989586621679425515"><span id="local-6989586621679425517"><span id="local-6989586621679425519"><span id="local-6989586621679425525"><span id="local-6989586621679425527"><span id="local-6989586621679425529"><span id="local-6989586621679425537"><span id="local-6989586621679425545"><span class="annot"><span class="annottext">RPatOp l -&gt; DataType
RPatOp l -&gt; Constr
forall {l}. Data l =&gt; Typeable (RPatOp l)
forall l. Data l =&gt; RPatOp l -&gt; DataType
forall l. Data l =&gt; RPatOp l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; RPatOp l -&gt; RPatOp l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RPatOp l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; RPatOp l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPatOp l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPatOp l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPatOp l -&gt; m (RPatOp l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPatOp l -&gt; m (RPatOp l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RPatOp l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RPatOp l -&gt; c (RPatOp l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RPatOp l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (RPatOp l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RPatOp l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RPatOp l -&gt; c (RPatOp l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RPatOp l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPatOp l -&gt; m (RPatOp l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPatOp l -&gt; m (RPatOp l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPatOp l -&gt; m (RPatOp l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPatOp l -&gt; m (RPatOp l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPatOp l -&gt; m (RPatOp l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPatOp l -&gt; m (RPatOp l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RPatOp l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RPatOp l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RPatOp l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; RPatOp l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPatOp l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPatOp l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPatOp l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPatOp l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; RPatOp l -&gt; RPatOp l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; RPatOp l -&gt; RPatOp l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (RPatOp l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (RPatOp l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RPatOp l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RPatOp l))
dataTypeOf :: RPatOp l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; RPatOp l -&gt; DataType
toConstr :: RPatOp l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; RPatOp l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RPatOp l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RPatOp l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RPatOp l -&gt; c (RPatOp l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RPatOp l -&gt; c (RPatOp l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425468"><span id="local-6989586621679425470"><span id="local-6989586621679425472"><span id="local-6989586621679425474"><span id="local-6989586621679425476"><span id="local-6989586621679425478"><span id="local-6989586621679425480"><span id="local-6989586621679425482"><span id="local-6989586621679425484"><span id="local-6989586621679425486"><span id="local-6989586621679425488"><span id="local-6989586621679425490"><span id="local-6989586621679425492"><span id="local-6989586621679425494"><span id="local-6989586621679425496"><span id="local-6989586621679425499"><span id="local-6989586621679425501"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; RPatOp a -&gt; Bool
forall a. Num a =&gt; RPatOp a -&gt; a
forall a. Ord a =&gt; RPatOp a -&gt; a
forall m. Monoid m =&gt; RPatOp m -&gt; m
forall a. RPatOp a -&gt; Bool
forall a. RPatOp a -&gt; Int
forall a. RPatOp a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; RPatOp a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RPatOp a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RPatOp a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RPatOp a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; RPatOp a -&gt; a
$cproduct :: forall a. Num a =&gt; RPatOp a -&gt; a
sum :: forall a. Num a =&gt; RPatOp a -&gt; a
$csum :: forall a. Num a =&gt; RPatOp a -&gt; a
minimum :: forall a. Ord a =&gt; RPatOp a -&gt; a
$cminimum :: forall a. Ord a =&gt; RPatOp a -&gt; a
maximum :: forall a. Ord a =&gt; RPatOp a -&gt; a
$cmaximum :: forall a. Ord a =&gt; RPatOp a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; RPatOp a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; RPatOp a -&gt; Bool
length :: forall a. RPatOp a -&gt; Int
$clength :: forall a. RPatOp a -&gt; Int
null :: forall a. RPatOp a -&gt; Bool
$cnull :: forall a. RPatOp a -&gt; Bool
toList :: forall a. RPatOp a -&gt; [a]
$ctoList :: forall a. RPatOp a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; RPatOp a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; RPatOp a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; RPatOp a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; RPatOp a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RPatOp a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RPatOp a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RPatOp a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RPatOp a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RPatOp a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RPatOp a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RPatOp a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RPatOp a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RPatOp a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RPatOp a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RPatOp a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RPatOp a -&gt; m
fold :: forall m. Monoid m =&gt; RPatOp m -&gt; m
$cfold :: forall m. Monoid m =&gt; RPatOp m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425447"><span id="local-6989586621679425449"><span id="local-6989586621679425451"><span id="local-6989586621679425461"><span class="annot"><span class="annottext">Functor RPatOp
Foldable RPatOp
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; RPatOp (m a) -&gt; m (RPatOp a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
RPatOp (f a) -&gt; f (RPatOp a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; RPatOp a -&gt; m (RPatOp b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; RPatOp a -&gt; f (RPatOp b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; RPatOp (m a) -&gt; m (RPatOp a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; RPatOp (m a) -&gt; m (RPatOp a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; RPatOp a -&gt; m (RPatOp b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; RPatOp a -&gt; m (RPatOp b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
RPatOp (f a) -&gt; f (RPatOp a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
RPatOp (f a) -&gt; f (RPatOp a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; RPatOp a -&gt; f (RPatOp b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; RPatOp a -&gt; f (RPatOp b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425443"><span id="local-6989586621679425445"><span class="annot"><span class="annottext">forall a b. a -&gt; RPatOp b -&gt; RPatOp a
forall a b. (a -&gt; b) -&gt; RPatOp a -&gt; RPatOp b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; RPatOp b -&gt; RPatOp a
$c&lt;$ :: forall a b. a -&gt; RPatOp b -&gt; RPatOp a
fmap :: forall a b. (a -&gt; b) -&gt; RPatOp a -&gt; RPatOp b
$cfmap :: forall a b. (a -&gt; b) -&gt; RPatOp a -&gt; RPatOp b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (RPatOp l) x -&gt; RPatOp l
forall l x. RPatOp l -&gt; Rep (RPatOp l) x
$cto :: forall l x. Rep (RPatOp l) x -&gt; RPatOp l
$cfrom :: forall l x. RPatOp l -&gt; Rep (RPatOp l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-948"></span><span>
</span><span id="line-949"></span><span class="hs-comment">-- | An entity in a regular pattern.</span><span>
</span><span id="line-950"></span><span id="local-6989586621679425438"><span id="local-6989586621679425439"></span></span><span class="hs-keyword">data</span><span> </span><span id="RPat"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier hs-var">RPat</span></a></span></span><span> </span><span id="local-6989586621679452490"><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-951"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="RPOp"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPOp"><span class="hs-identifier hs-var">RPOp</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier hs-type">RPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPatOp"><span class="hs-identifier hs-type">RPatOp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- ^ operator pattern, e.g. pat*</span><span>
</span><span id="line-952"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPEither"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPEither"><span class="hs-identifier hs-var">RPEither</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier hs-type">RPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier hs-type">RPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ choice pattern, e.g. (1 | 2)</span><span>
</span><span id="line-953"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPSeq"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPSeq"><span class="hs-identifier hs-var">RPSeq</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier hs-type">RPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>             </span><span class="hs-comment">-- ^ sequence pattern, e.g. (| 1, 2, 3 |)</span><span>
</span><span id="line-954"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPGuard"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPGuard"><span class="hs-identifier hs-var">RPGuard</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>   </span><span class="hs-comment">-- ^ guarded pattern, e.g. (| p | p &lt; 3 |)</span><span>
</span><span id="line-955"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPCAs"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPCAs"><span class="hs-identifier hs-var">RPCAs</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier hs-type">RPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ non-linear variable binding, e.g. (foo\@:(1 | 2))*</span><span>
</span><span id="line-956"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPAs"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPAs"><span class="hs-identifier hs-var">RPAs</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier hs-type">RPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- ^ linear variable binding, e.g. foo\@(1 | 2)</span><span>
</span><span id="line-957"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPParen"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPParen"><span class="hs-identifier hs-var">RPParen</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier hs-type">RPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>           </span><span class="hs-comment">-- ^ parenthesised pattern, e.g. (2*)</span><span>
</span><span id="line-958"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RPPat"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPPat"><span class="hs-identifier hs-var">RPPat</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452490"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>              </span><span class="hs-comment">-- ^ an ordinary pattern</span><span>
</span><span id="line-959"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679425404"><span id="local-6989586621679425428"><span class="annot"><span class="annottext">RPat l -&gt; RPat l -&gt; Bool
forall l. Eq l =&gt; RPat l -&gt; RPat l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: RPat l -&gt; RPat l -&gt; Bool
$c/= :: forall l. Eq l =&gt; RPat l -&gt; RPat l -&gt; Bool
== :: RPat l -&gt; RPat l -&gt; Bool
$c== :: forall l. Eq l =&gt; RPat l -&gt; RPat l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425366"><span id="local-6989586621679425368"><span id="local-6989586621679425370"><span id="local-6989586621679425372"><span id="local-6989586621679425374"><span id="local-6989586621679425376"><span id="local-6989586621679425400"><span class="annot"><span class="annottext">RPat l -&gt; RPat l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (RPat l)
forall l. Ord l =&gt; RPat l -&gt; RPat l -&gt; Bool
forall l. Ord l =&gt; RPat l -&gt; RPat l -&gt; Ordering
forall l. Ord l =&gt; RPat l -&gt; RPat l -&gt; RPat l
min :: RPat l -&gt; RPat l -&gt; RPat l
$cmin :: forall l. Ord l =&gt; RPat l -&gt; RPat l -&gt; RPat l
max :: RPat l -&gt; RPat l -&gt; RPat l
$cmax :: forall l. Ord l =&gt; RPat l -&gt; RPat l -&gt; RPat l
&gt;= :: RPat l -&gt; RPat l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; RPat l -&gt; RPat l -&gt; Bool
&gt; :: RPat l -&gt; RPat l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; RPat l -&gt; RPat l -&gt; Bool
&lt;= :: RPat l -&gt; RPat l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; RPat l -&gt; RPat l -&gt; Bool
&lt; :: RPat l -&gt; RPat l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; RPat l -&gt; RPat l -&gt; Bool
compare :: RPat l -&gt; RPat l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; RPat l -&gt; RPat l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425330"><span id="local-6989586621679425332"><span id="local-6989586621679425364"><span class="annot"><span class="annottext">Int -&gt; RPat l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; RPat l -&gt; ShowS
forall l. Show l =&gt; [RPat l] -&gt; ShowS
forall l. Show l =&gt; RPat l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [RPat l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [RPat l] -&gt; ShowS
show :: RPat l -&gt; String
$cshow :: forall l. Show l =&gt; RPat l -&gt; String
showsPrec :: Int -&gt; RPat l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; RPat l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679425251"><span id="local-6989586621679425253"><span id="local-6989586621679425255"><span id="local-6989586621679425257"><span id="local-6989586621679425259"><span id="local-6989586621679425261"><span id="local-6989586621679425263"><span id="local-6989586621679425265"><span id="local-6989586621679425267"><span id="local-6989586621679425273"><span id="local-6989586621679425275"><span id="local-6989586621679425277"><span id="local-6989586621679425301"><span id="local-6989586621679425325"><span class="annot"><span class="annottext">RPat l -&gt; DataType
RPat l -&gt; Constr
forall {l}. Data l =&gt; Typeable (RPat l)
forall l. Data l =&gt; RPat l -&gt; DataType
forall l. Data l =&gt; RPat l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; RPat l -&gt; RPat l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RPat l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RPat l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPat l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPat l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPat l -&gt; m (RPat l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPat l -&gt; m (RPat l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RPat l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RPat l -&gt; c (RPat l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RPat l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (RPat l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RPat l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RPat l -&gt; c (RPat l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RPat l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPat l -&gt; m (RPat l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPat l -&gt; m (RPat l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPat l -&gt; m (RPat l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPat l -&gt; m (RPat l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPat l -&gt; m (RPat l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; RPat l -&gt; m (RPat l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RPat l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RPat l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; RPat l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; RPat l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPat l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPat l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPat l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; RPat l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; RPat l -&gt; RPat l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; RPat l -&gt; RPat l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (RPat l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (RPat l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RPat l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (RPat l))
dataTypeOf :: RPat l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; RPat l -&gt; DataType
toConstr :: RPat l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; RPat l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RPat l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (RPat l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RPat l -&gt; c (RPat l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; RPat l -&gt; c (RPat l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425158"><span id="local-6989586621679425160"><span id="local-6989586621679425162"><span id="local-6989586621679425164"><span id="local-6989586621679425166"><span id="local-6989586621679425168"><span id="local-6989586621679425170"><span id="local-6989586621679425172"><span id="local-6989586621679425174"><span id="local-6989586621679425176"><span id="local-6989586621679425178"><span id="local-6989586621679425180"><span id="local-6989586621679425182"><span id="local-6989586621679425199"><span id="local-6989586621679425201"><span id="local-6989586621679425247"><span id="local-6989586621679425249"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; RPat a -&gt; Bool
forall a. Num a =&gt; RPat a -&gt; a
forall a. Ord a =&gt; RPat a -&gt; a
forall m. Monoid m =&gt; RPat m -&gt; m
forall a. RPat a -&gt; Bool
forall a. RPat a -&gt; Int
forall a. RPat a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; RPat a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RPat a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RPat a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RPat a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; RPat a -&gt; a
$cproduct :: forall a. Num a =&gt; RPat a -&gt; a
sum :: forall a. Num a =&gt; RPat a -&gt; a
$csum :: forall a. Num a =&gt; RPat a -&gt; a
minimum :: forall a. Ord a =&gt; RPat a -&gt; a
$cminimum :: forall a. Ord a =&gt; RPat a -&gt; a
maximum :: forall a. Ord a =&gt; RPat a -&gt; a
$cmaximum :: forall a. Ord a =&gt; RPat a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; RPat a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; RPat a -&gt; Bool
length :: forall a. RPat a -&gt; Int
$clength :: forall a. RPat a -&gt; Int
null :: forall a. RPat a -&gt; Bool
$cnull :: forall a. RPat a -&gt; Bool
toList :: forall a. RPat a -&gt; [a]
$ctoList :: forall a. RPat a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; RPat a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; RPat a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; RPat a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; RPat a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RPat a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RPat a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RPat a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; RPat a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RPat a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RPat a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RPat a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; RPat a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RPat a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RPat a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RPat a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; RPat a -&gt; m
fold :: forall m. Monoid m =&gt; RPat m -&gt; m
$cfold :: forall m. Monoid m =&gt; RPat m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425102"><span id="local-6989586621679425104"><span id="local-6989586621679425106"><span id="local-6989586621679425152"><span class="annot"><span class="annottext">Functor RPat
Foldable RPat
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; RPat (m a) -&gt; m (RPat a)
forall (f :: * -&gt; *) a. Applicative f =&gt; RPat (f a) -&gt; f (RPat a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; RPat a -&gt; m (RPat b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; RPat a -&gt; f (RPat b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; RPat (m a) -&gt; m (RPat a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; RPat (m a) -&gt; m (RPat a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; RPat a -&gt; m (RPat b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; RPat a -&gt; m (RPat b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; RPat (f a) -&gt; f (RPat a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; RPat (f a) -&gt; f (RPat a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; RPat a -&gt; f (RPat b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; RPat a -&gt; f (RPat b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425083"><span id="local-6989586621679425100"><span class="annot"><span class="annottext">forall a b. a -&gt; RPat b -&gt; RPat a
forall a b. (a -&gt; b) -&gt; RPat a -&gt; RPat b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; RPat b -&gt; RPat a
$c&lt;$ :: forall a b. a -&gt; RPat b -&gt; RPat a
fmap :: forall a b. (a -&gt; b) -&gt; RPat a -&gt; RPat b
$cfmap :: forall a b. (a -&gt; b) -&gt; RPat a -&gt; RPat b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (RPat l) x -&gt; RPat l
forall l x. RPat l -&gt; Rep (RPat l) x
$cto :: forall l x. Rep (RPat l) x -&gt; RPat l
$cfrom :: forall l x. RPat l -&gt; Rep (RPat l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-960"></span><span>
</span><span id="line-961"></span><span class="hs-comment">-- | An /fpat/ in a labeled record pattern.</span><span>
</span><span id="line-962"></span><span id="local-6989586621679425063"><span id="local-6989586621679425064"></span></span><span class="hs-keyword">data</span><span> </span><span id="PatField"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatField"><span class="hs-identifier hs-var">PatField</span></a></span></span><span> </span><span id="local-6989586621679452491"><span class="annot"><a href="#local-6989586621679452491"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-963"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="PFieldPat"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PFieldPat"><span class="hs-identifier hs-var">PFieldPat</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452491"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452491"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452491"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- ^ ordinary label-pattern pair</span><span>
</span><span id="line-964"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PFieldPun"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PFieldPun"><span class="hs-identifier hs-var">PFieldPun</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452491"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452491"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- ^ record field pun</span><span>
</span><span id="line-965"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="PFieldWildcard"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PFieldWildcard"><span class="hs-identifier hs-var">PFieldWildcard</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452491"><span class="hs-identifier hs-type">l</span></a></span><span>                  </span><span class="hs-comment">-- ^ record field wildcard</span><span>
</span><span id="line-966"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679425050"><span id="local-6989586621679425058"><span class="annot"><span class="annottext">PatField l -&gt; PatField l -&gt; Bool
forall l. Eq l =&gt; PatField l -&gt; PatField l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: PatField l -&gt; PatField l -&gt; Bool
$c/= :: forall l. Eq l =&gt; PatField l -&gt; PatField l -&gt; Bool
== :: PatField l -&gt; PatField l -&gt; Bool
$c== :: forall l. Eq l =&gt; PatField l -&gt; PatField l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425019"><span id="local-6989586621679425021"><span id="local-6989586621679425024"><span id="local-6989586621679425027"><span id="local-6989586621679425030"><span id="local-6989586621679425038"><span id="local-6989586621679425046"><span class="annot"><span class="annottext">PatField l -&gt; PatField l -&gt; Bool
PatField l -&gt; PatField l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (PatField l)
forall l. Ord l =&gt; PatField l -&gt; PatField l -&gt; Bool
forall l. Ord l =&gt; PatField l -&gt; PatField l -&gt; Ordering
forall l. Ord l =&gt; PatField l -&gt; PatField l -&gt; PatField l
min :: PatField l -&gt; PatField l -&gt; PatField l
$cmin :: forall l. Ord l =&gt; PatField l -&gt; PatField l -&gt; PatField l
max :: PatField l -&gt; PatField l -&gt; PatField l
$cmax :: forall l. Ord l =&gt; PatField l -&gt; PatField l -&gt; PatField l
&gt;= :: PatField l -&gt; PatField l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; PatField l -&gt; PatField l -&gt; Bool
&gt; :: PatField l -&gt; PatField l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; PatField l -&gt; PatField l -&gt; Bool
&lt;= :: PatField l -&gt; PatField l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; PatField l -&gt; PatField l -&gt; Bool
&lt; :: PatField l -&gt; PatField l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; PatField l -&gt; PatField l -&gt; Bool
compare :: PatField l -&gt; PatField l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; PatField l -&gt; PatField l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679425004"><span id="local-6989586621679425006"><span id="local-6989586621679425017"><span class="annot"><span class="annottext">Int -&gt; PatField l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; PatField l -&gt; ShowS
forall l. Show l =&gt; [PatField l] -&gt; ShowS
forall l. Show l =&gt; PatField l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [PatField l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [PatField l] -&gt; ShowS
show :: PatField l -&gt; String
$cshow :: forall l. Show l =&gt; PatField l -&gt; String
showsPrec :: Int -&gt; PatField l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; PatField l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679424957"><span id="local-6989586621679424959"><span id="local-6989586621679424961"><span id="local-6989586621679424963"><span id="local-6989586621679424965"><span id="local-6989586621679424967"><span id="local-6989586621679424969"><span id="local-6989586621679424971"><span id="local-6989586621679424973"><span id="local-6989586621679424979"><span id="local-6989586621679424981"><span id="local-6989586621679424983"><span id="local-6989586621679424991"><span id="local-6989586621679424999"><span class="annot"><span class="annottext">PatField l -&gt; DataType
PatField l -&gt; Constr
forall {l}. Data l =&gt; Typeable (PatField l)
forall l. Data l =&gt; PatField l -&gt; DataType
forall l. Data l =&gt; PatField l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; PatField l -&gt; PatField l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatField l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; PatField l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatField l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatField l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatField l -&gt; m (PatField l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatField l -&gt; m (PatField l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PatField l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PatField l -&gt; c (PatField l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PatField l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (PatField l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PatField l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PatField l -&gt; c (PatField l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PatField l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatField l -&gt; m (PatField l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatField l -&gt; m (PatField l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatField l -&gt; m (PatField l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatField l -&gt; m (PatField l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatField l -&gt; m (PatField l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; PatField l -&gt; m (PatField l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatField l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; PatField l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; PatField l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; PatField l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatField l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatField l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatField l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; PatField l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; PatField l -&gt; PatField l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; PatField l -&gt; PatField l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (PatField l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (PatField l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PatField l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (PatField l))
dataTypeOf :: PatField l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; PatField l -&gt; DataType
toConstr :: PatField l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; PatField l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PatField l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (PatField l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PatField l -&gt; c (PatField l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; PatField l -&gt; c (PatField l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424910"><span id="local-6989586621679424912"><span id="local-6989586621679424914"><span id="local-6989586621679424916"><span id="local-6989586621679424918"><span id="local-6989586621679424920"><span id="local-6989586621679424922"><span id="local-6989586621679424924"><span id="local-6989586621679424926"><span id="local-6989586621679424928"><span id="local-6989586621679424930"><span id="local-6989586621679424932"><span id="local-6989586621679424934"><span id="local-6989586621679424939"><span id="local-6989586621679424941"><span id="local-6989586621679424953"><span id="local-6989586621679424955"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; PatField a -&gt; Bool
forall a. Num a =&gt; PatField a -&gt; a
forall a. Ord a =&gt; PatField a -&gt; a
forall m. Monoid m =&gt; PatField m -&gt; m
forall a. PatField a -&gt; Bool
forall a. PatField a -&gt; Int
forall a. PatField a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; PatField a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PatField a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PatField a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PatField a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; PatField a -&gt; a
$cproduct :: forall a. Num a =&gt; PatField a -&gt; a
sum :: forall a. Num a =&gt; PatField a -&gt; a
$csum :: forall a. Num a =&gt; PatField a -&gt; a
minimum :: forall a. Ord a =&gt; PatField a -&gt; a
$cminimum :: forall a. Ord a =&gt; PatField a -&gt; a
maximum :: forall a. Ord a =&gt; PatField a -&gt; a
$cmaximum :: forall a. Ord a =&gt; PatField a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; PatField a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; PatField a -&gt; Bool
length :: forall a. PatField a -&gt; Int
$clength :: forall a. PatField a -&gt; Int
null :: forall a. PatField a -&gt; Bool
$cnull :: forall a. PatField a -&gt; Bool
toList :: forall a. PatField a -&gt; [a]
$ctoList :: forall a. PatField a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; PatField a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; PatField a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; PatField a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; PatField a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PatField a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PatField a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PatField a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; PatField a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PatField a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PatField a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PatField a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; PatField a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PatField a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PatField a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PatField a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; PatField a -&gt; m
fold :: forall m. Monoid m =&gt; PatField m -&gt; m
$cfold :: forall m. Monoid m =&gt; PatField m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424886"><span id="local-6989586621679424888"><span id="local-6989586621679424890"><span id="local-6989586621679424904"><span class="annot"><span class="annottext">Functor PatField
Foldable PatField
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; PatField (m a) -&gt; m (PatField a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
PatField (f a) -&gt; f (PatField a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PatField a -&gt; m (PatField b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PatField a -&gt; f (PatField b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; PatField (m a) -&gt; m (PatField a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; PatField (m a) -&gt; m (PatField a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PatField a -&gt; m (PatField b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; PatField a -&gt; m (PatField b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
PatField (f a) -&gt; f (PatField a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
PatField (f a) -&gt; f (PatField a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PatField a -&gt; f (PatField b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; PatField a -&gt; f (PatField b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424879"><span id="local-6989586621679424884"><span class="annot"><span class="annottext">forall a b. a -&gt; PatField b -&gt; PatField a
forall a b. (a -&gt; b) -&gt; PatField a -&gt; PatField b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; PatField b -&gt; PatField a
$c&lt;$ :: forall a b. a -&gt; PatField b -&gt; PatField a
fmap :: forall a b. (a -&gt; b) -&gt; PatField a -&gt; PatField b
$cfmap :: forall a b. (a -&gt; b) -&gt; PatField a -&gt; PatField b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (PatField l) x -&gt; PatField l
forall l x. PatField l -&gt; Rep (PatField l) x
$cto :: forall l x. Rep (PatField l) x -&gt; PatField l
$cfrom :: forall l x. PatField l -&gt; Rep (PatField l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-967"></span><span>
</span><span id="line-968"></span><span class="hs-comment">-- | A statement, representing both a /stmt/ in a @do@-expression,</span><span>
</span><span id="line-969"></span><span class="hs-comment">--   an ordinary /qual/ in a list comprehension, as well as a /stmt/</span><span>
</span><span id="line-970"></span><span class="hs-comment">--   in a pattern guard.</span><span>
</span><span id="line-971"></span><span id="local-6989586621679424871"><span id="local-6989586621679424872"></span></span><span class="hs-keyword">data</span><span> </span><span id="Stmt"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-var">Stmt</span></a></span></span><span> </span><span id="local-6989586621679452599"><span class="annot"><a href="#local-6989586621679452599"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-972"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="Generator"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Generator"><span class="hs-identifier hs-var">Generator</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452599"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452599"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452599"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-973"></span><span>                            </span><span class="hs-comment">-- ^ a generator: /pat/ @&lt;-@ /exp/</span><span>
</span><span id="line-974"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="Qualifier"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Qualifier"><span class="hs-identifier hs-var">Qualifier</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452599"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452599"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- ^ an /exp/ by itself: in a @do@-expression,</span><span>
</span><span id="line-975"></span><span>                            </span><span class="hs-comment">--   an action whose result is discarded;</span><span>
</span><span id="line-976"></span><span>                            </span><span class="hs-comment">--   in a list comprehension and pattern guard,</span><span>
</span><span id="line-977"></span><span>                            </span><span class="hs-comment">--   a guard expression</span><span>
</span><span id="line-978"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="LetStmt"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LetStmt"><span class="hs-identifier hs-var">LetStmt</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452599"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Binds"><span class="hs-identifier hs-type">Binds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452599"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- ^ local bindings</span><span>
</span><span id="line-979"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="RecStmt"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecStmt"><span class="hs-identifier hs-var">RecStmt</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452599"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452599"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">]</span><span>    </span><span class="hs-comment">-- ^ a recursive binding group for arrows</span><span>
</span><span id="line-980"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679424853"><span id="local-6989586621679424865"><span class="annot"><span class="annottext">Stmt l -&gt; Stmt l -&gt; Bool
forall l. Eq l =&gt; Stmt l -&gt; Stmt l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Stmt l -&gt; Stmt l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Stmt l -&gt; Stmt l -&gt; Bool
== :: Stmt l -&gt; Stmt l -&gt; Bool
$c== :: forall l. Eq l =&gt; Stmt l -&gt; Stmt l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424827"><span id="local-6989586621679424829"><span id="local-6989586621679424831"><span id="local-6989586621679424833"><span id="local-6989586621679424835"><span id="local-6989586621679424837"><span id="local-6989586621679424849"><span class="annot"><span class="annottext">Stmt l -&gt; Stmt l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Stmt l)
forall l. Ord l =&gt; Stmt l -&gt; Stmt l -&gt; Bool
forall l. Ord l =&gt; Stmt l -&gt; Stmt l -&gt; Ordering
forall l. Ord l =&gt; Stmt l -&gt; Stmt l -&gt; Stmt l
min :: Stmt l -&gt; Stmt l -&gt; Stmt l
$cmin :: forall l. Ord l =&gt; Stmt l -&gt; Stmt l -&gt; Stmt l
max :: Stmt l -&gt; Stmt l -&gt; Stmt l
$cmax :: forall l. Ord l =&gt; Stmt l -&gt; Stmt l -&gt; Stmt l
&gt;= :: Stmt l -&gt; Stmt l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Stmt l -&gt; Stmt l -&gt; Bool
&gt; :: Stmt l -&gt; Stmt l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Stmt l -&gt; Stmt l -&gt; Bool
&lt;= :: Stmt l -&gt; Stmt l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Stmt l -&gt; Stmt l -&gt; Bool
&lt; :: Stmt l -&gt; Stmt l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Stmt l -&gt; Stmt l -&gt; Bool
compare :: Stmt l -&gt; Stmt l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Stmt l -&gt; Stmt l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424807"><span id="local-6989586621679424809"><span id="local-6989586621679424825"><span class="annot"><span class="annottext">Int -&gt; Stmt l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Stmt l -&gt; ShowS
forall l. Show l =&gt; [Stmt l] -&gt; ShowS
forall l. Show l =&gt; Stmt l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Stmt l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Stmt l] -&gt; ShowS
show :: Stmt l -&gt; String
$cshow :: forall l. Show l =&gt; Stmt l -&gt; String
showsPrec :: Int -&gt; Stmt l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Stmt l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679424752"><span id="local-6989586621679424754"><span id="local-6989586621679424756"><span id="local-6989586621679424758"><span id="local-6989586621679424760"><span id="local-6989586621679424762"><span id="local-6989586621679424764"><span id="local-6989586621679424766"><span id="local-6989586621679424768"><span id="local-6989586621679424774"><span id="local-6989586621679424776"><span id="local-6989586621679424778"><span id="local-6989586621679424790"><span id="local-6989586621679424802"><span class="annot"><span class="annottext">Stmt l -&gt; DataType
Stmt l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Stmt l)
forall l. Data l =&gt; Stmt l -&gt; DataType
forall l. Data l =&gt; Stmt l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Stmt l -&gt; Stmt l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt l -&gt; m (Stmt l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt l -&gt; m (Stmt l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Stmt l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Stmt l -&gt; c (Stmt l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Stmt l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Stmt l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Stmt l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Stmt l -&gt; c (Stmt l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Stmt l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt l -&gt; m (Stmt l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt l -&gt; m (Stmt l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt l -&gt; m (Stmt l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt l -&gt; m (Stmt l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt l -&gt; m (Stmt l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Stmt l -&gt; m (Stmt l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Stmt l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Stmt l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Stmt l -&gt; Stmt l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; Stmt l -&gt; Stmt l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Stmt l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Stmt l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Stmt l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Stmt l))
dataTypeOf :: Stmt l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Stmt l -&gt; DataType
toConstr :: Stmt l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Stmt l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Stmt l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Stmt l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Stmt l -&gt; c (Stmt l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Stmt l -&gt; c (Stmt l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424694"><span id="local-6989586621679424696"><span id="local-6989586621679424698"><span id="local-6989586621679424700"><span id="local-6989586621679424702"><span id="local-6989586621679424704"><span id="local-6989586621679424706"><span id="local-6989586621679424708"><span id="local-6989586621679424710"><span id="local-6989586621679424712"><span id="local-6989586621679424714"><span id="local-6989586621679424716"><span id="local-6989586621679424718"><span id="local-6989586621679424726"><span id="local-6989586621679424728"><span id="local-6989586621679424748"><span id="local-6989586621679424750"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Stmt a -&gt; Bool
forall a. Num a =&gt; Stmt a -&gt; a
forall a. Ord a =&gt; Stmt a -&gt; a
forall m. Monoid m =&gt; Stmt m -&gt; m
forall a. Stmt a -&gt; Bool
forall a. Stmt a -&gt; Int
forall a. Stmt a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Stmt a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Stmt a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Stmt a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Stmt a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Stmt a -&gt; a
$cproduct :: forall a. Num a =&gt; Stmt a -&gt; a
sum :: forall a. Num a =&gt; Stmt a -&gt; a
$csum :: forall a. Num a =&gt; Stmt a -&gt; a
minimum :: forall a. Ord a =&gt; Stmt a -&gt; a
$cminimum :: forall a. Ord a =&gt; Stmt a -&gt; a
maximum :: forall a. Ord a =&gt; Stmt a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Stmt a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Stmt a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Stmt a -&gt; Bool
length :: forall a. Stmt a -&gt; Int
$clength :: forall a. Stmt a -&gt; Int
null :: forall a. Stmt a -&gt; Bool
$cnull :: forall a. Stmt a -&gt; Bool
toList :: forall a. Stmt a -&gt; [a]
$ctoList :: forall a. Stmt a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Stmt a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Stmt a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Stmt a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Stmt a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Stmt a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Stmt a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Stmt a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Stmt a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Stmt a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Stmt a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Stmt a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Stmt a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Stmt a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Stmt a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Stmt a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Stmt a -&gt; m
fold :: forall m. Monoid m =&gt; Stmt m -&gt; m
$cfold :: forall m. Monoid m =&gt; Stmt m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424664"><span id="local-6989586621679424666"><span id="local-6989586621679424668"><span id="local-6989586621679424688"><span class="annot"><span class="annottext">Functor Stmt
Foldable Stmt
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Stmt (m a) -&gt; m (Stmt a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Stmt (f a) -&gt; f (Stmt a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Stmt a -&gt; m (Stmt b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Stmt a -&gt; f (Stmt b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Stmt (m a) -&gt; m (Stmt a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Stmt (m a) -&gt; m (Stmt a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Stmt a -&gt; m (Stmt b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Stmt a -&gt; m (Stmt b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Stmt (f a) -&gt; f (Stmt a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Stmt (f a) -&gt; f (Stmt a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Stmt a -&gt; f (Stmt b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Stmt a -&gt; f (Stmt b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424654"><span id="local-6989586621679424662"><span class="annot"><span class="annottext">forall a b. a -&gt; Stmt b -&gt; Stmt a
forall a b. (a -&gt; b) -&gt; Stmt a -&gt; Stmt b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Stmt b -&gt; Stmt a
$c&lt;$ :: forall a b. a -&gt; Stmt b -&gt; Stmt a
fmap :: forall a b. (a -&gt; b) -&gt; Stmt a -&gt; Stmt b
$cfmap :: forall a b. (a -&gt; b) -&gt; Stmt a -&gt; Stmt b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Stmt l) x -&gt; Stmt l
forall l x. Stmt l -&gt; Rep (Stmt l) x
$cto :: forall l x. Rep (Stmt l) x -&gt; Stmt l
$cfrom :: forall l x. Stmt l -&gt; Rep (Stmt l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-981"></span><span>
</span><span id="line-982"></span><span class="hs-comment">-- | A general /transqual/ in a list comprehension,</span><span>
</span><span id="line-983"></span><span class="hs-comment">--   which could potentially be a transform of the kind</span><span>
</span><span id="line-984"></span><span class="hs-comment">--   enabled by TransformListComp.</span><span>
</span><span id="line-985"></span><span id="local-6989586621679424643"><span id="local-6989586621679424644"></span></span><span class="hs-keyword">data</span><span> </span><span id="QualStmt"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualStmt"><span class="hs-identifier hs-var">QualStmt</span></a></span></span><span> </span><span id="local-6989586621679452546"><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-986"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="QualStmt"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualStmt"><span class="hs-identifier hs-var">QualStmt</span></a></span></span><span>     </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- ^ an ordinary statement</span><span>
</span><span id="line-987"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ThenTrans"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ThenTrans"><span class="hs-identifier hs-var">ThenTrans</span></a></span></span><span>    </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>          </span><span class="hs-comment">-- ^ @then@ /exp/</span><span>
</span><span id="line-988"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="ThenBy"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ThenBy"><span class="hs-identifier hs-var">ThenBy</span></a></span></span><span>       </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- ^ @then@ /exp/ @by@ /exp/</span><span>
</span><span id="line-989"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="GroupBy"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GroupBy"><span class="hs-identifier hs-var">GroupBy</span></a></span></span><span>      </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>          </span><span class="hs-comment">-- ^ @then@ @group@ @by@ /exp/</span><span>
</span><span id="line-990"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="GroupUsing"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GroupUsing"><span class="hs-identifier hs-var">GroupUsing</span></a></span></span><span>   </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>          </span><span class="hs-comment">-- ^ @then@ @group@ @using@ /exp/</span><span>
</span><span id="line-991"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="GroupByUsing"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GroupByUsing"><span class="hs-identifier hs-var">GroupByUsing</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452546"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- ^ @then@ @group@ @by@ /exp/ @using@ /exp/</span><span>
</span><span id="line-992"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679424619"><span id="local-6989586621679424635"><span class="annot"><span class="annottext">QualStmt l -&gt; QualStmt l -&gt; Bool
forall l. Eq l =&gt; QualStmt l -&gt; QualStmt l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: QualStmt l -&gt; QualStmt l -&gt; Bool
$c/= :: forall l. Eq l =&gt; QualStmt l -&gt; QualStmt l -&gt; Bool
== :: QualStmt l -&gt; QualStmt l -&gt; Bool
$c== :: forall l. Eq l =&gt; QualStmt l -&gt; QualStmt l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424589"><span id="local-6989586621679424591"><span id="local-6989586621679424593"><span id="local-6989586621679424595"><span id="local-6989586621679424597"><span id="local-6989586621679424599"><span id="local-6989586621679424615"><span class="annot"><span class="annottext">QualStmt l -&gt; QualStmt l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (QualStmt l)
forall l. Ord l =&gt; QualStmt l -&gt; QualStmt l -&gt; Bool
forall l. Ord l =&gt; QualStmt l -&gt; QualStmt l -&gt; Ordering
forall l. Ord l =&gt; QualStmt l -&gt; QualStmt l -&gt; QualStmt l
min :: QualStmt l -&gt; QualStmt l -&gt; QualStmt l
$cmin :: forall l. Ord l =&gt; QualStmt l -&gt; QualStmt l -&gt; QualStmt l
max :: QualStmt l -&gt; QualStmt l -&gt; QualStmt l
$cmax :: forall l. Ord l =&gt; QualStmt l -&gt; QualStmt l -&gt; QualStmt l
&gt;= :: QualStmt l -&gt; QualStmt l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; QualStmt l -&gt; QualStmt l -&gt; Bool
&gt; :: QualStmt l -&gt; QualStmt l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; QualStmt l -&gt; QualStmt l -&gt; Bool
&lt;= :: QualStmt l -&gt; QualStmt l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; QualStmt l -&gt; QualStmt l -&gt; Bool
&lt; :: QualStmt l -&gt; QualStmt l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; QualStmt l -&gt; QualStmt l -&gt; Bool
compare :: QualStmt l -&gt; QualStmt l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; QualStmt l -&gt; QualStmt l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424563"><span id="local-6989586621679424565"><span id="local-6989586621679424587"><span class="annot"><span class="annottext">Int -&gt; QualStmt l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; QualStmt l -&gt; ShowS
forall l. Show l =&gt; [QualStmt l] -&gt; ShowS
forall l. Show l =&gt; QualStmt l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [QualStmt l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [QualStmt l] -&gt; ShowS
show :: QualStmt l -&gt; String
$cshow :: forall l. Show l =&gt; QualStmt l -&gt; String
showsPrec :: Int -&gt; QualStmt l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; QualStmt l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679424500"><span id="local-6989586621679424502"><span id="local-6989586621679424504"><span id="local-6989586621679424506"><span id="local-6989586621679424508"><span id="local-6989586621679424510"><span id="local-6989586621679424512"><span id="local-6989586621679424514"><span id="local-6989586621679424516"><span id="local-6989586621679424522"><span id="local-6989586621679424524"><span id="local-6989586621679424526"><span id="local-6989586621679424542"><span id="local-6989586621679424558"><span class="annot"><span class="annottext">QualStmt l -&gt; DataType
QualStmt l -&gt; Constr
forall {l}. Data l =&gt; Typeable (QualStmt l)
forall l. Data l =&gt; QualStmt l -&gt; DataType
forall l. Data l =&gt; QualStmt l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; QualStmt l -&gt; QualStmt l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QualStmt l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; QualStmt l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualStmt l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualStmt l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QualStmt l -&gt; m (QualStmt l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QualStmt l -&gt; m (QualStmt l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QualStmt l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QualStmt l -&gt; c (QualStmt l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QualStmt l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (QualStmt l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QualStmt l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QualStmt l -&gt; c (QualStmt l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QualStmt l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QualStmt l -&gt; m (QualStmt l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QualStmt l -&gt; m (QualStmt l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QualStmt l -&gt; m (QualStmt l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QualStmt l -&gt; m (QualStmt l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QualStmt l -&gt; m (QualStmt l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; QualStmt l -&gt; m (QualStmt l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QualStmt l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; QualStmt l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; QualStmt l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; QualStmt l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualStmt l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualStmt l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualStmt l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; QualStmt l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; QualStmt l -&gt; QualStmt l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; QualStmt l -&gt; QualStmt l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (QualStmt l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (QualStmt l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QualStmt l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (QualStmt l))
dataTypeOf :: QualStmt l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; QualStmt l -&gt; DataType
toConstr :: QualStmt l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; QualStmt l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QualStmt l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (QualStmt l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QualStmt l -&gt; c (QualStmt l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; QualStmt l -&gt; c (QualStmt l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424433"><span id="local-6989586621679424435"><span id="local-6989586621679424437"><span id="local-6989586621679424439"><span id="local-6989586621679424441"><span id="local-6989586621679424443"><span id="local-6989586621679424445"><span id="local-6989586621679424447"><span id="local-6989586621679424449"><span id="local-6989586621679424451"><span id="local-6989586621679424453"><span id="local-6989586621679424455"><span id="local-6989586621679424457"><span id="local-6989586621679424467"><span id="local-6989586621679424469"><span id="local-6989586621679424496"><span id="local-6989586621679424498"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; QualStmt a -&gt; Bool
forall a. Num a =&gt; QualStmt a -&gt; a
forall a. Ord a =&gt; QualStmt a -&gt; a
forall m. Monoid m =&gt; QualStmt m -&gt; m
forall a. QualStmt a -&gt; Bool
forall a. QualStmt a -&gt; Int
forall a. QualStmt a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; QualStmt a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QualStmt a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QualStmt a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QualStmt a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; QualStmt a -&gt; a
$cproduct :: forall a. Num a =&gt; QualStmt a -&gt; a
sum :: forall a. Num a =&gt; QualStmt a -&gt; a
$csum :: forall a. Num a =&gt; QualStmt a -&gt; a
minimum :: forall a. Ord a =&gt; QualStmt a -&gt; a
$cminimum :: forall a. Ord a =&gt; QualStmt a -&gt; a
maximum :: forall a. Ord a =&gt; QualStmt a -&gt; a
$cmaximum :: forall a. Ord a =&gt; QualStmt a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; QualStmt a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; QualStmt a -&gt; Bool
length :: forall a. QualStmt a -&gt; Int
$clength :: forall a. QualStmt a -&gt; Int
null :: forall a. QualStmt a -&gt; Bool
$cnull :: forall a. QualStmt a -&gt; Bool
toList :: forall a. QualStmt a -&gt; [a]
$ctoList :: forall a. QualStmt a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; QualStmt a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; QualStmt a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; QualStmt a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; QualStmt a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QualStmt a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QualStmt a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QualStmt a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; QualStmt a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QualStmt a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QualStmt a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QualStmt a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; QualStmt a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QualStmt a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QualStmt a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QualStmt a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; QualStmt a -&gt; m
fold :: forall m. Monoid m =&gt; QualStmt m -&gt; m
$cfold :: forall m. Monoid m =&gt; QualStmt m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424396"><span id="local-6989586621679424398"><span id="local-6989586621679424400"><span id="local-6989586621679424427"><span class="annot"><span class="annottext">Functor QualStmt
Foldable QualStmt
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; QualStmt (m a) -&gt; m (QualStmt a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
QualStmt (f a) -&gt; f (QualStmt a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QualStmt a -&gt; m (QualStmt b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QualStmt a -&gt; f (QualStmt b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; QualStmt (m a) -&gt; m (QualStmt a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; QualStmt (m a) -&gt; m (QualStmt a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QualStmt a -&gt; m (QualStmt b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; QualStmt a -&gt; m (QualStmt b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
QualStmt (f a) -&gt; f (QualStmt a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
QualStmt (f a) -&gt; f (QualStmt a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QualStmt a -&gt; f (QualStmt b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; QualStmt a -&gt; f (QualStmt b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424384"><span id="local-6989586621679424394"><span class="annot"><span class="annottext">forall a b. a -&gt; QualStmt b -&gt; QualStmt a
forall a b. (a -&gt; b) -&gt; QualStmt a -&gt; QualStmt b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; QualStmt b -&gt; QualStmt a
$c&lt;$ :: forall a b. a -&gt; QualStmt b -&gt; QualStmt a
fmap :: forall a b. (a -&gt; b) -&gt; QualStmt a -&gt; QualStmt b
$cfmap :: forall a b. (a -&gt; b) -&gt; QualStmt a -&gt; QualStmt b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (QualStmt l) x -&gt; QualStmt l
forall l x. QualStmt l -&gt; Rep (QualStmt l) x
$cto :: forall l x. Rep (QualStmt l) x -&gt; QualStmt l
$cfrom :: forall l x. QualStmt l -&gt; Rep (QualStmt l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-993"></span><span>
</span><span id="line-994"></span><span class="hs-comment">-- | An /fbind/ in a labeled construction or update expression.</span><span>
</span><span id="line-995"></span><span id="local-6989586621679424371"><span id="local-6989586621679424372"></span></span><span class="hs-keyword">data</span><span> </span><span id="FieldUpdate"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldUpdate"><span class="hs-identifier hs-var">FieldUpdate</span></a></span></span><span> </span><span id="local-6989586621679452547"><span class="annot"><a href="#local-6989586621679452547"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-996"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="FieldUpdate"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldUpdate"><span class="hs-identifier hs-var">FieldUpdate</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452547"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452547"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452547"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ ordinary label-expresion pair</span><span>
</span><span id="line-997"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="FieldPun"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldPun"><span class="hs-identifier hs-var">FieldPun</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452547"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452547"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>               </span><span class="hs-comment">-- ^ record field pun</span><span>
</span><span id="line-998"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="FieldWildcard"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldWildcard"><span class="hs-identifier hs-var">FieldWildcard</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452547"><span class="hs-identifier hs-type">l</span></a></span><span>                    </span><span class="hs-comment">-- ^ record field wildcard</span><span>
</span><span id="line-999"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679424358"><span id="local-6989586621679424366"><span class="annot"><span class="annottext">FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
forall l. Eq l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
$c/= :: forall l. Eq l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
== :: FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
$c== :: forall l. Eq l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424327"><span id="local-6989586621679424329"><span id="local-6989586621679424332"><span id="local-6989586621679424335"><span id="local-6989586621679424338"><span id="local-6989586621679424346"><span id="local-6989586621679424354"><span class="annot"><span class="annottext">FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
FieldUpdate l -&gt; FieldUpdate l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (FieldUpdate l)
forall l. Ord l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
forall l. Ord l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; Ordering
forall l. Ord l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; FieldUpdate l
min :: FieldUpdate l -&gt; FieldUpdate l -&gt; FieldUpdate l
$cmin :: forall l. Ord l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; FieldUpdate l
max :: FieldUpdate l -&gt; FieldUpdate l -&gt; FieldUpdate l
$cmax :: forall l. Ord l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; FieldUpdate l
&gt;= :: FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
&gt; :: FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
&lt;= :: FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
&lt; :: FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; Bool
compare :: FieldUpdate l -&gt; FieldUpdate l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; FieldUpdate l -&gt; FieldUpdate l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424312"><span id="local-6989586621679424314"><span id="local-6989586621679424325"><span class="annot"><span class="annottext">Int -&gt; FieldUpdate l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; FieldUpdate l -&gt; ShowS
forall l. Show l =&gt; [FieldUpdate l] -&gt; ShowS
forall l. Show l =&gt; FieldUpdate l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [FieldUpdate l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [FieldUpdate l] -&gt; ShowS
show :: FieldUpdate l -&gt; String
$cshow :: forall l. Show l =&gt; FieldUpdate l -&gt; String
showsPrec :: Int -&gt; FieldUpdate l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; FieldUpdate l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679424265"><span id="local-6989586621679424267"><span id="local-6989586621679424269"><span id="local-6989586621679424271"><span id="local-6989586621679424273"><span id="local-6989586621679424275"><span id="local-6989586621679424277"><span id="local-6989586621679424279"><span id="local-6989586621679424281"><span id="local-6989586621679424287"><span id="local-6989586621679424289"><span id="local-6989586621679424291"><span id="local-6989586621679424299"><span id="local-6989586621679424307"><span class="annot"><span class="annottext">FieldUpdate l -&gt; DataType
FieldUpdate l -&gt; Constr
forall {l}. Data l =&gt; Typeable (FieldUpdate l)
forall l. Data l =&gt; FieldUpdate l -&gt; DataType
forall l. Data l =&gt; FieldUpdate l -&gt; Constr
forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; FieldUpdate l -&gt; FieldUpdate l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldUpdate l -&gt; u
forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; FieldUpdate l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldUpdate l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldUpdate l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldUpdate l -&gt; m (FieldUpdate l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldUpdate l -&gt; m (FieldUpdate l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FieldUpdate l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldUpdate l -&gt; c (FieldUpdate l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FieldUpdate l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (FieldUpdate l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FieldUpdate l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldUpdate l -&gt; c (FieldUpdate l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FieldUpdate l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldUpdate l -&gt; m (FieldUpdate l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldUpdate l -&gt; m (FieldUpdate l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldUpdate l -&gt; m (FieldUpdate l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldUpdate l -&gt; m (FieldUpdate l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldUpdate l -&gt; m (FieldUpdate l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldUpdate l -&gt; m (FieldUpdate l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldUpdate l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldUpdate l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FieldUpdate l -&gt; [u]
$cgmapQ :: forall l u.
Data l =&gt;
(forall d. Data d =&gt; d -&gt; u) -&gt; FieldUpdate l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldUpdate l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldUpdate l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldUpdate l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldUpdate l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FieldUpdate l -&gt; FieldUpdate l
$cgmapT :: forall l.
Data l =&gt;
(forall b. Data b =&gt; b -&gt; b) -&gt; FieldUpdate l -&gt; FieldUpdate l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (FieldUpdate l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c (FieldUpdate l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FieldUpdate l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (FieldUpdate l))
dataTypeOf :: FieldUpdate l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; FieldUpdate l -&gt; DataType
toConstr :: FieldUpdate l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; FieldUpdate l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FieldUpdate l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (FieldUpdate l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldUpdate l -&gt; c (FieldUpdate l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldUpdate l -&gt; c (FieldUpdate l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424218"><span id="local-6989586621679424220"><span id="local-6989586621679424222"><span id="local-6989586621679424224"><span id="local-6989586621679424226"><span id="local-6989586621679424228"><span id="local-6989586621679424230"><span id="local-6989586621679424232"><span id="local-6989586621679424234"><span id="local-6989586621679424236"><span id="local-6989586621679424238"><span id="local-6989586621679424240"><span id="local-6989586621679424242"><span id="local-6989586621679424247"><span id="local-6989586621679424249"><span id="local-6989586621679424261"><span id="local-6989586621679424263"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; FieldUpdate a -&gt; Bool
forall a. Num a =&gt; FieldUpdate a -&gt; a
forall a. Ord a =&gt; FieldUpdate a -&gt; a
forall m. Monoid m =&gt; FieldUpdate m -&gt; m
forall a. FieldUpdate a -&gt; Bool
forall a. FieldUpdate a -&gt; Int
forall a. FieldUpdate a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; FieldUpdate a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FieldUpdate a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FieldUpdate a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FieldUpdate a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; FieldUpdate a -&gt; a
$cproduct :: forall a. Num a =&gt; FieldUpdate a -&gt; a
sum :: forall a. Num a =&gt; FieldUpdate a -&gt; a
$csum :: forall a. Num a =&gt; FieldUpdate a -&gt; a
minimum :: forall a. Ord a =&gt; FieldUpdate a -&gt; a
$cminimum :: forall a. Ord a =&gt; FieldUpdate a -&gt; a
maximum :: forall a. Ord a =&gt; FieldUpdate a -&gt; a
$cmaximum :: forall a. Ord a =&gt; FieldUpdate a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; FieldUpdate a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; FieldUpdate a -&gt; Bool
length :: forall a. FieldUpdate a -&gt; Int
$clength :: forall a. FieldUpdate a -&gt; Int
null :: forall a. FieldUpdate a -&gt; Bool
$cnull :: forall a. FieldUpdate a -&gt; Bool
toList :: forall a. FieldUpdate a -&gt; [a]
$ctoList :: forall a. FieldUpdate a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; FieldUpdate a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; FieldUpdate a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; FieldUpdate a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; FieldUpdate a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FieldUpdate a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FieldUpdate a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FieldUpdate a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; FieldUpdate a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FieldUpdate a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FieldUpdate a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FieldUpdate a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; FieldUpdate a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FieldUpdate a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FieldUpdate a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FieldUpdate a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; FieldUpdate a -&gt; m
fold :: forall m. Monoid m =&gt; FieldUpdate m -&gt; m
$cfold :: forall m. Monoid m =&gt; FieldUpdate m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424194"><span id="local-6989586621679424196"><span id="local-6989586621679424198"><span id="local-6989586621679424212"><span class="annot"><span class="annottext">Functor FieldUpdate
Foldable FieldUpdate
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a.
Monad m =&gt;
FieldUpdate (m a) -&gt; m (FieldUpdate a)
forall (f :: * -&gt; *) a.
Applicative f =&gt;
FieldUpdate (f a) -&gt; f (FieldUpdate a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; FieldUpdate a -&gt; m (FieldUpdate b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; FieldUpdate a -&gt; f (FieldUpdate b)
sequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
FieldUpdate (m a) -&gt; m (FieldUpdate a)
$csequence :: forall (m :: * -&gt; *) a.
Monad m =&gt;
FieldUpdate (m a) -&gt; m (FieldUpdate a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; FieldUpdate a -&gt; m (FieldUpdate b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; FieldUpdate a -&gt; m (FieldUpdate b)
sequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
FieldUpdate (f a) -&gt; f (FieldUpdate a)
$csequenceA :: forall (f :: * -&gt; *) a.
Applicative f =&gt;
FieldUpdate (f a) -&gt; f (FieldUpdate a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; FieldUpdate a -&gt; f (FieldUpdate b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; FieldUpdate a -&gt; f (FieldUpdate b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424187"><span id="local-6989586621679424192"><span class="annot"><span class="annottext">forall a b. a -&gt; FieldUpdate b -&gt; FieldUpdate a
forall a b. (a -&gt; b) -&gt; FieldUpdate a -&gt; FieldUpdate b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; FieldUpdate b -&gt; FieldUpdate a
$c&lt;$ :: forall a b. a -&gt; FieldUpdate b -&gt; FieldUpdate a
fmap :: forall a b. (a -&gt; b) -&gt; FieldUpdate a -&gt; FieldUpdate b
$cfmap :: forall a b. (a -&gt; b) -&gt; FieldUpdate a -&gt; FieldUpdate b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (FieldUpdate l) x -&gt; FieldUpdate l
forall l x. FieldUpdate l -&gt; Rep (FieldUpdate l) x
$cto :: forall l x. Rep (FieldUpdate l) x -&gt; FieldUpdate l
$cfrom :: forall l x. FieldUpdate l -&gt; Rep (FieldUpdate l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-1000"></span><span>
</span><span id="line-1001"></span><span class="hs-comment">-- | An /alt/ alternative in a @case@ expression.</span><span>
</span><span id="line-1002"></span><span id="local-6989586621679424179"><span id="local-6989586621679424180"></span></span><span class="hs-keyword">data</span><span> </span><span id="Alt"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Alt"><span class="hs-identifier hs-var">Alt</span></a></span></span><span> </span><span id="local-6989586621679452548"><span class="annot"><a href="#local-6989586621679452548"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1003"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="Alt"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Alt"><span class="hs-identifier hs-var">Alt</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679452548"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452548"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rhs"><span class="hs-identifier hs-type">Rhs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452548"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Binds"><span class="hs-identifier hs-type">Binds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452548"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1004"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679424169"><span id="local-6989586621679424176"><span class="annot"><span class="annottext">Alt l -&gt; Alt l -&gt; Bool
forall l. Eq l =&gt; Alt l -&gt; Alt l -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Alt l -&gt; Alt l -&gt; Bool
$c/= :: forall l. Eq l =&gt; Alt l -&gt; Alt l -&gt; Bool
== :: Alt l -&gt; Alt l -&gt; Bool
$c== :: forall l. Eq l =&gt; Alt l -&gt; Alt l -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424140"><span id="local-6989586621679424142"><span id="local-6989586621679424145"><span id="local-6989586621679424148"><span id="local-6989586621679424151"><span id="local-6989586621679424158"><span id="local-6989586621679424165"><span class="annot"><span class="annottext">Alt l -&gt; Alt l -&gt; Bool
Alt l -&gt; Alt l -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {l}. Ord l =&gt; Eq (Alt l)
forall l. Ord l =&gt; Alt l -&gt; Alt l -&gt; Bool
forall l. Ord l =&gt; Alt l -&gt; Alt l -&gt; Ordering
forall l. Ord l =&gt; Alt l -&gt; Alt l -&gt; Alt l
min :: Alt l -&gt; Alt l -&gt; Alt l
$cmin :: forall l. Ord l =&gt; Alt l -&gt; Alt l -&gt; Alt l
max :: Alt l -&gt; Alt l -&gt; Alt l
$cmax :: forall l. Ord l =&gt; Alt l -&gt; Alt l -&gt; Alt l
&gt;= :: Alt l -&gt; Alt l -&gt; Bool
$c&gt;= :: forall l. Ord l =&gt; Alt l -&gt; Alt l -&gt; Bool
&gt; :: Alt l -&gt; Alt l -&gt; Bool
$c&gt; :: forall l. Ord l =&gt; Alt l -&gt; Alt l -&gt; Bool
&lt;= :: Alt l -&gt; Alt l -&gt; Bool
$c&lt;= :: forall l. Ord l =&gt; Alt l -&gt; Alt l -&gt; Bool
&lt; :: Alt l -&gt; Alt l -&gt; Bool
$c&lt; :: forall l. Ord l =&gt; Alt l -&gt; Alt l -&gt; Bool
compare :: Alt l -&gt; Alt l -&gt; Ordering
$ccompare :: forall l. Ord l =&gt; Alt l -&gt; Alt l -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424128"><span id="local-6989586621679424130"><span id="local-6989586621679424138"><span class="annot"><span class="annottext">Int -&gt; Alt l -&gt; ShowS
forall l. Show l =&gt; Int -&gt; Alt l -&gt; ShowS
forall l. Show l =&gt; [Alt l] -&gt; ShowS
forall l. Show l =&gt; Alt l -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Alt l] -&gt; ShowS
$cshowList :: forall l. Show l =&gt; [Alt l] -&gt; ShowS
show :: Alt l -&gt; String
$cshow :: forall l. Show l =&gt; Alt l -&gt; String
showsPrec :: Int -&gt; Alt l -&gt; ShowS
$cshowsPrec :: forall l. Show l =&gt; Int -&gt; Alt l -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span id="local-6989586621679424083"><span id="local-6989586621679424085"><span id="local-6989586621679424087"><span id="local-6989586621679424089"><span id="local-6989586621679424091"><span id="local-6989586621679424093"><span id="local-6989586621679424095"><span id="local-6989586621679424097"><span id="local-6989586621679424099"><span id="local-6989586621679424105"><span id="local-6989586621679424107"><span id="local-6989586621679424109"><span id="local-6989586621679424116"><span id="local-6989586621679424123"><span class="annot"><span class="annottext">Alt l -&gt; DataType
Alt l -&gt; Constr
forall {l}. Data l =&gt; Typeable (Alt l)
forall l. Data l =&gt; Alt l -&gt; DataType
forall l. Data l =&gt; Alt l -&gt; Constr
forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; Alt l -&gt; Alt l
forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Alt l -&gt; u
forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Alt l -&gt; [u]
forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Alt l -&gt; r
forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Alt l -&gt; r
forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Alt l -&gt; m (Alt l)
forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Alt l -&gt; m (Alt l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Alt l)
forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Alt l -&gt; c (Alt l)
forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Alt l))
forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Alt l))
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Alt l)
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Alt l -&gt; c (Alt l)
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Alt l))
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Alt l -&gt; m (Alt l)
$cgmapMo :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Alt l -&gt; m (Alt l)
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Alt l -&gt; m (Alt l)
$cgmapMp :: forall l (m :: * -&gt; *).
(Data l, MonadPlus m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Alt l -&gt; m (Alt l)
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Alt l -&gt; m (Alt l)
$cgmapM :: forall l (m :: * -&gt; *).
(Data l, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Alt l -&gt; m (Alt l)
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Alt l -&gt; u
$cgmapQi :: forall l u.
Data l =&gt;
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Alt l -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Alt l -&gt; [u]
$cgmapQ :: forall l u. Data l =&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Alt l -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Alt l -&gt; r
$cgmapQr :: forall l r r'.
Data l =&gt;
(r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Alt l -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Alt l -&gt; r
$cgmapQl :: forall l r r'.
Data l =&gt;
(r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Alt l -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Alt l -&gt; Alt l
$cgmapT :: forall l. Data l =&gt; (forall b. Data b =&gt; b -&gt; b) -&gt; Alt l -&gt; Alt l
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Alt l))
$cdataCast2 :: forall l (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c (Alt l))
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Alt l))
$cdataCast1 :: forall l (t :: * -&gt; *) (c :: * -&gt; *).
(Data l, Typeable t) =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c (Alt l))
dataTypeOf :: Alt l -&gt; DataType
$cdataTypeOf :: forall l. Data l =&gt; Alt l -&gt; DataType
toConstr :: Alt l -&gt; Constr
$ctoConstr :: forall l. Data l =&gt; Alt l -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Alt l)
$cgunfold :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c (Alt l)
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Alt l -&gt; c (Alt l)
$cgfoldl :: forall l (c :: * -&gt; *).
Data l =&gt;
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Alt l -&gt; c (Alt l)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424033"><span id="local-6989586621679424035"><span id="local-6989586621679424037"><span id="local-6989586621679424039"><span id="local-6989586621679424041"><span id="local-6989586621679424043"><span id="local-6989586621679424045"><span id="local-6989586621679424047"><span id="local-6989586621679424049"><span id="local-6989586621679424051"><span id="local-6989586621679424053"><span id="local-6989586621679424055"><span id="local-6989586621679424057"><span id="local-6989586621679424063"><span id="local-6989586621679424065"><span id="local-6989586621679424079"><span id="local-6989586621679424081"><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; Alt a -&gt; Bool
forall a. Num a =&gt; Alt a -&gt; a
forall a. Ord a =&gt; Alt a -&gt; a
forall m. Monoid m =&gt; Alt m -&gt; m
forall a. Alt a -&gt; Bool
forall a. Alt a -&gt; Int
forall a. Alt a -&gt; [a]
forall a. (a -&gt; a -&gt; a) -&gt; Alt a -&gt; a
forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Alt a -&gt; m
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Alt a -&gt; b
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Alt a -&gt; b
forall (t :: * -&gt; *).
(forall m. Monoid m =&gt; t m -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall m a. Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a)
-&gt; (forall a. t a -&gt; [a])
-&gt; (forall a. t a -&gt; Bool)
-&gt; (forall a. t a -&gt; Int)
-&gt; (forall a. Eq a =&gt; a -&gt; t a -&gt; Bool)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Ord a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; (forall a. Num a =&gt; t a -&gt; a)
-&gt; Foldable t
product :: forall a. Num a =&gt; Alt a -&gt; a
$cproduct :: forall a. Num a =&gt; Alt a -&gt; a
sum :: forall a. Num a =&gt; Alt a -&gt; a
$csum :: forall a. Num a =&gt; Alt a -&gt; a
minimum :: forall a. Ord a =&gt; Alt a -&gt; a
$cminimum :: forall a. Ord a =&gt; Alt a -&gt; a
maximum :: forall a. Ord a =&gt; Alt a -&gt; a
$cmaximum :: forall a. Ord a =&gt; Alt a -&gt; a
elem :: forall a. Eq a =&gt; a -&gt; Alt a -&gt; Bool
$celem :: forall a. Eq a =&gt; a -&gt; Alt a -&gt; Bool
length :: forall a. Alt a -&gt; Int
$clength :: forall a. Alt a -&gt; Int
null :: forall a. Alt a -&gt; Bool
$cnull :: forall a. Alt a -&gt; Bool
toList :: forall a. Alt a -&gt; [a]
$ctoList :: forall a. Alt a -&gt; [a]
foldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Alt a -&gt; a
$cfoldl1 :: forall a. (a -&gt; a -&gt; a) -&gt; Alt a -&gt; a
foldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Alt a -&gt; a
$cfoldr1 :: forall a. (a -&gt; a -&gt; a) -&gt; Alt a -&gt; a
foldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Alt a -&gt; b
$cfoldl' :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Alt a -&gt; b
foldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Alt a -&gt; b
$cfoldl :: forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Alt a -&gt; b
foldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Alt a -&gt; b
$cfoldr' :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Alt a -&gt; b
foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Alt a -&gt; b
$cfoldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Alt a -&gt; b
foldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Alt a -&gt; m
$cfoldMap' :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Alt a -&gt; m
foldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Alt a -&gt; m
$cfoldMap :: forall m a. Monoid m =&gt; (a -&gt; m) -&gt; Alt a -&gt; m
fold :: forall m. Monoid m =&gt; Alt m -&gt; m
$cfold :: forall m. Monoid m =&gt; Alt m -&gt; m
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424009"><span id="local-6989586621679424011"><span id="local-6989586621679424013"><span id="local-6989586621679424027"><span class="annot"><span class="annottext">Functor Alt
Foldable Alt
forall (t :: * -&gt; *).
Functor t
-&gt; Foldable t
-&gt; (forall (f :: * -&gt; *) a b.
    Applicative f =&gt;
    (a -&gt; f b) -&gt; t a -&gt; f (t b))
-&gt; (forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a))
-&gt; (forall (m :: * -&gt; *) a b.
    Monad m =&gt;
    (a -&gt; m b) -&gt; t a -&gt; m (t b))
-&gt; (forall (m :: * -&gt; *) a. Monad m =&gt; t (m a) -&gt; m (t a))
-&gt; Traversable t
forall (m :: * -&gt; *) a. Monad m =&gt; Alt (m a) -&gt; m (Alt a)
forall (f :: * -&gt; *) a. Applicative f =&gt; Alt (f a) -&gt; f (Alt a)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Alt a -&gt; m (Alt b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Alt a -&gt; f (Alt b)
sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Alt (m a) -&gt; m (Alt a)
$csequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Alt (m a) -&gt; m (Alt a)
mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Alt a -&gt; m (Alt b)
$cmapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Alt a -&gt; m (Alt b)
sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Alt (f a) -&gt; f (Alt a)
$csequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Alt (f a) -&gt; f (Alt a)
traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Alt a -&gt; f (Alt b)
$ctraverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Alt a -&gt; f (Alt b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Traversable</span></span></span></span></span></span><span class="hs-special">,</span><span id="local-6989586621679424001"><span id="local-6989586621679424007"><span class="annot"><span class="annottext">forall a b. a -&gt; Alt b -&gt; Alt a
forall a b. (a -&gt; b) -&gt; Alt a -&gt; Alt b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: forall a b. a -&gt; Alt b -&gt; Alt a
$c&lt;$ :: forall a b. a -&gt; Alt b -&gt; Alt a
fmap :: forall a b. (a -&gt; b) -&gt; Alt a -&gt; Alt b
$cfmap :: forall a b. (a -&gt; b) -&gt; Alt a -&gt; Alt b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall l x. Rep (Alt l) x -&gt; Alt l
forall l x. Alt l -&gt; Rep (Alt l) x
$cto :: forall l x. Rep (Alt l) x -&gt; Alt l
$cfrom :: forall l x. Alt l -&gt; Rep (Alt l) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-1005"></span><span>
</span><span id="line-1006"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-1007"></span><span class="hs-comment">-- Builtin names.</span><span>
</span><span id="line-1008"></span><span>
</span><span id="line-1009"></span><span id="local-6989586621679452452"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#prelude_mod"><span class="hs-identifier hs-type">prelude_mod</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#main_mod"><span class="hs-identifier hs-type">main_mod</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679452452"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452452"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1010"></span><span id="prelude_mod"><span class="annot"><span class="annottext">prelude_mod :: forall l. l -&gt; ModuleName l
</span><a href="Language.Haskell.Exts.Syntax.html#prelude_mod"><span class="hs-identifier hs-var hs-var">prelude_mod</span></a></span></span><span> </span><span id="local-6989586621679423993"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423993"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; ModuleName l
</span><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-var">ModuleName</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423993"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Prelude&quot;</span></span><span>
</span><span id="line-1011"></span><span id="main_mod"><span class="annot"><span class="annottext">main_mod :: forall l. l -&gt; ModuleName l
</span><a href="Language.Haskell.Exts.Syntax.html#main_mod"><span class="hs-identifier hs-var hs-var">main_mod</span></a></span></span><span>    </span><span id="local-6989586621679423992"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423992"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; ModuleName l
</span><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-var">ModuleName</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423992"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Main&quot;</span></span><span>
</span><span id="line-1012"></span><span>
</span><span id="line-1013"></span><span id="local-6989586621679452449"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#main_name"><span class="hs-identifier hs-type">main_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679452449"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452449"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1014"></span><span id="main_name"><span class="annot"><span class="annottext">main_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#main_name"><span class="hs-identifier hs-var hs-var">main_name</span></a></span></span><span> </span><span id="local-6989586621679423991"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423991"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423991"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;main&quot;</span></span><span>
</span><span id="line-1015"></span><span>
</span><span id="line-1016"></span><span id="local-6989586621679452447"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unit_con_name"><span class="hs-identifier hs-type">unit_con_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679452447"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452447"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1017"></span><span id="unit_con_name"><span class="annot"><span class="annottext">unit_con_name :: forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#unit_con_name"><span class="hs-identifier hs-var hs-var">unit_con_name</span></a></span></span><span> </span><span id="local-6989586621679423990"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423990"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-var">Special</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423990"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l
</span><a href="Language.Haskell.Exts.Syntax.html#UnitCon"><span class="hs-identifier hs-var">UnitCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423990"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1018"></span><span>
</span><span id="line-1019"></span><span id="local-6989586621679452445"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#tuple_con_name"><span class="hs-identifier hs-type">tuple_con_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679452445"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier hs-type">Boxed</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452445"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1020"></span><span id="tuple_con_name"><span class="annot"><span class="annottext">tuple_con_name :: forall l. l -&gt; Boxed -&gt; Int -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#tuple_con_name"><span class="hs-identifier hs-var hs-var">tuple_con_name</span></a></span></span><span> </span><span id="local-6989586621679423986"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423986"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423985"><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679423985"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679423984"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679423984"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-var">Special</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423986"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; Boxed -&gt; Int -&gt; SpecialCon l
</span><a href="Language.Haskell.Exts.Syntax.html#TupleCon"><span class="hs-identifier hs-var">TupleCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423986"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679423985"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679423984"><span class="hs-identifier hs-var">i</span></a></span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1021"></span><span>
</span><span id="line-1022"></span><span id="local-6989586621679423982"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#list_con_name"><span class="hs-identifier hs-type">list_con_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679423982"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679423982"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1023"></span><span id="list_con_name"><span class="annot"><span class="annottext">list_con_name :: forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#list_con_name"><span class="hs-identifier hs-var hs-var">list_con_name</span></a></span></span><span> </span><span id="local-6989586621679423981"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423981"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-var">Special</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423981"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l
</span><a href="Language.Haskell.Exts.Syntax.html#ListCon"><span class="hs-identifier hs-var">ListCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423981"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1024"></span><span>
</span><span id="line-1025"></span><span id="local-6989586621679423980"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#list_cons_name"><span class="hs-identifier hs-type">list_cons_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679423980"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679423980"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1026"></span><span id="list_cons_name"><span class="annot"><span class="annottext">list_cons_name :: forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#list_cons_name"><span class="hs-identifier hs-var hs-var">list_cons_name</span></a></span></span><span> </span><span id="local-6989586621679423979"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423979"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-var">Special</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423979"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l
</span><a href="Language.Haskell.Exts.Syntax.html#Cons"><span class="hs-identifier hs-var">Cons</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423979"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1027"></span><span>
</span><span id="line-1028"></span><span id="local-6989586621679423978"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_con_name"><span class="hs-identifier hs-type">unboxed_singleton_con_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679423978"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679423978"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1029"></span><span id="unboxed_singleton_con_name"><span class="annot"><span class="annottext">unboxed_singleton_con_name :: forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_con_name"><span class="hs-identifier hs-var hs-var">unboxed_singleton_con_name</span></a></span></span><span> </span><span id="local-6989586621679423977"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423977"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-var">Special</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423977"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l
</span><a href="Language.Haskell.Exts.Syntax.html#UnboxedSingleCon"><span class="hs-identifier hs-var">UnboxedSingleCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423977"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1030"></span><span>
</span><span id="line-1031"></span><span id="local-6989586621679452439"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unit_con"><span class="hs-identifier hs-type">unit_con</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679452439"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452439"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1032"></span><span id="unit_con"><span class="annot"><span class="annottext">unit_con :: forall l. l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#unit_con"><span class="hs-identifier hs-var hs-var">unit_con</span></a></span></span><span> </span><span id="local-6989586621679423976"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423976"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Con"><span class="hs-identifier hs-var">Con</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423976"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#unit_con_name"><span class="hs-identifier hs-var">unit_con_name</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423976"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1033"></span><span>
</span><span id="line-1034"></span><span id="local-6989586621679452434"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#tuple_con"><span class="hs-identifier hs-type">tuple_con</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679452434"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier hs-type">Boxed</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452434"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1035"></span><span id="tuple_con"><span class="annot"><span class="annottext">tuple_con :: forall l. l -&gt; Boxed -&gt; Int -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#tuple_con"><span class="hs-identifier hs-var hs-var">tuple_con</span></a></span></span><span> </span><span id="local-6989586621679423975"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423975"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423974"><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679423974"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679423973"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679423973"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Con"><span class="hs-identifier hs-var">Con</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423975"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; Boxed -&gt; Int -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#tuple_con_name"><span class="hs-identifier hs-var">tuple_con_name</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423975"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679423974"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679423973"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1036"></span><span>
</span><span id="line-1037"></span><span id="local-6989586621679423972"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_con"><span class="hs-identifier hs-type">unboxed_singleton_con</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679423972"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679423972"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1038"></span><span id="unboxed_singleton_con"><span class="annot"><span class="annottext">unboxed_singleton_con :: forall l. l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_con"><span class="hs-identifier hs-var hs-var">unboxed_singleton_con</span></a></span></span><span> </span><span id="local-6989586621679423971"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423971"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Con"><span class="hs-identifier hs-var">Con</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423971"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_con_name"><span class="hs-identifier hs-var">unboxed_singleton_con_name</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423971"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1039"></span><span>
</span><span id="line-1040"></span><span id="local-6989586621679423970"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#as_name"><span class="hs-identifier hs-type">as_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#qualified_name"><span class="hs-identifier hs-type">qualified_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#hiding_name"><span class="hs-identifier hs-type">hiding_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#minus_name"><span class="hs-identifier hs-type">minus_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#bang_name"><span class="hs-identifier hs-type">bang_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#dot_name"><span class="hs-identifier hs-type">dot_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#star_name"><span class="hs-identifier hs-type">star_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679423970"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679423970"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1041"></span><span id="as_name"><span class="annot"><span class="annottext">as_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#as_name"><span class="hs-identifier hs-var hs-var">as_name</span></a></span></span><span>        </span><span id="local-6989586621679423969"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423969"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span>  </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423969"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;as&quot;</span></span><span>
</span><span id="line-1042"></span><span id="qualified_name"><span class="annot"><span class="annottext">qualified_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#qualified_name"><span class="hs-identifier hs-var hs-var">qualified_name</span></a></span></span><span> </span><span id="local-6989586621679423968"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423968"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span>  </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423968"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qualified&quot;</span></span><span>
</span><span id="line-1043"></span><span id="hiding_name"><span class="annot"><span class="annottext">hiding_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#hiding_name"><span class="hs-identifier hs-var hs-var">hiding_name</span></a></span></span><span>    </span><span id="local-6989586621679423967"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423967"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span>  </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423967"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;hiding&quot;</span></span><span>
</span><span id="line-1044"></span><span id="minus_name"><span class="annot"><span class="annottext">minus_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#minus_name"><span class="hs-identifier hs-var hs-var">minus_name</span></a></span></span><span>     </span><span id="local-6989586621679423966"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423966"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Symbol"><span class="hs-identifier hs-var">Symbol</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423966"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;-&quot;</span></span><span>
</span><span id="line-1045"></span><span id="bang_name"><span class="annot"><span class="annottext">bang_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#bang_name"><span class="hs-identifier hs-var hs-var">bang_name</span></a></span></span><span>      </span><span id="local-6989586621679423965"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423965"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Symbol"><span class="hs-identifier hs-var">Symbol</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423965"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;!&quot;</span></span><span>
</span><span id="line-1046"></span><span id="dot_name"><span class="annot"><span class="annottext">dot_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#dot_name"><span class="hs-identifier hs-var hs-var">dot_name</span></a></span></span><span>       </span><span id="local-6989586621679423964"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423964"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Symbol"><span class="hs-identifier hs-var">Symbol</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423964"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;.&quot;</span></span><span>
</span><span id="line-1047"></span><span id="star_name"><span class="annot"><span class="annottext">star_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#star_name"><span class="hs-identifier hs-var hs-var">star_name</span></a></span></span><span>      </span><span id="local-6989586621679423963"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423963"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Symbol"><span class="hs-identifier hs-var">Symbol</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423963"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;*&quot;</span></span><span>
</span><span id="line-1048"></span><span>
</span><span id="line-1049"></span><span id="local-6989586621679423962"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#hole_name"><span class="hs-identifier hs-type">hole_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679423962"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679423962"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1050"></span><span id="hole_name"><span class="annot"><span class="annottext">hole_name :: forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#hole_name"><span class="hs-identifier hs-var hs-var">hole_name</span></a></span></span><span>      </span><span id="local-6989586621679423961"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423961"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-var">Special</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423961"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l
</span><a href="Language.Haskell.Exts.Syntax.html#ExprHole"><span class="hs-identifier hs-var">ExprHole</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423961"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1051"></span><span>
</span><span id="line-1052"></span><span id="local-6989586621679423960"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#export_name"><span class="hs-identifier hs-type">export_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#safe_name"><span class="hs-identifier hs-type">safe_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unsafe_name"><span class="hs-identifier hs-type">unsafe_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#interruptible_name"><span class="hs-identifier hs-type">interruptible_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#threadsafe_name"><span class="hs-identifier hs-type">threadsafe_name</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1053"></span><span>  </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#stdcall_name"><span class="hs-identifier hs-type">stdcall_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ccall_name"><span class="hs-identifier hs-type">ccall_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#cplusplus_name"><span class="hs-identifier hs-type">cplusplus_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#dotnet_name"><span class="hs-identifier hs-type">dotnet_name</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1054"></span><span>  </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#jvm_name"><span class="hs-identifier hs-type">jvm_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#js_name"><span class="hs-identifier hs-type">js_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#javascript_name"><span class="hs-identifier hs-type">javascript_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#capi_name"><span class="hs-identifier hs-type">capi_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#forall_name"><span class="hs-identifier hs-type">forall_name</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1055"></span><span>  </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#family_name"><span class="hs-identifier hs-type">family_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#role_name"><span class="hs-identifier hs-type">role_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#stock_name"><span class="hs-identifier hs-type">stock_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#anyclass_name"><span class="hs-identifier hs-type">anyclass_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#via_name"><span class="hs-identifier hs-type">via_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679423960"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679423960"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1056"></span><span id="export_name"><span class="annot"><span class="annottext">export_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#export_name"><span class="hs-identifier hs-var hs-var">export_name</span></a></span></span><span>     </span><span id="local-6989586621679423959"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423959"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423959"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;export&quot;</span></span><span>
</span><span id="line-1057"></span><span id="safe_name"><span class="annot"><span class="annottext">safe_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#safe_name"><span class="hs-identifier hs-var hs-var">safe_name</span></a></span></span><span>       </span><span id="local-6989586621679423958"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423958"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423958"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;safe&quot;</span></span><span>
</span><span id="line-1058"></span><span id="unsafe_name"><span class="annot"><span class="annottext">unsafe_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#unsafe_name"><span class="hs-identifier hs-var hs-var">unsafe_name</span></a></span></span><span>     </span><span id="local-6989586621679423957"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423957"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423957"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;unsafe&quot;</span></span><span>
</span><span id="line-1059"></span><span id="interruptible_name"><span class="annot"><span class="annottext">interruptible_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#interruptible_name"><span class="hs-identifier hs-var hs-var">interruptible_name</span></a></span></span><span> </span><span id="local-6989586621679423956"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423956"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423956"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;interruptible&quot;</span></span><span>
</span><span id="line-1060"></span><span id="threadsafe_name"><span class="annot"><span class="annottext">threadsafe_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#threadsafe_name"><span class="hs-identifier hs-var hs-var">threadsafe_name</span></a></span></span><span> </span><span id="local-6989586621679423955"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423955"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423955"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;threadsafe&quot;</span></span><span>
</span><span id="line-1061"></span><span id="stdcall_name"><span class="annot"><span class="annottext">stdcall_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#stdcall_name"><span class="hs-identifier hs-var hs-var">stdcall_name</span></a></span></span><span>    </span><span id="local-6989586621679423954"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423954"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423954"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;stdcall&quot;</span></span><span>
</span><span id="line-1062"></span><span id="ccall_name"><span class="annot"><span class="annottext">ccall_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#ccall_name"><span class="hs-identifier hs-var hs-var">ccall_name</span></a></span></span><span>      </span><span id="local-6989586621679423953"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423953"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423953"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;ccall&quot;</span></span><span>
</span><span id="line-1063"></span><span id="cplusplus_name"><span class="annot"><span class="annottext">cplusplus_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#cplusplus_name"><span class="hs-identifier hs-var hs-var">cplusplus_name</span></a></span></span><span>  </span><span id="local-6989586621679423952"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423952"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423952"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;cplusplus&quot;</span></span><span>
</span><span id="line-1064"></span><span id="dotnet_name"><span class="annot"><span class="annottext">dotnet_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#dotnet_name"><span class="hs-identifier hs-var hs-var">dotnet_name</span></a></span></span><span>     </span><span id="local-6989586621679423951"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423951"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423951"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;dotnet&quot;</span></span><span>
</span><span id="line-1065"></span><span id="jvm_name"><span class="annot"><span class="annottext">jvm_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#jvm_name"><span class="hs-identifier hs-var hs-var">jvm_name</span></a></span></span><span>        </span><span id="local-6989586621679423950"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423950"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423950"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;jvm&quot;</span></span><span>
</span><span id="line-1066"></span><span id="js_name"><span class="annot"><span class="annottext">js_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#js_name"><span class="hs-identifier hs-var hs-var">js_name</span></a></span></span><span>         </span><span id="local-6989586621679423949"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423949"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423949"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;js&quot;</span></span><span>
</span><span id="line-1067"></span><span id="javascript_name"><span class="annot"><span class="annottext">javascript_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#javascript_name"><span class="hs-identifier hs-var hs-var">javascript_name</span></a></span></span><span> </span><span id="local-6989586621679423948"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423948"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423948"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;javascript&quot;</span></span><span>
</span><span id="line-1068"></span><span id="capi_name"><span class="annot"><span class="annottext">capi_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#capi_name"><span class="hs-identifier hs-var hs-var">capi_name</span></a></span></span><span>       </span><span id="local-6989586621679423947"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423947"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423947"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;capi&quot;</span></span><span>
</span><span id="line-1069"></span><span id="forall_name"><span class="annot"><span class="annottext">forall_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#forall_name"><span class="hs-identifier hs-var hs-var">forall_name</span></a></span></span><span>     </span><span id="local-6989586621679423946"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423946"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423946"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;forall&quot;</span></span><span>
</span><span id="line-1070"></span><span id="family_name"><span class="annot"><span class="annottext">family_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#family_name"><span class="hs-identifier hs-var hs-var">family_name</span></a></span></span><span>     </span><span id="local-6989586621679423945"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423945"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423945"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;family&quot;</span></span><span>
</span><span id="line-1071"></span><span id="role_name"><span class="annot"><span class="annottext">role_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#role_name"><span class="hs-identifier hs-var hs-var">role_name</span></a></span></span><span>       </span><span id="local-6989586621679423944"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423944"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423944"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;role&quot;</span></span><span>
</span><span id="line-1072"></span><span id="stock_name"><span class="annot"><span class="annottext">stock_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#stock_name"><span class="hs-identifier hs-var hs-var">stock_name</span></a></span></span><span>      </span><span id="local-6989586621679423943"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423943"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423943"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;stock&quot;</span></span><span>
</span><span id="line-1073"></span><span id="anyclass_name"><span class="annot"><span class="annottext">anyclass_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#anyclass_name"><span class="hs-identifier hs-var hs-var">anyclass_name</span></a></span></span><span>   </span><span id="local-6989586621679423942"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423942"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423942"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;anyclass&quot;</span></span><span>
</span><span id="line-1074"></span><span id="via_name"><span class="annot"><span class="annottext">via_name :: forall l. l -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#via_name"><span class="hs-identifier hs-var hs-var">via_name</span></a></span></span><span>        </span><span id="local-6989586621679423941"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423941"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Name l
</span><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-var">Ident</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423941"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;via&quot;</span></span><span>
</span><span id="line-1075"></span><span>
</span><span id="line-1076"></span><span id="local-6989586621679423940"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unit_tycon_name"><span class="hs-identifier hs-type">unit_tycon_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#fun_tycon_name"><span class="hs-identifier hs-type">fun_tycon_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#list_tycon_name"><span class="hs-identifier hs-type">list_tycon_name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_tycon_name"><span class="hs-identifier hs-type">unboxed_singleton_tycon_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679423940"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679423940"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1077"></span><span id="unit_tycon_name"><span class="annot"><span class="annottext">unit_tycon_name :: forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#unit_tycon_name"><span class="hs-identifier hs-var hs-var">unit_tycon_name</span></a></span></span><span> </span><span id="local-6989586621679423939"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423939"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#unit_con_name"><span class="hs-identifier hs-var">unit_con_name</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423939"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1078"></span><span id="fun_tycon_name"><span class="annot"><span class="annottext">fun_tycon_name :: forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#fun_tycon_name"><span class="hs-identifier hs-var hs-var">fun_tycon_name</span></a></span></span><span>  </span><span id="local-6989586621679423938"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423938"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-var">Special</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423938"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l
</span><a href="Language.Haskell.Exts.Syntax.html#FunCon"><span class="hs-identifier hs-var">FunCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423938"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1079"></span><span id="list_tycon_name"><span class="annot"><span class="annottext">list_tycon_name :: forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#list_tycon_name"><span class="hs-identifier hs-var hs-var">list_tycon_name</span></a></span></span><span> </span><span id="local-6989586621679423937"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423937"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-var">Special</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423937"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l
</span><a href="Language.Haskell.Exts.Syntax.html#ListCon"><span class="hs-identifier hs-var">ListCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423937"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1080"></span><span id="unboxed_singleton_tycon_name"><span class="annot"><span class="annottext">unboxed_singleton_tycon_name :: forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_tycon_name"><span class="hs-identifier hs-var hs-var">unboxed_singleton_tycon_name</span></a></span></span><span> </span><span id="local-6989586621679423936"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423936"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-var">Special</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423936"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l
</span><a href="Language.Haskell.Exts.Syntax.html#UnboxedSingleCon"><span class="hs-identifier hs-var">UnboxedSingleCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423936"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1081"></span><span>
</span><span id="line-1082"></span><span id="local-6989586621679423935"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#tuple_tycon_name"><span class="hs-identifier hs-type">tuple_tycon_name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679423935"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier hs-type">Boxed</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679423935"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1083"></span><span id="tuple_tycon_name"><span class="annot"><span class="annottext">tuple_tycon_name :: forall l. l -&gt; Boxed -&gt; Int -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#tuple_tycon_name"><span class="hs-identifier hs-var hs-var">tuple_tycon_name</span></a></span></span><span> </span><span id="local-6989586621679423934"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423934"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423933"><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679423933"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679423932"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679423932"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Boxed -&gt; Int -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#tuple_con_name"><span class="hs-identifier hs-var">tuple_con_name</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423934"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679423933"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679423932"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-1084"></span><span>
</span><span id="line-1085"></span><span id="local-6989586621679452399"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unit_tycon"><span class="hs-identifier hs-type">unit_tycon</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#fun_tycon"><span class="hs-identifier hs-type">fun_tycon</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#list_tycon"><span class="hs-identifier hs-type">list_tycon</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_tycon"><span class="hs-identifier hs-type">unboxed_singleton_tycon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679452399"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452399"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1086"></span><span id="unit_tycon"><span class="annot"><span class="annottext">unit_tycon :: forall l. l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#unit_tycon"><span class="hs-identifier hs-var hs-var">unit_tycon</span></a></span></span><span> </span><span id="local-6989586621679423931"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423931"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyCon"><span class="hs-identifier hs-var">TyCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423931"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#unit_tycon_name"><span class="hs-identifier hs-var">unit_tycon_name</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423931"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1087"></span><span id="fun_tycon"><span class="annot"><span class="annottext">fun_tycon :: forall l. l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#fun_tycon"><span class="hs-identifier hs-var hs-var">fun_tycon</span></a></span></span><span>  </span><span id="local-6989586621679423930"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423930"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyCon"><span class="hs-identifier hs-var">TyCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423930"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#fun_tycon_name"><span class="hs-identifier hs-var">fun_tycon_name</span></a></span><span>  </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423930"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1088"></span><span id="list_tycon"><span class="annot"><span class="annottext">list_tycon :: forall l. l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#list_tycon"><span class="hs-identifier hs-var hs-var">list_tycon</span></a></span></span><span> </span><span id="local-6989586621679423929"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423929"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyCon"><span class="hs-identifier hs-var">TyCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423929"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#list_tycon_name"><span class="hs-identifier hs-var">list_tycon_name</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423929"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1089"></span><span id="unboxed_singleton_tycon"><span class="annot"><span class="annottext">unboxed_singleton_tycon :: forall l. l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_tycon"><span class="hs-identifier hs-var hs-var">unboxed_singleton_tycon</span></a></span></span><span> </span><span id="local-6989586621679423928"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423928"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyCon"><span class="hs-identifier hs-var">TyCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423928"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#unboxed_singleton_tycon_name"><span class="hs-identifier hs-var">unboxed_singleton_tycon_name</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423928"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1090"></span><span>
</span><span id="line-1091"></span><span id="local-6989586621679452394"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#tuple_tycon"><span class="hs-identifier hs-type">tuple_tycon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679452394"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Boxed"><span class="hs-identifier hs-type">Boxed</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452394"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1092"></span><span id="tuple_tycon"><span class="annot"><span class="annottext">tuple_tycon :: forall l. l -&gt; Boxed -&gt; Int -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#tuple_tycon"><span class="hs-identifier hs-var hs-var">tuple_tycon</span></a></span></span><span> </span><span id="local-6989586621679423927"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423927"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423926"><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679423926"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679423925"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679423925"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyCon"><span class="hs-identifier hs-var">TyCon</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423927"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l. l -&gt; Boxed -&gt; Int -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#tuple_tycon_name"><span class="hs-identifier hs-var">tuple_tycon_name</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423927"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679423926"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679423925"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1093"></span><span>
</span><span id="line-1094"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-1095"></span><span class="hs-comment">-- AST traversal, boiler-plate style</span><span>
</span><span id="line-1096"></span><span>
</span><span id="line-1097"></span><span class="hs-comment">-- | Test if two AST elements are equal modulo annotations.</span><span>
</span><span id="line-1098"></span><span id="local-6989586621679452389"><span id="local-6989586621679452390"><span id="local-6989586621679452392"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#%3D~%3D"><span class="hs-operator hs-type">(=~=)</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452392"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679452392"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679452392"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452390"><span class="hs-identifier hs-type">l1</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679452392"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452389"><span class="hs-identifier hs-type">l2</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-1099"></span><span id="local-6989586621679423917"><span class="annot"><span class="annottext">a l1
</span><a href="#local-6989586621679423917"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="%3D~%3D"><span class="annot"><span class="annottext">=~= :: forall (a :: * -&gt; *) l1 l2.
(Annotated a, Eq (a ())) =&gt;
a l1 -&gt; a l2 -&gt; Bool
</span><a href="Language.Haskell.Exts.Syntax.html#%3D~%3D"><span class="hs-operator hs-var hs-var">=~=</span></a></span></span><span> </span><span id="local-6989586621679423916"><span class="annot"><span class="annottext">a l2
</span><a href="#local-6989586621679423916"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a l1
</span><a href="#local-6989586621679423917"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a l2
</span><a href="#local-6989586621679423916"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-1100"></span><span>
</span><span id="line-1101"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-1102"></span><span class="hs-comment">-- Reading annotations</span><span>
</span><span id="line-1103"></span><span>
</span><span id="line-1104"></span><span class="hs-comment">-- | AST nodes are annotated, and this class allows manipulation of the annotations.</span><span>
</span><span id="line-1105"></span><span class="hs-keyword">class</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679452387"><span class="hs-identifier hs-type">ast</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span id="Annotated"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-var">Annotated</span></a></span></span><span> </span><span id="local-6989586621679452387"><span class="annot"><a href="#local-6989586621679452387"><span class="hs-identifier hs-type">ast</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1106"></span><span>    </span><span class="hs-comment">-- | Retrieve the annotation of an AST node.</span><span>
</span><span id="line-1107"></span><span>    </span><span id="ann"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-type">ann</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679452382"><span class="annot"><a href="#local-6989586621679452387"><span class="hs-identifier hs-type">ast</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452382"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679452382"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1108"></span><span>    </span><span class="hs-comment">-- | Change the annotation of an AST node. Note that only the annotation of</span><span>
</span><span id="line-1109"></span><span>    </span><span class="hs-comment">--   the node itself is affected, and not the annotations of any child nodes.</span><span>
</span><span id="line-1110"></span><span>    </span><span class="hs-comment">--   if all nodes in the AST tree are to be affected, use 'fmap'.</span><span>
</span><span id="line-1111"></span><span>    </span><span id="amap"><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-type">amap</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679452381"><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679452381"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679452381"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679452387"><span class="hs-identifier hs-type">ast</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452381"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679452387"><span class="hs-identifier hs-type">ast</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679452381"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-1112"></span><span>
</span><span id="line-1113"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1114"></span><span>    </span><span id="local-6989586621679423906"><span class="annot"><span class="annottext">ann :: forall l. ModuleName l -&gt; l
</span><a href="#local-6989586621679423906"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span> </span><span id="local-6989586621679423905"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423905"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423905"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1115"></span><span>    </span><span id="local-6989586621679423904"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; ModuleName l -&gt; ModuleName l
</span><a href="#local-6989586621679423904"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423903"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423903"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span> </span><span id="local-6989586621679423902"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423902"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423901"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679423901"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; ModuleName l
</span><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-var">ModuleName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423903"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423902"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679423901"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1116"></span><span>
</span><span id="line-1117"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpecialCon"><span class="hs-identifier hs-type">SpecialCon</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1118"></span><span>    </span><span id="local-6989586621679423895"><span class="annot"><span class="annottext">ann :: forall l. SpecialCon l -&gt; l
</span><a href="#local-6989586621679423895"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679423894"><span class="annot"><span class="annottext">SpecialCon l
</span><a href="#local-6989586621679423894"><span class="hs-identifier hs-var">sc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">SpecialCon l
</span><a href="#local-6989586621679423894"><span class="hs-identifier hs-var">sc</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1119"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnitCon"><span class="hs-identifier hs-type">UnitCon</span></a></span><span> </span><span id="local-6989586621679423893"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423893"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423893"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1120"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ListCon"><span class="hs-identifier hs-type">ListCon</span></a></span><span> </span><span id="local-6989586621679423892"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423892"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423892"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1121"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunCon"><span class="hs-identifier hs-type">FunCon</span></a></span><span>  </span><span id="local-6989586621679423891"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423891"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423891"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1122"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TupleCon"><span class="hs-identifier hs-type">TupleCon</span></a></span><span> </span><span id="local-6989586621679423890"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423890"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxed
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423890"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1123"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Cons"><span class="hs-identifier hs-type">Cons</span></a></span><span> </span><span id="local-6989586621679423889"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423889"><span class="hs-identifier hs-var">l</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423889"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1124"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnboxedSingleCon"><span class="hs-identifier hs-type">UnboxedSingleCon</span></a></span><span> </span><span id="local-6989586621679423888"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423888"><span class="hs-identifier hs-var">l</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423888"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1125"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExprHole"><span class="hs-identifier hs-type">ExprHole</span></a></span><span> </span><span id="local-6989586621679423887"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423887"><span class="hs-identifier hs-var">l</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423887"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1126"></span><span>    </span><span id="local-6989586621679423885"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; SpecialCon l -&gt; SpecialCon l
</span><a href="#local-6989586621679423885"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1127"></span><span>
</span><span id="line-1128"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QName"><span class="hs-identifier hs-type">QName</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1129"></span><span>    </span><span id="local-6989586621679423879"><span class="annot"><span class="annottext">ann :: forall l. QName l -&gt; l
</span><a href="#local-6989586621679423879"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679423878"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423878"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423878"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1130"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Qual"><span class="hs-identifier hs-type">Qual</span></a></span><span>    </span><span id="local-6989586621679423877"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423877"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">ModuleName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423877"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1131"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnQual"><span class="hs-identifier hs-type">UnQual</span></a></span><span>  </span><span id="local-6989586621679423876"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423876"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423876"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1132"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-type">Special</span></a></span><span> </span><span id="local-6989586621679423875"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423875"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">SpecialCon l
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423875"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1133"></span><span>    </span><span id="local-6989586621679423874"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; QName l -&gt; QName l
</span><a href="#local-6989586621679423874"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423873"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423873"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679423872"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423872"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423872"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1134"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Qual"><span class="hs-identifier hs-type">Qual</span></a></span><span>    </span><span id="local-6989586621679423871"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423871"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423870"><span class="annot"><span class="annottext">ModuleName l
</span><a href="#local-6989586621679423870"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679423869"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423869"><span class="hs-identifier hs-var">n</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; ModuleName l -&gt; Name l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#Qual"><span class="hs-identifier hs-var">Qual</span></a></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423873"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423871"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ModuleName l
</span><a href="#local-6989586621679423870"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423869"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1135"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnQual"><span class="hs-identifier hs-type">UnQual</span></a></span><span>  </span><span id="local-6989586621679423868"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423868"><span class="hs-identifier hs-var">l</span></a></span></span><span>    </span><span id="local-6989586621679423867"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423867"><span class="hs-identifier hs-var">n</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#UnQual"><span class="hs-identifier hs-var">UnQual</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423873"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423868"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>    </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423867"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1136"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-type">Special</span></a></span><span> </span><span id="local-6989586621679423866"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423866"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423865"><span class="annot"><span class="annottext">SpecialCon l
</span><a href="#local-6989586621679423865"><span class="hs-identifier hs-var">sc</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; SpecialCon l -&gt; QName l
</span><a href="Language.Haskell.Exts.Syntax.html#Special"><span class="hs-identifier hs-var">Special</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423873"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423866"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">SpecialCon l
</span><a href="#local-6989586621679423865"><span class="hs-identifier hs-var">sc</span></a></span><span>
</span><span id="line-1137"></span><span>
</span><span id="line-1138"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1139"></span><span>    </span><span id="local-6989586621679423859"><span class="annot"><span class="annottext">ann :: forall l. Name l -&gt; l
</span><a href="#local-6989586621679423859"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Ident"><span class="hs-identifier hs-type">Ident</span></a></span><span>  </span><span id="local-6989586621679423858"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423858"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423858"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1140"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Symbol"><span class="hs-identifier hs-type">Symbol</span></a></span><span> </span><span id="local-6989586621679423857"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423857"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423857"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1141"></span><span>    </span><span id="local-6989586621679423855"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Name l -&gt; Name l
</span><a href="#local-6989586621679423855"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1142"></span><span>
</span><span id="line-1143"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPName"><span class="hs-identifier hs-type">IPName</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1144"></span><span>    </span><span id="local-6989586621679423849"><span class="annot"><span class="annottext">ann :: forall l. IPName l -&gt; l
</span><a href="#local-6989586621679423849"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPDup"><span class="hs-identifier hs-type">IPDup</span></a></span><span> </span><span id="local-6989586621679423848"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423848"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423848"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1145"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPLin"><span class="hs-identifier hs-type">IPLin</span></a></span><span> </span><span id="local-6989586621679423847"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423847"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423847"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1146"></span><span>    </span><span id="local-6989586621679423845"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; IPName l -&gt; IPName l
</span><a href="#local-6989586621679423845"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1147"></span><span>
</span><span id="line-1148"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QOp"><span class="hs-identifier hs-type">QOp</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1149"></span><span>    </span><span id="local-6989586621679423839"><span class="annot"><span class="annottext">ann :: forall l. QOp l -&gt; l
</span><a href="#local-6989586621679423839"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QVarOp"><span class="hs-identifier hs-type">QVarOp</span></a></span><span> </span><span id="local-6989586621679423838"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423838"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423838"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1150"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QConOp"><span class="hs-identifier hs-type">QConOp</span></a></span><span> </span><span id="local-6989586621679423837"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423837"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423837"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1151"></span><span>    </span><span id="local-6989586621679423836"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; QOp l -&gt; QOp l
</span><a href="#local-6989586621679423836"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423835"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423835"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QVarOp"><span class="hs-identifier hs-type">QVarOp</span></a></span><span> </span><span id="local-6989586621679423834"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423834"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423833"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423833"><span class="hs-identifier hs-var">qn</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; QOp l
</span><a href="Language.Haskell.Exts.Syntax.html#QVarOp"><span class="hs-identifier hs-var">QVarOp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423835"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423834"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423833"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1152"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423832"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423832"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QConOp"><span class="hs-identifier hs-type">QConOp</span></a></span><span> </span><span id="local-6989586621679423831"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423831"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423830"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423830"><span class="hs-identifier hs-var">qn</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; QOp l
</span><a href="Language.Haskell.Exts.Syntax.html#QConOp"><span class="hs-identifier hs-var">QConOp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423832"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423831"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423830"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1153"></span><span>
</span><span id="line-1154"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Op"><span class="hs-identifier hs-type">Op</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1155"></span><span>    </span><span id="local-6989586621679423824"><span class="annot"><span class="annottext">ann :: forall l. Op l -&gt; l
</span><a href="#local-6989586621679423824"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarOp"><span class="hs-identifier hs-type">VarOp</span></a></span><span> </span><span id="local-6989586621679423823"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423823"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423823"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1156"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConOp"><span class="hs-identifier hs-type">ConOp</span></a></span><span> </span><span id="local-6989586621679423822"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423822"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423822"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1157"></span><span>    </span><span id="local-6989586621679423821"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Op l -&gt; Op l
</span><a href="#local-6989586621679423821"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423820"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423820"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarOp"><span class="hs-identifier hs-type">VarOp</span></a></span><span> </span><span id="local-6989586621679423819"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423819"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423818"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423818"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; Op l
</span><a href="Language.Haskell.Exts.Syntax.html#VarOp"><span class="hs-identifier hs-var">VarOp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423820"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423819"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423818"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1158"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423817"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423817"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConOp"><span class="hs-identifier hs-type">ConOp</span></a></span><span> </span><span id="local-6989586621679423816"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423816"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423815"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423815"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; Op l
</span><a href="Language.Haskell.Exts.Syntax.html#ConOp"><span class="hs-identifier hs-var">ConOp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423817"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423816"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423815"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1159"></span><span>
</span><span id="line-1160"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CName"><span class="hs-identifier hs-type">CName</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1161"></span><span>    </span><span id="local-6989586621679423809"><span class="annot"><span class="annottext">ann :: forall l. CName l -&gt; l
</span><a href="#local-6989586621679423809"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span> </span><span id="local-6989586621679423808"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423808"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423808"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1162"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConName"><span class="hs-identifier hs-type">ConName</span></a></span><span> </span><span id="local-6989586621679423807"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423807"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423807"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1163"></span><span>    </span><span id="local-6989586621679423806"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; CName l -&gt; CName l
</span><a href="#local-6989586621679423806"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423805"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423805"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarName"><span class="hs-identifier hs-type">VarName</span></a></span><span> </span><span id="local-6989586621679423804"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423804"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423803"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423803"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; CName l
</span><a href="Language.Haskell.Exts.Syntax.html#VarName"><span class="hs-identifier hs-var">VarName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423805"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423804"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423803"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1164"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423802"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423802"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConName"><span class="hs-identifier hs-type">ConName</span></a></span><span> </span><span id="local-6989586621679423801"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423801"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423800"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423800"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; CName l
</span><a href="Language.Haskell.Exts.Syntax.html#ConName"><span class="hs-identifier hs-var">ConName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423802"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423801"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423800"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1165"></span><span>
</span><span id="line-1166"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Module"><span class="hs-identifier hs-type">Module</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1167"></span><span>    </span><span id="local-6989586621679423794"><span class="annot"><span class="annottext">ann :: forall l. Module l -&gt; l
</span><a href="#local-6989586621679423794"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Module"><span class="hs-identifier hs-type">Module</span></a></span><span> </span><span id="local-6989586621679423793"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423793"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (ModuleHead l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[ModulePragma l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[ImportDecl l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Decl l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423793"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1168"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XmlPage"><span class="hs-identifier hs-type">XmlPage</span></a></span><span> </span><span id="local-6989586621679423792"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423792"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">ModuleName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[ModulePragma l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">XName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[XAttr l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Exp l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423792"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1169"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XmlHybrid"><span class="hs-identifier hs-type">XmlHybrid</span></a></span><span> </span><span id="local-6989586621679423791"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423791"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (ModuleHead l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[ModulePragma l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[ImportDecl l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Decl l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">XName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[XAttr l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Exp l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423791"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1170"></span><span>
</span><span id="line-1171"></span><span>    </span><span id="local-6989586621679423790"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Module l -&gt; Module l
</span><a href="#local-6989586621679423790"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423789"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423789"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Module"><span class="hs-identifier hs-type">Module</span></a></span><span> </span><span id="local-6989586621679423788"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423788"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423787"><span class="annot"><span class="annottext">Maybe (ModuleHead l)
</span><a href="#local-6989586621679423787"><span class="hs-identifier hs-var">mmh</span></a></span></span><span> </span><span id="local-6989586621679423786"><span class="annot"><span class="annottext">[ModulePragma l]
</span><a href="#local-6989586621679423786"><span class="hs-identifier hs-var">ops</span></a></span></span><span> </span><span id="local-6989586621679423785"><span class="annot"><span class="annottext">[ImportDecl l]
</span><a href="#local-6989586621679423785"><span class="hs-identifier hs-var">iss</span></a></span></span><span> </span><span id="local-6989586621679423784"><span class="annot"><span class="annottext">[Decl l]
</span><a href="#local-6989586621679423784"><span class="hs-identifier hs-var">dcls</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1172"></span><span>        </span><span class="annot"><span class="annottext">forall l.
l
-&gt; Maybe (ModuleHead l)
-&gt; [ModulePragma l]
-&gt; [ImportDecl l]
-&gt; [Decl l]
-&gt; Module l
</span><a href="Language.Haskell.Exts.Syntax.html#Module"><span class="hs-identifier hs-var">Module</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423789"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423788"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (ModuleHead l)
</span><a href="#local-6989586621679423787"><span class="hs-identifier hs-var">mmh</span></a></span><span> </span><span class="annot"><span class="annottext">[ModulePragma l]
</span><a href="#local-6989586621679423786"><span class="hs-identifier hs-var">ops</span></a></span><span> </span><span class="annot"><span class="annottext">[ImportDecl l]
</span><a href="#local-6989586621679423785"><span class="hs-identifier hs-var">iss</span></a></span><span> </span><span class="annot"><span class="annottext">[Decl l]
</span><a href="#local-6989586621679423784"><span class="hs-identifier hs-var">dcls</span></a></span><span>
</span><span id="line-1173"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423783"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423783"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XmlPage"><span class="hs-identifier hs-type">XmlPage</span></a></span><span> </span><span id="local-6989586621679423782"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423782"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423781"><span class="annot"><span class="annottext">ModuleName l
</span><a href="#local-6989586621679423781"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679423780"><span class="annot"><span class="annottext">[ModulePragma l]
</span><a href="#local-6989586621679423780"><span class="hs-identifier hs-var">os</span></a></span></span><span> </span><span id="local-6989586621679423779"><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679423779"><span class="hs-identifier hs-var">xn</span></a></span></span><span> </span><span id="local-6989586621679423778"><span class="annot"><span class="annottext">[XAttr l]
</span><a href="#local-6989586621679423778"><span class="hs-identifier hs-var">xas</span></a></span></span><span> </span><span id="local-6989586621679423777"><span class="annot"><span class="annottext">Maybe (Exp l)
</span><a href="#local-6989586621679423777"><span class="hs-identifier hs-var">me</span></a></span></span><span> </span><span id="local-6989586621679423776"><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679423776"><span class="hs-identifier hs-var">es</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1174"></span><span>        </span><span class="annot"><span class="annottext">forall l.
l
-&gt; ModuleName l
-&gt; [ModulePragma l]
-&gt; XName l
-&gt; [XAttr l]
-&gt; Maybe (Exp l)
-&gt; [Exp l]
-&gt; Module l
</span><a href="Language.Haskell.Exts.Syntax.html#XmlPage"><span class="hs-identifier hs-var">XmlPage</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423783"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423782"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ModuleName l
</span><a href="#local-6989586621679423781"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">[ModulePragma l]
</span><a href="#local-6989586621679423780"><span class="hs-identifier hs-var">os</span></a></span><span> </span><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679423779"><span class="hs-identifier hs-var">xn</span></a></span><span> </span><span class="annot"><span class="annottext">[XAttr l]
</span><a href="#local-6989586621679423778"><span class="hs-identifier hs-var">xas</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Exp l)
</span><a href="#local-6989586621679423777"><span class="hs-identifier hs-var">me</span></a></span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679423776"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-1175"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423775"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423775"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XmlHybrid"><span class="hs-identifier hs-type">XmlHybrid</span></a></span><span> </span><span id="local-6989586621679423774"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423774"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423773"><span class="annot"><span class="annottext">Maybe (ModuleHead l)
</span><a href="#local-6989586621679423773"><span class="hs-identifier hs-var">mmh</span></a></span></span><span> </span><span id="local-6989586621679423772"><span class="annot"><span class="annottext">[ModulePragma l]
</span><a href="#local-6989586621679423772"><span class="hs-identifier hs-var">ops</span></a></span></span><span> </span><span id="local-6989586621679423771"><span class="annot"><span class="annottext">[ImportDecl l]
</span><a href="#local-6989586621679423771"><span class="hs-identifier hs-var">iss</span></a></span></span><span> </span><span id="local-6989586621679423770"><span class="annot"><span class="annottext">[Decl l]
</span><a href="#local-6989586621679423770"><span class="hs-identifier hs-var">dcls</span></a></span></span><span> </span><span id="local-6989586621679423769"><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679423769"><span class="hs-identifier hs-var">xn</span></a></span></span><span> </span><span id="local-6989586621679423768"><span class="annot"><span class="annottext">[XAttr l]
</span><a href="#local-6989586621679423768"><span class="hs-identifier hs-var">xas</span></a></span></span><span> </span><span id="local-6989586621679423767"><span class="annot"><span class="annottext">Maybe (Exp l)
</span><a href="#local-6989586621679423767"><span class="hs-identifier hs-var">me</span></a></span></span><span> </span><span id="local-6989586621679423766"><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679423766"><span class="hs-identifier hs-var">es</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1176"></span><span>        </span><span class="annot"><span class="annottext">forall l.
l
-&gt; Maybe (ModuleHead l)
-&gt; [ModulePragma l]
-&gt; [ImportDecl l]
-&gt; [Decl l]
-&gt; XName l
-&gt; [XAttr l]
-&gt; Maybe (Exp l)
-&gt; [Exp l]
-&gt; Module l
</span><a href="Language.Haskell.Exts.Syntax.html#XmlHybrid"><span class="hs-identifier hs-var">XmlHybrid</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423775"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423774"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (ModuleHead l)
</span><a href="#local-6989586621679423773"><span class="hs-identifier hs-var">mmh</span></a></span><span> </span><span class="annot"><span class="annottext">[ModulePragma l]
</span><a href="#local-6989586621679423772"><span class="hs-identifier hs-var">ops</span></a></span><span> </span><span class="annot"><span class="annottext">[ImportDecl l]
</span><a href="#local-6989586621679423771"><span class="hs-identifier hs-var">iss</span></a></span><span> </span><span class="annot"><span class="annottext">[Decl l]
</span><a href="#local-6989586621679423770"><span class="hs-identifier hs-var">dcls</span></a></span><span> </span><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679423769"><span class="hs-identifier hs-var">xn</span></a></span><span> </span><span class="annot"><span class="annottext">[XAttr l]
</span><a href="#local-6989586621679423768"><span class="hs-identifier hs-var">xas</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Exp l)
</span><a href="#local-6989586621679423767"><span class="hs-identifier hs-var">me</span></a></span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679423766"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-1177"></span><span>
</span><span id="line-1178"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleHead"><span class="hs-identifier hs-type">ModuleHead</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1179"></span><span>    </span><span id="local-6989586621679423760"><span class="annot"><span class="annottext">ann :: forall l. ModuleHead l -&gt; l
</span><a href="#local-6989586621679423760"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleHead"><span class="hs-identifier hs-type">ModuleHead</span></a></span><span> </span><span id="local-6989586621679423759"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423759"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">ModuleName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (WarningText l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (ExportSpecList l)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423759"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1180"></span><span>    </span><span id="local-6989586621679423758"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; ModuleHead l -&gt; ModuleHead l
</span><a href="#local-6989586621679423758"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423757"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423757"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleHead"><span class="hs-identifier hs-type">ModuleHead</span></a></span><span> </span><span id="local-6989586621679423756"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423756"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423755"><span class="annot"><span class="annottext">ModuleName l
</span><a href="#local-6989586621679423755"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423754"><span class="annot"><span class="annottext">Maybe (WarningText l)
</span><a href="#local-6989586621679423754"><span class="hs-identifier hs-var">mwt</span></a></span></span><span> </span><span id="local-6989586621679423753"><span class="annot"><span class="annottext">Maybe (ExportSpecList l)
</span><a href="#local-6989586621679423753"><span class="hs-identifier hs-var">mesl</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; ModuleName l
-&gt; Maybe (WarningText l)
-&gt; Maybe (ExportSpecList l)
-&gt; ModuleHead l
</span><a href="Language.Haskell.Exts.Syntax.html#ModuleHead"><span class="hs-identifier hs-var">ModuleHead</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423757"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423756"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ModuleName l
</span><a href="#local-6989586621679423755"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (WarningText l)
</span><a href="#local-6989586621679423754"><span class="hs-identifier hs-var">mwt</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (ExportSpecList l)
</span><a href="#local-6989586621679423753"><span class="hs-identifier hs-var">mesl</span></a></span><span>
</span><span id="line-1181"></span><span>
</span><span id="line-1182"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExportSpecList"><span class="hs-identifier hs-type">ExportSpecList</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1183"></span><span>    </span><span id="local-6989586621679423747"><span class="annot"><span class="annottext">ann :: forall l. ExportSpecList l -&gt; l
</span><a href="#local-6989586621679423747"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExportSpecList"><span class="hs-identifier hs-type">ExportSpecList</span></a></span><span> </span><span id="local-6989586621679423746"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423746"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[ExportSpec l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423746"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1184"></span><span>    </span><span id="local-6989586621679423745"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; ExportSpecList l -&gt; ExportSpecList l
</span><a href="#local-6989586621679423745"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423744"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423744"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExportSpecList"><span class="hs-identifier hs-type">ExportSpecList</span></a></span><span> </span><span id="local-6989586621679423743"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423743"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423742"><span class="annot"><span class="annottext">[ExportSpec l]
</span><a href="#local-6989586621679423742"><span class="hs-identifier hs-var">ess</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [ExportSpec l] -&gt; ExportSpecList l
</span><a href="Language.Haskell.Exts.Syntax.html#ExportSpecList"><span class="hs-identifier hs-var">ExportSpecList</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423744"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423743"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[ExportSpec l]
</span><a href="#local-6989586621679423742"><span class="hs-identifier hs-var">ess</span></a></span><span>
</span><span id="line-1185"></span><span>
</span><span id="line-1186"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExportSpec"><span class="hs-identifier hs-type">ExportSpec</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1187"></span><span>    </span><span id="local-6989586621679423736"><span class="annot"><span class="annottext">ann :: forall l. ExportSpec l -&gt; l
</span><a href="#local-6989586621679423736"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679423735"><span class="annot"><span class="annottext">ExportSpec l
</span><a href="#local-6989586621679423735"><span class="hs-identifier hs-var">es</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">ExportSpec l
</span><a href="#local-6989586621679423735"><span class="hs-identifier hs-var">es</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1188"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EVar"><span class="hs-identifier hs-type">EVar</span></a></span><span> </span><span id="local-6989586621679423734"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423734"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423734"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1189"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EAbs"><span class="hs-identifier hs-type">EAbs</span></a></span><span> </span><span id="local-6989586621679423733"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423733"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Namespace l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423733"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1190"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EThingWith"><span class="hs-identifier hs-type">EThingWith</span></a></span><span> </span><span id="local-6989586621679423732"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423732"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">EWildcard l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[CName l]
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423732"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1191"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EModuleContents"><span class="hs-identifier hs-type">EModuleContents</span></a></span><span> </span><span id="local-6989586621679423731"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423731"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">ModuleName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423731"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1192"></span><span>    </span><span id="local-6989586621679423730"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; ExportSpec l -&gt; ExportSpec l
</span><a href="#local-6989586621679423730"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423729"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423729"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679423728"><span class="annot"><span class="annottext">ExportSpec l
</span><a href="#local-6989586621679423728"><span class="hs-identifier hs-var">es</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">ExportSpec l
</span><a href="#local-6989586621679423728"><span class="hs-identifier hs-var">es</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1193"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EVar"><span class="hs-identifier hs-type">EVar</span></a></span><span> </span><span id="local-6989586621679423727"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423727"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423726"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423726"><span class="hs-identifier hs-var">qn</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; ExportSpec l
</span><a href="Language.Haskell.Exts.Syntax.html#EVar"><span class="hs-identifier hs-var">EVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423729"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423727"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423726"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1194"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EAbs"><span class="hs-identifier hs-type">EAbs</span></a></span><span> </span><span id="local-6989586621679423725"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423725"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423724"><span class="annot"><span class="annottext">Namespace l
</span><a href="#local-6989586621679423724"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423723"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423723"><span class="hs-identifier hs-var">qn</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Namespace l -&gt; QName l -&gt; ExportSpec l
</span><a href="Language.Haskell.Exts.Syntax.html#EAbs"><span class="hs-identifier hs-var">EAbs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423729"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423725"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Namespace l
</span><a href="#local-6989586621679423724"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423723"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1195"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EThingWith"><span class="hs-identifier hs-type">EThingWith</span></a></span><span> </span><span id="local-6989586621679423722"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423722"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423721"><span class="annot"><span class="annottext">EWildcard l
</span><a href="#local-6989586621679423721"><span class="hs-identifier hs-var">wc</span></a></span></span><span> </span><span id="local-6989586621679423720"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423720"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621679423719"><span class="annot"><span class="annottext">[CName l]
</span><a href="#local-6989586621679423719"><span class="hs-identifier hs-var">cns</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; EWildcard l -&gt; QName l -&gt; [CName l] -&gt; ExportSpec l
</span><a href="Language.Haskell.Exts.Syntax.html#EThingWith"><span class="hs-identifier hs-var">EThingWith</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423729"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423722"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EWildcard l
</span><a href="#local-6989586621679423721"><span class="hs-identifier hs-var">wc</span></a></span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423720"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="annot"><span class="annottext">[CName l]
</span><a href="#local-6989586621679423719"><span class="hs-identifier hs-var">cns</span></a></span><span>
</span><span id="line-1196"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EModuleContents"><span class="hs-identifier hs-type">EModuleContents</span></a></span><span> </span><span id="local-6989586621679423718"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423718"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423717"><span class="annot"><span class="annottext">ModuleName l
</span><a href="#local-6989586621679423717"><span class="hs-identifier hs-var">mn</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; ModuleName l -&gt; ExportSpec l
</span><a href="Language.Haskell.Exts.Syntax.html#EModuleContents"><span class="hs-identifier hs-var">EModuleContents</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423729"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423718"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ModuleName l
</span><a href="#local-6989586621679423717"><span class="hs-identifier hs-var">mn</span></a></span><span>
</span><span id="line-1197"></span><span>
</span><span id="line-1198"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EWildcard"><span class="hs-identifier hs-type">EWildcard</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1199"></span><span>  </span><span id="local-6989586621679423711"><span class="annot"><span class="annottext">ann :: forall l. EWildcard l -&gt; l
</span><a href="#local-6989586621679423711"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679423710"><span class="annot"><span class="annottext">EWildcard l
</span><a href="#local-6989586621679423710"><span class="hs-identifier hs-var">ewc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">EWildcard l
</span><a href="#local-6989586621679423710"><span class="hs-identifier hs-var">ewc</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1200"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoWildcard"><span class="hs-identifier hs-type">NoWildcard</span></a></span><span> </span><span id="local-6989586621679423709"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423709"><span class="hs-identifier hs-var">l</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423709"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1201"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EWildcard"><span class="hs-identifier hs-type">EWildcard</span></a></span><span> </span><span id="local-6989586621679423708"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423708"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423708"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1202"></span><span>  </span><span id="local-6989586621679423707"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; EWildcard l -&gt; EWildcard l
</span><a href="#local-6989586621679423707"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423706"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423706"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679423705"><span class="annot"><span class="annottext">EWildcard l
</span><a href="#local-6989586621679423705"><span class="hs-identifier hs-var">ewc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">EWildcard l
</span><a href="#local-6989586621679423705"><span class="hs-identifier hs-var">ewc</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1203"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoWildcard"><span class="hs-identifier hs-type">NoWildcard</span></a></span><span> </span><span id="local-6989586621679423704"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423704"><span class="hs-identifier hs-var">l</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; EWildcard l
</span><a href="Language.Haskell.Exts.Syntax.html#NoWildcard"><span class="hs-identifier hs-var">NoWildcard</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423706"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423704"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1204"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EWildcard"><span class="hs-identifier hs-type">EWildcard</span></a></span><span> </span><span id="local-6989586621679423703"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423703"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423702"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679423702"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Int -&gt; EWildcard l
</span><a href="Language.Haskell.Exts.Syntax.html#EWildcard"><span class="hs-identifier hs-var">EWildcard</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423706"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423703"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679423702"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1205"></span><span>
</span><span id="line-1206"></span><span>
</span><span id="line-1207"></span><span>
</span><span id="line-1208"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Namespace"><span class="hs-identifier hs-type">Namespace</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1209"></span><span>    </span><span id="local-6989586621679423696"><span class="annot"><span class="annottext">ann :: forall l. Namespace l -&gt; l
</span><a href="#local-6989586621679423696"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679423695"><span class="annot"><span class="annottext">Namespace l
</span><a href="#local-6989586621679423695"><span class="hs-identifier hs-var">es</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Namespace l
</span><a href="#local-6989586621679423695"><span class="hs-identifier hs-var">es</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1210"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoNamespace"><span class="hs-identifier hs-type">NoNamespace</span></a></span><span> </span><span id="local-6989586621679423694"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423694"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423694"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1211"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeNamespace"><span class="hs-identifier hs-type">TypeNamespace</span></a></span><span> </span><span id="local-6989586621679423693"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423693"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423693"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1212"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatternNamespace"><span class="hs-identifier hs-type">PatternNamespace</span></a></span><span> </span><span id="local-6989586621679423692"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423692"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423692"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1213"></span><span>    </span><span id="local-6989586621679423691"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Namespace l -&gt; Namespace l
</span><a href="#local-6989586621679423691"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423690"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423690"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679423689"><span class="annot"><span class="annottext">Namespace l
</span><a href="#local-6989586621679423689"><span class="hs-identifier hs-var">es</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Namespace l
</span><a href="#local-6989586621679423689"><span class="hs-identifier hs-var">es</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1214"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoNamespace"><span class="hs-identifier hs-type">NoNamespace</span></a></span><span> </span><span id="local-6989586621679423688"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423688"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Namespace l
</span><a href="Language.Haskell.Exts.Syntax.html#NoNamespace"><span class="hs-identifier hs-var">NoNamespace</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423690"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423688"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1215"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeNamespace"><span class="hs-identifier hs-type">TypeNamespace</span></a></span><span> </span><span id="local-6989586621679423687"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423687"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Namespace l
</span><a href="Language.Haskell.Exts.Syntax.html#TypeNamespace"><span class="hs-identifier hs-var">TypeNamespace</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423690"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423687"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1216"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatternNamespace"><span class="hs-identifier hs-type">PatternNamespace</span></a></span><span> </span><span id="local-6989586621679423686"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423686"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Namespace l
</span><a href="Language.Haskell.Exts.Syntax.html#PatternNamespace"><span class="hs-identifier hs-var">PatternNamespace</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423690"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423686"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1217"></span><span>
</span><span id="line-1218"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-type">ImportDecl</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1219"></span><span>    </span><span id="local-6989586621679423680"><span class="annot"><span class="annottext">ann :: forall l. ImportDecl l -&gt; l
</span><a href="#local-6989586621679423680"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-type">ImportDecl</span></a></span><span> </span><span id="local-6989586621679423679"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423679"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">ModuleName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (ModuleName l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (ImportSpecList l)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423679"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1220"></span><span>    </span><span id="local-6989586621679423678"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; ImportDecl l -&gt; ImportDecl l
</span><a href="#local-6989586621679423678"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423677"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423677"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-type">ImportDecl</span></a></span><span> </span><span id="local-6989586621679423676"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423676"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423675"><span class="annot"><span class="annottext">ModuleName l
</span><a href="#local-6989586621679423675"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679423674"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423674"><span class="hs-identifier hs-var">qual</span></a></span></span><span> </span><span id="local-6989586621679423673"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423673"><span class="hs-identifier hs-var">src</span></a></span></span><span> </span><span id="local-6989586621679423672"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423672"><span class="hs-identifier hs-var">safe</span></a></span></span><span> </span><span id="local-6989586621679423671"><span class="annot"><span class="annottext">Maybe String
</span><a href="#local-6989586621679423671"><span class="hs-identifier hs-var">pkg</span></a></span></span><span> </span><span id="local-6989586621679423670"><span class="annot"><span class="annottext">Maybe (ModuleName l)
</span><a href="#local-6989586621679423670"><span class="hs-identifier hs-var">mmn</span></a></span></span><span> </span><span id="local-6989586621679423669"><span class="annot"><span class="annottext">Maybe (ImportSpecList l)
</span><a href="#local-6989586621679423669"><span class="hs-identifier hs-var">mis</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1221"></span><span>        </span><span class="annot"><span class="annottext">forall l.
l
-&gt; ModuleName l
-&gt; Bool
-&gt; Bool
-&gt; Bool
-&gt; Maybe String
-&gt; Maybe (ModuleName l)
-&gt; Maybe (ImportSpecList l)
-&gt; ImportDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-var">ImportDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423677"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423676"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ModuleName l
</span><a href="#local-6989586621679423675"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423674"><span class="hs-identifier hs-var">qual</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423673"><span class="hs-identifier hs-var">src</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423672"><span class="hs-identifier hs-var">safe</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe String
</span><a href="#local-6989586621679423671"><span class="hs-identifier hs-var">pkg</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (ModuleName l)
</span><a href="#local-6989586621679423670"><span class="hs-identifier hs-var">mmn</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (ImportSpecList l)
</span><a href="#local-6989586621679423669"><span class="hs-identifier hs-var">mis</span></a></span><span>
</span><span id="line-1222"></span><span>
</span><span id="line-1223"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportSpecList"><span class="hs-identifier hs-type">ImportSpecList</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1224"></span><span>    </span><span id="local-6989586621679423663"><span class="annot"><span class="annottext">ann :: forall l. ImportSpecList l -&gt; l
</span><a href="#local-6989586621679423663"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportSpecList"><span class="hs-identifier hs-type">ImportSpecList</span></a></span><span> </span><span id="local-6989586621679423662"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423662"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[ImportSpec l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423662"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1225"></span><span>    </span><span id="local-6989586621679423661"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; ImportSpecList l -&gt; ImportSpecList l
</span><a href="#local-6989586621679423661"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423660"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423660"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportSpecList"><span class="hs-identifier hs-type">ImportSpecList</span></a></span><span> </span><span id="local-6989586621679423659"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423659"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423658"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423658"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679423657"><span class="annot"><span class="annottext">[ImportSpec l]
</span><a href="#local-6989586621679423657"><span class="hs-identifier hs-var">iss</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Bool -&gt; [ImportSpec l] -&gt; ImportSpecList l
</span><a href="Language.Haskell.Exts.Syntax.html#ImportSpecList"><span class="hs-identifier hs-var">ImportSpecList</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423660"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423659"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423658"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">[ImportSpec l]
</span><a href="#local-6989586621679423657"><span class="hs-identifier hs-var">iss</span></a></span><span>
</span><span id="line-1226"></span><span>
</span><span id="line-1227"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ImportSpec"><span class="hs-identifier hs-type">ImportSpec</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1228"></span><span>    </span><span id="local-6989586621679423651"><span class="annot"><span class="annottext">ann :: forall l. ImportSpec l -&gt; l
</span><a href="#local-6989586621679423651"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679423650"><span class="annot"><span class="annottext">ImportSpec l
</span><a href="#local-6989586621679423650"><span class="hs-identifier hs-var">is</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">ImportSpec l
</span><a href="#local-6989586621679423650"><span class="hs-identifier hs-var">is</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1229"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IVar"><span class="hs-identifier hs-type">IVar</span></a></span><span> </span><span id="local-6989586621679423649"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423649"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423649"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1230"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IAbs"><span class="hs-identifier hs-type">IAbs</span></a></span><span> </span><span id="local-6989586621679423648"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423648"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Namespace l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423648"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1231"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IThingAll"><span class="hs-identifier hs-type">IThingAll</span></a></span><span> </span><span id="local-6989586621679423647"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423647"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423647"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1232"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IThingWith"><span class="hs-identifier hs-type">IThingWith</span></a></span><span> </span><span id="local-6989586621679423646"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423646"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[CName l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423646"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1233"></span><span>    </span><span id="local-6989586621679423645"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; ImportSpec l -&gt; ImportSpec l
</span><a href="#local-6989586621679423645"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423644"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423644"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679423643"><span class="annot"><span class="annottext">ImportSpec l
</span><a href="#local-6989586621679423643"><span class="hs-identifier hs-var">is</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">ImportSpec l
</span><a href="#local-6989586621679423643"><span class="hs-identifier hs-var">is</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1234"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IVar"><span class="hs-identifier hs-type">IVar</span></a></span><span> </span><span id="local-6989586621679423642"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423642"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423641"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423641"><span class="hs-identifier hs-var">n</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; ImportSpec l
</span><a href="Language.Haskell.Exts.Syntax.html#IVar"><span class="hs-identifier hs-var">IVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423644"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423642"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423641"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1235"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IAbs"><span class="hs-identifier hs-type">IAbs</span></a></span><span> </span><span id="local-6989586621679423640"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423640"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423639"><span class="annot"><span class="annottext">Namespace l
</span><a href="#local-6989586621679423639"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span id="local-6989586621679423638"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423638"><span class="hs-identifier hs-var">n</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Namespace l -&gt; Name l -&gt; ImportSpec l
</span><a href="Language.Haskell.Exts.Syntax.html#IAbs"><span class="hs-identifier hs-var">IAbs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423644"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423640"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Namespace l
</span><a href="#local-6989586621679423639"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423638"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1236"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IThingAll"><span class="hs-identifier hs-type">IThingAll</span></a></span><span> </span><span id="local-6989586621679423637"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423637"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423636"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423636"><span class="hs-identifier hs-var">n</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; ImportSpec l
</span><a href="Language.Haskell.Exts.Syntax.html#IThingAll"><span class="hs-identifier hs-var">IThingAll</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423644"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423637"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423636"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1237"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IThingWith"><span class="hs-identifier hs-type">IThingWith</span></a></span><span> </span><span id="local-6989586621679423635"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423635"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423634"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423634"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423633"><span class="annot"><span class="annottext">[CName l]
</span><a href="#local-6989586621679423633"><span class="hs-identifier hs-var">cns</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; [CName l] -&gt; ImportSpec l
</span><a href="Language.Haskell.Exts.Syntax.html#IThingWith"><span class="hs-identifier hs-var">IThingWith</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423644"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423635"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423634"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[CName l]
</span><a href="#local-6989586621679423633"><span class="hs-identifier hs-var">cns</span></a></span><span>
</span><span id="line-1238"></span><span>
</span><span id="line-1239"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Assoc"><span class="hs-identifier hs-type">Assoc</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1240"></span><span>    </span><span id="local-6989586621679423627"><span class="annot"><span class="annottext">ann :: forall l. Assoc l -&gt; l
</span><a href="#local-6989586621679423627"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AssocNone"><span class="hs-identifier hs-type">AssocNone</span></a></span><span>  </span><span id="local-6989586621679423626"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423626"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423626"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1241"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AssocLeft"><span class="hs-identifier hs-type">AssocLeft</span></a></span><span>  </span><span id="local-6989586621679423625"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423625"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423625"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1242"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AssocRight"><span class="hs-identifier hs-type">AssocRight</span></a></span><span> </span><span id="local-6989586621679423624"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423624"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423624"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1243"></span><span>    </span><span id="local-6989586621679423622"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Assoc l -&gt; Assoc l
</span><a href="#local-6989586621679423622"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1244"></span><span>
</span><span id="line-1245"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-type">Deriving</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1246"></span><span>    </span><span id="local-6989586621679423616"><span class="annot"><span class="annottext">ann :: forall l. Deriving l -&gt; l
</span><a href="#local-6989586621679423616"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-type">Deriving</span></a></span><span> </span><span id="local-6989586621679423615"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423615"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (DerivStrategy l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[InstRule l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423615"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1247"></span><span>    </span><span id="local-6989586621679423614"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Deriving l -&gt; Deriving l
</span><a href="#local-6989586621679423614"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423613"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423613"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-type">Deriving</span></a></span><span> </span><span id="local-6989586621679423612"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423612"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423611"><span class="annot"><span class="annottext">Maybe (DerivStrategy l)
</span><a href="#local-6989586621679423611"><span class="hs-identifier hs-var">mds</span></a></span></span><span> </span><span id="local-6989586621679423610"><span class="annot"><span class="annottext">[InstRule l]
</span><a href="#local-6989586621679423610"><span class="hs-identifier hs-var">ihs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l.
l -&gt; Maybe (DerivStrategy l) -&gt; [InstRule l] -&gt; Deriving l
</span><a href="Language.Haskell.Exts.Syntax.html#Deriving"><span class="hs-identifier hs-var">Deriving</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423613"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423612"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (DerivStrategy l)
</span><a href="#local-6989586621679423611"><span class="hs-identifier hs-var">mds</span></a></span><span> </span><span class="annot"><span class="annottext">[InstRule l]
</span><a href="#local-6989586621679423610"><span class="hs-identifier hs-var">ihs</span></a></span><span>
</span><span id="line-1248"></span><span>
</span><span id="line-1249"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivStrategy"><span class="hs-identifier hs-type">DerivStrategy</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1250"></span><span>    </span><span id="local-6989586621679423604"><span class="annot"><span class="annottext">ann :: forall l. DerivStrategy l -&gt; l
</span><a href="#local-6989586621679423604"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivStock"><span class="hs-identifier hs-type">DerivStock</span></a></span><span> </span><span id="local-6989586621679423603"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423603"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423603"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1251"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivAnyclass"><span class="hs-identifier hs-type">DerivAnyclass</span></a></span><span> </span><span id="local-6989586621679423602"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423602"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423602"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1252"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivNewtype"><span class="hs-identifier hs-type">DerivNewtype</span></a></span><span> </span><span id="local-6989586621679423601"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423601"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423601"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1253"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivVia"><span class="hs-identifier hs-type">DerivVia</span></a></span><span> </span><span id="local-6989586621679423600"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423600"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423600"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1254"></span><span>
</span><span id="line-1255"></span><span>    </span><span id="local-6989586621679423599"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; DerivStrategy l -&gt; DerivStrategy l
</span><a href="#local-6989586621679423599"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423598"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423598"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivStock"><span class="hs-identifier hs-type">DerivStock</span></a></span><span> </span><span id="local-6989586621679423597"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423597"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; DerivStrategy l
</span><a href="Language.Haskell.Exts.Syntax.html#DerivStock"><span class="hs-identifier hs-var">DerivStock</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423598"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423597"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1256"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423596"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423596"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivAnyclass"><span class="hs-identifier hs-type">DerivAnyclass</span></a></span><span> </span><span id="local-6989586621679423595"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423595"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; DerivStrategy l
</span><a href="Language.Haskell.Exts.Syntax.html#DerivAnyclass"><span class="hs-identifier hs-var">DerivAnyclass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423596"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423595"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1257"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423594"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423594"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivNewtype"><span class="hs-identifier hs-type">DerivNewtype</span></a></span><span> </span><span id="local-6989586621679423593"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423593"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; DerivStrategy l
</span><a href="Language.Haskell.Exts.Syntax.html#DerivNewtype"><span class="hs-identifier hs-var">DerivNewtype</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423594"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423593"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1258"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423592"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423592"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivVia"><span class="hs-identifier hs-type">DerivVia</span></a></span><span> </span><span id="local-6989586621679423591"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423591"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423590"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423590"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; DerivStrategy l
</span><a href="Language.Haskell.Exts.Syntax.html#DerivVia"><span class="hs-identifier hs-var">DerivVia</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423592"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423591"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423590"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1259"></span><span>
</span><span id="line-1260"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeEqn"><span class="hs-identifier hs-type">TypeEqn</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1261"></span><span>    </span><span id="local-6989586621679423584"><span class="annot"><span class="annottext">ann :: forall l. TypeEqn l -&gt; l
</span><a href="#local-6989586621679423584"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeEqn"><span class="hs-identifier hs-type">TypeEqn</span></a></span><span> </span><span id="local-6989586621679423583"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423583"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423583"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1262"></span><span>    </span><span id="local-6989586621679423582"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; TypeEqn l -&gt; TypeEqn l
</span><a href="#local-6989586621679423582"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423581"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423581"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeEqn"><span class="hs-identifier hs-type">TypeEqn</span></a></span><span> </span><span id="local-6989586621679423580"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423580"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423579"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423579"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679423578"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423578"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Type l -&gt; TypeEqn l
</span><a href="Language.Haskell.Exts.Syntax.html#TypeEqn"><span class="hs-identifier hs-var">TypeEqn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423581"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423580"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423579"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423578"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-1263"></span><span>
</span><span id="line-1264"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InjectivityInfo"><span class="hs-identifier hs-type">InjectivityInfo</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1265"></span><span>  </span><span id="local-6989586621679423572"><span class="annot"><span class="annottext">ann :: forall l. InjectivityInfo l -&gt; l
</span><a href="#local-6989586621679423572"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InjectivityInfo"><span class="hs-identifier hs-type">InjectivityInfo</span></a></span><span> </span><span id="local-6989586621679423571"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423571"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423571"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1266"></span><span>  </span><span id="local-6989586621679423570"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; InjectivityInfo l -&gt; InjectivityInfo l
</span><a href="#local-6989586621679423570"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423569"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423569"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InjectivityInfo"><span class="hs-identifier hs-type">InjectivityInfo</span></a></span><span> </span><span id="local-6989586621679423568"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423568"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423567"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423567"><span class="hs-identifier hs-var">to</span></a></span></span><span> </span><span id="local-6989586621679423566"><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679423566"><span class="hs-identifier hs-var">from</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; [Name l] -&gt; InjectivityInfo l
</span><a href="Language.Haskell.Exts.Syntax.html#InjectivityInfo"><span class="hs-identifier hs-var">InjectivityInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423569"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423568"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423567"><span class="hs-identifier hs-var">to</span></a></span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679423566"><span class="hs-identifier hs-var">from</span></a></span><span>
</span><span id="line-1267"></span><span>
</span><span id="line-1268"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ResultSig"><span class="hs-identifier hs-type">ResultSig</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1269"></span><span>  </span><span id="local-6989586621679423560"><span class="annot"><span class="annottext">ann :: forall l. ResultSig l -&gt; l
</span><a href="#local-6989586621679423560"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#KindSig"><span class="hs-identifier hs-type">KindSig</span></a></span><span> </span><span id="local-6989586621679423559"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423559"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Kind l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423559"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1270"></span><span>  </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarSig"><span class="hs-identifier hs-type">TyVarSig</span></a></span><span> </span><span id="local-6989586621679423558"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423558"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">TyVarBind l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423558"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1271"></span><span>
</span><span id="line-1272"></span><span>  </span><span id="local-6989586621679423557"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; ResultSig l -&gt; ResultSig l
</span><a href="#local-6989586621679423557"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423556"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423556"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#KindSig"><span class="hs-identifier hs-type">KindSig</span></a></span><span> </span><span id="local-6989586621679423555"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423555"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423554"><span class="annot"><span class="annottext">Kind l
</span><a href="#local-6989586621679423554"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Kind l -&gt; ResultSig l
</span><a href="Language.Haskell.Exts.Syntax.html#KindSig"><span class="hs-identifier hs-var">KindSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423556"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423555"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Kind l
</span><a href="#local-6989586621679423554"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1273"></span><span>  </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423553"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423553"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarSig"><span class="hs-identifier hs-type">TyVarSig</span></a></span><span> </span><span id="local-6989586621679423552"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423552"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423551"><span class="annot"><span class="annottext">TyVarBind l
</span><a href="#local-6989586621679423551"><span class="hs-identifier hs-var">tv</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; TyVarBind l -&gt; ResultSig l
</span><a href="Language.Haskell.Exts.Syntax.html#TyVarSig"><span class="hs-identifier hs-var">TyVarSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423553"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423552"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">TyVarBind l
</span><a href="#local-6989586621679423551"><span class="hs-identifier hs-var">tv</span></a></span><span>
</span><span id="line-1274"></span><span>
</span><span id="line-1275"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1276"></span><span>    </span><span id="local-6989586621679423545"><span class="annot"><span class="annottext">ann :: forall l. Decl l -&gt; l
</span><a href="#local-6989586621679423545"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679423544"><span class="annot"><span class="annottext">Decl l
</span><a href="#local-6989586621679423544"><span class="hs-identifier hs-var">decl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Decl l
</span><a href="#local-6989586621679423544"><span class="hs-identifier hs-var">decl</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1277"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeDecl"><span class="hs-identifier hs-type">TypeDecl</span></a></span><span>     </span><span id="local-6989586621679423543"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423543"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423543"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1278"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeFamDecl"><span class="hs-identifier hs-type">TypeFamDecl</span></a></span><span>  </span><span id="local-6989586621679423542"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423542"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (InjectivityInfo l)
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423542"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1279"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClosedTypeFamDecl"><span class="hs-identifier hs-type">ClosedTypeFamDecl</span></a></span><span>  </span><span id="local-6989586621679423541"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423541"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (InjectivityInfo l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[TypeEqn l]
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423541"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1280"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataDecl"><span class="hs-identifier hs-type">DataDecl</span></a></span><span>     </span><span id="local-6989586621679423540"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423540"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[QualConDecl l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423540"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1281"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GDataDecl"><span class="hs-identifier hs-type">GDataDecl</span></a></span><span>    </span><span id="local-6989586621679423539"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423539"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Type l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[GadtDecl l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423539"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1282"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataFamDecl"><span class="hs-identifier hs-type">DataFamDecl</span></a></span><span>  </span><span id="local-6989586621679423538"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423538"><span class="hs-identifier hs-var">l</span></a></span></span><span>    </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423538"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1283"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeInsDecl"><span class="hs-identifier hs-type">TypeInsDecl</span></a></span><span>  </span><span id="local-6989586621679423537"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423537"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>  </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423537"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1284"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataInsDecl"><span class="hs-identifier hs-type">DataInsDecl</span></a></span><span>  </span><span id="local-6989586621679423536"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423536"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[QualConDecl l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423536"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1285"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GDataInsDecl"><span class="hs-identifier hs-type">GDataInsDecl</span></a></span><span> </span><span id="local-6989586621679423535"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423535"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Type l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[GadtDecl l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423535"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1286"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClassDecl"><span class="hs-identifier hs-type">ClassDecl</span></a></span><span>    </span><span id="local-6989586621679423534"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423534"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[FunDep l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe [ClassDecl l]
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423534"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1287"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstDecl"><span class="hs-identifier hs-type">InstDecl</span></a></span><span>     </span><span id="local-6989586621679423533"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423533"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (Overlap l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">InstRule l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe [InstDecl l]
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423533"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1288"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivDecl"><span class="hs-identifier hs-type">DerivDecl</span></a></span><span>    </span><span id="local-6989586621679423532"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423532"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (DerivStrategy l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Overlap l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">InstRule l
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423532"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1289"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixDecl"><span class="hs-identifier hs-type">InfixDecl</span></a></span><span>    </span><span id="local-6989586621679423531"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423531"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Assoc l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Op l]
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423531"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1290"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DefaultDecl"><span class="hs-identifier hs-type">DefaultDecl</span></a></span><span>  </span><span id="local-6989586621679423530"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423530"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423530"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1291"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpliceDecl"><span class="hs-identifier hs-type">SpliceDecl</span></a></span><span>   </span><span id="local-6989586621679423529"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423529"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423529"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1292"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TSpliceDecl"><span class="hs-identifier hs-type">TSpliceDecl</span></a></span><span>  </span><span id="local-6989586621679423528"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423528"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423528"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1293"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeSig"><span class="hs-identifier hs-type">TypeSig</span></a></span><span>      </span><span id="local-6989586621679423527"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423527"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423527"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1294"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatSynSig"><span class="hs-identifier hs-type">PatSynSig</span></a></span><span>    </span><span id="local-6989586621679423526"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423526"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423526"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1295"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunBind"><span class="hs-identifier hs-type">FunBind</span></a></span><span>      </span><span id="local-6989586621679423525"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423525"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Match l]
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423525"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1296"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatBind"><span class="hs-identifier hs-type">PatBind</span></a></span><span>      </span><span id="local-6989586621679423524"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423524"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Rhs l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Binds l)
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423524"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1297"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ForImp"><span class="hs-identifier hs-type">ForImp</span></a></span><span>       </span><span id="local-6989586621679423523"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423523"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">CallConv l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Safety l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423523"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1298"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ForExp"><span class="hs-identifier hs-type">ForExp</span></a></span><span>       </span><span id="local-6989586621679423522"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423522"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">CallConv l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423522"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1299"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RulePragmaDecl"><span class="hs-identifier hs-type">RulePragmaDecl</span></a></span><span>   </span><span id="local-6989586621679423521"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423521"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Rule l]
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423521"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1300"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeprPragmaDecl"><span class="hs-identifier hs-type">DeprPragmaDecl</span></a></span><span>   </span><span id="local-6989586621679423520"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423520"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[([Name l], String)]
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423520"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1301"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#WarnPragmaDecl"><span class="hs-identifier hs-type">WarnPragmaDecl</span></a></span><span>   </span><span id="local-6989586621679423519"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423519"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[([Name l], String)]
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423519"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1302"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InlineSig"><span class="hs-identifier hs-type">InlineSig</span></a></span><span>        </span><span id="local-6989586621679423518"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423518"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Activation l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423518"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1303"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InlineConlikeSig"><span class="hs-identifier hs-type">InlineConlikeSig</span></a></span><span> </span><span id="local-6989586621679423517"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423517"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span class="annot"><span class="annottext">Maybe (Activation l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423517"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1304"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpecSig"><span class="hs-identifier hs-type">SpecSig</span></a></span><span>          </span><span id="local-6989586621679423516"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423516"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span class="annot"><span class="annottext">Maybe (Activation l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423516"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1305"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpecInlineSig"><span class="hs-identifier hs-type">SpecInlineSig</span></a></span><span>    </span><span id="local-6989586621679423515"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423515"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Activation l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423515"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1306"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstSig"><span class="hs-identifier hs-type">InstSig</span></a></span><span>          </span><span id="local-6989586621679423514"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423514"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">InstRule l
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423514"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1307"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AnnPragma"><span class="hs-identifier hs-type">AnnPragma</span></a></span><span>        </span><span id="local-6989586621679423513"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423513"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Annotation l
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423513"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1308"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MinimalPragma"><span class="hs-identifier hs-type">MinimalPragma</span></a></span><span>    </span><span id="local-6989586621679423512"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423512"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (BooleanFormula l)
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423512"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1309"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RoleAnnotDecl"><span class="hs-identifier hs-type">RoleAnnotDecl</span></a></span><span>    </span><span id="local-6989586621679423511"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423511"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Role l]
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423511"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1310"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatSyn"><span class="hs-identifier hs-type">PatSyn</span></a></span><span>           </span><span id="local-6989586621679423510"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423510"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">PatternSynDirection l
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423510"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1311"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CompletePragma"><span class="hs-identifier hs-type">CompletePragma</span></a></span><span> </span><span id="local-6989586621679423509"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423509"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (QName l)
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423509"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1312"></span><span>    </span><span id="local-6989586621679423508"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Decl l -&gt; Decl l
</span><a href="#local-6989586621679423508"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423507"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679423506"><span class="annot"><span class="annottext">Decl l
</span><a href="#local-6989586621679423506"><span class="hs-identifier hs-var">decl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Decl l
</span><a href="#local-6989586621679423506"><span class="hs-identifier hs-var">decl</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1313"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeDecl"><span class="hs-identifier hs-type">TypeDecl</span></a></span><span>     </span><span id="local-6989586621679423505"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423505"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423504"><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423504"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423503"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423503"><span class="hs-identifier hs-var">t</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; DeclHead l -&gt; Type l -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#TypeDecl"><span class="hs-identifier hs-var">TypeDecl</span></a></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423505"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423504"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423503"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1314"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeFamDecl"><span class="hs-identifier hs-type">TypeFamDecl</span></a></span><span>  </span><span id="local-6989586621679423502"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423502"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423501"><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423501"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423500"><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><a href="#local-6989586621679423500"><span class="hs-identifier hs-var">mk</span></a></span></span><span> </span><span id="local-6989586621679423499"><span class="annot"><span class="annottext">Maybe (InjectivityInfo l)
</span><a href="#local-6989586621679423499"><span class="hs-identifier hs-var">mi</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; DeclHead l
-&gt; Maybe (ResultSig l)
-&gt; Maybe (InjectivityInfo l)
-&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#TypeFamDecl"><span class="hs-identifier hs-var">TypeFamDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423502"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423501"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><a href="#local-6989586621679423500"><span class="hs-identifier hs-var">mk</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (InjectivityInfo l)
</span><a href="#local-6989586621679423499"><span class="hs-identifier hs-var">mi</span></a></span><span>
</span><span id="line-1315"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClosedTypeFamDecl"><span class="hs-identifier hs-type">ClosedTypeFamDecl</span></a></span><span>  </span><span id="local-6989586621679423498"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423498"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423497"><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423497"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423496"><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><a href="#local-6989586621679423496"><span class="hs-identifier hs-var">mk</span></a></span></span><span> </span><span id="local-6989586621679423495"><span class="annot"><span class="annottext">Maybe (InjectivityInfo l)
</span><a href="#local-6989586621679423495"><span class="hs-identifier hs-var">mi</span></a></span></span><span> </span><span id="local-6989586621679423494"><span class="annot"><span class="annottext">[TypeEqn l]
</span><a href="#local-6989586621679423494"><span class="hs-identifier hs-var">eqns</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; DeclHead l
-&gt; Maybe (ResultSig l)
-&gt; Maybe (InjectivityInfo l)
-&gt; [TypeEqn l]
-&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#ClosedTypeFamDecl"><span class="hs-identifier hs-var">ClosedTypeFamDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423498"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423497"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><a href="#local-6989586621679423496"><span class="hs-identifier hs-var">mk</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (InjectivityInfo l)
</span><a href="#local-6989586621679423495"><span class="hs-identifier hs-var">mi</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeEqn l]
</span><a href="#local-6989586621679423494"><span class="hs-identifier hs-var">eqns</span></a></span><span>
</span><span id="line-1316"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataDecl"><span class="hs-identifier hs-type">DataDecl</span></a></span><span>     </span><span id="local-6989586621679423493"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423493"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423492"><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423492"><span class="hs-identifier hs-var">dn</span></a></span></span><span> </span><span id="local-6989586621679423491"><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423491"><span class="hs-identifier hs-var">mcx</span></a></span></span><span> </span><span id="local-6989586621679423490"><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423490"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423489"><span class="annot"><span class="annottext">[QualConDecl l]
</span><a href="#local-6989586621679423489"><span class="hs-identifier hs-var">cds</span></a></span></span><span> </span><span id="local-6989586621679423488"><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423488"><span class="hs-identifier hs-var">ders</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1317"></span><span>            </span><span class="annot"><span class="annottext">forall l.
l
-&gt; DataOrNew l
-&gt; Maybe (Context l)
-&gt; DeclHead l
-&gt; [QualConDecl l]
-&gt; [Deriving l]
-&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#DataDecl"><span class="hs-identifier hs-var">DataDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423493"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423492"><span class="hs-identifier hs-var">dn</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423491"><span class="hs-identifier hs-var">mcx</span></a></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423490"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">[QualConDecl l]
</span><a href="#local-6989586621679423489"><span class="hs-identifier hs-var">cds</span></a></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423488"><span class="hs-identifier hs-var">ders</span></a></span><span>
</span><span id="line-1318"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GDataDecl"><span class="hs-identifier hs-type">GDataDecl</span></a></span><span>    </span><span id="local-6989586621679423487"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423487"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423486"><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423486"><span class="hs-identifier hs-var">dn</span></a></span></span><span> </span><span id="local-6989586621679423485"><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423485"><span class="hs-identifier hs-var">mcx</span></a></span></span><span> </span><span id="local-6989586621679423484"><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423484"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423483"><span class="annot"><span class="annottext">Maybe (Type l)
</span><a href="#local-6989586621679423483"><span class="hs-identifier hs-var">mk</span></a></span></span><span> </span><span id="local-6989586621679423482"><span class="annot"><span class="annottext">[GadtDecl l]
</span><a href="#local-6989586621679423482"><span class="hs-identifier hs-var">gds</span></a></span></span><span> </span><span id="local-6989586621679423481"><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423481"><span class="hs-identifier hs-var">ders</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1319"></span><span>            </span><span class="annot"><span class="annottext">forall l.
l
-&gt; DataOrNew l
-&gt; Maybe (Context l)
-&gt; DeclHead l
-&gt; Maybe (Type l)
-&gt; [GadtDecl l]
-&gt; [Deriving l]
-&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#GDataDecl"><span class="hs-identifier hs-var">GDataDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423487"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423486"><span class="hs-identifier hs-var">dn</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423485"><span class="hs-identifier hs-var">mcx</span></a></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423484"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Type l)
</span><a href="#local-6989586621679423483"><span class="hs-identifier hs-var">mk</span></a></span><span> </span><span class="annot"><span class="annottext">[GadtDecl l]
</span><a href="#local-6989586621679423482"><span class="hs-identifier hs-var">gds</span></a></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423481"><span class="hs-identifier hs-var">ders</span></a></span><span>
</span><span id="line-1320"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataFamDecl"><span class="hs-identifier hs-type">DataFamDecl</span></a></span><span>  </span><span id="local-6989586621679423480"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423480"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423479"><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423479"><span class="hs-identifier hs-var">mcx</span></a></span></span><span> </span><span id="local-6989586621679423478"><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423478"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423477"><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><a href="#local-6989586621679423477"><span class="hs-identifier hs-var">mk</span></a></span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; Maybe (Context l) -&gt; DeclHead l -&gt; Maybe (ResultSig l) -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#DataFamDecl"><span class="hs-identifier hs-var">DataFamDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423480"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423479"><span class="hs-identifier hs-var">mcx</span></a></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423478"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><a href="#local-6989586621679423477"><span class="hs-identifier hs-var">mk</span></a></span><span>
</span><span id="line-1321"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeInsDecl"><span class="hs-identifier hs-type">TypeInsDecl</span></a></span><span>  </span><span id="local-6989586621679423476"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423476"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423475"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423475"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679423474"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423474"><span class="hs-identifier hs-var">t2</span></a></span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Type l -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#TypeInsDecl"><span class="hs-identifier hs-var">TypeInsDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423476"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423475"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423474"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1322"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataInsDecl"><span class="hs-identifier hs-type">DataInsDecl</span></a></span><span>  </span><span id="local-6989586621679423473"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423473"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423472"><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423472"><span class="hs-identifier hs-var">dn</span></a></span></span><span> </span><span id="local-6989586621679423471"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423471"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679423470"><span class="annot"><span class="annottext">[QualConDecl l]
</span><a href="#local-6989586621679423470"><span class="hs-identifier hs-var">cds</span></a></span></span><span> </span><span id="local-6989586621679423469"><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423469"><span class="hs-identifier hs-var">ders</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; DataOrNew l
-&gt; Type l
-&gt; [QualConDecl l]
-&gt; [Deriving l]
-&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#DataInsDecl"><span class="hs-identifier hs-var">DataInsDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423473"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423472"><span class="hs-identifier hs-var">dn</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423471"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">[QualConDecl l]
</span><a href="#local-6989586621679423470"><span class="hs-identifier hs-var">cds</span></a></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423469"><span class="hs-identifier hs-var">ders</span></a></span><span>
</span><span id="line-1323"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GDataInsDecl"><span class="hs-identifier hs-type">GDataInsDecl</span></a></span><span> </span><span id="local-6989586621679423468"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423468"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423467"><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423467"><span class="hs-identifier hs-var">dn</span></a></span></span><span> </span><span id="local-6989586621679423466"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423466"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679423465"><span class="annot"><span class="annottext">Maybe (Type l)
</span><a href="#local-6989586621679423465"><span class="hs-identifier hs-var">mk</span></a></span></span><span> </span><span id="local-6989586621679423464"><span class="annot"><span class="annottext">[GadtDecl l]
</span><a href="#local-6989586621679423464"><span class="hs-identifier hs-var">gds</span></a></span></span><span> </span><span id="local-6989586621679423463"><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423463"><span class="hs-identifier hs-var">ders</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; DataOrNew l
-&gt; Type l
-&gt; Maybe (Type l)
-&gt; [GadtDecl l]
-&gt; [Deriving l]
-&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#GDataInsDecl"><span class="hs-identifier hs-var">GDataInsDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423468"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423467"><span class="hs-identifier hs-var">dn</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423466"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Type l)
</span><a href="#local-6989586621679423465"><span class="hs-identifier hs-var">mk</span></a></span><span> </span><span class="annot"><span class="annottext">[GadtDecl l]
</span><a href="#local-6989586621679423464"><span class="hs-identifier hs-var">gds</span></a></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423463"><span class="hs-identifier hs-var">ders</span></a></span><span>
</span><span id="line-1324"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClassDecl"><span class="hs-identifier hs-type">ClassDecl</span></a></span><span>    </span><span id="local-6989586621679423462"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423462"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423461"><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423461"><span class="hs-identifier hs-var">mcx</span></a></span></span><span> </span><span id="local-6989586621679423460"><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423460"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423459"><span class="annot"><span class="annottext">[FunDep l]
</span><a href="#local-6989586621679423459"><span class="hs-identifier hs-var">fds</span></a></span></span><span> </span><span id="local-6989586621679423458"><span class="annot"><span class="annottext">Maybe [ClassDecl l]
</span><a href="#local-6989586621679423458"><span class="hs-identifier hs-var">cds</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; Maybe (Context l)
-&gt; DeclHead l
-&gt; [FunDep l]
-&gt; Maybe [ClassDecl l]
-&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#ClassDecl"><span class="hs-identifier hs-var">ClassDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423462"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423461"><span class="hs-identifier hs-var">mcx</span></a></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423460"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">[FunDep l]
</span><a href="#local-6989586621679423459"><span class="hs-identifier hs-var">fds</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [ClassDecl l]
</span><a href="#local-6989586621679423458"><span class="hs-identifier hs-var">cds</span></a></span><span>
</span><span id="line-1325"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstDecl"><span class="hs-identifier hs-type">InstDecl</span></a></span><span>     </span><span id="local-6989586621679423457"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423457"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423456"><span class="annot"><span class="annottext">Maybe (Overlap l)
</span><a href="#local-6989586621679423456"><span class="hs-identifier hs-var">mo</span></a></span></span><span> </span><span id="local-6989586621679423455"><span class="annot"><span class="annottext">InstRule l
</span><a href="#local-6989586621679423455"><span class="hs-identifier hs-var">ih</span></a></span></span><span> </span><span id="local-6989586621679423454"><span class="annot"><span class="annottext">Maybe [InstDecl l]
</span><a href="#local-6989586621679423454"><span class="hs-identifier hs-var">ids</span></a></span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; Maybe (Overlap l) -&gt; InstRule l -&gt; Maybe [InstDecl l] -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#InstDecl"><span class="hs-identifier hs-var">InstDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423457"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (Overlap l)
</span><a href="#local-6989586621679423456"><span class="hs-identifier hs-var">mo</span></a></span><span> </span><span class="annot"><span class="annottext">InstRule l
</span><a href="#local-6989586621679423455"><span class="hs-identifier hs-var">ih</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [InstDecl l]
</span><a href="#local-6989586621679423454"><span class="hs-identifier hs-var">ids</span></a></span><span>
</span><span id="line-1326"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DerivDecl"><span class="hs-identifier hs-type">DerivDecl</span></a></span><span>    </span><span id="local-6989586621679423453"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423453"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423452"><span class="annot"><span class="annottext">Maybe (DerivStrategy l)
</span><a href="#local-6989586621679423452"><span class="hs-identifier hs-var">mds</span></a></span></span><span> </span><span id="local-6989586621679423451"><span class="annot"><span class="annottext">Maybe (Overlap l)
</span><a href="#local-6989586621679423451"><span class="hs-identifier hs-var">mo</span></a></span></span><span> </span><span id="local-6989586621679423450"><span class="annot"><span class="annottext">InstRule l
</span><a href="#local-6989586621679423450"><span class="hs-identifier hs-var">ih</span></a></span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; Maybe (DerivStrategy l)
-&gt; Maybe (Overlap l)
-&gt; InstRule l
-&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#DerivDecl"><span class="hs-identifier hs-var">DerivDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423453"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (DerivStrategy l)
</span><a href="#local-6989586621679423452"><span class="hs-identifier hs-var">mds</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Overlap l)
</span><a href="#local-6989586621679423451"><span class="hs-identifier hs-var">mo</span></a></span><span> </span><span class="annot"><span class="annottext">InstRule l
</span><a href="#local-6989586621679423450"><span class="hs-identifier hs-var">ih</span></a></span><span>
</span><span id="line-1327"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixDecl"><span class="hs-identifier hs-type">InfixDecl</span></a></span><span>    </span><span id="local-6989586621679423449"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423449"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423448"><span class="annot"><span class="annottext">Assoc l
</span><a href="#local-6989586621679423448"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679423447"><span class="annot"><span class="annottext">Maybe Int
</span><a href="#local-6989586621679423447"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679423446"><span class="annot"><span class="annottext">[Op l]
</span><a href="#local-6989586621679423446"><span class="hs-identifier hs-var">ops</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Assoc l -&gt; Maybe Int -&gt; [Op l] -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#InfixDecl"><span class="hs-identifier hs-var">InfixDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423449"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Assoc l
</span><a href="#local-6989586621679423448"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Int
</span><a href="#local-6989586621679423447"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">[Op l]
</span><a href="#local-6989586621679423446"><span class="hs-identifier hs-var">ops</span></a></span><span>
</span><span id="line-1328"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DefaultDecl"><span class="hs-identifier hs-type">DefaultDecl</span></a></span><span>  </span><span id="local-6989586621679423445"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423445"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423444"><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679423444"><span class="hs-identifier hs-var">ts</span></a></span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Type l] -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#DefaultDecl"><span class="hs-identifier hs-var">DefaultDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423445"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679423444"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-1329"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpliceDecl"><span class="hs-identifier hs-type">SpliceDecl</span></a></span><span>   </span><span id="local-6989586621679423443"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423443"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423442"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423442"><span class="hs-identifier hs-var">sp</span></a></span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#SpliceDecl"><span class="hs-identifier hs-var">SpliceDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423443"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423442"><span class="hs-identifier hs-var">sp</span></a></span><span>
</span><span id="line-1330"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TSpliceDecl"><span class="hs-identifier hs-type">TSpliceDecl</span></a></span><span>  </span><span id="local-6989586621679423441"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423441"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423440"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423440"><span class="hs-identifier hs-var">sp</span></a></span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#TSpliceDecl"><span class="hs-identifier hs-var">TSpliceDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423441"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423440"><span class="hs-identifier hs-var">sp</span></a></span><span>
</span><span id="line-1331"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeSig"><span class="hs-identifier hs-type">TypeSig</span></a></span><span>      </span><span id="local-6989586621679423439"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423439"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423438"><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679423438"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span id="local-6989586621679423437"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423437"><span class="hs-identifier hs-var">t</span></a></span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Name l] -&gt; Type l -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#TypeSig"><span class="hs-identifier hs-var">TypeSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423439"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679423438"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423437"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1332"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatSynSig"><span class="hs-identifier hs-type">PatSynSig</span></a></span><span>    </span><span id="local-6989586621679423436"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423436"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423435"><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679423435"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423434"><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679423434"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423433"><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423433"><span class="hs-identifier hs-var">c1</span></a></span></span><span> </span><span id="local-6989586621679423432"><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679423432"><span class="hs-identifier hs-var">dh2</span></a></span></span><span> </span><span id="local-6989586621679423431"><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423431"><span class="hs-identifier hs-var">c2</span></a></span></span><span> </span><span id="local-6989586621679423430"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423430"><span class="hs-identifier hs-var">t</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; [Name l]
-&gt; Maybe [TyVarBind l]
-&gt; Maybe (Context l)
-&gt; Maybe [TyVarBind l]
-&gt; Maybe (Context l)
-&gt; Type l
-&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#PatSynSig"><span class="hs-identifier hs-var">PatSynSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423436"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679423435"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679423434"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423433"><span class="hs-identifier hs-var">c1</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679423432"><span class="hs-identifier hs-var">dh2</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423431"><span class="hs-identifier hs-var">c2</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423430"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1333"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunBind"><span class="hs-identifier hs-type">FunBind</span></a></span><span>      </span><span id="local-6989586621679423429"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423429"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423428"><span class="annot"><span class="annottext">[Match l]
</span><a href="#local-6989586621679423428"><span class="hs-identifier hs-var">ms</span></a></span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Match l] -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#FunBind"><span class="hs-identifier hs-var">FunBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423429"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Match l]
</span><a href="#local-6989586621679423428"><span class="hs-identifier hs-var">ms</span></a></span><span>
</span><span id="line-1334"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatBind"><span class="hs-identifier hs-type">PatBind</span></a></span><span>      </span><span id="local-6989586621679423427"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423427"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423426"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679423426"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679423425"><span class="annot"><span class="annottext">Rhs l
</span><a href="#local-6989586621679423425"><span class="hs-identifier hs-var">rhs</span></a></span></span><span> </span><span id="local-6989586621679423424"><span class="annot"><span class="annottext">Maybe (Binds l)
</span><a href="#local-6989586621679423424"><span class="hs-identifier hs-var">bs</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; Rhs l -&gt; Maybe (Binds l) -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#PatBind"><span class="hs-identifier hs-var">PatBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423427"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679423426"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Rhs l
</span><a href="#local-6989586621679423425"><span class="hs-identifier hs-var">rhs</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Binds l)
</span><a href="#local-6989586621679423424"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-1335"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ForImp"><span class="hs-identifier hs-type">ForImp</span></a></span><span>       </span><span id="local-6989586621679423423"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423423"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423422"><span class="annot"><span class="annottext">CallConv l
</span><a href="#local-6989586621679423422"><span class="hs-identifier hs-var">cc</span></a></span></span><span> </span><span id="local-6989586621679423421"><span class="annot"><span class="annottext">Maybe (Safety l)
</span><a href="#local-6989586621679423421"><span class="hs-identifier hs-var">msf</span></a></span></span><span> </span><span id="local-6989586621679423420"><span class="annot"><span class="annottext">Maybe String
</span><a href="#local-6989586621679423420"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679423419"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423419"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423418"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423418"><span class="hs-identifier hs-var">t</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; CallConv l
-&gt; Maybe (Safety l)
-&gt; Maybe String
-&gt; Name l
-&gt; Type l
-&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#ForImp"><span class="hs-identifier hs-var">ForImp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423423"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">CallConv l
</span><a href="#local-6989586621679423422"><span class="hs-identifier hs-var">cc</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Safety l)
</span><a href="#local-6989586621679423421"><span class="hs-identifier hs-var">msf</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe String
</span><a href="#local-6989586621679423420"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423419"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423418"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1336"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ForExp"><span class="hs-identifier hs-type">ForExp</span></a></span><span>       </span><span id="local-6989586621679423417"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423417"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423416"><span class="annot"><span class="annottext">CallConv l
</span><a href="#local-6989586621679423416"><span class="hs-identifier hs-var">cc</span></a></span></span><span>     </span><span id="local-6989586621679423415"><span class="annot"><span class="annottext">Maybe String
</span><a href="#local-6989586621679423415"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679423414"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423414"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423413"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423413"><span class="hs-identifier hs-var">t</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l -&gt; CallConv l -&gt; Maybe String -&gt; Name l -&gt; Type l -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#ForExp"><span class="hs-identifier hs-var">ForExp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423417"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">CallConv l
</span><a href="#local-6989586621679423416"><span class="hs-identifier hs-var">cc</span></a></span><span>     </span><span class="annot"><span class="annottext">Maybe String
</span><a href="#local-6989586621679423415"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423414"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423413"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1337"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RulePragmaDecl"><span class="hs-identifier hs-type">RulePragmaDecl</span></a></span><span>   </span><span id="local-6989586621679423412"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423412"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423411"><span class="annot"><span class="annottext">[Rule l]
</span><a href="#local-6989586621679423411"><span class="hs-identifier hs-var">rs</span></a></span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Rule l] -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#RulePragmaDecl"><span class="hs-identifier hs-var">RulePragmaDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423412"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Rule l]
</span><a href="#local-6989586621679423411"><span class="hs-identifier hs-var">rs</span></a></span><span>
</span><span id="line-1338"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeprPragmaDecl"><span class="hs-identifier hs-type">DeprPragmaDecl</span></a></span><span>   </span><span id="local-6989586621679423410"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423410"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423409"><span class="annot"><span class="annottext">[([Name l], String)]
</span><a href="#local-6989586621679423409"><span class="hs-identifier hs-var">nss</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [([Name l], String)] -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#DeprPragmaDecl"><span class="hs-identifier hs-var">DeprPragmaDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423410"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([Name l], String)]
</span><a href="#local-6989586621679423409"><span class="hs-identifier hs-var">nss</span></a></span><span>
</span><span id="line-1339"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#WarnPragmaDecl"><span class="hs-identifier hs-type">WarnPragmaDecl</span></a></span><span>   </span><span id="local-6989586621679423408"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423408"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423407"><span class="annot"><span class="annottext">[([Name l], String)]
</span><a href="#local-6989586621679423407"><span class="hs-identifier hs-var">nss</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [([Name l], String)] -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#WarnPragmaDecl"><span class="hs-identifier hs-var">WarnPragmaDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423408"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[([Name l], String)]
</span><a href="#local-6989586621679423407"><span class="hs-identifier hs-var">nss</span></a></span><span>
</span><span id="line-1340"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InlineSig"><span class="hs-identifier hs-type">InlineSig</span></a></span><span>        </span><span id="local-6989586621679423406"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423406"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423405"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423405"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679423404"><span class="annot"><span class="annottext">Maybe (Activation l)
</span><a href="#local-6989586621679423404"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span id="local-6989586621679423403"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423403"><span class="hs-identifier hs-var">qn</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Bool -&gt; Maybe (Activation l) -&gt; QName l -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#InlineSig"><span class="hs-identifier hs-var">InlineSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423406"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423405"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Activation l)
</span><a href="#local-6989586621679423404"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423403"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1341"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InlineConlikeSig"><span class="hs-identifier hs-type">InlineConlikeSig</span></a></span><span> </span><span id="local-6989586621679423402"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423402"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span id="local-6989586621679423401"><span class="annot"><span class="annottext">Maybe (Activation l)
</span><a href="#local-6989586621679423401"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span id="local-6989586621679423400"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423400"><span class="hs-identifier hs-var">qn</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Maybe (Activation l) -&gt; QName l -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#InlineConlikeSig"><span class="hs-identifier hs-var">InlineConlikeSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423402"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (Activation l)
</span><a href="#local-6989586621679423401"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423400"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1342"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpecSig"><span class="hs-identifier hs-type">SpecSig</span></a></span><span>          </span><span id="local-6989586621679423399"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423399"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span id="local-6989586621679423398"><span class="annot"><span class="annottext">Maybe (Activation l)
</span><a href="#local-6989586621679423398"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span id="local-6989586621679423397"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423397"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621679423396"><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679423396"><span class="hs-identifier hs-var">ts</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l -&gt; Maybe (Activation l) -&gt; QName l -&gt; [Type l] -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#SpecSig"><span class="hs-identifier hs-var">SpecSig</span></a></span><span>       </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423399"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="annottext">Maybe (Activation l)
</span><a href="#local-6989586621679423398"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423397"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679423396"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-1343"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpecInlineSig"><span class="hs-identifier hs-type">SpecInlineSig</span></a></span><span>    </span><span id="local-6989586621679423395"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423395"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423394"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423394"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679423393"><span class="annot"><span class="annottext">Maybe (Activation l)
</span><a href="#local-6989586621679423393"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span id="local-6989586621679423392"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423392"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621679423391"><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679423391"><span class="hs-identifier hs-var">ts</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l -&gt; Bool -&gt; Maybe (Activation l) -&gt; QName l -&gt; [Type l] -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#SpecInlineSig"><span class="hs-identifier hs-var">SpecInlineSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423395"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679423394"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Activation l)
</span><a href="#local-6989586621679423393"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423392"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679423391"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-1344"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstSig"><span class="hs-identifier hs-type">InstSig</span></a></span><span>          </span><span id="local-6989586621679423390"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423390"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423389"><span class="annot"><span class="annottext">InstRule l
</span><a href="#local-6989586621679423389"><span class="hs-identifier hs-var">ih</span></a></span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; InstRule l -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#InstSig"><span class="hs-identifier hs-var">InstSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423390"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">InstRule l
</span><a href="#local-6989586621679423389"><span class="hs-identifier hs-var">ih</span></a></span><span>
</span><span id="line-1345"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AnnPragma"><span class="hs-identifier hs-type">AnnPragma</span></a></span><span>        </span><span id="local-6989586621679423388"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423388"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423387"><span class="annot"><span class="annottext">Annotation l
</span><a href="#local-6989586621679423387"><span class="hs-identifier hs-var">ann'</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Annotation l -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#AnnPragma"><span class="hs-identifier hs-var">AnnPragma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423388"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Annotation l
</span><a href="#local-6989586621679423387"><span class="hs-identifier hs-var">ann'</span></a></span><span>
</span><span id="line-1346"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MinimalPragma"><span class="hs-identifier hs-type">MinimalPragma</span></a></span><span>    </span><span id="local-6989586621679423386"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423386"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423385"><span class="annot"><span class="annottext">Maybe (BooleanFormula l)
</span><a href="#local-6989586621679423385"><span class="hs-identifier hs-var">b</span></a></span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Maybe (BooleanFormula l) -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#MinimalPragma"><span class="hs-identifier hs-var">MinimalPragma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423386"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (BooleanFormula l)
</span><a href="#local-6989586621679423385"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-1347"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RoleAnnotDecl"><span class="hs-identifier hs-type">RoleAnnotDecl</span></a></span><span>    </span><span id="local-6989586621679423384"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423384"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423383"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423383"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679423382"><span class="annot"><span class="annottext">[Role l]
</span><a href="#local-6989586621679423382"><span class="hs-identifier hs-var">rs</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; [Role l] -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#RoleAnnotDecl"><span class="hs-identifier hs-var">RoleAnnotDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423384"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423383"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">[Role l]
</span><a href="#local-6989586621679423382"><span class="hs-identifier hs-var">rs</span></a></span><span>
</span><span id="line-1348"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatSyn"><span class="hs-identifier hs-type">PatSyn</span></a></span><span>           </span><span id="local-6989586621679423381"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423381"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423380"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679423380"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679423379"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679423379"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621679423378"><span class="annot"><span class="annottext">PatternSynDirection l
</span><a href="#local-6989586621679423378"><span class="hs-identifier hs-var">d</span></a></span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; Pat l -&gt; PatternSynDirection l -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#PatSyn"><span class="hs-identifier hs-var">PatSyn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423381"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679423380"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679423379"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">PatternSynDirection l
</span><a href="#local-6989586621679423378"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-1349"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CompletePragma"><span class="hs-identifier hs-type">CompletePragma</span></a></span><span>   </span><span id="local-6989586621679423377"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423377"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423376"><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679423376"><span class="hs-identifier hs-var">cs</span></a></span></span><span> </span><span id="local-6989586621679423375"><span class="annot"><span class="annottext">Maybe (QName l)
</span><a href="#local-6989586621679423375"><span class="hs-identifier hs-var">ty</span></a></span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Name l] -&gt; Maybe (QName l) -&gt; Decl l
</span><a href="Language.Haskell.Exts.Syntax.html#CompletePragma"><span class="hs-identifier hs-var">CompletePragma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423507"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423377"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679423376"><span class="hs-identifier hs-var">cs</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (QName l)
</span><a href="#local-6989586621679423375"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-1350"></span><span>
</span><span id="line-1351"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Role"><span class="hs-identifier hs-type">Role</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1352"></span><span>    </span><span id="local-6989586621679423369"><span class="annot"><span class="annottext">ann :: forall l. Role l -&gt; l
</span><a href="#local-6989586621679423369"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679423368"><span class="annot"><span class="annottext">Role l
</span><a href="#local-6989586621679423368"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Role l
</span><a href="#local-6989586621679423368"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1353"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RoleWildcard"><span class="hs-identifier hs-type">RoleWildcard</span></a></span><span> </span><span id="local-6989586621679423367"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423367"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423367"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1354"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Representational"><span class="hs-identifier hs-type">Representational</span></a></span><span> </span><span id="local-6989586621679423366"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423366"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423366"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1355"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Phantom"><span class="hs-identifier hs-type">Phantom</span></a></span><span> </span><span id="local-6989586621679423365"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423365"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423365"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1356"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Nominal"><span class="hs-identifier hs-type">Nominal</span></a></span><span> </span><span id="local-6989586621679423364"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423364"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423364"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1357"></span><span>    </span><span id="local-6989586621679423363"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Role l -&gt; Role l
</span><a href="#local-6989586621679423363"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423362"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423362"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679423361"><span class="annot"><span class="annottext">Role l
</span><a href="#local-6989586621679423361"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Role l
</span><a href="#local-6989586621679423361"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1358"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RoleWildcard"><span class="hs-identifier hs-type">RoleWildcard</span></a></span><span> </span><span id="local-6989586621679423360"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423360"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Role l
</span><a href="Language.Haskell.Exts.Syntax.html#RoleWildcard"><span class="hs-identifier hs-var">RoleWildcard</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423362"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423360"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1359"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Representational"><span class="hs-identifier hs-type">Representational</span></a></span><span> </span><span id="local-6989586621679423359"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423359"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Role l
</span><a href="Language.Haskell.Exts.Syntax.html#Representational"><span class="hs-identifier hs-var">Representational</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423362"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423359"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1360"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Phantom"><span class="hs-identifier hs-type">Phantom</span></a></span><span> </span><span id="local-6989586621679423358"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423358"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Role l
</span><a href="Language.Haskell.Exts.Syntax.html#Phantom"><span class="hs-identifier hs-var">Phantom</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423362"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423358"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1361"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Nominal"><span class="hs-identifier hs-type">Nominal</span></a></span><span> </span><span id="local-6989586621679423357"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423357"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Role l
</span><a href="Language.Haskell.Exts.Syntax.html#Nominal"><span class="hs-identifier hs-var">Nominal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423362"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423357"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1362"></span><span>
</span><span id="line-1363"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotation"><span class="hs-identifier hs-type">Annotation</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1364"></span><span>    </span><span id="local-6989586621679423351"><span class="annot"><span class="annottext">ann :: forall l. Annotation l -&gt; l
</span><a href="#local-6989586621679423351"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Ann"><span class="hs-identifier hs-type">Ann</span></a></span><span>     </span><span id="local-6989586621679423350"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423350"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423350"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1365"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeAnn"><span class="hs-identifier hs-type">TypeAnn</span></a></span><span> </span><span id="local-6989586621679423349"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423349"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423349"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1366"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleAnn"><span class="hs-identifier hs-type">ModuleAnn</span></a></span><span> </span><span id="local-6989586621679423348"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423348"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423348"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1367"></span><span>    </span><span id="local-6989586621679423347"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Annotation l -&gt; Annotation l
</span><a href="#local-6989586621679423347"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423346"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423346"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Ann"><span class="hs-identifier hs-type">Ann</span></a></span><span>     </span><span id="local-6989586621679423345"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423345"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423344"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423344"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423343"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423343"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; Exp l -&gt; Annotation l
</span><a href="Language.Haskell.Exts.Syntax.html#Ann"><span class="hs-identifier hs-var">Ann</span></a></span><span>     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423346"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423345"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423344"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423343"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1368"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423342"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423342"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeAnn"><span class="hs-identifier hs-type">TypeAnn</span></a></span><span> </span><span id="local-6989586621679423341"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423341"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423340"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423340"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423339"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423339"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; Exp l -&gt; Annotation l
</span><a href="Language.Haskell.Exts.Syntax.html#TypeAnn"><span class="hs-identifier hs-var">TypeAnn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423342"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423341"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423340"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423339"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1369"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423338"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423338"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModuleAnn"><span class="hs-identifier hs-type">ModuleAnn</span></a></span><span> </span><span id="local-6989586621679423337"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423337"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423336"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423336"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Annotation l
</span><a href="Language.Haskell.Exts.Syntax.html#ModuleAnn"><span class="hs-identifier hs-var">ModuleAnn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423338"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423337"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423336"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1370"></span><span>
</span><span id="line-1371"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BooleanFormula"><span class="hs-identifier hs-type">BooleanFormula</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1372"></span><span>    </span><span id="local-6989586621679423330"><span class="annot"><span class="annottext">ann :: forall l. BooleanFormula l -&gt; l
</span><a href="#local-6989586621679423330"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarFormula"><span class="hs-identifier hs-type">VarFormula</span></a></span><span> </span><span id="local-6989586621679423329"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423329"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423329"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1373"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AndFormula"><span class="hs-identifier hs-type">AndFormula</span></a></span><span> </span><span id="local-6989586621679423328"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423328"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[BooleanFormula l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423328"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1374"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#OrFormula"><span class="hs-identifier hs-type">OrFormula</span></a></span><span> </span><span id="local-6989586621679423327"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423327"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[BooleanFormula l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423327"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1375"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParenFormula"><span class="hs-identifier hs-type">ParenFormula</span></a></span><span> </span><span id="local-6989586621679423326"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423326"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">BooleanFormula l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423326"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1376"></span><span>    </span><span id="local-6989586621679423325"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; BooleanFormula l -&gt; BooleanFormula l
</span><a href="#local-6989586621679423325"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423324"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423324"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarFormula"><span class="hs-identifier hs-type">VarFormula</span></a></span><span> </span><span id="local-6989586621679423323"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423323"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423322"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423322"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; BooleanFormula l
</span><a href="Language.Haskell.Exts.Syntax.html#VarFormula"><span class="hs-identifier hs-var">VarFormula</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423324"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423323"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423322"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1377"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423321"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423321"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AndFormula"><span class="hs-identifier hs-type">AndFormula</span></a></span><span> </span><span id="local-6989586621679423320"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423320"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423319"><span class="annot"><span class="annottext">[BooleanFormula l]
</span><a href="#local-6989586621679423319"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [BooleanFormula l] -&gt; BooleanFormula l
</span><a href="Language.Haskell.Exts.Syntax.html#AndFormula"><span class="hs-identifier hs-var">AndFormula</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423321"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423320"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[BooleanFormula l]
</span><a href="#local-6989586621679423319"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-1378"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423318"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423318"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#OrFormula"><span class="hs-identifier hs-type">OrFormula</span></a></span><span> </span><span id="local-6989586621679423317"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423317"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423316"><span class="annot"><span class="annottext">[BooleanFormula l]
</span><a href="#local-6989586621679423316"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [BooleanFormula l] -&gt; BooleanFormula l
</span><a href="Language.Haskell.Exts.Syntax.html#OrFormula"><span class="hs-identifier hs-var">OrFormula</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423318"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423317"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[BooleanFormula l]
</span><a href="#local-6989586621679423316"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-1379"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423315"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423315"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParenFormula"><span class="hs-identifier hs-type">ParenFormula</span></a></span><span> </span><span id="local-6989586621679423314"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423314"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423313"><span class="annot"><span class="annottext">BooleanFormula l
</span><a href="#local-6989586621679423313"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; BooleanFormula l -&gt; BooleanFormula l
</span><a href="Language.Haskell.Exts.Syntax.html#ParenFormula"><span class="hs-identifier hs-var">ParenFormula</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423315"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423314"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">BooleanFormula l
</span><a href="#local-6989586621679423313"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-1380"></span><span>
</span><span id="line-1381"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataOrNew"><span class="hs-identifier hs-type">DataOrNew</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1382"></span><span>    </span><span id="local-6989586621679423307"><span class="annot"><span class="annottext">ann :: forall l. DataOrNew l -&gt; l
</span><a href="#local-6989586621679423307"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DataType"><span class="hs-identifier hs-type">DataType</span></a></span><span> </span><span id="local-6989586621679423306"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423306"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423306"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1383"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NewType"><span class="hs-identifier hs-type">NewType</span></a></span><span>  </span><span id="local-6989586621679423305"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423305"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423305"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1384"></span><span>    </span><span id="local-6989586621679423303"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; DataOrNew l -&gt; DataOrNew l
</span><a href="#local-6989586621679423303"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1385"></span><span>
</span><span id="line-1386"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclHead"><span class="hs-identifier hs-type">DeclHead</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1387"></span><span>    </span><span id="local-6989586621679423297"><span class="annot"><span class="annottext">ann :: forall l. DeclHead l -&gt; l
</span><a href="#local-6989586621679423297"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHead"><span class="hs-identifier hs-type">DHead</span></a></span><span> </span><span id="local-6989586621679423296"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423296"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423296"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1388"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHInfix"><span class="hs-identifier hs-type">DHInfix</span></a></span><span> </span><span id="local-6989586621679423295"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423295"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">TyVarBind l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423295"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1389"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHParen"><span class="hs-identifier hs-type">DHParen</span></a></span><span> </span><span id="local-6989586621679423294"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423294"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423294"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1390"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHApp"><span class="hs-identifier hs-type">DHApp</span></a></span><span> </span><span id="local-6989586621679423293"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423293"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">TyVarBind l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423293"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1391"></span><span>    </span><span id="local-6989586621679423292"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; DeclHead l -&gt; DeclHead l
</span><a href="#local-6989586621679423292"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423291"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423291"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHead"><span class="hs-identifier hs-type">DHead</span></a></span><span> </span><span id="local-6989586621679423290"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423290"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423289"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423289"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; DeclHead l
</span><a href="Language.Haskell.Exts.Syntax.html#DHead"><span class="hs-identifier hs-var">DHead</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423291"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423290"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423289"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1392"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423288"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423288"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHInfix"><span class="hs-identifier hs-type">DHInfix</span></a></span><span> </span><span id="local-6989586621679423287"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423287"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423286"><span class="annot"><span class="annottext">TyVarBind l
</span><a href="#local-6989586621679423286"><span class="hs-identifier hs-var">tva</span></a></span></span><span> </span><span id="local-6989586621679423285"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423285"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; TyVarBind l -&gt; Name l -&gt; DeclHead l
</span><a href="Language.Haskell.Exts.Syntax.html#DHInfix"><span class="hs-identifier hs-var">DHInfix</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423288"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423287"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">TyVarBind l
</span><a href="#local-6989586621679423286"><span class="hs-identifier hs-var">tva</span></a></span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423285"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1393"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423284"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423284"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHParen"><span class="hs-identifier hs-type">DHParen</span></a></span><span> </span><span id="local-6989586621679423283"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423283"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423282"><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423282"><span class="hs-identifier hs-var">dh</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; DeclHead l -&gt; DeclHead l
</span><a href="Language.Haskell.Exts.Syntax.html#DHParen"><span class="hs-identifier hs-var">DHParen</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423284"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423283"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423282"><span class="hs-identifier hs-var">dh</span></a></span><span>
</span><span id="line-1394"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423281"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423281"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DHApp"><span class="hs-identifier hs-type">DHApp</span></a></span><span> </span><span id="local-6989586621679423280"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423280"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423279"><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423279"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423278"><span class="annot"><span class="annottext">TyVarBind l
</span><a href="#local-6989586621679423278"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; DeclHead l -&gt; TyVarBind l -&gt; DeclHead l
</span><a href="Language.Haskell.Exts.Syntax.html#DHApp"><span class="hs-identifier hs-var">DHApp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423281"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423280"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423279"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBind l
</span><a href="#local-6989586621679423278"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1395"></span><span>
</span><span id="line-1396"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstRule"><span class="hs-identifier hs-type">InstRule</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1397"></span><span>    </span><span id="local-6989586621679423272"><span class="annot"><span class="annottext">ann :: forall l. InstRule l -&gt; l
</span><a href="#local-6989586621679423272"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IRule"><span class="hs-identifier hs-type">IRule</span></a></span><span> </span><span id="local-6989586621679423271"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423271"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">InstHead l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423271"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1398"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IParen"><span class="hs-identifier hs-type">IParen</span></a></span><span> </span><span id="local-6989586621679423270"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423270"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">InstRule l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423270"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1399"></span><span>    </span><span id="local-6989586621679423269"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; InstRule l -&gt; InstRule l
</span><a href="#local-6989586621679423269"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423268"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423268"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IRule"><span class="hs-identifier hs-type">IRule</span></a></span><span> </span><span id="local-6989586621679423267"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423267"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423266"><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679423266"><span class="hs-identifier hs-var">mtv</span></a></span></span><span> </span><span id="local-6989586621679423265"><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423265"><span class="hs-identifier hs-var">cxt</span></a></span></span><span> </span><span id="local-6989586621679423264"><span class="annot"><span class="annottext">InstHead l
</span><a href="#local-6989586621679423264"><span class="hs-identifier hs-var">qn</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; Maybe [TyVarBind l]
-&gt; Maybe (Context l)
-&gt; InstHead l
-&gt; InstRule l
</span><a href="Language.Haskell.Exts.Syntax.html#IRule"><span class="hs-identifier hs-var">IRule</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423268"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423267"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679423266"><span class="hs-identifier hs-var">mtv</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423265"><span class="hs-identifier hs-var">cxt</span></a></span><span> </span><span class="annot"><span class="annottext">InstHead l
</span><a href="#local-6989586621679423264"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1400"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423263"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423263"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IParen"><span class="hs-identifier hs-type">IParen</span></a></span><span> </span><span id="local-6989586621679423262"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423262"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423261"><span class="annot"><span class="annottext">InstRule l
</span><a href="#local-6989586621679423261"><span class="hs-identifier hs-var">ih</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; InstRule l -&gt; InstRule l
</span><a href="Language.Haskell.Exts.Syntax.html#IParen"><span class="hs-identifier hs-var">IParen</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423263"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423262"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">InstRule l
</span><a href="#local-6989586621679423261"><span class="hs-identifier hs-var">ih</span></a></span><span>
</span><span id="line-1401"></span><span>
</span><span id="line-1402"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstHead"><span class="hs-identifier hs-type">InstHead</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1403"></span><span>    </span><span id="local-6989586621679423255"><span class="annot"><span class="annottext">ann :: forall l. InstHead l -&gt; l
</span><a href="#local-6989586621679423255"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHCon"><span class="hs-identifier hs-type">IHCon</span></a></span><span> </span><span id="local-6989586621679423254"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423254"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423254"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1404"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHInfix"><span class="hs-identifier hs-type">IHInfix</span></a></span><span> </span><span id="local-6989586621679423253"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423253"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423253"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1405"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHParen"><span class="hs-identifier hs-type">IHParen</span></a></span><span> </span><span id="local-6989586621679423252"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423252"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">InstHead l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423252"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1406"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHApp"><span class="hs-identifier hs-type">IHApp</span></a></span><span> </span><span id="local-6989586621679423251"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423251"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">InstHead l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423251"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1407"></span><span>    </span><span id="local-6989586621679423250"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; InstHead l -&gt; InstHead l
</span><a href="#local-6989586621679423250"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423249"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423249"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHCon"><span class="hs-identifier hs-type">IHCon</span></a></span><span> </span><span id="local-6989586621679423248"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423248"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423247"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423247"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; InstHead l
</span><a href="Language.Haskell.Exts.Syntax.html#IHCon"><span class="hs-identifier hs-var">IHCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423249"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423248"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423247"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1408"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423246"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423246"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHInfix"><span class="hs-identifier hs-type">IHInfix</span></a></span><span> </span><span id="local-6989586621679423245"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423245"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423244"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423244"><span class="hs-identifier hs-var">tva</span></a></span></span><span> </span><span id="local-6989586621679423243"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423243"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; QName l -&gt; InstHead l
</span><a href="Language.Haskell.Exts.Syntax.html#IHInfix"><span class="hs-identifier hs-var">IHInfix</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423246"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423245"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423244"><span class="hs-identifier hs-var">tva</span></a></span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679423243"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1409"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423242"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423242"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHParen"><span class="hs-identifier hs-type">IHParen</span></a></span><span> </span><span id="local-6989586621679423241"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423241"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423240"><span class="annot"><span class="annottext">InstHead l
</span><a href="#local-6989586621679423240"><span class="hs-identifier hs-var">dh</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; InstHead l -&gt; InstHead l
</span><a href="Language.Haskell.Exts.Syntax.html#IHParen"><span class="hs-identifier hs-var">IHParen</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423242"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423241"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">InstHead l
</span><a href="#local-6989586621679423240"><span class="hs-identifier hs-var">dh</span></a></span><span>
</span><span id="line-1410"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423239"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423239"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IHApp"><span class="hs-identifier hs-type">IHApp</span></a></span><span> </span><span id="local-6989586621679423238"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423238"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423237"><span class="annot"><span class="annottext">InstHead l
</span><a href="#local-6989586621679423237"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423236"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423236"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; InstHead l -&gt; Type l -&gt; InstHead l
</span><a href="Language.Haskell.Exts.Syntax.html#IHApp"><span class="hs-identifier hs-var">IHApp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423239"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423238"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">InstHead l
</span><a href="#local-6989586621679423237"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423236"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1411"></span><span>
</span><span id="line-1412"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Binds"><span class="hs-identifier hs-type">Binds</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1413"></span><span>    </span><span id="local-6989586621679423230"><span class="annot"><span class="annottext">ann :: forall l. Binds l -&gt; l
</span><a href="#local-6989586621679423230"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BDecls"><span class="hs-identifier hs-type">BDecls</span></a></span><span>  </span><span id="local-6989586621679423229"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423229"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Decl l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423229"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1414"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPBinds"><span class="hs-identifier hs-type">IPBinds</span></a></span><span> </span><span id="local-6989586621679423228"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423228"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[IPBind l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423228"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1415"></span><span>    </span><span id="local-6989586621679423227"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Binds l -&gt; Binds l
</span><a href="#local-6989586621679423227"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423226"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423226"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BDecls"><span class="hs-identifier hs-type">BDecls</span></a></span><span>  </span><span id="local-6989586621679423225"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423225"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423224"><span class="annot"><span class="annottext">[Decl l]
</span><a href="#local-6989586621679423224"><span class="hs-identifier hs-var">decls</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Decl l] -&gt; Binds l
</span><a href="Language.Haskell.Exts.Syntax.html#BDecls"><span class="hs-identifier hs-var">BDecls</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423226"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423225"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Decl l]
</span><a href="#local-6989586621679423224"><span class="hs-identifier hs-var">decls</span></a></span><span>
</span><span id="line-1416"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423223"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423223"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPBinds"><span class="hs-identifier hs-type">IPBinds</span></a></span><span> </span><span id="local-6989586621679423222"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423222"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423221"><span class="annot"><span class="annottext">[IPBind l]
</span><a href="#local-6989586621679423221"><span class="hs-identifier hs-var">ibs</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [IPBind l] -&gt; Binds l
</span><a href="Language.Haskell.Exts.Syntax.html#IPBinds"><span class="hs-identifier hs-var">IPBinds</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423223"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423222"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[IPBind l]
</span><a href="#local-6989586621679423221"><span class="hs-identifier hs-var">ibs</span></a></span><span>
</span><span id="line-1417"></span><span>
</span><span id="line-1418"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPBind"><span class="hs-identifier hs-type">IPBind</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1419"></span><span>    </span><span id="local-6989586621679423215"><span class="annot"><span class="annottext">ann :: forall l. IPBind l -&gt; l
</span><a href="#local-6989586621679423215"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPBind"><span class="hs-identifier hs-type">IPBind</span></a></span><span> </span><span id="local-6989586621679423214"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423214"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">IPName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423214"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1420"></span><span>    </span><span id="local-6989586621679423213"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; IPBind l -&gt; IPBind l
</span><a href="#local-6989586621679423213"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423212"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423212"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPBind"><span class="hs-identifier hs-type">IPBind</span></a></span><span> </span><span id="local-6989586621679423211"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423211"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423210"><span class="annot"><span class="annottext">IPName l
</span><a href="#local-6989586621679423210"><span class="hs-identifier hs-var">ipn</span></a></span></span><span> </span><span id="local-6989586621679423209"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423209"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; IPName l -&gt; Exp l -&gt; IPBind l
</span><a href="Language.Haskell.Exts.Syntax.html#IPBind"><span class="hs-identifier hs-var">IPBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423212"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423211"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">IPName l
</span><a href="#local-6989586621679423210"><span class="hs-identifier hs-var">ipn</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423209"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1421"></span><span>
</span><span id="line-1422"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1423"></span><span>    </span><span id="local-6989586621679423203"><span class="annot"><span class="annottext">ann :: forall l. Match l -&gt; l
</span><a href="#local-6989586621679423203"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span id="local-6989586621679423202"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423202"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Rhs l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Binds l)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423202"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1424"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixMatch"><span class="hs-identifier hs-type">InfixMatch</span></a></span><span> </span><span id="local-6989586621679423201"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423201"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Rhs l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Binds l)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423201"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1425"></span><span>    </span><span id="local-6989586621679423200"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Match l -&gt; Match l
</span><a href="#local-6989586621679423200"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423199"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423199"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span id="local-6989586621679423198"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423198"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423197"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423197"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423196"><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679423196"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621679423195"><span class="annot"><span class="annottext">Rhs l
</span><a href="#local-6989586621679423195"><span class="hs-identifier hs-var">rhs</span></a></span></span><span> </span><span id="local-6989586621679423194"><span class="annot"><span class="annottext">Maybe (Binds l)
</span><a href="#local-6989586621679423194"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l.
l -&gt; Name l -&gt; [Pat l] -&gt; Rhs l -&gt; Maybe (Binds l) -&gt; Match l
</span><a href="Language.Haskell.Exts.Syntax.html#Match"><span class="hs-identifier hs-var">Match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423199"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423198"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423197"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679423196"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">Rhs l
</span><a href="#local-6989586621679423195"><span class="hs-identifier hs-var">rhs</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Binds l)
</span><a href="#local-6989586621679423194"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-1426"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423193"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423193"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixMatch"><span class="hs-identifier hs-type">InfixMatch</span></a></span><span> </span><span id="local-6989586621679423192"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423192"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423191"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679423191"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679423190"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423190"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423189"><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679423189"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679423188"><span class="annot"><span class="annottext">Rhs l
</span><a href="#local-6989586621679423188"><span class="hs-identifier hs-var">rhs</span></a></span></span><span> </span><span id="local-6989586621679423187"><span class="annot"><span class="annottext">Maybe (Binds l)
</span><a href="#local-6989586621679423187"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; Pat l
-&gt; Name l
-&gt; [Pat l]
-&gt; Rhs l
-&gt; Maybe (Binds l)
-&gt; Match l
</span><a href="Language.Haskell.Exts.Syntax.html#InfixMatch"><span class="hs-identifier hs-var">InfixMatch</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423193"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423192"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679423191"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423190"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679423189"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Rhs l
</span><a href="#local-6989586621679423188"><span class="hs-identifier hs-var">rhs</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Binds l)
</span><a href="#local-6989586621679423187"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-1427"></span><span>
</span><span id="line-1428"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualConDecl"><span class="hs-identifier hs-type">QualConDecl</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1429"></span><span>    </span><span id="local-6989586621679423181"><span class="annot"><span class="annottext">ann :: forall l. QualConDecl l -&gt; l
</span><a href="#local-6989586621679423181"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualConDecl"><span class="hs-identifier hs-type">QualConDecl</span></a></span><span> </span><span id="local-6989586621679423180"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423180"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">ConDecl l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423180"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1430"></span><span>    </span><span id="local-6989586621679423179"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; QualConDecl l -&gt; QualConDecl l
</span><a href="#local-6989586621679423179"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423178"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423178"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualConDecl"><span class="hs-identifier hs-type">QualConDecl</span></a></span><span> </span><span id="local-6989586621679423177"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423177"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423176"><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679423176"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621679423175"><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423175"><span class="hs-identifier hs-var">cx</span></a></span></span><span> </span><span id="local-6989586621679423174"><span class="annot"><span class="annottext">ConDecl l
</span><a href="#local-6989586621679423174"><span class="hs-identifier hs-var">cd</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; Maybe [TyVarBind l]
-&gt; Maybe (Context l)
-&gt; ConDecl l
-&gt; QualConDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#QualConDecl"><span class="hs-identifier hs-var">QualConDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423178"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423177"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679423176"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423175"><span class="hs-identifier hs-var">cx</span></a></span><span> </span><span class="annot"><span class="annottext">ConDecl l
</span><a href="#local-6989586621679423174"><span class="hs-identifier hs-var">cd</span></a></span><span>
</span><span id="line-1431"></span><span>
</span><span id="line-1432"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConDecl"><span class="hs-identifier hs-type">ConDecl</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1433"></span><span>    </span><span id="local-6989586621679423168"><span class="annot"><span class="annottext">ann :: forall l. ConDecl l -&gt; l
</span><a href="#local-6989586621679423168"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConDecl"><span class="hs-identifier hs-type">ConDecl</span></a></span><span> </span><span id="local-6989586621679423167"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423167"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423167"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1434"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixConDecl"><span class="hs-identifier hs-type">InfixConDecl</span></a></span><span> </span><span id="local-6989586621679423166"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423166"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423166"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1435"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecDecl"><span class="hs-identifier hs-type">RecDecl</span></a></span><span> </span><span id="local-6989586621679423165"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423165"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[FieldDecl l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423165"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1436"></span><span>    </span><span id="local-6989586621679423164"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; ConDecl l -&gt; ConDecl l
</span><a href="#local-6989586621679423164"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423163"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423163"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ConDecl"><span class="hs-identifier hs-type">ConDecl</span></a></span><span> </span><span id="local-6989586621679423162"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423162"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423161"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423161"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423160"><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679423160"><span class="hs-identifier hs-var">bts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; [Type l] -&gt; ConDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#ConDecl"><span class="hs-identifier hs-var">ConDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423163"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423162"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423161"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679423160"><span class="hs-identifier hs-var">bts</span></a></span><span>
</span><span id="line-1437"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423159"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423159"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixConDecl"><span class="hs-identifier hs-type">InfixConDecl</span></a></span><span> </span><span id="local-6989586621679423158"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423158"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423157"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423157"><span class="hs-identifier hs-var">ta</span></a></span></span><span> </span><span id="local-6989586621679423156"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423156"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423155"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423155"><span class="hs-identifier hs-var">tb</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Name l -&gt; Type l -&gt; ConDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#InfixConDecl"><span class="hs-identifier hs-var">InfixConDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423159"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423158"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423157"><span class="hs-identifier hs-var">ta</span></a></span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423156"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423155"><span class="hs-identifier hs-var">tb</span></a></span><span>
</span><span id="line-1438"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423154"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423154"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecDecl"><span class="hs-identifier hs-type">RecDecl</span></a></span><span> </span><span id="local-6989586621679423153"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423153"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423152"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423152"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423151"><span class="annot"><span class="annottext">[FieldDecl l]
</span><a href="#local-6989586621679423151"><span class="hs-identifier hs-var">fds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; [FieldDecl l] -&gt; ConDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#RecDecl"><span class="hs-identifier hs-var">RecDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423154"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423153"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423152"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[FieldDecl l]
</span><a href="#local-6989586621679423151"><span class="hs-identifier hs-var">fds</span></a></span><span>
</span><span id="line-1439"></span><span>
</span><span id="line-1440"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldDecl"><span class="hs-identifier hs-type">FieldDecl</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1441"></span><span>    </span><span id="local-6989586621679423145"><span class="annot"><span class="annottext">ann :: forall l. FieldDecl l -&gt; l
</span><a href="#local-6989586621679423145"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldDecl"><span class="hs-identifier hs-type">FieldDecl</span></a></span><span> </span><span id="local-6989586621679423144"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423144"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423144"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1442"></span><span>    </span><span id="local-6989586621679423143"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; FieldDecl l -&gt; FieldDecl l
</span><a href="#local-6989586621679423143"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423142"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423142"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldDecl"><span class="hs-identifier hs-type">FieldDecl</span></a></span><span> </span><span id="local-6989586621679423141"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423141"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423140"><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679423140"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span id="local-6989586621679423139"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423139"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Name l] -&gt; Type l -&gt; FieldDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#FieldDecl"><span class="hs-identifier hs-var">FieldDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423142"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423141"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679423140"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423139"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1443"></span><span>
</span><span id="line-1444"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GadtDecl"><span class="hs-identifier hs-type">GadtDecl</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1445"></span><span>    </span><span id="local-6989586621679423133"><span class="annot"><span class="annottext">ann :: forall l. GadtDecl l -&gt; l
</span><a href="#local-6989586621679423133"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GadtDecl"><span class="hs-identifier hs-type">GadtDecl</span></a></span><span> </span><span id="local-6989586621679423132"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423132"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe [FieldDecl l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423132"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1446"></span><span>    </span><span id="local-6989586621679423131"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; GadtDecl l -&gt; GadtDecl l
</span><a href="#local-6989586621679423131"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423130"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423130"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GadtDecl"><span class="hs-identifier hs-type">GadtDecl</span></a></span><span> </span><span id="local-6989586621679423129"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423129"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423128"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423128"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423127"><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679423127"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679423126"><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423126"><span class="hs-identifier hs-var">t2</span></a></span></span><span> </span><span id="local-6989586621679423125"><span class="annot"><span class="annottext">Maybe [FieldDecl l]
</span><a href="#local-6989586621679423125"><span class="hs-identifier hs-var">t3</span></a></span></span><span> </span><span id="local-6989586621679423124"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423124"><span class="hs-identifier hs-var">t4</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; Name l
-&gt; Maybe [TyVarBind l]
-&gt; Maybe (Context l)
-&gt; Maybe [FieldDecl l]
-&gt; Type l
-&gt; GadtDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#GadtDecl"><span class="hs-identifier hs-var">GadtDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423130"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423129"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423128"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679423127"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423126"><span class="hs-identifier hs-var">t2</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [FieldDecl l]
</span><a href="#local-6989586621679423125"><span class="hs-identifier hs-var">t3</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423124"><span class="hs-identifier hs-var">t4</span></a></span><span>
</span><span id="line-1447"></span><span>
</span><span id="line-1448"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClassDecl"><span class="hs-identifier hs-type">ClassDecl</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1449"></span><span>    </span><span id="local-6989586621679423118"><span class="annot"><span class="annottext">ann :: forall l. ClassDecl l -&gt; l
</span><a href="#local-6989586621679423118"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsDecl"><span class="hs-identifier hs-type">ClsDecl</span></a></span><span>    </span><span id="local-6989586621679423117"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423117"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Decl l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423117"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1450"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsDataFam"><span class="hs-identifier hs-type">ClsDataFam</span></a></span><span> </span><span id="local-6989586621679423116"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423116"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423116"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1451"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsTyFam"><span class="hs-identifier hs-type">ClsTyFam</span></a></span><span>   </span><span id="local-6989586621679423115"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423115"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (InjectivityInfo l)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423115"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1452"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsTyDef"><span class="hs-identifier hs-type">ClsTyDef</span></a></span><span>   </span><span id="local-6989586621679423114"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423114"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">TypeEqn l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423114"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1453"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsDefSig"><span class="hs-identifier hs-type">ClsDefSig</span></a></span><span>  </span><span id="local-6989586621679423113"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423113"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423113"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1454"></span><span>    </span><span id="local-6989586621679423112"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; ClassDecl l -&gt; ClassDecl l
</span><a href="#local-6989586621679423112"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423111"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423111"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsDecl"><span class="hs-identifier hs-type">ClsDecl</span></a></span><span>    </span><span id="local-6989586621679423110"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423110"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423109"><span class="annot"><span class="annottext">Decl l
</span><a href="#local-6989586621679423109"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Decl l -&gt; ClassDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#ClsDecl"><span class="hs-identifier hs-var">ClsDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423111"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423110"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Decl l
</span><a href="#local-6989586621679423109"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-1455"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423108"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423108"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsDataFam"><span class="hs-identifier hs-type">ClsDataFam</span></a></span><span> </span><span id="local-6989586621679423107"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423107"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423106"><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423106"><span class="hs-identifier hs-var">mcx</span></a></span></span><span> </span><span id="local-6989586621679423105"><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423105"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423104"><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><a href="#local-6989586621679423104"><span class="hs-identifier hs-var">mk</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; Maybe (Context l)
-&gt; DeclHead l
-&gt; Maybe (ResultSig l)
-&gt; ClassDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#ClsDataFam"><span class="hs-identifier hs-var">ClsDataFam</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423108"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423107"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679423106"><span class="hs-identifier hs-var">mcx</span></a></span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423105"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><a href="#local-6989586621679423104"><span class="hs-identifier hs-var">mk</span></a></span><span>
</span><span id="line-1456"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423103"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423103"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsTyFam"><span class="hs-identifier hs-type">ClsTyFam</span></a></span><span>   </span><span id="local-6989586621679423102"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423102"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423101"><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423101"><span class="hs-identifier hs-var">dh</span></a></span></span><span> </span><span id="local-6989586621679423100"><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><a href="#local-6989586621679423100"><span class="hs-identifier hs-var">mk</span></a></span></span><span> </span><span id="local-6989586621679423099"><span class="annot"><span class="annottext">Maybe (InjectivityInfo l)
</span><a href="#local-6989586621679423099"><span class="hs-identifier hs-var">mi</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; DeclHead l
-&gt; Maybe (ResultSig l)
-&gt; Maybe (InjectivityInfo l)
-&gt; ClassDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#ClsTyFam"><span class="hs-identifier hs-var">ClsTyFam</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423103"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423102"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DeclHead l
</span><a href="#local-6989586621679423101"><span class="hs-identifier hs-var">dh</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (ResultSig l)
</span><a href="#local-6989586621679423100"><span class="hs-identifier hs-var">mk</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (InjectivityInfo l)
</span><a href="#local-6989586621679423099"><span class="hs-identifier hs-var">mi</span></a></span><span>
</span><span id="line-1457"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423098"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423098"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsTyDef"><span class="hs-identifier hs-type">ClsTyDef</span></a></span><span>   </span><span id="local-6989586621679423097"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423097"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423096"><span class="annot"><span class="annottext">TypeEqn l
</span><a href="#local-6989586621679423096"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; TypeEqn l -&gt; ClassDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#ClsTyDef"><span class="hs-identifier hs-var">ClsTyDef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423098"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423097"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">TypeEqn l
</span><a href="#local-6989586621679423096"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1458"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423095"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423095"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ClsDefSig"><span class="hs-identifier hs-type">ClsDefSig</span></a></span><span>  </span><span id="local-6989586621679423094"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423094"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423093"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423093"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679423092"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423092"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; Type l -&gt; ClassDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#ClsDefSig"><span class="hs-identifier hs-var">ClsDefSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423095"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423094"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679423093"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423092"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1459"></span><span>
</span><span id="line-1460"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InstDecl"><span class="hs-identifier hs-type">InstDecl</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1461"></span><span>    </span><span id="local-6989586621679423086"><span class="annot"><span class="annottext">ann :: forall l. InstDecl l -&gt; l
</span><a href="#local-6989586621679423086"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679423085"><span class="annot"><span class="annottext">InstDecl l
</span><a href="#local-6989586621679423085"><span class="hs-identifier hs-var">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">InstDecl l
</span><a href="#local-6989586621679423085"><span class="hs-identifier hs-var">id</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1462"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsDecl"><span class="hs-identifier hs-type">InsDecl</span></a></span><span>   </span><span id="local-6989586621679423084"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423084"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Decl l
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423084"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1463"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsType"><span class="hs-identifier hs-type">InsType</span></a></span><span>   </span><span id="local-6989586621679423083"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423083"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423083"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1464"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsData"><span class="hs-identifier hs-type">InsData</span></a></span><span>   </span><span id="local-6989586621679423082"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423082"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>  </span><span class="annot"><span class="annottext">[QualConDecl l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423082"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1465"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsGData"><span class="hs-identifier hs-type">InsGData</span></a></span><span>  </span><span id="local-6989586621679423081"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423081"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Type l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[GadtDecl l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423081"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1466"></span><span class="hs-comment">--        InsInline l _ _ _    -&gt; l</span><span>
</span><span id="line-1467"></span><span>    </span><span id="local-6989586621679423080"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; InstDecl l -&gt; InstDecl l
</span><a href="#local-6989586621679423080"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423079"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423079"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679423078"><span class="annot"><span class="annottext">InstDecl l
</span><a href="#local-6989586621679423078"><span class="hs-identifier hs-var">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">InstDecl l
</span><a href="#local-6989586621679423078"><span class="hs-identifier hs-var">id</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1468"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsDecl"><span class="hs-identifier hs-type">InsDecl</span></a></span><span>   </span><span id="local-6989586621679423077"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423077"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423076"><span class="annot"><span class="annottext">Decl l
</span><a href="#local-6989586621679423076"><span class="hs-identifier hs-var">d</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Decl l -&gt; InstDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#InsDecl"><span class="hs-identifier hs-var">InsDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423079"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423077"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Decl l
</span><a href="#local-6989586621679423076"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-1469"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsType"><span class="hs-identifier hs-type">InsType</span></a></span><span>   </span><span id="local-6989586621679423075"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423075"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423074"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423074"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679423073"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423073"><span class="hs-identifier hs-var">t2</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Type l -&gt; InstDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#InsType"><span class="hs-identifier hs-var">InsType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423079"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423075"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423074"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423073"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1470"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsData"><span class="hs-identifier hs-type">InsData</span></a></span><span>   </span><span id="local-6989586621679423072"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423072"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423071"><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423071"><span class="hs-identifier hs-var">dn</span></a></span></span><span> </span><span id="local-6989586621679423070"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423070"><span class="hs-identifier hs-var">t</span></a></span></span><span>    </span><span id="local-6989586621679423069"><span class="annot"><span class="annottext">[QualConDecl l]
</span><a href="#local-6989586621679423069"><span class="hs-identifier hs-var">cds</span></a></span></span><span> </span><span id="local-6989586621679423068"><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423068"><span class="hs-identifier hs-var">ders</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; DataOrNew l
-&gt; Type l
-&gt; [QualConDecl l]
-&gt; [Deriving l]
-&gt; InstDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#InsData"><span class="hs-identifier hs-var">InsData</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423079"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423072"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423071"><span class="hs-identifier hs-var">dn</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423070"><span class="hs-identifier hs-var">t</span></a></span><span>    </span><span class="annot"><span class="annottext">[QualConDecl l]
</span><a href="#local-6989586621679423069"><span class="hs-identifier hs-var">cds</span></a></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423068"><span class="hs-identifier hs-var">ders</span></a></span><span>
</span><span id="line-1471"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InsGData"><span class="hs-identifier hs-type">InsGData</span></a></span><span>  </span><span id="local-6989586621679423067"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423067"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423066"><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423066"><span class="hs-identifier hs-var">dn</span></a></span></span><span> </span><span id="local-6989586621679423065"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423065"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679423064"><span class="annot"><span class="annottext">Maybe (Type l)
</span><a href="#local-6989586621679423064"><span class="hs-identifier hs-var">mk</span></a></span></span><span> </span><span id="local-6989586621679423063"><span class="annot"><span class="annottext">[GadtDecl l]
</span><a href="#local-6989586621679423063"><span class="hs-identifier hs-var">gds</span></a></span></span><span> </span><span id="local-6989586621679423062"><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423062"><span class="hs-identifier hs-var">ders</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; DataOrNew l
-&gt; Type l
-&gt; Maybe (Type l)
-&gt; [GadtDecl l]
-&gt; [Deriving l]
-&gt; InstDecl l
</span><a href="Language.Haskell.Exts.Syntax.html#InsGData"><span class="hs-identifier hs-var">InsGData</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423079"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423067"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DataOrNew l
</span><a href="#local-6989586621679423066"><span class="hs-identifier hs-var">dn</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679423065"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Type l)
</span><a href="#local-6989586621679423064"><span class="hs-identifier hs-var">mk</span></a></span><span> </span><span class="annot"><span class="annottext">[GadtDecl l]
</span><a href="#local-6989586621679423063"><span class="hs-identifier hs-var">gds</span></a></span><span> </span><span class="annot"><span class="annottext">[Deriving l]
</span><a href="#local-6989586621679423062"><span class="hs-identifier hs-var">ders</span></a></span><span>
</span><span id="line-1472"></span><span class="hs-comment">--        InsInline l b act qn    -&gt; InsInline (f l) b act qn</span><span>
</span><span id="line-1473"></span><span>
</span><span id="line-1474"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BangType"><span class="hs-identifier hs-type">BangType</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1475"></span><span>     </span><span id="local-6989586621679423056"><span class="annot"><span class="annottext">ann :: forall l. BangType l -&gt; l
</span><a href="#local-6989586621679423056"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BangedTy"><span class="hs-identifier hs-type">BangedTy</span></a></span><span>   </span><span id="local-6989586621679423055"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423055"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423055"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1476"></span><span>     </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LazyTy"><span class="hs-identifier hs-type">LazyTy</span></a></span><span>   </span><span id="local-6989586621679423054"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423054"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423054"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1477"></span><span>     </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoStrictAnnot"><span class="hs-identifier hs-type">NoStrictAnnot</span></a></span><span> </span><span id="local-6989586621679423053"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423053"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423053"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1478"></span><span>
</span><span id="line-1479"></span><span>     </span><span id="local-6989586621679423052"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; BangType l -&gt; BangType l
</span><a href="#local-6989586621679423052"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423051"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423051"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BangedTy"><span class="hs-identifier hs-type">BangedTy</span></a></span><span>   </span><span id="local-6989586621679423050"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423050"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; BangType l
</span><a href="Language.Haskell.Exts.Syntax.html#BangedTy"><span class="hs-identifier hs-var">BangedTy</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423051"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423050"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1480"></span><span>     </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423049"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423049"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LazyTy"><span class="hs-identifier hs-type">LazyTy</span></a></span><span>   </span><span id="local-6989586621679423048"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423048"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; BangType l
</span><a href="Language.Haskell.Exts.Syntax.html#LazyTy"><span class="hs-identifier hs-var">LazyTy</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423049"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423048"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1481"></span><span>     </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423047"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423047"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoStrictAnnot"><span class="hs-identifier hs-type">NoStrictAnnot</span></a></span><span> </span><span id="local-6989586621679423046"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423046"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; BangType l
</span><a href="Language.Haskell.Exts.Syntax.html#NoStrictAnnot"><span class="hs-identifier hs-var">NoStrictAnnot</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423047"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423046"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1482"></span><span>
</span><span id="line-1483"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Unpackedness"><span class="hs-identifier hs-type">Unpackedness</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1484"></span><span>    </span><span id="local-6989586621679423040"><span class="annot"><span class="annottext">ann :: forall l. Unpackedness l -&gt; l
</span><a href="#local-6989586621679423040"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Unpack"><span class="hs-identifier hs-type">Unpack</span></a></span><span> </span><span id="local-6989586621679423039"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423039"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423039"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1485"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoUnpack"><span class="hs-identifier hs-type">NoUnpack</span></a></span><span> </span><span id="local-6989586621679423038"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423038"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423038"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1486"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoUnpackPragma"><span class="hs-identifier hs-type">NoUnpackPragma</span></a></span><span> </span><span id="local-6989586621679423037"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423037"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423037"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1487"></span><span>
</span><span id="line-1488"></span><span>    </span><span id="local-6989586621679423036"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Unpackedness l -&gt; Unpackedness l
</span><a href="#local-6989586621679423036"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423035"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423035"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Unpack"><span class="hs-identifier hs-type">Unpack</span></a></span><span> </span><span id="local-6989586621679423034"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423034"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Unpackedness l
</span><a href="Language.Haskell.Exts.Syntax.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423035"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423034"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1489"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423033"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423033"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoUnpack"><span class="hs-identifier hs-type">NoUnpack</span></a></span><span> </span><span id="local-6989586621679423032"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423032"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Unpackedness l
</span><a href="Language.Haskell.Exts.Syntax.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423033"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423032"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1490"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423031"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423031"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoUnpackPragma"><span class="hs-identifier hs-type">NoUnpackPragma</span></a></span><span> </span><span id="local-6989586621679423030"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423030"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Unpackedness l
</span><a href="Language.Haskell.Exts.Syntax.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423031"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423030"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1491"></span><span>
</span><span id="line-1492"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rhs"><span class="hs-identifier hs-type">Rhs</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1493"></span><span>     </span><span id="local-6989586621679423024"><span class="annot"><span class="annottext">ann :: forall l. Rhs l -&gt; l
</span><a href="#local-6989586621679423024"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnGuardedRhs"><span class="hs-identifier hs-type">UnGuardedRhs</span></a></span><span> </span><span id="local-6989586621679423023"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423023"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423023"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1494"></span><span>     </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GuardedRhss"><span class="hs-identifier hs-type">GuardedRhss</span></a></span><span>  </span><span id="local-6989586621679423022"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423022"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[GuardedRhs l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423022"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1495"></span><span>     </span><span id="local-6989586621679423021"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Rhs l -&gt; Rhs l
</span><a href="#local-6989586621679423021"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423020"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423020"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnGuardedRhs"><span class="hs-identifier hs-type">UnGuardedRhs</span></a></span><span> </span><span id="local-6989586621679423019"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423019"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423018"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423018"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Rhs l
</span><a href="Language.Haskell.Exts.Syntax.html#UnGuardedRhs"><span class="hs-identifier hs-var">UnGuardedRhs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423020"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423019"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423018"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1496"></span><span>     </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679423017"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423017"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GuardedRhss"><span class="hs-identifier hs-type">GuardedRhss</span></a></span><span>  </span><span id="local-6989586621679423016"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423016"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423015"><span class="annot"><span class="annottext">[GuardedRhs l]
</span><a href="#local-6989586621679423015"><span class="hs-identifier hs-var">grhss</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [GuardedRhs l] -&gt; Rhs l
</span><a href="Language.Haskell.Exts.Syntax.html#GuardedRhss"><span class="hs-identifier hs-var">GuardedRhss</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423017"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423016"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[GuardedRhs l]
</span><a href="#local-6989586621679423015"><span class="hs-identifier hs-var">grhss</span></a></span><span>
</span><span id="line-1497"></span><span>
</span><span id="line-1498"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GuardedRhs"><span class="hs-identifier hs-type">GuardedRhs</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1499"></span><span>     </span><span id="local-6989586621679423009"><span class="annot"><span class="annottext">ann :: forall l. GuardedRhs l -&gt; l
</span><a href="#local-6989586621679423009"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GuardedRhs"><span class="hs-identifier hs-type">GuardedRhs</span></a></span><span> </span><span id="local-6989586621679423008"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423008"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Stmt l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423008"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1500"></span><span>     </span><span id="local-6989586621679423007"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; GuardedRhs l -&gt; GuardedRhs l
</span><a href="#local-6989586621679423007"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679423006"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423006"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GuardedRhs"><span class="hs-identifier hs-type">GuardedRhs</span></a></span><span> </span><span id="local-6989586621679423005"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423005"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679423004"><span class="annot"><span class="annottext">[Stmt l]
</span><a href="#local-6989586621679423004"><span class="hs-identifier hs-var">ss</span></a></span></span><span> </span><span id="local-6989586621679423003"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423003"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Stmt l] -&gt; Exp l -&gt; GuardedRhs l
</span><a href="Language.Haskell.Exts.Syntax.html#GuardedRhs"><span class="hs-identifier hs-var">GuardedRhs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679423006"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679423005"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Stmt l]
</span><a href="#local-6989586621679423004"><span class="hs-identifier hs-var">ss</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679423003"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1501"></span><span>
</span><span id="line-1502"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1503"></span><span>    </span><span id="local-6989586621679422997"><span class="annot"><span class="annottext">ann :: forall l. Type l -&gt; l
</span><a href="#local-6989586621679422997"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679422996"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422996"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422996"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1504"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyForall"><span class="hs-identifier hs-type">TyForall</span></a></span><span> </span><span id="local-6989586621679422995"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422995"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422995"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1505"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyStar"><span class="hs-identifier hs-type">TyStar</span></a></span><span>  </span><span id="local-6989586621679422994"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422994"><span class="hs-identifier hs-var">l</span></a></span></span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422994"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1506"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyFun"><span class="hs-identifier hs-type">TyFun</span></a></span><span>   </span><span id="local-6989586621679422993"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422993"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422993"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1507"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyTuple"><span class="hs-identifier hs-type">TyTuple</span></a></span><span> </span><span id="local-6989586621679422992"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422992"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxed
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422992"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1508"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyUnboxedSum"><span class="hs-identifier hs-type">TyUnboxedSum</span></a></span><span> </span><span id="local-6989586621679422991"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422991"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422991"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1509"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyList"><span class="hs-identifier hs-type">TyList</span></a></span><span>  </span><span id="local-6989586621679422990"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422990"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422990"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1510"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyParArray"><span class="hs-identifier hs-type">TyParArray</span></a></span><span>  </span><span id="local-6989586621679422989"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422989"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422989"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1511"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyApp"><span class="hs-identifier hs-type">TyApp</span></a></span><span>   </span><span id="local-6989586621679422988"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422988"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422988"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1512"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span>   </span><span id="local-6989586621679422987"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422987"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422987"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1513"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyCon"><span class="hs-identifier hs-type">TyCon</span></a></span><span>   </span><span id="local-6989586621679422986"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422986"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422986"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1514"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyParen"><span class="hs-identifier hs-type">TyParen</span></a></span><span> </span><span id="local-6989586621679422985"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422985"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422985"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1515"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyInfix"><span class="hs-identifier hs-type">TyInfix</span></a></span><span> </span><span id="local-6989586621679422984"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422984"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">MaybePromotedName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422984"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1516"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyKind"><span class="hs-identifier hs-type">TyKind</span></a></span><span>  </span><span id="local-6989586621679422983"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422983"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422983"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1517"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyPromoted"><span class="hs-identifier hs-type">TyPromoted</span></a></span><span> </span><span id="local-6989586621679422982"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422982"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span class="annot"><span class="annottext">Promoted l
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422982"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1518"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyEquals"><span class="hs-identifier hs-type">TyEquals</span></a></span><span> </span><span id="local-6989586621679422981"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422981"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422981"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1519"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TySplice"><span class="hs-identifier hs-type">TySplice</span></a></span><span> </span><span id="local-6989586621679422980"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422980"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Splice l
</span><span class="hs-identifier">_</span></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422980"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1520"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyBang"><span class="hs-identifier hs-type">TyBang</span></a></span><span> </span><span id="local-6989586621679422979"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422979"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">BangType l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Unpackedness l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422979"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1521"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyWildCard"><span class="hs-identifier hs-type">TyWildCard</span></a></span><span> </span><span id="local-6989586621679422978"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422978"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (Name l)
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422978"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1522"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyQuasiQuote"><span class="hs-identifier hs-type">TyQuasiQuote</span></a></span><span> </span><span id="local-6989586621679422977"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422977"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422977"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1523"></span><span>    </span><span id="local-6989586621679422976"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Type l -&gt; Type l
</span><a href="#local-6989586621679422976"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422975"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679422974"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422974"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422974"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1524"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyForall"><span class="hs-identifier hs-type">TyForall</span></a></span><span> </span><span id="local-6989586621679422973"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422973"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422972"><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679422972"><span class="hs-identifier hs-var">mtvs</span></a></span></span><span> </span><span id="local-6989586621679422971"><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679422971"><span class="hs-identifier hs-var">mcx</span></a></span></span><span> </span><span id="local-6989586621679422970"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422970"><span class="hs-identifier hs-var">t</span></a></span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l -&gt; Maybe [TyVarBind l] -&gt; Maybe (Context l) -&gt; Type l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyForall"><span class="hs-identifier hs-var">TyForall</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422973"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBind l]
</span><a href="#local-6989586621679422972"><span class="hs-identifier hs-var">mtvs</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Context l)
</span><a href="#local-6989586621679422971"><span class="hs-identifier hs-var">mcx</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422970"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1525"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyStar"><span class="hs-identifier hs-type">TyStar</span></a></span><span>  </span><span id="local-6989586621679422969"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422969"><span class="hs-identifier hs-var">l</span></a></span></span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyStar"><span class="hs-identifier hs-var">TyStar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422969"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1526"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyFun"><span class="hs-identifier hs-type">TyFun</span></a></span><span>   </span><span id="local-6989586621679422968"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422968"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422967"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422967"><span class="hs-identifier hs-var">t1'</span></a></span></span><span> </span><span id="local-6989586621679422966"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422966"><span class="hs-identifier hs-var">t2</span></a></span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Type l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyFun"><span class="hs-identifier hs-var">TyFun</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422968"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422967"><span class="hs-identifier hs-var">t1'</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422966"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1527"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyTuple"><span class="hs-identifier hs-type">TyTuple</span></a></span><span> </span><span id="local-6989586621679422965"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422965"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422964"><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679422964"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679422963"><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679422963"><span class="hs-identifier hs-var">ts</span></a></span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Boxed -&gt; [Type l] -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyTuple"><span class="hs-identifier hs-var">TyTuple</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422965"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679422964"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679422963"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-1528"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyUnboxedSum"><span class="hs-identifier hs-type">TyUnboxedSum</span></a></span><span> </span><span id="local-6989586621679422962"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422962"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422961"><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679422961"><span class="hs-identifier hs-var">s</span></a></span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Type l] -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyUnboxedSum"><span class="hs-identifier hs-var">TyUnboxedSum</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422962"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679422961"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1529"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyList"><span class="hs-identifier hs-type">TyList</span></a></span><span>  </span><span id="local-6989586621679422960"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422960"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422959"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422959"><span class="hs-identifier hs-var">t</span></a></span></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyList"><span class="hs-identifier hs-var">TyList</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422960"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422959"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1530"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyParArray"><span class="hs-identifier hs-type">TyParArray</span></a></span><span>  </span><span id="local-6989586621679422958"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422958"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422957"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422957"><span class="hs-identifier hs-var">t</span></a></span></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyParArray"><span class="hs-identifier hs-var">TyParArray</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422958"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422957"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1531"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyApp"><span class="hs-identifier hs-type">TyApp</span></a></span><span>   </span><span id="local-6989586621679422956"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422956"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422955"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422955"><span class="hs-identifier hs-var">t1'</span></a></span></span><span> </span><span id="local-6989586621679422954"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422954"><span class="hs-identifier hs-var">t2</span></a></span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Type l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyApp"><span class="hs-identifier hs-var">TyApp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422956"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422955"><span class="hs-identifier hs-var">t1'</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422954"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1532"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span>   </span><span id="local-6989586621679422953"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422953"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422952"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422952"><span class="hs-identifier hs-var">n</span></a></span></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyVar"><span class="hs-identifier hs-var">TyVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422953"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422952"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1533"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyCon"><span class="hs-identifier hs-type">TyCon</span></a></span><span>   </span><span id="local-6989586621679422951"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422951"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422950"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422950"><span class="hs-identifier hs-var">qn</span></a></span></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyCon"><span class="hs-identifier hs-var">TyCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422951"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422950"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1534"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyParen"><span class="hs-identifier hs-type">TyParen</span></a></span><span> </span><span id="local-6989586621679422949"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422949"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422948"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422948"><span class="hs-identifier hs-var">t</span></a></span></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyParen"><span class="hs-identifier hs-var">TyParen</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422949"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422948"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1535"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyInfix"><span class="hs-identifier hs-type">TyInfix</span></a></span><span> </span><span id="local-6989586621679422947"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422947"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422946"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422946"><span class="hs-identifier hs-var">ta</span></a></span></span><span> </span><span id="local-6989586621679422945"><span class="annot"><span class="annottext">MaybePromotedName l
</span><a href="#local-6989586621679422945"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621679422944"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422944"><span class="hs-identifier hs-var">tb</span></a></span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; MaybePromotedName l -&gt; Type l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyInfix"><span class="hs-identifier hs-var">TyInfix</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422947"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422946"><span class="hs-identifier hs-var">ta</span></a></span><span> </span><span class="annot"><span class="annottext">MaybePromotedName l
</span><a href="#local-6989586621679422945"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422944"><span class="hs-identifier hs-var">tb</span></a></span><span>
</span><span id="line-1536"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyKind"><span class="hs-identifier hs-type">TyKind</span></a></span><span>  </span><span id="local-6989586621679422943"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422943"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422942"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422942"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679422941"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422941"><span class="hs-identifier hs-var">k</span></a></span></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Type l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyKind"><span class="hs-identifier hs-var">TyKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422943"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422942"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422941"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1537"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyPromoted"><span class="hs-identifier hs-type">TyPromoted</span></a></span><span> </span><span id="local-6989586621679422940"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422940"><span class="hs-identifier hs-var">l</span></a></span></span><span>   </span><span id="local-6989586621679422939"><span class="annot"><span class="annottext">Promoted l
</span><a href="#local-6989586621679422939"><span class="hs-identifier hs-var">p</span></a></span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Promoted l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyPromoted"><span class="hs-identifier hs-var">TyPromoted</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422940"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="annottext">Promoted l
</span><a href="#local-6989586621679422939"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1538"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyEquals"><span class="hs-identifier hs-type">TyEquals</span></a></span><span> </span><span id="local-6989586621679422938"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422938"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422937"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422937"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679422936"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422936"><span class="hs-identifier hs-var">b</span></a></span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Type l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyEquals"><span class="hs-identifier hs-var">TyEquals</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422938"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422937"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422936"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-1539"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TySplice"><span class="hs-identifier hs-type">TySplice</span></a></span><span> </span><span id="local-6989586621679422935"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422935"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422934"><span class="annot"><span class="annottext">Splice l
</span><a href="#local-6989586621679422934"><span class="hs-identifier hs-var">s</span></a></span></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Splice l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TySplice"><span class="hs-identifier hs-var">TySplice</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422935"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Splice l
</span><a href="#local-6989586621679422934"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1540"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyBang"><span class="hs-identifier hs-type">TyBang</span></a></span><span> </span><span id="local-6989586621679422933"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422933"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422932"><span class="annot"><span class="annottext">BangType l
</span><a href="#local-6989586621679422932"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679422931"><span class="annot"><span class="annottext">Unpackedness l
</span><a href="#local-6989586621679422931"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span id="local-6989586621679422930"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422930"><span class="hs-identifier hs-var">t</span></a></span></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; BangType l -&gt; Unpackedness l -&gt; Type l -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyBang"><span class="hs-identifier hs-var">TyBang</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422933"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">BangType l
</span><a href="#local-6989586621679422932"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Unpackedness l
</span><a href="#local-6989586621679422931"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422930"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1541"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyWildCard"><span class="hs-identifier hs-type">TyWildCard</span></a></span><span> </span><span id="local-6989586621679422929"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422929"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422928"><span class="annot"><span class="annottext">Maybe (Name l)
</span><a href="#local-6989586621679422928"><span class="hs-identifier hs-var">n</span></a></span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Maybe (Name l) -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyWildCard"><span class="hs-identifier hs-var">TyWildCard</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422929"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (Name l)
</span><a href="#local-6989586621679422928"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1542"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyQuasiQuote"><span class="hs-identifier hs-type">TyQuasiQuote</span></a></span><span> </span><span id="local-6989586621679422927"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422927"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422926"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422926"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679422925"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422925"><span class="hs-identifier hs-var">s</span></a></span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; String -&gt; Type l
</span><a href="Language.Haskell.Exts.Syntax.html#TyQuasiQuote"><span class="hs-identifier hs-var">TyQuasiQuote</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422975"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422927"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422926"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422925"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1543"></span><span>
</span><span id="line-1544"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MaybePromotedName"><span class="hs-identifier hs-type">MaybePromotedName</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1545"></span><span>  </span><span id="local-6989586621679422919"><span class="annot"><span class="annottext">ann :: forall l. MaybePromotedName l -&gt; l
</span><a href="#local-6989586621679422919"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679422918"><span class="annot"><span class="annottext">MaybePromotedName l
</span><a href="#local-6989586621679422918"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">MaybePromotedName l
</span><a href="#local-6989586621679422918"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1546"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedName"><span class="hs-identifier hs-type">PromotedName</span></a></span><span> </span><span id="local-6989586621679422917"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422917"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422917"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1547"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnpromotedName"><span class="hs-identifier hs-type">UnpromotedName</span></a></span><span> </span><span id="local-6989586621679422916"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422916"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422916"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1548"></span><span>  </span><span id="local-6989586621679422915"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; MaybePromotedName l -&gt; MaybePromotedName l
</span><a href="#local-6989586621679422915"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422914"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422914"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679422913"><span class="annot"><span class="annottext">MaybePromotedName l
</span><a href="#local-6989586621679422913"><span class="hs-identifier hs-var">tl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">MaybePromotedName l
</span><a href="#local-6989586621679422913"><span class="hs-identifier hs-var">tl</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1549"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedName"><span class="hs-identifier hs-type">PromotedName</span></a></span><span> </span><span id="local-6989586621679422912"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422912"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422911"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422911"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; MaybePromotedName l
</span><a href="Language.Haskell.Exts.Syntax.html#PromotedName"><span class="hs-identifier hs-var">PromotedName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422914"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422912"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>     </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422911"><span class="hs-identifier hs-var">q</span></a></span><span>
</span><span id="line-1550"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnpromotedName"><span class="hs-identifier hs-type">UnpromotedName</span></a></span><span> </span><span id="local-6989586621679422910"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422910"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422909"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422909"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; MaybePromotedName l
</span><a href="Language.Haskell.Exts.Syntax.html#UnpromotedName"><span class="hs-identifier hs-var">UnpromotedName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422914"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422910"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422909"><span class="hs-identifier hs-var">q</span></a></span><span>
</span><span id="line-1551"></span><span>
</span><span id="line-1552"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TyVarBind"><span class="hs-identifier hs-type">TyVarBind</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1553"></span><span>    </span><span id="local-6989586621679422903"><span class="annot"><span class="annottext">ann :: forall l. TyVarBind l -&gt; l
</span><a href="#local-6989586621679422903"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#KindedVar"><span class="hs-identifier hs-type">KindedVar</span></a></span><span>   </span><span id="local-6989586621679422902"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422902"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Kind l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422902"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1554"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnkindedVar"><span class="hs-identifier hs-type">UnkindedVar</span></a></span><span> </span><span id="local-6989586621679422901"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422901"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422901"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1555"></span><span>    </span><span id="local-6989586621679422900"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; TyVarBind l -&gt; TyVarBind l
</span><a href="#local-6989586621679422900"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422899"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422899"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#KindedVar"><span class="hs-identifier hs-type">KindedVar</span></a></span><span>   </span><span id="local-6989586621679422898"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422898"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422897"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422897"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679422896"><span class="annot"><span class="annottext">Kind l
</span><a href="#local-6989586621679422896"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; Kind l -&gt; TyVarBind l
</span><a href="Language.Haskell.Exts.Syntax.html#KindedVar"><span class="hs-identifier hs-var">KindedVar</span></a></span><span>   </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422899"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422898"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422897"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Kind l
</span><a href="#local-6989586621679422896"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1556"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422895"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422895"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnkindedVar"><span class="hs-identifier hs-type">UnkindedVar</span></a></span><span> </span><span id="local-6989586621679422894"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422894"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422893"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422893"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; TyVarBind l
</span><a href="Language.Haskell.Exts.Syntax.html#UnkindedVar"><span class="hs-identifier hs-var">UnkindedVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422895"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422894"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422893"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1557"></span><span>
</span><span id="line-1558"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunDep"><span class="hs-identifier hs-type">FunDep</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1559"></span><span>    </span><span id="local-6989586621679422887"><span class="annot"><span class="annottext">ann :: forall l. FunDep l -&gt; l
</span><a href="#local-6989586621679422887"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunDep"><span class="hs-identifier hs-type">FunDep</span></a></span><span> </span><span id="local-6989586621679422886"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422886"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422886"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1560"></span><span>    </span><span id="local-6989586621679422885"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; FunDep l -&gt; FunDep l
</span><a href="#local-6989586621679422885"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422884"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422884"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FunDep"><span class="hs-identifier hs-type">FunDep</span></a></span><span> </span><span id="local-6989586621679422883"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422883"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422882"><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679422882"><span class="hs-identifier hs-var">ns1</span></a></span></span><span> </span><span id="local-6989586621679422881"><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679422881"><span class="hs-identifier hs-var">ns2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Name l] -&gt; [Name l] -&gt; FunDep l
</span><a href="Language.Haskell.Exts.Syntax.html#FunDep"><span class="hs-identifier hs-var">FunDep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422884"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422883"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679422882"><span class="hs-identifier hs-var">ns1</span></a></span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679422881"><span class="hs-identifier hs-var">ns2</span></a></span><span>
</span><span id="line-1561"></span><span>
</span><span id="line-1562"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Context"><span class="hs-identifier hs-type">Context</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1563"></span><span>    </span><span id="local-6989586621679422875"><span class="annot"><span class="annottext">ann :: forall l. Context l -&gt; l
</span><a href="#local-6989586621679422875"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CxSingle"><span class="hs-identifier hs-type">CxSingle</span></a></span><span> </span><span id="local-6989586621679422874"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422874"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Asst l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422874"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1564"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CxTuple"><span class="hs-identifier hs-type">CxTuple</span></a></span><span>  </span><span id="local-6989586621679422873"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422873"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Asst l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422873"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1565"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CxEmpty"><span class="hs-identifier hs-type">CxEmpty</span></a></span><span>  </span><span id="local-6989586621679422872"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422872"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422872"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1566"></span><span>    </span><span id="local-6989586621679422871"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Context l -&gt; Context l
</span><a href="#local-6989586621679422871"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422870"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422870"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CxSingle"><span class="hs-identifier hs-type">CxSingle</span></a></span><span> </span><span id="local-6989586621679422869"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422869"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422868"><span class="annot"><span class="annottext">Asst l
</span><a href="#local-6989586621679422868"><span class="hs-identifier hs-var">asst</span></a></span></span><span> </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Asst l -&gt; Context l
</span><a href="Language.Haskell.Exts.Syntax.html#CxSingle"><span class="hs-identifier hs-var">CxSingle</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422870"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422869"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Asst l
</span><a href="#local-6989586621679422868"><span class="hs-identifier hs-var">asst</span></a></span><span>
</span><span id="line-1567"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422867"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422867"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CxTuple"><span class="hs-identifier hs-type">CxTuple</span></a></span><span>  </span><span id="local-6989586621679422866"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422866"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422865"><span class="annot"><span class="annottext">[Asst l]
</span><a href="#local-6989586621679422865"><span class="hs-identifier hs-var">assts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Asst l] -&gt; Context l
</span><a href="Language.Haskell.Exts.Syntax.html#CxTuple"><span class="hs-identifier hs-var">CxTuple</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422867"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422866"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Asst l]
</span><a href="#local-6989586621679422865"><span class="hs-identifier hs-var">assts</span></a></span><span>
</span><span id="line-1568"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422864"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422864"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CxEmpty"><span class="hs-identifier hs-type">CxEmpty</span></a></span><span> </span><span id="local-6989586621679422863"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422863"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Context l
</span><a href="Language.Haskell.Exts.Syntax.html#CxEmpty"><span class="hs-identifier hs-var">CxEmpty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422864"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422863"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1569"></span><span>
</span><span id="line-1570"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Asst"><span class="hs-identifier hs-type">Asst</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1571"></span><span>    </span><span id="local-6989586621679422857"><span class="annot"><span class="annottext">ann :: forall l. Asst l -&gt; l
</span><a href="#local-6989586621679422857"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679422856"><span class="annot"><span class="annottext">Asst l
</span><a href="#local-6989586621679422856"><span class="hs-identifier hs-var">asst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Asst l
</span><a href="#local-6989586621679422856"><span class="hs-identifier hs-var">asst</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1572"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeA"><span class="hs-identifier hs-type">TypeA</span></a></span><span> </span><span id="local-6989586621679422855"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422855"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422855"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1573"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IParam"><span class="hs-identifier hs-type">IParam</span></a></span><span> </span><span id="local-6989586621679422854"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422854"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">IPName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422854"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1574"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParenA"><span class="hs-identifier hs-type">ParenA</span></a></span><span> </span><span id="local-6989586621679422853"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422853"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Asst l
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422853"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1575"></span><span>    </span><span id="local-6989586621679422852"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Asst l -&gt; Asst l
</span><a href="#local-6989586621679422852"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422851"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422851"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679422850"><span class="annot"><span class="annottext">Asst l
</span><a href="#local-6989586621679422850"><span class="hs-identifier hs-var">asst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Asst l
</span><a href="#local-6989586621679422850"><span class="hs-identifier hs-var">asst</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1576"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeA"><span class="hs-identifier hs-type">TypeA</span></a></span><span> </span><span id="local-6989586621679422849"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422849"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422848"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422848"><span class="hs-identifier hs-var">t</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Asst l
</span><a href="Language.Haskell.Exts.Syntax.html#TypeA"><span class="hs-identifier hs-var">TypeA</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422851"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422849"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422848"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1577"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IParam"><span class="hs-identifier hs-type">IParam</span></a></span><span> </span><span id="local-6989586621679422847"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422847"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422846"><span class="annot"><span class="annottext">IPName l
</span><a href="#local-6989586621679422846"><span class="hs-identifier hs-var">ipn</span></a></span></span><span> </span><span id="local-6989586621679422845"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422845"><span class="hs-identifier hs-var">t</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; IPName l -&gt; Type l -&gt; Asst l
</span><a href="Language.Haskell.Exts.Syntax.html#IParam"><span class="hs-identifier hs-var">IParam</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422851"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422847"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">IPName l
</span><a href="#local-6989586621679422846"><span class="hs-identifier hs-var">ipn</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422845"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1578"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParenA"><span class="hs-identifier hs-type">ParenA</span></a></span><span> </span><span id="local-6989586621679422844"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422844"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422843"><span class="annot"><span class="annottext">Asst l
</span><a href="#local-6989586621679422843"><span class="hs-identifier hs-var">a</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Asst l -&gt; Asst l
</span><a href="Language.Haskell.Exts.Syntax.html#ParenA"><span class="hs-identifier hs-var">ParenA</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422851"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422844"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Asst l
</span><a href="#local-6989586621679422843"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-1579"></span><span>
</span><span id="line-1580"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Literal"><span class="hs-identifier hs-type">Literal</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1581"></span><span>    </span><span id="local-6989586621679422837"><span class="annot"><span class="annottext">ann :: forall l. Literal l -&gt; l
</span><a href="#local-6989586621679422837"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679422836"><span class="annot"><span class="annottext">Literal l
</span><a href="#local-6989586621679422836"><span class="hs-identifier hs-var">lit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Literal l
</span><a href="#local-6989586621679422836"><span class="hs-identifier hs-var">lit</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1582"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Char"><span class="hs-identifier hs-type">Char</span></a></span><span>    </span><span id="local-6989586621679422835"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422835"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-identifier">_</span></span><span>    </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422835"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1583"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#String"><span class="hs-identifier hs-type">String</span></a></span><span>  </span><span id="local-6989586621679422834"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422834"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>    </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422834"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1584"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Int"><span class="hs-identifier hs-type">Int</span></a></span><span>     </span><span id="local-6989586621679422833"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422833"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-identifier">_</span></span><span>    </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422833"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1585"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Frac"><span class="hs-identifier hs-type">Frac</span></a></span><span>    </span><span id="local-6989586621679422832"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422832"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Rational
</span><span class="hs-identifier">_</span></span><span>    </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422832"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1586"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimInt"><span class="hs-identifier hs-type">PrimInt</span></a></span><span>    </span><span id="local-6989586621679422831"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422831"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422831"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1587"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimWord"><span class="hs-identifier hs-type">PrimWord</span></a></span><span>   </span><span id="local-6989586621679422830"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422830"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422830"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1588"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimFloat"><span class="hs-identifier hs-type">PrimFloat</span></a></span><span>  </span><span id="local-6989586621679422829"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422829"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Rational
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422829"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1589"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimDouble"><span class="hs-identifier hs-type">PrimDouble</span></a></span><span> </span><span id="local-6989586621679422828"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422828"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Rational
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422828"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1590"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimChar"><span class="hs-identifier hs-type">PrimChar</span></a></span><span>   </span><span id="local-6989586621679422827"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422827"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422827"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1591"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PrimString"><span class="hs-identifier hs-type">PrimString</span></a></span><span> </span><span id="local-6989586621679422826"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422826"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422826"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1592"></span><span>    </span><span id="local-6989586621679422824"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Literal l -&gt; Literal l
</span><a href="#local-6989586621679422824"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1593"></span><span>
</span><span id="line-1594"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Sign"><span class="hs-identifier hs-type">Sign</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1595"></span><span>    </span><span id="local-6989586621679422818"><span class="annot"><span class="annottext">ann :: forall l. Sign l -&gt; l
</span><a href="#local-6989586621679422818"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679422817"><span class="annot"><span class="annottext">Sign l
</span><a href="#local-6989586621679422817"><span class="hs-identifier hs-var">sg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Sign l
</span><a href="#local-6989586621679422817"><span class="hs-identifier hs-var">sg</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1596"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Signless"><span class="hs-identifier hs-type">Signless</span></a></span><span> </span><span id="local-6989586621679422816"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422816"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422816"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1597"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Negative"><span class="hs-identifier hs-type">Negative</span></a></span><span> </span><span id="local-6989586621679422815"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422815"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422815"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1598"></span><span>    </span><span id="local-6989586621679422813"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Sign l -&gt; Sign l
</span><a href="#local-6989586621679422813"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1599"></span><span>
</span><span id="line-1600"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1601"></span><span>    </span><span id="local-6989586621679422807"><span class="annot"><span class="annottext">ann :: forall l. Exp l -&gt; l
</span><a href="#local-6989586621679422807"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679422806"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422806"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422806"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1602"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Var"><span class="hs-identifier hs-type">Var</span></a></span><span> </span><span id="local-6989586621679422805"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422805"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422805"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1603"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#OverloadedLabel"><span class="hs-identifier hs-type">OverloadedLabel</span></a></span><span> </span><span id="local-6989586621679422804"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422804"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422804"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1604"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPVar"><span class="hs-identifier hs-type">IPVar</span></a></span><span> </span><span id="local-6989586621679422803"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422803"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">IPName l
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422803"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1605"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span> </span><span id="local-6989586621679422802"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422802"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422802"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1606"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span id="local-6989586621679422801"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422801"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Literal l
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422801"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1607"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixApp"><span class="hs-identifier hs-type">InfixApp</span></a></span><span> </span><span id="local-6989586621679422800"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422800"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">QOp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422800"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1608"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#App"><span class="hs-identifier hs-type">App</span></a></span><span> </span><span id="local-6989586621679422799"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422799"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422799"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1609"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NegApp"><span class="hs-identifier hs-type">NegApp</span></a></span><span> </span><span id="local-6989586621679422798"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422798"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422798"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1610"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Lambda"><span class="hs-identifier hs-type">Lambda</span></a></span><span> </span><span id="local-6989586621679422797"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422797"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422797"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1611"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Let"><span class="hs-identifier hs-type">Let</span></a></span><span> </span><span id="local-6989586621679422796"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422796"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Binds l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422796"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1612"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#If"><span class="hs-identifier hs-type">If</span></a></span><span> </span><span id="local-6989586621679422795"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422795"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422795"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1613"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MultiIf"><span class="hs-identifier hs-type">MultiIf</span></a></span><span> </span><span id="local-6989586621679422794"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422794"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[GuardedRhs l]
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422794"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1614"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Case"><span class="hs-identifier hs-type">Case</span></a></span><span> </span><span id="local-6989586621679422793"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422793"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Alt l]
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422793"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1615"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Do"><span class="hs-identifier hs-type">Do</span></a></span><span> </span><span id="local-6989586621679422792"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422792"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Stmt l]
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422792"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1616"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MDo"><span class="hs-identifier hs-type">MDo</span></a></span><span> </span><span id="local-6989586621679422791"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422791"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Stmt l]
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422791"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1617"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Tuple"><span class="hs-identifier hs-type">Tuple</span></a></span><span> </span><span id="local-6989586621679422790"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422790"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxed
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422790"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1618"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnboxedSum"><span class="hs-identifier hs-type">UnboxedSum</span></a></span><span> </span><span id="local-6989586621679422789"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422789"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422789"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1619"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TupleSection"><span class="hs-identifier hs-type">TupleSection</span></a></span><span> </span><span id="local-6989586621679422788"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422788"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxed
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Maybe (Exp l)]
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422788"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1620"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#List"><span class="hs-identifier hs-type">List</span></a></span><span> </span><span id="local-6989586621679422787"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422787"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><span class="hs-identifier">_</span></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422787"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1621"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArray"><span class="hs-identifier hs-type">ParArray</span></a></span><span> </span><span id="local-6989586621679422786"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422786"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422786"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1622"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Paren"><span class="hs-identifier hs-type">Paren</span></a></span><span> </span><span id="local-6989586621679422785"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422785"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422785"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1623"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LeftSection"><span class="hs-identifier hs-type">LeftSection</span></a></span><span> </span><span id="local-6989586621679422784"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422784"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">QOp l
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422784"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1624"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RightSection"><span class="hs-identifier hs-type">RightSection</span></a></span><span> </span><span id="local-6989586621679422783"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422783"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QOp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422783"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1625"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecConstr"><span class="hs-identifier hs-type">RecConstr</span></a></span><span> </span><span id="local-6989586621679422782"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422782"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[FieldUpdate l]
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422782"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1626"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecUpdate"><span class="hs-identifier hs-type">RecUpdate</span></a></span><span> </span><span id="local-6989586621679422781"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422781"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[FieldUpdate l]
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422781"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1627"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFrom"><span class="hs-identifier hs-type">EnumFrom</span></a></span><span> </span><span id="local-6989586621679422780"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422780"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422780"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1628"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFromTo"><span class="hs-identifier hs-type">EnumFromTo</span></a></span><span> </span><span id="local-6989586621679422779"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422779"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422779"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1629"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFromThen"><span class="hs-identifier hs-type">EnumFromThen</span></a></span><span> </span><span id="local-6989586621679422778"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422778"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422778"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1630"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFromThenTo"><span class="hs-identifier hs-type">EnumFromThenTo</span></a></span><span> </span><span id="local-6989586621679422777"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422777"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422777"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1631"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArrayFromTo"><span class="hs-identifier hs-type">ParArrayFromTo</span></a></span><span> </span><span id="local-6989586621679422776"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422776"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422776"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1632"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArrayFromThenTo"><span class="hs-identifier hs-type">ParArrayFromThenTo</span></a></span><span> </span><span id="local-6989586621679422775"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422775"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422775"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1633"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ListComp"><span class="hs-identifier hs-type">ListComp</span></a></span><span> </span><span id="local-6989586621679422774"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422774"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[QualStmt l]
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422774"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1634"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParComp"><span class="hs-identifier hs-type">ParComp</span></a></span><span>  </span><span id="local-6989586621679422773"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422773"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[[QualStmt l]]
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422773"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1635"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArrayComp"><span class="hs-identifier hs-type">ParArrayComp</span></a></span><span>  </span><span id="local-6989586621679422772"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422772"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[[QualStmt l]]
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422772"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1636"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExpTypeSig"><span class="hs-identifier hs-type">ExpTypeSig</span></a></span><span> </span><span id="local-6989586621679422771"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422771"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422771"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1637"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarQuote"><span class="hs-identifier hs-type">VarQuote</span></a></span><span> </span><span id="local-6989586621679422770"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422770"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422770"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1638"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypQuote"><span class="hs-identifier hs-type">TypQuote</span></a></span><span> </span><span id="local-6989586621679422769"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422769"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422769"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1639"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BracketExp"><span class="hs-identifier hs-type">BracketExp</span></a></span><span> </span><span id="local-6989586621679422768"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422768"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bracket l
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422768"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1640"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpliceExp"><span class="hs-identifier hs-type">SpliceExp</span></a></span><span> </span><span id="local-6989586621679422767"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422767"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Splice l
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422767"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1641"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QuasiQuote"><span class="hs-identifier hs-type">QuasiQuote</span></a></span><span> </span><span id="local-6989586621679422766"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422766"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422766"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1642"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeApp"><span class="hs-identifier hs-type">TypeApp</span></a></span><span> </span><span id="local-6989586621679422765"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422765"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422765"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1643"></span><span>
</span><span id="line-1644"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XTag"><span class="hs-identifier hs-type">XTag</span></a></span><span>  </span><span id="local-6989586621679422764"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422764"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">XName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[XAttr l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Exp l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422764"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1645"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XETag"><span class="hs-identifier hs-type">XETag</span></a></span><span> </span><span id="local-6989586621679422763"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422763"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">XName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[XAttr l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Exp l)
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422763"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1646"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XPcdata"><span class="hs-identifier hs-type">XPcdata</span></a></span><span> </span><span id="local-6989586621679422762"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422762"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422762"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1647"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XExpTag"><span class="hs-identifier hs-type">XExpTag</span></a></span><span> </span><span id="local-6989586621679422761"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422761"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422761"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1648"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XChildTag"><span class="hs-identifier hs-type">XChildTag</span></a></span><span> </span><span id="local-6989586621679422760"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422760"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422760"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1649"></span><span>
</span><span id="line-1650"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CorePragma"><span class="hs-identifier hs-type">CorePragma</span></a></span><span> </span><span id="local-6989586621679422759"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422759"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422759"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1651"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SCCPragma"><span class="hs-identifier hs-type">SCCPragma</span></a></span><span>  </span><span id="local-6989586621679422758"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422758"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422758"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1652"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GenPragma"><span class="hs-identifier hs-type">GenPragma</span></a></span><span>  </span><span id="local-6989586621679422757"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422757"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">(Int, Int)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">(Int, Int)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422757"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1653"></span><span>
</span><span id="line-1654"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Proc"><span class="hs-identifier hs-type">Proc</span></a></span><span>            </span><span id="local-6989586621679422756"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422756"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422756"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1655"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LeftArrApp"><span class="hs-identifier hs-type">LeftArrApp</span></a></span><span>      </span><span id="local-6989586621679422755"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422755"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422755"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1656"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RightArrApp"><span class="hs-identifier hs-type">RightArrApp</span></a></span><span>     </span><span id="local-6989586621679422754"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422754"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422754"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1657"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LeftArrHighApp"><span class="hs-identifier hs-type">LeftArrHighApp</span></a></span><span>  </span><span id="local-6989586621679422753"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422753"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422753"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1658"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RightArrHighApp"><span class="hs-identifier hs-type">RightArrHighApp</span></a></span><span> </span><span id="local-6989586621679422752"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422752"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422752"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1659"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ArrOp"><span class="hs-identifier hs-type">ArrOp</span></a></span><span>           </span><span id="local-6989586621679422751"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422751"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422751"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1660"></span><span>
</span><span id="line-1661"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LCase"><span class="hs-identifier hs-type">LCase</span></a></span><span> </span><span id="local-6989586621679422750"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422750"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Alt l]
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422750"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1662"></span><span>
</span><span id="line-1663"></span><span>    </span><span id="local-6989586621679422749"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Exp l -&gt; Exp l
</span><a href="#local-6989586621679422749"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422748"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679422747"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422747"><span class="hs-identifier hs-var">e1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422747"><span class="hs-identifier hs-var">e1</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1664"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Var"><span class="hs-identifier hs-type">Var</span></a></span><span> </span><span id="local-6989586621679422746"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422746"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422745"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422745"><span class="hs-identifier hs-var">qn</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Var"><span class="hs-identifier hs-var">Var</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422746"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422745"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1665"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#OverloadedLabel"><span class="hs-identifier hs-type">OverloadedLabel</span></a></span><span> </span><span id="local-6989586621679422744"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422744"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422743"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422743"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#OverloadedLabel"><span class="hs-identifier hs-var">OverloadedLabel</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422744"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422743"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1666"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IPVar"><span class="hs-identifier hs-type">IPVar</span></a></span><span> </span><span id="local-6989586621679422742"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422742"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422741"><span class="annot"><span class="annottext">IPName l
</span><a href="#local-6989586621679422741"><span class="hs-identifier hs-var">ipn</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; IPName l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#IPVar"><span class="hs-identifier hs-var">IPVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422742"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">IPName l
</span><a href="#local-6989586621679422741"><span class="hs-identifier hs-var">ipn</span></a></span><span>
</span><span id="line-1667"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span> </span><span id="local-6989586621679422740"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422740"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422739"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422739"><span class="hs-identifier hs-var">qn</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Con"><span class="hs-identifier hs-var">Con</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422740"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422739"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1668"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span id="local-6989586621679422738"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422738"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422737"><span class="annot"><span class="annottext">Literal l
</span><a href="#local-6989586621679422737"><span class="hs-identifier hs-var">lit</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Literal l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Lit"><span class="hs-identifier hs-var">Lit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422738"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Literal l
</span><a href="#local-6989586621679422737"><span class="hs-identifier hs-var">lit</span></a></span><span>
</span><span id="line-1669"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#InfixApp"><span class="hs-identifier hs-type">InfixApp</span></a></span><span> </span><span id="local-6989586621679422736"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422736"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422735"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422735"><span class="hs-identifier hs-var">e1'</span></a></span></span><span> </span><span id="local-6989586621679422734"><span class="annot"><span class="annottext">QOp l
</span><a href="#local-6989586621679422734"><span class="hs-identifier hs-var">qop</span></a></span></span><span> </span><span id="local-6989586621679422733"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422733"><span class="hs-identifier hs-var">e2</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; QOp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#InfixApp"><span class="hs-identifier hs-var">InfixApp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422736"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422735"><span class="hs-identifier hs-var">e1'</span></a></span><span> </span><span class="annot"><span class="annottext">QOp l
</span><a href="#local-6989586621679422734"><span class="hs-identifier hs-var">qop</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422733"><span class="hs-identifier hs-var">e2</span></a></span><span>
</span><span id="line-1670"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#App"><span class="hs-identifier hs-type">App</span></a></span><span> </span><span id="local-6989586621679422732"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422732"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422731"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422731"><span class="hs-identifier hs-var">e1'</span></a></span></span><span> </span><span id="local-6989586621679422730"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422730"><span class="hs-identifier hs-var">e2</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#App"><span class="hs-identifier hs-var">App</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422732"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422731"><span class="hs-identifier hs-var">e1'</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422730"><span class="hs-identifier hs-var">e2</span></a></span><span>
</span><span id="line-1671"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NegApp"><span class="hs-identifier hs-type">NegApp</span></a></span><span> </span><span id="local-6989586621679422729"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422729"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422728"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422728"><span class="hs-identifier hs-var">e</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#NegApp"><span class="hs-identifier hs-var">NegApp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422729"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422728"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1672"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Lambda"><span class="hs-identifier hs-type">Lambda</span></a></span><span> </span><span id="local-6989586621679422727"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422727"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422726"><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679422726"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621679422725"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422725"><span class="hs-identifier hs-var">e</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Pat l] -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Lambda"><span class="hs-identifier hs-var">Lambda</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422727"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679422726"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422725"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1673"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Let"><span class="hs-identifier hs-type">Let</span></a></span><span> </span><span id="local-6989586621679422724"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422724"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422723"><span class="annot"><span class="annottext">Binds l
</span><a href="#local-6989586621679422723"><span class="hs-identifier hs-var">bs</span></a></span></span><span> </span><span id="local-6989586621679422722"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422722"><span class="hs-identifier hs-var">e</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Binds l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Let"><span class="hs-identifier hs-var">Let</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422724"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Binds l
</span><a href="#local-6989586621679422723"><span class="hs-identifier hs-var">bs</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422722"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1674"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#If"><span class="hs-identifier hs-type">If</span></a></span><span> </span><span id="local-6989586621679422721"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422721"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422720"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422720"><span class="hs-identifier hs-var">ec</span></a></span></span><span> </span><span id="local-6989586621679422719"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422719"><span class="hs-identifier hs-var">et</span></a></span></span><span> </span><span id="local-6989586621679422718"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422718"><span class="hs-identifier hs-var">ee</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#If"><span class="hs-identifier hs-var">If</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422721"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422720"><span class="hs-identifier hs-var">ec</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422719"><span class="hs-identifier hs-var">et</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422718"><span class="hs-identifier hs-var">ee</span></a></span><span>
</span><span id="line-1675"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Case"><span class="hs-identifier hs-type">Case</span></a></span><span> </span><span id="local-6989586621679422717"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422717"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422716"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422716"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679422715"><span class="annot"><span class="annottext">[Alt l]
</span><a href="#local-6989586621679422715"><span class="hs-identifier hs-var">alts</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; [Alt l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Case"><span class="hs-identifier hs-var">Case</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422717"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422716"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="annot"><span class="annottext">[Alt l]
</span><a href="#local-6989586621679422715"><span class="hs-identifier hs-var">alts</span></a></span><span>
</span><span id="line-1676"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Do"><span class="hs-identifier hs-type">Do</span></a></span><span> </span><span id="local-6989586621679422714"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422714"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422713"><span class="annot"><span class="annottext">[Stmt l]
</span><a href="#local-6989586621679422713"><span class="hs-identifier hs-var">ss</span></a></span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Stmt l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Do"><span class="hs-identifier hs-var">Do</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422714"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Stmt l]
</span><a href="#local-6989586621679422713"><span class="hs-identifier hs-var">ss</span></a></span><span>
</span><span id="line-1677"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MDo"><span class="hs-identifier hs-type">MDo</span></a></span><span> </span><span id="local-6989586621679422712"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422712"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422711"><span class="annot"><span class="annottext">[Stmt l]
</span><a href="#local-6989586621679422711"><span class="hs-identifier hs-var">ss</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Stmt l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#MDo"><span class="hs-identifier hs-var">MDo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422712"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Stmt l]
</span><a href="#local-6989586621679422711"><span class="hs-identifier hs-var">ss</span></a></span><span>
</span><span id="line-1678"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Tuple"><span class="hs-identifier hs-type">Tuple</span></a></span><span> </span><span id="local-6989586621679422710"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422710"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422709"><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679422709"><span class="hs-identifier hs-var">bx</span></a></span></span><span> </span><span id="local-6989586621679422708"><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679422708"><span class="hs-identifier hs-var">es</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Boxed -&gt; [Exp l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Tuple"><span class="hs-identifier hs-var">Tuple</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422710"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679422709"><span class="hs-identifier hs-var">bx</span></a></span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679422708"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-1679"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#UnboxedSum"><span class="hs-identifier hs-type">UnboxedSum</span></a></span><span> </span><span id="local-6989586621679422707"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422707"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422706"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679422706"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679422705"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679422705"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679422704"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422704"><span class="hs-identifier hs-var">es</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Int -&gt; Int -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#UnboxedSum"><span class="hs-identifier hs-var">UnboxedSum</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422707"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679422706"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679422705"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422704"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-1680"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TupleSection"><span class="hs-identifier hs-type">TupleSection</span></a></span><span> </span><span id="local-6989586621679422703"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422703"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422702"><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679422702"><span class="hs-identifier hs-var">bx</span></a></span></span><span> </span><span id="local-6989586621679422701"><span class="annot"><span class="annottext">[Maybe (Exp l)]
</span><a href="#local-6989586621679422701"><span class="hs-identifier hs-var">mes</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Boxed -&gt; [Maybe (Exp l)] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#TupleSection"><span class="hs-identifier hs-var">TupleSection</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422703"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679422702"><span class="hs-identifier hs-var">bx</span></a></span><span> </span><span class="annot"><span class="annottext">[Maybe (Exp l)]
</span><a href="#local-6989586621679422701"><span class="hs-identifier hs-var">mes</span></a></span><span>
</span><span id="line-1681"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#List"><span class="hs-identifier hs-type">List</span></a></span><span> </span><span id="local-6989586621679422700"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422700"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422699"><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679422699"><span class="hs-identifier hs-var">es</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Exp l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#List"><span class="hs-identifier hs-var">List</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422700"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679422699"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-1682"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArray"><span class="hs-identifier hs-type">ParArray</span></a></span><span> </span><span id="local-6989586621679422698"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422698"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422697"><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679422697"><span class="hs-identifier hs-var">es</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Exp l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#ParArray"><span class="hs-identifier hs-var">ParArray</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422698"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679422697"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-1683"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Paren"><span class="hs-identifier hs-type">Paren</span></a></span><span> </span><span id="local-6989586621679422696"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422696"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422695"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422695"><span class="hs-identifier hs-var">e</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Paren"><span class="hs-identifier hs-var">Paren</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422696"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422695"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1684"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LeftSection"><span class="hs-identifier hs-type">LeftSection</span></a></span><span> </span><span id="local-6989586621679422694"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422694"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422693"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422693"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679422692"><span class="annot"><span class="annottext">QOp l
</span><a href="#local-6989586621679422692"><span class="hs-identifier hs-var">qop</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; QOp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#LeftSection"><span class="hs-identifier hs-var">LeftSection</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422694"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422693"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="annot"><span class="annottext">QOp l
</span><a href="#local-6989586621679422692"><span class="hs-identifier hs-var">qop</span></a></span><span>
</span><span id="line-1685"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RightSection"><span class="hs-identifier hs-type">RightSection</span></a></span><span> </span><span id="local-6989586621679422691"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422691"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422690"><span class="annot"><span class="annottext">QOp l
</span><a href="#local-6989586621679422690"><span class="hs-identifier hs-var">qop</span></a></span></span><span> </span><span id="local-6989586621679422689"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422689"><span class="hs-identifier hs-var">e</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QOp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#RightSection"><span class="hs-identifier hs-var">RightSection</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422691"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QOp l
</span><a href="#local-6989586621679422690"><span class="hs-identifier hs-var">qop</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422689"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1686"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecConstr"><span class="hs-identifier hs-type">RecConstr</span></a></span><span> </span><span id="local-6989586621679422688"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422688"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422687"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422687"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621679422686"><span class="annot"><span class="annottext">[FieldUpdate l]
</span><a href="#local-6989586621679422686"><span class="hs-identifier hs-var">fups</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; [FieldUpdate l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#RecConstr"><span class="hs-identifier hs-var">RecConstr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422688"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422687"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="annot"><span class="annottext">[FieldUpdate l]
</span><a href="#local-6989586621679422686"><span class="hs-identifier hs-var">fups</span></a></span><span>
</span><span id="line-1687"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecUpdate"><span class="hs-identifier hs-type">RecUpdate</span></a></span><span> </span><span id="local-6989586621679422685"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422685"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422684"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422684"><span class="hs-identifier hs-var">e</span></a></span></span><span>  </span><span id="local-6989586621679422683"><span class="annot"><span class="annottext">[FieldUpdate l]
</span><a href="#local-6989586621679422683"><span class="hs-identifier hs-var">fups</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; [FieldUpdate l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#RecUpdate"><span class="hs-identifier hs-var">RecUpdate</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422685"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422684"><span class="hs-identifier hs-var">e</span></a></span><span>  </span><span class="annot"><span class="annottext">[FieldUpdate l]
</span><a href="#local-6989586621679422683"><span class="hs-identifier hs-var">fups</span></a></span><span>
</span><span id="line-1688"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFrom"><span class="hs-identifier hs-type">EnumFrom</span></a></span><span> </span><span id="local-6989586621679422682"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422682"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422681"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422681"><span class="hs-identifier hs-var">e</span></a></span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#EnumFrom"><span class="hs-identifier hs-var">EnumFrom</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422682"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422681"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1689"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFromTo"><span class="hs-identifier hs-type">EnumFromTo</span></a></span><span> </span><span id="local-6989586621679422680"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422680"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422679"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422679"><span class="hs-identifier hs-var">ef</span></a></span></span><span> </span><span id="local-6989586621679422678"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422678"><span class="hs-identifier hs-var">et</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#EnumFromTo"><span class="hs-identifier hs-var">EnumFromTo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422680"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422679"><span class="hs-identifier hs-var">ef</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422678"><span class="hs-identifier hs-var">et</span></a></span><span>
</span><span id="line-1690"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFromThen"><span class="hs-identifier hs-type">EnumFromThen</span></a></span><span> </span><span id="local-6989586621679422677"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422677"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422676"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422676"><span class="hs-identifier hs-var">ef</span></a></span></span><span> </span><span id="local-6989586621679422675"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422675"><span class="hs-identifier hs-var">et</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#EnumFromThen"><span class="hs-identifier hs-var">EnumFromThen</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422677"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422676"><span class="hs-identifier hs-var">ef</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422675"><span class="hs-identifier hs-var">et</span></a></span><span>
</span><span id="line-1691"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#EnumFromThenTo"><span class="hs-identifier hs-type">EnumFromThenTo</span></a></span><span> </span><span id="local-6989586621679422674"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422674"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422673"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422673"><span class="hs-identifier hs-var">ef</span></a></span></span><span> </span><span id="local-6989586621679422672"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422672"><span class="hs-identifier hs-var">eth</span></a></span></span><span> </span><span id="local-6989586621679422671"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422671"><span class="hs-identifier hs-var">eto</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#EnumFromThenTo"><span class="hs-identifier hs-var">EnumFromThenTo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422674"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422673"><span class="hs-identifier hs-var">ef</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422672"><span class="hs-identifier hs-var">eth</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422671"><span class="hs-identifier hs-var">eto</span></a></span><span>
</span><span id="line-1692"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArrayFromTo"><span class="hs-identifier hs-type">ParArrayFromTo</span></a></span><span> </span><span id="local-6989586621679422670"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422670"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422669"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422669"><span class="hs-identifier hs-var">ef</span></a></span></span><span> </span><span id="local-6989586621679422668"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422668"><span class="hs-identifier hs-var">et</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#ParArrayFromTo"><span class="hs-identifier hs-var">ParArrayFromTo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422670"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422669"><span class="hs-identifier hs-var">ef</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422668"><span class="hs-identifier hs-var">et</span></a></span><span>
</span><span id="line-1693"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArrayFromThenTo"><span class="hs-identifier hs-type">ParArrayFromThenTo</span></a></span><span> </span><span id="local-6989586621679422667"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422667"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422666"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422666"><span class="hs-identifier hs-var">ef</span></a></span></span><span> </span><span id="local-6989586621679422665"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422665"><span class="hs-identifier hs-var">eth</span></a></span></span><span> </span><span id="local-6989586621679422664"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422664"><span class="hs-identifier hs-var">eto</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#ParArrayFromThenTo"><span class="hs-identifier hs-var">ParArrayFromThenTo</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422667"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422666"><span class="hs-identifier hs-var">ef</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422665"><span class="hs-identifier hs-var">eth</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422664"><span class="hs-identifier hs-var">eto</span></a></span><span>
</span><span id="line-1694"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ListComp"><span class="hs-identifier hs-type">ListComp</span></a></span><span> </span><span id="local-6989586621679422663"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422663"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422662"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422662"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679422661"><span class="annot"><span class="annottext">[QualStmt l]
</span><a href="#local-6989586621679422661"><span class="hs-identifier hs-var">qss</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; [QualStmt l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#ListComp"><span class="hs-identifier hs-var">ListComp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422663"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422662"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="annot"><span class="annottext">[QualStmt l]
</span><a href="#local-6989586621679422661"><span class="hs-identifier hs-var">qss</span></a></span><span>
</span><span id="line-1695"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParComp"><span class="hs-identifier hs-type">ParComp</span></a></span><span>  </span><span id="local-6989586621679422660"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422660"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422659"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422659"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679422658"><span class="annot"><span class="annottext">[[QualStmt l]]
</span><a href="#local-6989586621679422658"><span class="hs-identifier hs-var">qsss</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; [[QualStmt l]] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#ParComp"><span class="hs-identifier hs-var">ParComp</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422660"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422659"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="annot"><span class="annottext">[[QualStmt l]]
</span><a href="#local-6989586621679422658"><span class="hs-identifier hs-var">qsss</span></a></span><span>
</span><span id="line-1696"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParArrayComp"><span class="hs-identifier hs-type">ParArrayComp</span></a></span><span>  </span><span id="local-6989586621679422657"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422657"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422656"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422656"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679422655"><span class="annot"><span class="annottext">[[QualStmt l]]
</span><a href="#local-6989586621679422655"><span class="hs-identifier hs-var">qsss</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; [[QualStmt l]] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#ParArrayComp"><span class="hs-identifier hs-var">ParArrayComp</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422657"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422656"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="annot"><span class="annottext">[[QualStmt l]]
</span><a href="#local-6989586621679422655"><span class="hs-identifier hs-var">qsss</span></a></span><span>
</span><span id="line-1697"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExpTypeSig"><span class="hs-identifier hs-type">ExpTypeSig</span></a></span><span> </span><span id="local-6989586621679422654"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422654"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422653"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422653"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679422652"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422652"><span class="hs-identifier hs-var">t</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Type l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#ExpTypeSig"><span class="hs-identifier hs-var">ExpTypeSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422654"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422653"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422652"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1698"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#VarQuote"><span class="hs-identifier hs-type">VarQuote</span></a></span><span> </span><span id="local-6989586621679422651"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422651"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422650"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422650"><span class="hs-identifier hs-var">qn</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#VarQuote"><span class="hs-identifier hs-var">VarQuote</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422651"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422650"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1699"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypQuote"><span class="hs-identifier hs-type">TypQuote</span></a></span><span> </span><span id="local-6989586621679422649"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422649"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422648"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422648"><span class="hs-identifier hs-var">qn</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#TypQuote"><span class="hs-identifier hs-var">TypQuote</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422649"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422648"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1700"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#BracketExp"><span class="hs-identifier hs-type">BracketExp</span></a></span><span> </span><span id="local-6989586621679422647"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422647"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422646"><span class="annot"><span class="annottext">Bracket l
</span><a href="#local-6989586621679422646"><span class="hs-identifier hs-var">br</span></a></span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Bracket l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#BracketExp"><span class="hs-identifier hs-var">BracketExp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422647"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bracket l
</span><a href="#local-6989586621679422646"><span class="hs-identifier hs-var">br</span></a></span><span>
</span><span id="line-1701"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SpliceExp"><span class="hs-identifier hs-type">SpliceExp</span></a></span><span> </span><span id="local-6989586621679422645"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422645"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422644"><span class="annot"><span class="annottext">Splice l
</span><a href="#local-6989586621679422644"><span class="hs-identifier hs-var">sp</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Splice l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#SpliceExp"><span class="hs-identifier hs-var">SpliceExp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422645"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Splice l
</span><a href="#local-6989586621679422644"><span class="hs-identifier hs-var">sp</span></a></span><span>
</span><span id="line-1702"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QuasiQuote"><span class="hs-identifier hs-type">QuasiQuote</span></a></span><span> </span><span id="local-6989586621679422643"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422643"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422642"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422642"><span class="hs-identifier hs-var">sn</span></a></span></span><span> </span><span id="local-6989586621679422641"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422641"><span class="hs-identifier hs-var">se</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; String -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#QuasiQuote"><span class="hs-identifier hs-var">QuasiQuote</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422643"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422642"><span class="hs-identifier hs-var">sn</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422641"><span class="hs-identifier hs-var">se</span></a></span><span>
</span><span id="line-1703"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeApp"><span class="hs-identifier hs-type">TypeApp</span></a></span><span> </span><span id="local-6989586621679422640"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422640"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422639"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422639"><span class="hs-identifier hs-var">t</span></a></span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#TypeApp"><span class="hs-identifier hs-var">TypeApp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422640"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422639"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1704"></span><span>
</span><span id="line-1705"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XTag"><span class="hs-identifier hs-type">XTag</span></a></span><span>  </span><span id="local-6989586621679422638"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422638"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422637"><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422637"><span class="hs-identifier hs-var">xn</span></a></span></span><span> </span><span id="local-6989586621679422636"><span class="annot"><span class="annottext">[XAttr l]
</span><a href="#local-6989586621679422636"><span class="hs-identifier hs-var">xas</span></a></span></span><span> </span><span id="local-6989586621679422635"><span class="annot"><span class="annottext">Maybe (Exp l)
</span><a href="#local-6989586621679422635"><span class="hs-identifier hs-var">me</span></a></span></span><span> </span><span id="local-6989586621679422634"><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679422634"><span class="hs-identifier hs-var">es</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l -&gt; XName l -&gt; [XAttr l] -&gt; Maybe (Exp l) -&gt; [Exp l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#XTag"><span class="hs-identifier hs-var">XTag</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422638"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422637"><span class="hs-identifier hs-var">xn</span></a></span><span> </span><span class="annot"><span class="annottext">[XAttr l]
</span><a href="#local-6989586621679422636"><span class="hs-identifier hs-var">xas</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Exp l)
</span><a href="#local-6989586621679422635"><span class="hs-identifier hs-var">me</span></a></span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679422634"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-1706"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XETag"><span class="hs-identifier hs-type">XETag</span></a></span><span> </span><span id="local-6989586621679422633"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422633"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422632"><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422632"><span class="hs-identifier hs-var">xn</span></a></span></span><span> </span><span id="local-6989586621679422631"><span class="annot"><span class="annottext">[XAttr l]
</span><a href="#local-6989586621679422631"><span class="hs-identifier hs-var">xas</span></a></span></span><span> </span><span id="local-6989586621679422630"><span class="annot"><span class="annottext">Maybe (Exp l)
</span><a href="#local-6989586621679422630"><span class="hs-identifier hs-var">me</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; XName l -&gt; [XAttr l] -&gt; Maybe (Exp l) -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#XETag"><span class="hs-identifier hs-var">XETag</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422633"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422632"><span class="hs-identifier hs-var">xn</span></a></span><span> </span><span class="annot"><span class="annottext">[XAttr l]
</span><a href="#local-6989586621679422631"><span class="hs-identifier hs-var">xas</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Exp l)
</span><a href="#local-6989586621679422630"><span class="hs-identifier hs-var">me</span></a></span><span>
</span><span id="line-1707"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XPcdata"><span class="hs-identifier hs-type">XPcdata</span></a></span><span> </span><span id="local-6989586621679422629"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422629"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422628"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422628"><span class="hs-identifier hs-var">s</span></a></span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#XPcdata"><span class="hs-identifier hs-var">XPcdata</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422629"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422628"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1708"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XExpTag"><span class="hs-identifier hs-type">XExpTag</span></a></span><span> </span><span id="local-6989586621679422627"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422627"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422626"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422626"><span class="hs-identifier hs-var">e</span></a></span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#XExpTag"><span class="hs-identifier hs-var">XExpTag</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422627"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422626"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1709"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XChildTag"><span class="hs-identifier hs-type">XChildTag</span></a></span><span> </span><span id="local-6989586621679422625"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422625"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422624"><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679422624"><span class="hs-identifier hs-var">es</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Exp l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#XChildTag"><span class="hs-identifier hs-var">XChildTag</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422625"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Exp l]
</span><a href="#local-6989586621679422624"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-1710"></span><span>
</span><span id="line-1711"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CorePragma"><span class="hs-identifier hs-type">CorePragma</span></a></span><span> </span><span id="local-6989586621679422623"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422623"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422622"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422622"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679422621"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422621"><span class="hs-identifier hs-var">e</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#CorePragma"><span class="hs-identifier hs-var">CorePragma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422623"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422622"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422621"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1712"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#SCCPragma"><span class="hs-identifier hs-type">SCCPragma</span></a></span><span>  </span><span id="local-6989586621679422620"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422620"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422619"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422619"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679422618"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422618"><span class="hs-identifier hs-var">e</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#SCCPragma"><span class="hs-identifier hs-var">SCCPragma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422620"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422619"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422618"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1713"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GenPragma"><span class="hs-identifier hs-type">GenPragma</span></a></span><span>  </span><span id="local-6989586621679422617"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422617"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422616"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422616"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679422615"><span class="annot"><span class="annottext">(Int, Int)
</span><a href="#local-6989586621679422615"><span class="hs-identifier hs-var">n12</span></a></span></span><span> </span><span id="local-6989586621679422614"><span class="annot"><span class="annottext">(Int, Int)
</span><a href="#local-6989586621679422614"><span class="hs-identifier hs-var">n34</span></a></span></span><span> </span><span id="local-6989586621679422613"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422613"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; (Int, Int) -&gt; (Int, Int) -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#GenPragma"><span class="hs-identifier hs-var">GenPragma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422617"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422616"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">(Int, Int)
</span><a href="#local-6989586621679422615"><span class="hs-identifier hs-var">n12</span></a></span><span> </span><span class="annot"><span class="annottext">(Int, Int)
</span><a href="#local-6989586621679422614"><span class="hs-identifier hs-var">n34</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422613"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1714"></span><span>
</span><span id="line-1715"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Proc"><span class="hs-identifier hs-type">Proc</span></a></span><span>            </span><span id="local-6989586621679422612"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422612"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422611"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422611"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679422610"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422610"><span class="hs-identifier hs-var">e</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#Proc"><span class="hs-identifier hs-var">Proc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422612"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422611"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422610"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1716"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LeftArrApp"><span class="hs-identifier hs-type">LeftArrApp</span></a></span><span>      </span><span id="local-6989586621679422609"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422609"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422608"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422608"><span class="hs-identifier hs-var">e1'</span></a></span></span><span> </span><span id="local-6989586621679422607"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422607"><span class="hs-identifier hs-var">e2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#LeftArrApp"><span class="hs-identifier hs-var">LeftArrApp</span></a></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422609"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422608"><span class="hs-identifier hs-var">e1'</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422607"><span class="hs-identifier hs-var">e2</span></a></span><span>
</span><span id="line-1717"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RightArrApp"><span class="hs-identifier hs-type">RightArrApp</span></a></span><span>     </span><span id="local-6989586621679422606"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422606"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422605"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422605"><span class="hs-identifier hs-var">e1'</span></a></span></span><span> </span><span id="local-6989586621679422604"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422604"><span class="hs-identifier hs-var">e2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#RightArrApp"><span class="hs-identifier hs-var">RightArrApp</span></a></span><span>     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422606"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422605"><span class="hs-identifier hs-var">e1'</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422604"><span class="hs-identifier hs-var">e2</span></a></span><span>
</span><span id="line-1718"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LeftArrHighApp"><span class="hs-identifier hs-type">LeftArrHighApp</span></a></span><span>  </span><span id="local-6989586621679422603"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422603"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422602"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422602"><span class="hs-identifier hs-var">e1'</span></a></span></span><span> </span><span id="local-6989586621679422601"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422601"><span class="hs-identifier hs-var">e2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#LeftArrHighApp"><span class="hs-identifier hs-var">LeftArrHighApp</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422603"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422602"><span class="hs-identifier hs-var">e1'</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422601"><span class="hs-identifier hs-var">e2</span></a></span><span>
</span><span id="line-1719"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RightArrHighApp"><span class="hs-identifier hs-type">RightArrHighApp</span></a></span><span> </span><span id="local-6989586621679422600"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422600"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422599"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422599"><span class="hs-identifier hs-var">e1'</span></a></span></span><span> </span><span id="local-6989586621679422598"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422598"><span class="hs-identifier hs-var">e2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#RightArrHighApp"><span class="hs-identifier hs-var">RightArrHighApp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422600"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422599"><span class="hs-identifier hs-var">e1'</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422598"><span class="hs-identifier hs-var">e2</span></a></span><span>
</span><span id="line-1720"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ArrOp"><span class="hs-identifier hs-type">ArrOp</span></a></span><span>           </span><span id="local-6989586621679422597"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422597"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422596"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422596"><span class="hs-identifier hs-var">e</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#ArrOp"><span class="hs-identifier hs-var">ArrOp</span></a></span><span>           </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422597"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422596"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1721"></span><span>
</span><span id="line-1722"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LCase"><span class="hs-identifier hs-type">LCase</span></a></span><span> </span><span id="local-6989586621679422595"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422595"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422594"><span class="annot"><span class="annottext">[Alt l]
</span><a href="#local-6989586621679422594"><span class="hs-identifier hs-var">alts</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Alt l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#LCase"><span class="hs-identifier hs-var">LCase</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422595"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Alt l]
</span><a href="#local-6989586621679422594"><span class="hs-identifier hs-var">alts</span></a></span><span>
</span><span id="line-1723"></span><span>        </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#MultiIf"><span class="hs-identifier hs-type">MultiIf</span></a></span><span> </span><span id="local-6989586621679422593"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422593"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422592"><span class="annot"><span class="annottext">[GuardedRhs l]
</span><a href="#local-6989586621679422592"><span class="hs-identifier hs-var">alts</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [GuardedRhs l] -&gt; Exp l
</span><a href="Language.Haskell.Exts.Syntax.html#MultiIf"><span class="hs-identifier hs-var">MultiIf</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422748"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422593"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[GuardedRhs l]
</span><a href="#local-6989586621679422592"><span class="hs-identifier hs-var">alts</span></a></span><span>
</span><span id="line-1724"></span><span>
</span><span id="line-1725"></span><span>
</span><span id="line-1726"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-type">XName</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1727"></span><span>    </span><span id="local-6989586621679422586"><span class="annot"><span class="annottext">ann :: forall l. XName l -&gt; l
</span><a href="#local-6989586621679422586"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XName"><span class="hs-identifier hs-type">XName</span></a></span><span> </span><span id="local-6989586621679422585"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422585"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422585"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1728"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XDomName"><span class="hs-identifier hs-type">XDomName</span></a></span><span> </span><span id="local-6989586621679422584"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422584"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422584"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1729"></span><span>    </span><span id="local-6989586621679422582"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; XName l -&gt; XName l
</span><a href="#local-6989586621679422582"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1730"></span><span>
</span><span id="line-1731"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XAttr"><span class="hs-identifier hs-type">XAttr</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1732"></span><span>    </span><span id="local-6989586621679422576"><span class="annot"><span class="annottext">ann :: forall l. XAttr l -&gt; l
</span><a href="#local-6989586621679422576"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XAttr"><span class="hs-identifier hs-type">XAttr</span></a></span><span> </span><span id="local-6989586621679422575"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422575"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">XName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422575"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1733"></span><span>    </span><span id="local-6989586621679422574"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; XAttr l -&gt; XAttr l
</span><a href="#local-6989586621679422574"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422573"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422573"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#XAttr"><span class="hs-identifier hs-type">XAttr</span></a></span><span> </span><span id="local-6989586621679422572"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422572"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422571"><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422571"><span class="hs-identifier hs-var">xn</span></a></span></span><span> </span><span id="local-6989586621679422570"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422570"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; XName l -&gt; Exp l -&gt; XAttr l
</span><a href="Language.Haskell.Exts.Syntax.html#XAttr"><span class="hs-identifier hs-var">XAttr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422573"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422572"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422571"><span class="hs-identifier hs-var">xn</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422570"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1734"></span><span>
</span><span id="line-1735"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Bracket"><span class="hs-identifier hs-type">Bracket</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1736"></span><span>    </span><span id="local-6989586621679422564"><span class="annot"><span class="annottext">ann :: forall l. Bracket l -&gt; l
</span><a href="#local-6989586621679422564"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExpBracket"><span class="hs-identifier hs-type">ExpBracket</span></a></span><span> </span><span id="local-6989586621679422563"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422563"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422563"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1737"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TExpBracket"><span class="hs-identifier hs-type">TExpBracket</span></a></span><span> </span><span id="local-6989586621679422562"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422562"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422562"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1738"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatBracket"><span class="hs-identifier hs-type">PatBracket</span></a></span><span> </span><span id="local-6989586621679422561"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422561"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422561"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1739"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeBracket"><span class="hs-identifier hs-type">TypeBracket</span></a></span><span> </span><span id="local-6989586621679422560"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422560"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422560"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1740"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclBracket"><span class="hs-identifier hs-type">DeclBracket</span></a></span><span> </span><span id="local-6989586621679422559"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422559"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Decl l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422559"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1741"></span><span>    </span><span id="local-6989586621679422558"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Bracket l -&gt; Bracket l
</span><a href="#local-6989586621679422558"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422557"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422557"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ExpBracket"><span class="hs-identifier hs-type">ExpBracket</span></a></span><span> </span><span id="local-6989586621679422556"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422556"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422555"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422555"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Bracket l
</span><a href="Language.Haskell.Exts.Syntax.html#ExpBracket"><span class="hs-identifier hs-var">ExpBracket</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422557"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422556"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422555"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1742"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422554"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422554"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TExpBracket"><span class="hs-identifier hs-type">TExpBracket</span></a></span><span> </span><span id="local-6989586621679422553"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422553"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422552"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422552"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Bracket l
</span><a href="Language.Haskell.Exts.Syntax.html#TExpBracket"><span class="hs-identifier hs-var">TExpBracket</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422554"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422553"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422552"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1743"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422551"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422551"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatBracket"><span class="hs-identifier hs-type">PatBracket</span></a></span><span> </span><span id="local-6989586621679422550"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422550"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422549"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422549"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; Bracket l
</span><a href="Language.Haskell.Exts.Syntax.html#PatBracket"><span class="hs-identifier hs-var">PatBracket</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422551"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422550"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422549"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1744"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422548"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422548"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypeBracket"><span class="hs-identifier hs-type">TypeBracket</span></a></span><span> </span><span id="local-6989586621679422547"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422547"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422546"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422546"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Type l -&gt; Bracket l
</span><a href="Language.Haskell.Exts.Syntax.html#TypeBracket"><span class="hs-identifier hs-var">TypeBracket</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422548"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422547"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422546"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1745"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422545"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422545"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeclBracket"><span class="hs-identifier hs-type">DeclBracket</span></a></span><span> </span><span id="local-6989586621679422544"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422544"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422543"><span class="annot"><span class="annottext">[Decl l]
</span><a href="#local-6989586621679422543"><span class="hs-identifier hs-var">ds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Decl l] -&gt; Bracket l
</span><a href="Language.Haskell.Exts.Syntax.html#DeclBracket"><span class="hs-identifier hs-var">DeclBracket</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422545"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422544"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Decl l]
</span><a href="#local-6989586621679422543"><span class="hs-identifier hs-var">ds</span></a></span><span>
</span><span id="line-1746"></span><span>
</span><span id="line-1747"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1748"></span><span>    </span><span id="local-6989586621679422537"><span class="annot"><span class="annottext">ann :: forall l. Splice l -&gt; l
</span><a href="#local-6989586621679422537"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IdSplice"><span class="hs-identifier hs-type">IdSplice</span></a></span><span> </span><span id="local-6989586621679422536"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422536"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422536"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1749"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TIdSplice"><span class="hs-identifier hs-type">TIdSplice</span></a></span><span> </span><span id="local-6989586621679422535"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422535"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422535"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1750"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParenSplice"><span class="hs-identifier hs-type">ParenSplice</span></a></span><span> </span><span id="local-6989586621679422534"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422534"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422534"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1751"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TParenSplice"><span class="hs-identifier hs-type">TParenSplice</span></a></span><span> </span><span id="local-6989586621679422533"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422533"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422533"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1752"></span><span>    </span><span id="local-6989586621679422532"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Splice l -&gt; Splice l
</span><a href="#local-6989586621679422532"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422531"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422531"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#IdSplice"><span class="hs-identifier hs-type">IdSplice</span></a></span><span> </span><span id="local-6989586621679422530"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422530"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422529"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422529"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Splice l
</span><a href="Language.Haskell.Exts.Syntax.html#IdSplice"><span class="hs-identifier hs-var">IdSplice</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422531"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422530"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422529"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1753"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422528"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422528"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TIdSplice"><span class="hs-identifier hs-type">TIdSplice</span></a></span><span> </span><span id="local-6989586621679422527"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422527"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422526"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422526"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Splice l
</span><a href="Language.Haskell.Exts.Syntax.html#TIdSplice"><span class="hs-identifier hs-var">TIdSplice</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422528"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422527"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422526"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1754"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422525"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422525"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ParenSplice"><span class="hs-identifier hs-type">ParenSplice</span></a></span><span> </span><span id="local-6989586621679422524"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422524"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422523"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422523"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Splice l
</span><a href="Language.Haskell.Exts.Syntax.html#ParenSplice"><span class="hs-identifier hs-var">ParenSplice</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422525"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422524"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422523"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1755"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422522"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422522"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TParenSplice"><span class="hs-identifier hs-type">TParenSplice</span></a></span><span> </span><span id="local-6989586621679422521"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422521"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422520"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422520"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Splice l
</span><a href="Language.Haskell.Exts.Syntax.html#TParenSplice"><span class="hs-identifier hs-var">TParenSplice</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422522"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422521"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422520"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1756"></span><span>
</span><span id="line-1757"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Safety"><span class="hs-identifier hs-type">Safety</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1758"></span><span>    </span><span id="local-6989586621679422514"><span class="annot"><span class="annottext">ann :: forall l. Safety l -&gt; l
</span><a href="#local-6989586621679422514"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PlayRisky"><span class="hs-identifier hs-type">PlayRisky</span></a></span><span> </span><span id="local-6989586621679422513"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422513"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422513"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1759"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PlaySafe"><span class="hs-identifier hs-type">PlaySafe</span></a></span><span> </span><span id="local-6989586621679422512"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422512"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422512"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1760"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PlayInterruptible"><span class="hs-identifier hs-type">PlayInterruptible</span></a></span><span> </span><span id="local-6989586621679422511"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422511"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422511"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1761"></span><span>    </span><span id="local-6989586621679422509"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Safety l -&gt; Safety l
</span><a href="#local-6989586621679422509"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1762"></span><span>
</span><span id="line-1763"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CallConv"><span class="hs-identifier hs-type">CallConv</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1764"></span><span>    </span><span id="local-6989586621679422503"><span class="annot"><span class="annottext">ann :: forall l. CallConv l -&gt; l
</span><a href="#local-6989586621679422503"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#StdCall"><span class="hs-identifier hs-type">StdCall</span></a></span><span> </span><span id="local-6989586621679422502"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422502"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422502"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1765"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CCall"><span class="hs-identifier hs-type">CCall</span></a></span><span> </span><span id="local-6989586621679422501"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422501"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422501"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1766"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CPlusPlus"><span class="hs-identifier hs-type">CPlusPlus</span></a></span><span> </span><span id="local-6989586621679422500"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422500"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422500"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1767"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DotNet"><span class="hs-identifier hs-type">DotNet</span></a></span><span> </span><span id="local-6989586621679422499"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422499"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422499"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1768"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Jvm"><span class="hs-identifier hs-type">Jvm</span></a></span><span> </span><span id="local-6989586621679422498"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422498"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422498"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1769"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Js"><span class="hs-identifier hs-type">Js</span></a></span><span> </span><span id="local-6989586621679422497"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422497"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422497"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1770"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#JavaScript"><span class="hs-identifier hs-type">JavaScript</span></a></span><span> </span><span id="local-6989586621679422496"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422496"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422496"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1771"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#CApi"><span class="hs-identifier hs-type">CApi</span></a></span><span> </span><span id="local-6989586621679422495"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422495"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422495"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1772"></span><span>    </span><span id="local-6989586621679422493"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; CallConv l -&gt; CallConv l
</span><a href="#local-6989586621679422493"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1773"></span><span>
</span><span id="line-1774"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ModulePragma"><span class="hs-identifier hs-type">ModulePragma</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1775"></span><span>    </span><span id="local-6989586621679422487"><span class="annot"><span class="annottext">ann :: forall l. ModulePragma l -&gt; l
</span><a href="#local-6989586621679422487"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LanguagePragma"><span class="hs-identifier hs-type">LanguagePragma</span></a></span><span>   </span><span id="local-6989586621679422486"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422486"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422486"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1776"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#OptionsPragma"><span class="hs-identifier hs-type">OptionsPragma</span></a></span><span>    </span><span id="local-6989586621679422485"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422485"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe Tool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422485"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1777"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AnnModulePragma"><span class="hs-identifier hs-type">AnnModulePragma</span></a></span><span>  </span><span id="local-6989586621679422484"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422484"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Annotation l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422484"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1778"></span><span>    </span><span id="local-6989586621679422482"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; ModulePragma l -&gt; ModulePragma l
</span><a href="#local-6989586621679422482"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422481"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422481"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LanguagePragma"><span class="hs-identifier hs-type">LanguagePragma</span></a></span><span>   </span><span id="local-6989586621679422480"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422480"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422479"><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679422479"><span class="hs-identifier hs-var">ns</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Name l] -&gt; ModulePragma l
</span><a href="Language.Haskell.Exts.Syntax.html#LanguagePragma"><span class="hs-identifier hs-var">LanguagePragma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422481"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422480"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Name l]
</span><a href="#local-6989586621679422479"><span class="hs-identifier hs-var">ns</span></a></span><span>
</span><span id="line-1779"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422478"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422478"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#AnnModulePragma"><span class="hs-identifier hs-type">AnnModulePragma</span></a></span><span>  </span><span id="local-6989586621679422477"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422477"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422476"><span class="annot"><span class="annottext">Annotation l
</span><a href="#local-6989586621679422476"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Annotation l -&gt; ModulePragma l
</span><a href="Language.Haskell.Exts.Syntax.html#AnnModulePragma"><span class="hs-identifier hs-var">AnnModulePragma</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422478"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422477"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Annotation l
</span><a href="#local-6989586621679422476"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-1780"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422475"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422475"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679422474"><span class="annot"><span class="annottext">ModulePragma l
</span><a href="#local-6989586621679422474"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422475"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">ModulePragma l
</span><a href="#local-6989586621679422474"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1781"></span><span>
</span><span id="line-1782"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlap"><span class="hs-identifier hs-type">Overlap</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1783"></span><span>    </span><span id="local-6989586621679422468"><span class="annot"><span class="annottext">ann :: forall l. Overlap l -&gt; l
</span><a href="#local-6989586621679422468"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#NoOverlap"><span class="hs-identifier hs-type">NoOverlap</span></a></span><span> </span><span id="local-6989586621679422467"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422467"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422467"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1784"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlap"><span class="hs-identifier hs-type">Overlap</span></a></span><span> </span><span id="local-6989586621679422466"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422466"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422466"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1785"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlaps"><span class="hs-identifier hs-type">Overlaps</span></a></span><span> </span><span id="local-6989586621679422465"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422465"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422465"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1786"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlappable"><span class="hs-identifier hs-type">Overlappable</span></a></span><span> </span><span id="local-6989586621679422464"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422464"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422464"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1787"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Overlapping"><span class="hs-identifier hs-type">Overlapping</span></a></span><span> </span><span id="local-6989586621679422463"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422463"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422463"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1788"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Incoherent"><span class="hs-identifier hs-type">Incoherent</span></a></span><span> </span><span id="local-6989586621679422462"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422462"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422462"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1789"></span><span>    </span><span id="local-6989586621679422460"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Overlap l -&gt; Overlap l
</span><a href="#local-6989586621679422460"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1790"></span><span>
</span><span id="line-1791"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Activation"><span class="hs-identifier hs-type">Activation</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1792"></span><span>    </span><span id="local-6989586621679422454"><span class="annot"><span class="annottext">ann :: forall l. Activation l -&gt; l
</span><a href="#local-6989586621679422454"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ActiveFrom"><span class="hs-identifier hs-type">ActiveFrom</span></a></span><span>   </span><span id="local-6989586621679422453"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422453"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422453"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1793"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ActiveUntil"><span class="hs-identifier hs-type">ActiveUntil</span></a></span><span>  </span><span id="local-6989586621679422452"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422452"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422452"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1794"></span><span>    </span><span id="local-6989586621679422450"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Activation l -&gt; Activation l
</span><a href="#local-6989586621679422450"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1795"></span><span>
</span><span id="line-1796"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rule"><span class="hs-identifier hs-type">Rule</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1797"></span><span>    </span><span id="local-6989586621679422444"><span class="annot"><span class="annottext">ann :: forall l. Rule l -&gt; l
</span><a href="#local-6989586621679422444"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rule"><span class="hs-identifier hs-type">Rule</span></a></span><span> </span><span id="local-6989586621679422443"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422443"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Activation l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe [RuleVar l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422443"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1798"></span><span>    </span><span id="local-6989586621679422442"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Rule l -&gt; Rule l
</span><a href="#local-6989586621679422442"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422441"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422441"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Rule"><span class="hs-identifier hs-type">Rule</span></a></span><span> </span><span id="local-6989586621679422440"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422440"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422439"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422439"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679422438"><span class="annot"><span class="annottext">Maybe (Activation l)
</span><a href="#local-6989586621679422438"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span id="local-6989586621679422437"><span class="annot"><span class="annottext">Maybe [RuleVar l]
</span><a href="#local-6989586621679422437"><span class="hs-identifier hs-var">mrvs</span></a></span></span><span> </span><span id="local-6989586621679422436"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422436"><span class="hs-identifier hs-var">e1</span></a></span></span><span> </span><span id="local-6989586621679422435"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422435"><span class="hs-identifier hs-var">e2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l.
l
-&gt; String
-&gt; Maybe (Activation l)
-&gt; Maybe [RuleVar l]
-&gt; Exp l
-&gt; Exp l
-&gt; Rule l
</span><a href="Language.Haskell.Exts.Syntax.html#Rule"><span class="hs-identifier hs-var">Rule</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422441"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422440"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422439"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Activation l)
</span><a href="#local-6989586621679422438"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [RuleVar l]
</span><a href="#local-6989586621679422437"><span class="hs-identifier hs-var">mrvs</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422436"><span class="hs-identifier hs-var">e1</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422435"><span class="hs-identifier hs-var">e2</span></a></span><span>
</span><span id="line-1799"></span><span>
</span><span id="line-1800"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RuleVar"><span class="hs-identifier hs-type">RuleVar</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1801"></span><span>    </span><span id="local-6989586621679422429"><span class="annot"><span class="annottext">ann :: forall l. RuleVar l -&gt; l
</span><a href="#local-6989586621679422429"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RuleVar"><span class="hs-identifier hs-type">RuleVar</span></a></span><span> </span><span id="local-6989586621679422428"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422428"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422428"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1802"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypedRuleVar"><span class="hs-identifier hs-type">TypedRuleVar</span></a></span><span> </span><span id="local-6989586621679422427"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422427"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422427"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1803"></span><span>    </span><span id="local-6989586621679422426"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; RuleVar l -&gt; RuleVar l
</span><a href="#local-6989586621679422426"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422425"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422425"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RuleVar"><span class="hs-identifier hs-type">RuleVar</span></a></span><span> </span><span id="local-6989586621679422424"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422424"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422423"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422423"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; RuleVar l
</span><a href="Language.Haskell.Exts.Syntax.html#RuleVar"><span class="hs-identifier hs-var">RuleVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422425"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422424"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422423"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1804"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422422"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422422"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#TypedRuleVar"><span class="hs-identifier hs-type">TypedRuleVar</span></a></span><span> </span><span id="local-6989586621679422421"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422421"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422420"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422420"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679422419"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422419"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; Type l -&gt; RuleVar l
</span><a href="Language.Haskell.Exts.Syntax.html#TypedRuleVar"><span class="hs-identifier hs-var">TypedRuleVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422422"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422421"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422420"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422419"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1805"></span><span>
</span><span id="line-1806"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#WarningText"><span class="hs-identifier hs-type">WarningText</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1807"></span><span>    </span><span id="local-6989586621679422413"><span class="annot"><span class="annottext">ann :: forall l. WarningText l -&gt; l
</span><a href="#local-6989586621679422413"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#DeprText"><span class="hs-identifier hs-type">DeprText</span></a></span><span> </span><span id="local-6989586621679422412"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422412"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422412"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1808"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#WarnText"><span class="hs-identifier hs-type">WarnText</span></a></span><span> </span><span id="local-6989586621679422411"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422411"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422411"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1809"></span><span>    </span><span id="local-6989586621679422409"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; WarningText l -&gt; WarningText l
</span><a href="#local-6989586621679422409"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1810"></span><span>
</span><span id="line-1811"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1812"></span><span>    </span><span id="local-6989586621679422403"><span class="annot"><span class="annottext">ann :: forall l. Pat l -&gt; l
</span><a href="#local-6989586621679422403"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679422402"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422402"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422402"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1813"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621679422401"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422401"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422401"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1814"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PLit"><span class="hs-identifier hs-type">PLit</span></a></span><span> </span><span id="local-6989586621679422400"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422400"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Sign l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Literal l
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422400"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1815"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PNPlusK"><span class="hs-identifier hs-type">PNPlusK</span></a></span><span> </span><span id="local-6989586621679422399"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422399"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-identifier">_</span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422399"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1816"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PInfixApp"><span class="hs-identifier hs-type">PInfixApp</span></a></span><span> </span><span id="local-6989586621679422398"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422398"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422398"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1817"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PApp"><span class="hs-identifier hs-type">PApp</span></a></span><span> </span><span id="local-6989586621679422397"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422397"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422397"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1818"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PTuple"><span class="hs-identifier hs-type">PTuple</span></a></span><span> </span><span id="local-6989586621679422396"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422396"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxed
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422396"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1819"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PUnboxedSum"><span class="hs-identifier hs-type">PUnboxedSum</span></a></span><span> </span><span id="local-6989586621679422395"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422395"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422395"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1820"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PList"><span class="hs-identifier hs-type">PList</span></a></span><span> </span><span id="local-6989586621679422394"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422394"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422394"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1821"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PParen"><span class="hs-identifier hs-type">PParen</span></a></span><span> </span><span id="local-6989586621679422393"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422393"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422393"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1822"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PRec"><span class="hs-identifier hs-type">PRec</span></a></span><span> </span><span id="local-6989586621679422392"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422392"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[PatField l]
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422392"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1823"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PAsPat"><span class="hs-identifier hs-type">PAsPat</span></a></span><span> </span><span id="local-6989586621679422391"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422391"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422391"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1824"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PWildCard"><span class="hs-identifier hs-type">PWildCard</span></a></span><span> </span><span id="local-6989586621679422390"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422390"><span class="hs-identifier hs-var">l</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422390"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1825"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PIrrPat"><span class="hs-identifier hs-type">PIrrPat</span></a></span><span> </span><span id="local-6989586621679422389"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422389"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422389"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1826"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatTypeSig"><span class="hs-identifier hs-type">PatTypeSig</span></a></span><span> </span><span id="local-6989586621679422388"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422388"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type l
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422388"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1827"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PViewPat"><span class="hs-identifier hs-type">PViewPat</span></a></span><span> </span><span id="local-6989586621679422387"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422387"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422387"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1828"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PRPat"><span class="hs-identifier hs-type">PRPat</span></a></span><span> </span><span id="local-6989586621679422386"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422386"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[RPat l]
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422386"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1829"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXTag"><span class="hs-identifier hs-type">PXTag</span></a></span><span> </span><span id="local-6989586621679422385"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422385"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">XName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[PXAttr l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Pat l)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422385"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1830"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXETag"><span class="hs-identifier hs-type">PXETag</span></a></span><span> </span><span id="local-6989586621679422384"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422384"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">XName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[PXAttr l]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Pat l)
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422384"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1831"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXPcdata"><span class="hs-identifier hs-type">PXPcdata</span></a></span><span> </span><span id="local-6989586621679422383"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422383"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422383"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1832"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXPatTag"><span class="hs-identifier hs-type">PXPatTag</span></a></span><span> </span><span id="local-6989586621679422382"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422382"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422382"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1833"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXRPats"><span class="hs-identifier hs-type">PXRPats</span></a></span><span>  </span><span id="local-6989586621679422381"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422381"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[RPat l]
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422381"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1834"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PSplice"><span class="hs-identifier hs-type">PSplice</span></a></span><span> </span><span id="local-6989586621679422380"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422380"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Splice l
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422380"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1835"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PQuasiQuote"><span class="hs-identifier hs-type">PQuasiQuote</span></a></span><span> </span><span id="local-6989586621679422379"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422379"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422379"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1836"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PBangPat"><span class="hs-identifier hs-type">PBangPat</span></a></span><span> </span><span id="local-6989586621679422378"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422378"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422378"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1837"></span><span>    </span><span id="local-6989586621679422377"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Pat l -&gt; Pat l
</span><a href="#local-6989586621679422377"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422376"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679422375"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422375"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422375"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1838"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PVar"><span class="hs-identifier hs-type">PVar</span></a></span><span> </span><span id="local-6989586621679422374"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422374"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422373"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422373"><span class="hs-identifier hs-var">n</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PVar"><span class="hs-identifier hs-var">PVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422374"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422373"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1839"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PLit"><span class="hs-identifier hs-type">PLit</span></a></span><span> </span><span id="local-6989586621679422372"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422372"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422371"><span class="annot"><span class="annottext">Sign l
</span><a href="#local-6989586621679422371"><span class="hs-identifier hs-var">sg</span></a></span></span><span> </span><span id="local-6989586621679422370"><span class="annot"><span class="annottext">Literal l
</span><a href="#local-6989586621679422370"><span class="hs-identifier hs-var">lit</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Sign l -&gt; Literal l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PLit"><span class="hs-identifier hs-var">PLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422372"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Sign l
</span><a href="#local-6989586621679422371"><span class="hs-identifier hs-var">sg</span></a></span><span> </span><span class="annot"><span class="annottext">Literal l
</span><a href="#local-6989586621679422370"><span class="hs-identifier hs-var">lit</span></a></span><span>
</span><span id="line-1840"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PNPlusK"><span class="hs-identifier hs-type">PNPlusK</span></a></span><span> </span><span id="local-6989586621679422369"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422369"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422368"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422368"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679422367"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679422367"><span class="hs-identifier hs-var">k</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; Integer -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PNPlusK"><span class="hs-identifier hs-var">PNPlusK</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422369"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422368"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679422367"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1841"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PInfixApp"><span class="hs-identifier hs-type">PInfixApp</span></a></span><span> </span><span id="local-6989586621679422366"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422366"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422365"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422365"><span class="hs-identifier hs-var">pa</span></a></span></span><span> </span><span id="local-6989586621679422364"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422364"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621679422363"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422363"><span class="hs-identifier hs-var">pb</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; QName l -&gt; Pat l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PInfixApp"><span class="hs-identifier hs-var">PInfixApp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422366"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422365"><span class="hs-identifier hs-var">pa</span></a></span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422364"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422363"><span class="hs-identifier hs-var">pb</span></a></span><span>
</span><span id="line-1842"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PApp"><span class="hs-identifier hs-type">PApp</span></a></span><span> </span><span id="local-6989586621679422362"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422362"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422361"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422361"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621679422360"><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679422360"><span class="hs-identifier hs-var">ps</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; [Pat l] -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PApp"><span class="hs-identifier hs-var">PApp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422362"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422361"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679422360"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-1843"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PTuple"><span class="hs-identifier hs-type">PTuple</span></a></span><span> </span><span id="local-6989586621679422359"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422359"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422358"><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679422358"><span class="hs-identifier hs-var">bx</span></a></span></span><span> </span><span id="local-6989586621679422357"><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679422357"><span class="hs-identifier hs-var">ps</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Boxed -&gt; [Pat l] -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PTuple"><span class="hs-identifier hs-var">PTuple</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422359"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Boxed
</span><a href="#local-6989586621679422358"><span class="hs-identifier hs-var">bx</span></a></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679422357"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-1844"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PUnboxedSum"><span class="hs-identifier hs-type">PUnboxedSum</span></a></span><span> </span><span id="local-6989586621679422356"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422356"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422355"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679422355"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679422354"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679422354"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679422353"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422353"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Int -&gt; Int -&gt; Pat l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PUnboxedSum"><span class="hs-identifier hs-var">PUnboxedSum</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422356"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679422355"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679422354"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422353"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-1845"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PList"><span class="hs-identifier hs-type">PList</span></a></span><span> </span><span id="local-6989586621679422352"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422352"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422351"><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679422351"><span class="hs-identifier hs-var">ps</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Pat l] -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PList"><span class="hs-identifier hs-var">PList</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422352"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679422351"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-1846"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PParen"><span class="hs-identifier hs-type">PParen</span></a></span><span> </span><span id="local-6989586621679422350"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422350"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422349"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422349"><span class="hs-identifier hs-var">p</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PParen"><span class="hs-identifier hs-var">PParen</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422350"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422349"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1847"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PRec"><span class="hs-identifier hs-type">PRec</span></a></span><span> </span><span id="local-6989586621679422348"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422348"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422347"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422347"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621679422346"><span class="annot"><span class="annottext">[PatField l]
</span><a href="#local-6989586621679422346"><span class="hs-identifier hs-var">pfs</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; [PatField l] -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PRec"><span class="hs-identifier hs-var">PRec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422348"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422347"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="annot"><span class="annottext">[PatField l]
</span><a href="#local-6989586621679422346"><span class="hs-identifier hs-var">pfs</span></a></span><span>
</span><span id="line-1848"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PAsPat"><span class="hs-identifier hs-type">PAsPat</span></a></span><span> </span><span id="local-6989586621679422345"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422345"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422344"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422344"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679422343"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422343"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; Pat l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PAsPat"><span class="hs-identifier hs-var">PAsPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422345"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422344"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422343"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1849"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PWildCard"><span class="hs-identifier hs-type">PWildCard</span></a></span><span> </span><span id="local-6989586621679422342"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422342"><span class="hs-identifier hs-var">l</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PWildCard"><span class="hs-identifier hs-var">PWildCard</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422342"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1850"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PIrrPat"><span class="hs-identifier hs-type">PIrrPat</span></a></span><span> </span><span id="local-6989586621679422341"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422341"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422340"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422340"><span class="hs-identifier hs-var">p</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PIrrPat"><span class="hs-identifier hs-var">PIrrPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422341"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422340"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1851"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatTypeSig"><span class="hs-identifier hs-type">PatTypeSig</span></a></span><span> </span><span id="local-6989586621679422339"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422339"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422338"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422338"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679422337"><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422337"><span class="hs-identifier hs-var">t</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; Type l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PatTypeSig"><span class="hs-identifier hs-var">PatTypeSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422339"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422338"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Type l
</span><a href="#local-6989586621679422337"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1852"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PViewPat"><span class="hs-identifier hs-type">PViewPat</span></a></span><span> </span><span id="local-6989586621679422336"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422336"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422335"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422335"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679422334"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422334"><span class="hs-identifier hs-var">p</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Pat l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PViewPat"><span class="hs-identifier hs-var">PViewPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422336"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422335"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422334"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1853"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PRPat"><span class="hs-identifier hs-type">PRPat</span></a></span><span> </span><span id="local-6989586621679422333"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422333"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422332"><span class="annot"><span class="annottext">[RPat l]
</span><a href="#local-6989586621679422332"><span class="hs-identifier hs-var">rps</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [RPat l] -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PRPat"><span class="hs-identifier hs-var">PRPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422333"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[RPat l]
</span><a href="#local-6989586621679422332"><span class="hs-identifier hs-var">rps</span></a></span><span>
</span><span id="line-1854"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXTag"><span class="hs-identifier hs-type">PXTag</span></a></span><span> </span><span id="local-6989586621679422331"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422331"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422330"><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422330"><span class="hs-identifier hs-var">xn</span></a></span></span><span> </span><span id="local-6989586621679422329"><span class="annot"><span class="annottext">[PXAttr l]
</span><a href="#local-6989586621679422329"><span class="hs-identifier hs-var">pxas</span></a></span></span><span> </span><span id="local-6989586621679422328"><span class="annot"><span class="annottext">Maybe (Pat l)
</span><a href="#local-6989586621679422328"><span class="hs-identifier hs-var">mp</span></a></span></span><span> </span><span id="local-6989586621679422327"><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679422327"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l.
l -&gt; XName l -&gt; [PXAttr l] -&gt; Maybe (Pat l) -&gt; [Pat l] -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PXTag"><span class="hs-identifier hs-var">PXTag</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422331"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422330"><span class="hs-identifier hs-var">xn</span></a></span><span> </span><span class="annot"><span class="annottext">[PXAttr l]
</span><a href="#local-6989586621679422329"><span class="hs-identifier hs-var">pxas</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Pat l)
</span><a href="#local-6989586621679422328"><span class="hs-identifier hs-var">mp</span></a></span><span> </span><span class="annot"><span class="annottext">[Pat l]
</span><a href="#local-6989586621679422327"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-1855"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXETag"><span class="hs-identifier hs-type">PXETag</span></a></span><span> </span><span id="local-6989586621679422326"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422326"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422325"><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422325"><span class="hs-identifier hs-var">xn</span></a></span></span><span> </span><span id="local-6989586621679422324"><span class="annot"><span class="annottext">[PXAttr l]
</span><a href="#local-6989586621679422324"><span class="hs-identifier hs-var">pxas</span></a></span></span><span> </span><span id="local-6989586621679422323"><span class="annot"><span class="annottext">Maybe (Pat l)
</span><a href="#local-6989586621679422323"><span class="hs-identifier hs-var">mp</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; XName l -&gt; [PXAttr l] -&gt; Maybe (Pat l) -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PXETag"><span class="hs-identifier hs-var">PXETag</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422326"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422325"><span class="hs-identifier hs-var">xn</span></a></span><span> </span><span class="annot"><span class="annottext">[PXAttr l]
</span><a href="#local-6989586621679422324"><span class="hs-identifier hs-var">pxas</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Pat l)
</span><a href="#local-6989586621679422323"><span class="hs-identifier hs-var">mp</span></a></span><span>
</span><span id="line-1856"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXPcdata"><span class="hs-identifier hs-type">PXPcdata</span></a></span><span> </span><span id="local-6989586621679422322"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422322"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422321"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422321"><span class="hs-identifier hs-var">s</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PXPcdata"><span class="hs-identifier hs-var">PXPcdata</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422322"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422321"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1857"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXPatTag"><span class="hs-identifier hs-type">PXPatTag</span></a></span><span> </span><span id="local-6989586621679422320"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422320"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422319"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422319"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PXPatTag"><span class="hs-identifier hs-var">PXPatTag</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422320"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422319"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1858"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXRPats"><span class="hs-identifier hs-type">PXRPats</span></a></span><span>  </span><span id="local-6989586621679422318"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422318"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422317"><span class="annot"><span class="annottext">[RPat l]
</span><a href="#local-6989586621679422317"><span class="hs-identifier hs-var">rps</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [RPat l] -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PXRPats"><span class="hs-identifier hs-var">PXRPats</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422318"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[RPat l]
</span><a href="#local-6989586621679422317"><span class="hs-identifier hs-var">rps</span></a></span><span>
</span><span id="line-1859"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PSplice"><span class="hs-identifier hs-type">PSplice</span></a></span><span> </span><span id="local-6989586621679422316"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422316"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422315"><span class="annot"><span class="annottext">Splice l
</span><a href="#local-6989586621679422315"><span class="hs-identifier hs-var">sp</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Splice l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PSplice"><span class="hs-identifier hs-var">PSplice</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422316"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Splice l
</span><a href="#local-6989586621679422315"><span class="hs-identifier hs-var">sp</span></a></span><span>
</span><span id="line-1860"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PQuasiQuote"><span class="hs-identifier hs-type">PQuasiQuote</span></a></span><span> </span><span id="local-6989586621679422314"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422314"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422313"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422313"><span class="hs-identifier hs-var">sn</span></a></span></span><span> </span><span id="local-6989586621679422312"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422312"><span class="hs-identifier hs-var">st</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; String -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PQuasiQuote"><span class="hs-identifier hs-var">PQuasiQuote</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422314"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422313"><span class="hs-identifier hs-var">sn</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422312"><span class="hs-identifier hs-var">st</span></a></span><span>
</span><span id="line-1861"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PBangPat"><span class="hs-identifier hs-type">PBangPat</span></a></span><span> </span><span id="local-6989586621679422311"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422311"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422310"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422310"><span class="hs-identifier hs-var">p</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; Pat l
</span><a href="Language.Haskell.Exts.Syntax.html#PBangPat"><span class="hs-identifier hs-var">PBangPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422376"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422311"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422310"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1862"></span><span>
</span><span id="line-1863"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXAttr"><span class="hs-identifier hs-type">PXAttr</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1864"></span><span>    </span><span id="local-6989586621679422304"><span class="annot"><span class="annottext">ann :: forall l. PXAttr l -&gt; l
</span><a href="#local-6989586621679422304"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXAttr"><span class="hs-identifier hs-type">PXAttr</span></a></span><span> </span><span id="local-6989586621679422303"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422303"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">XName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422303"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1865"></span><span>    </span><span id="local-6989586621679422302"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; PXAttr l -&gt; PXAttr l
</span><a href="#local-6989586621679422302"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422301"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422301"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PXAttr"><span class="hs-identifier hs-type">PXAttr</span></a></span><span> </span><span id="local-6989586621679422300"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422300"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422299"><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422299"><span class="hs-identifier hs-var">xn</span></a></span></span><span> </span><span id="local-6989586621679422298"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422298"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; XName l -&gt; Pat l -&gt; PXAttr l
</span><a href="Language.Haskell.Exts.Syntax.html#PXAttr"><span class="hs-identifier hs-var">PXAttr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422301"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422300"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">XName l
</span><a href="#local-6989586621679422299"><span class="hs-identifier hs-var">xn</span></a></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422298"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1866"></span><span>
</span><span id="line-1867"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPatOp"><span class="hs-identifier hs-type">RPatOp</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1868"></span><span>    </span><span id="local-6989586621679422292"><span class="annot"><span class="annottext">ann :: forall l. RPatOp l -&gt; l
</span><a href="#local-6989586621679422292"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPStar"><span class="hs-identifier hs-type">RPStar</span></a></span><span>  </span><span id="local-6989586621679422291"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422291"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422291"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1869"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPStarG"><span class="hs-identifier hs-type">RPStarG</span></a></span><span> </span><span id="local-6989586621679422290"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422290"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422290"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1870"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPPlus"><span class="hs-identifier hs-type">RPPlus</span></a></span><span>  </span><span id="local-6989586621679422289"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422289"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422289"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1871"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPPlusG"><span class="hs-identifier hs-type">RPPlusG</span></a></span><span> </span><span id="local-6989586621679422288"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422288"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422288"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1872"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPOpt"><span class="hs-identifier hs-type">RPOpt</span></a></span><span>   </span><span id="local-6989586621679422287"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422287"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422287"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1873"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPOptG"><span class="hs-identifier hs-type">RPOptG</span></a></span><span>  </span><span id="local-6989586621679422286"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422286"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422286"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1874"></span><span>    </span><span id="local-6989586621679422284"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; RPatOp l -&gt; RPatOp l
</span><a href="#local-6989586621679422284"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span>
</span><span id="line-1875"></span><span>
</span><span id="line-1876"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPat"><span class="hs-identifier hs-type">RPat</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1877"></span><span>    </span><span id="local-6989586621679422278"><span class="annot"><span class="annottext">ann :: forall l. RPat l -&gt; l
</span><a href="#local-6989586621679422278"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span id="local-6989586621679422277"><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422277"><span class="hs-identifier hs-var">rp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422277"><span class="hs-identifier hs-var">rp</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1878"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPOp"><span class="hs-identifier hs-type">RPOp</span></a></span><span> </span><span id="local-6989586621679422276"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422276"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">RPat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">RPatOp l
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422276"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1879"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPEither"><span class="hs-identifier hs-type">RPEither</span></a></span><span> </span><span id="local-6989586621679422275"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422275"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">RPat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">RPat l
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422275"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1880"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPSeq"><span class="hs-identifier hs-type">RPSeq</span></a></span><span> </span><span id="local-6989586621679422274"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422274"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[RPat l]
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422274"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1881"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPGuard"><span class="hs-identifier hs-type">RPGuard</span></a></span><span> </span><span id="local-6989586621679422273"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422273"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Stmt l]
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422273"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1882"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPCAs"><span class="hs-identifier hs-type">RPCAs</span></a></span><span> </span><span id="local-6989586621679422272"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422272"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">RPat l
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422272"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1883"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPAs"><span class="hs-identifier hs-type">RPAs</span></a></span><span> </span><span id="local-6989586621679422271"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422271"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Name l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">RPat l
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422271"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1884"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPParen"><span class="hs-identifier hs-type">RPParen</span></a></span><span> </span><span id="local-6989586621679422270"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422270"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">RPat l
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422270"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1885"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPPat"><span class="hs-identifier hs-type">RPPat</span></a></span><span> </span><span id="local-6989586621679422269"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422269"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422269"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1886"></span><span>    </span><span id="local-6989586621679422268"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; RPat l -&gt; RPat l
</span><a href="#local-6989586621679422268"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422267"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422267"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679422266"><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422266"><span class="hs-identifier hs-var">rp1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422266"><span class="hs-identifier hs-var">rp1</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1887"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPOp"><span class="hs-identifier hs-type">RPOp</span></a></span><span> </span><span id="local-6989586621679422265"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422265"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422264"><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422264"><span class="hs-identifier hs-var">rp</span></a></span></span><span> </span><span id="local-6989586621679422263"><span class="annot"><span class="annottext">RPatOp l
</span><a href="#local-6989586621679422263"><span class="hs-identifier hs-var">rop</span></a></span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; RPat l -&gt; RPatOp l -&gt; RPat l
</span><a href="Language.Haskell.Exts.Syntax.html#RPOp"><span class="hs-identifier hs-var">RPOp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422267"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422265"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422264"><span class="hs-identifier hs-var">rp</span></a></span><span> </span><span class="annot"><span class="annottext">RPatOp l
</span><a href="#local-6989586621679422263"><span class="hs-identifier hs-var">rop</span></a></span><span>
</span><span id="line-1888"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPEither"><span class="hs-identifier hs-type">RPEither</span></a></span><span> </span><span id="local-6989586621679422262"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422262"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422261"><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422261"><span class="hs-identifier hs-var">rp1'</span></a></span></span><span> </span><span id="local-6989586621679422260"><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422260"><span class="hs-identifier hs-var">rp2</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; RPat l -&gt; RPat l -&gt; RPat l
</span><a href="Language.Haskell.Exts.Syntax.html#RPEither"><span class="hs-identifier hs-var">RPEither</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422267"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422262"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422261"><span class="hs-identifier hs-var">rp1'</span></a></span><span> </span><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422260"><span class="hs-identifier hs-var">rp2</span></a></span><span>
</span><span id="line-1889"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPSeq"><span class="hs-identifier hs-type">RPSeq</span></a></span><span> </span><span id="local-6989586621679422259"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422259"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422258"><span class="annot"><span class="annottext">[RPat l]
</span><a href="#local-6989586621679422258"><span class="hs-identifier hs-var">rps</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [RPat l] -&gt; RPat l
</span><a href="Language.Haskell.Exts.Syntax.html#RPSeq"><span class="hs-identifier hs-var">RPSeq</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422267"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422259"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[RPat l]
</span><a href="#local-6989586621679422258"><span class="hs-identifier hs-var">rps</span></a></span><span>
</span><span id="line-1890"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPGuard"><span class="hs-identifier hs-type">RPGuard</span></a></span><span> </span><span id="local-6989586621679422257"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422257"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422256"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422256"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679422255"><span class="annot"><span class="annottext">[Stmt l]
</span><a href="#local-6989586621679422255"><span class="hs-identifier hs-var">ss</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; [Stmt l] -&gt; RPat l
</span><a href="Language.Haskell.Exts.Syntax.html#RPGuard"><span class="hs-identifier hs-var">RPGuard</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422267"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422257"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422256"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">[Stmt l]
</span><a href="#local-6989586621679422255"><span class="hs-identifier hs-var">ss</span></a></span><span>
</span><span id="line-1891"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPCAs"><span class="hs-identifier hs-type">RPCAs</span></a></span><span> </span><span id="local-6989586621679422254"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422254"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422253"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422253"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679422252"><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422252"><span class="hs-identifier hs-var">rp</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; RPat l -&gt; RPat l
</span><a href="Language.Haskell.Exts.Syntax.html#RPCAs"><span class="hs-identifier hs-var">RPCAs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422267"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422254"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422253"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422252"><span class="hs-identifier hs-var">rp</span></a></span><span>
</span><span id="line-1892"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPAs"><span class="hs-identifier hs-type">RPAs</span></a></span><span> </span><span id="local-6989586621679422251"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422251"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422250"><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422250"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679422249"><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422249"><span class="hs-identifier hs-var">rp</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Name l -&gt; RPat l -&gt; RPat l
</span><a href="Language.Haskell.Exts.Syntax.html#RPAs"><span class="hs-identifier hs-var">RPAs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422267"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422251"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679422250"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422249"><span class="hs-identifier hs-var">rp</span></a></span><span>
</span><span id="line-1893"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPParen"><span class="hs-identifier hs-type">RPParen</span></a></span><span> </span><span id="local-6989586621679422248"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422248"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422247"><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422247"><span class="hs-identifier hs-var">rp</span></a></span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; RPat l -&gt; RPat l
</span><a href="Language.Haskell.Exts.Syntax.html#RPParen"><span class="hs-identifier hs-var">RPParen</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422267"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422248"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RPat l
</span><a href="#local-6989586621679422247"><span class="hs-identifier hs-var">rp</span></a></span><span>
</span><span id="line-1894"></span><span>      </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RPPat"><span class="hs-identifier hs-type">RPPat</span></a></span><span> </span><span id="local-6989586621679422246"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422246"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422245"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422245"><span class="hs-identifier hs-var">p</span></a></span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; RPat l
</span><a href="Language.Haskell.Exts.Syntax.html#RPPat"><span class="hs-identifier hs-var">RPPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422267"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422246"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422245"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1895"></span><span>
</span><span id="line-1896"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PatField"><span class="hs-identifier hs-type">PatField</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1897"></span><span>    </span><span id="local-6989586621679422239"><span class="annot"><span class="annottext">ann :: forall l. PatField l -&gt; l
</span><a href="#local-6989586621679422239"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PFieldPat"><span class="hs-identifier hs-type">PFieldPat</span></a></span><span> </span><span id="local-6989586621679422238"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422238"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422238"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1898"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PFieldPun"><span class="hs-identifier hs-type">PFieldPun</span></a></span><span> </span><span id="local-6989586621679422237"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422237"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422237"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1899"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PFieldWildcard"><span class="hs-identifier hs-type">PFieldWildcard</span></a></span><span> </span><span id="local-6989586621679422236"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422236"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422236"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1900"></span><span>    </span><span id="local-6989586621679422235"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; PatField l -&gt; PatField l
</span><a href="#local-6989586621679422235"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422234"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422234"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PFieldPat"><span class="hs-identifier hs-type">PFieldPat</span></a></span><span> </span><span id="local-6989586621679422233"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422233"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422232"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422232"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621679422231"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422231"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Pat l -&gt; PatField l
</span><a href="Language.Haskell.Exts.Syntax.html#PFieldPat"><span class="hs-identifier hs-var">PFieldPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422234"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422233"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422232"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422231"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1901"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422230"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422230"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PFieldPun"><span class="hs-identifier hs-type">PFieldPun</span></a></span><span> </span><span id="local-6989586621679422229"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422229"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422228"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422228"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; PatField l
</span><a href="Language.Haskell.Exts.Syntax.html#PFieldPun"><span class="hs-identifier hs-var">PFieldPun</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422230"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422229"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422228"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1902"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422227"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422227"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PFieldWildcard"><span class="hs-identifier hs-type">PFieldWildcard</span></a></span><span> </span><span id="local-6989586621679422226"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422226"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; PatField l
</span><a href="Language.Haskell.Exts.Syntax.html#PFieldWildcard"><span class="hs-identifier hs-var">PFieldWildcard</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422227"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422226"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1903"></span><span>
</span><span id="line-1904"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1905"></span><span>    </span><span id="local-6989586621679422220"><span class="annot"><span class="annottext">ann :: forall l. Stmt l -&gt; l
</span><a href="#local-6989586621679422220"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Generator"><span class="hs-identifier hs-type">Generator</span></a></span><span> </span><span id="local-6989586621679422219"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422219"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422219"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1906"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Qualifier"><span class="hs-identifier hs-type">Qualifier</span></a></span><span> </span><span id="local-6989586621679422218"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422218"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422218"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1907"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LetStmt"><span class="hs-identifier hs-type">LetStmt</span></a></span><span> </span><span id="local-6989586621679422217"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422217"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Binds l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422217"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1908"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecStmt"><span class="hs-identifier hs-type">RecStmt</span></a></span><span> </span><span id="local-6989586621679422216"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422216"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Stmt l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422216"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1909"></span><span>    </span><span id="local-6989586621679422215"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Stmt l -&gt; Stmt l
</span><a href="#local-6989586621679422215"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422214"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422214"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Generator"><span class="hs-identifier hs-type">Generator</span></a></span><span> </span><span id="local-6989586621679422213"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422213"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422212"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422212"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679422211"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422211"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; Exp l -&gt; Stmt l
</span><a href="Language.Haskell.Exts.Syntax.html#Generator"><span class="hs-identifier hs-var">Generator</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422214"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422213"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422212"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422211"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1910"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422210"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422210"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Qualifier"><span class="hs-identifier hs-type">Qualifier</span></a></span><span> </span><span id="local-6989586621679422209"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422209"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422208"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422208"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Stmt l
</span><a href="Language.Haskell.Exts.Syntax.html#Qualifier"><span class="hs-identifier hs-var">Qualifier</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422210"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422209"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422208"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1911"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422207"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422207"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#LetStmt"><span class="hs-identifier hs-type">LetStmt</span></a></span><span> </span><span id="local-6989586621679422206"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422206"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422205"><span class="annot"><span class="annottext">Binds l
</span><a href="#local-6989586621679422205"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Binds l -&gt; Stmt l
</span><a href="Language.Haskell.Exts.Syntax.html#LetStmt"><span class="hs-identifier hs-var">LetStmt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422207"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422206"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Binds l
</span><a href="#local-6989586621679422205"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-1912"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422204"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422204"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#RecStmt"><span class="hs-identifier hs-type">RecStmt</span></a></span><span> </span><span id="local-6989586621679422203"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422203"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422202"><span class="annot"><span class="annottext">[Stmt l]
</span><a href="#local-6989586621679422202"><span class="hs-identifier hs-var">ss</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Stmt l] -&gt; Stmt l
</span><a href="Language.Haskell.Exts.Syntax.html#RecStmt"><span class="hs-identifier hs-var">RecStmt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422204"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422203"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Stmt l]
</span><a href="#local-6989586621679422202"><span class="hs-identifier hs-var">ss</span></a></span><span>
</span><span id="line-1913"></span><span>
</span><span id="line-1914"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualStmt"><span class="hs-identifier hs-type">QualStmt</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1915"></span><span>    </span><span id="local-6989586621679422196"><span class="annot"><span class="annottext">ann :: forall l. QualStmt l -&gt; l
</span><a href="#local-6989586621679422196"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualStmt"><span class="hs-identifier hs-type">QualStmt</span></a></span><span>     </span><span id="local-6989586621679422195"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422195"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Stmt l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422195"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1916"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ThenTrans"><span class="hs-identifier hs-type">ThenTrans</span></a></span><span>    </span><span id="local-6989586621679422194"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422194"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422194"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1917"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ThenBy"><span class="hs-identifier hs-type">ThenBy</span></a></span><span>       </span><span id="local-6989586621679422193"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422193"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422193"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1918"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GroupBy"><span class="hs-identifier hs-type">GroupBy</span></a></span><span>      </span><span id="local-6989586621679422192"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422192"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422192"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1919"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GroupUsing"><span class="hs-identifier hs-type">GroupUsing</span></a></span><span>   </span><span id="local-6989586621679422191"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422191"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422191"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1920"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GroupByUsing"><span class="hs-identifier hs-type">GroupByUsing</span></a></span><span> </span><span id="local-6989586621679422190"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422190"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422190"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1921"></span><span>    </span><span id="local-6989586621679422189"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; QualStmt l -&gt; QualStmt l
</span><a href="#local-6989586621679422189"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422188"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422188"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#QualStmt"><span class="hs-identifier hs-type">QualStmt</span></a></span><span>     </span><span id="local-6989586621679422187"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422187"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422186"><span class="annot"><span class="annottext">Stmt l
</span><a href="#local-6989586621679422186"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Stmt l -&gt; QualStmt l
</span><a href="Language.Haskell.Exts.Syntax.html#QualStmt"><span class="hs-identifier hs-var">QualStmt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422188"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422187"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Stmt l
</span><a href="#local-6989586621679422186"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-1922"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422185"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422185"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ThenTrans"><span class="hs-identifier hs-type">ThenTrans</span></a></span><span>    </span><span id="local-6989586621679422184"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422184"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422183"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422183"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; QualStmt l
</span><a href="Language.Haskell.Exts.Syntax.html#ThenTrans"><span class="hs-identifier hs-var">ThenTrans</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422185"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422184"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422183"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1923"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422182"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422182"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ThenBy"><span class="hs-identifier hs-type">ThenBy</span></a></span><span>       </span><span id="local-6989586621679422181"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422181"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422180"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422180"><span class="hs-identifier hs-var">e1</span></a></span></span><span> </span><span id="local-6989586621679422179"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422179"><span class="hs-identifier hs-var">e2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; QualStmt l
</span><a href="Language.Haskell.Exts.Syntax.html#ThenBy"><span class="hs-identifier hs-var">ThenBy</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422182"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422181"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422180"><span class="hs-identifier hs-var">e1</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422179"><span class="hs-identifier hs-var">e2</span></a></span><span>
</span><span id="line-1924"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422178"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422178"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GroupBy"><span class="hs-identifier hs-type">GroupBy</span></a></span><span>      </span><span id="local-6989586621679422177"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422177"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422176"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422176"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; QualStmt l
</span><a href="Language.Haskell.Exts.Syntax.html#GroupBy"><span class="hs-identifier hs-var">GroupBy</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422178"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422177"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422176"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1925"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422175"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422175"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GroupUsing"><span class="hs-identifier hs-type">GroupUsing</span></a></span><span>   </span><span id="local-6989586621679422174"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422174"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422173"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422173"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; QualStmt l
</span><a href="Language.Haskell.Exts.Syntax.html#GroupUsing"><span class="hs-identifier hs-var">GroupUsing</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422175"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422174"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422173"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1926"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422172"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422172"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#GroupByUsing"><span class="hs-identifier hs-type">GroupByUsing</span></a></span><span> </span><span id="local-6989586621679422171"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422171"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422170"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422170"><span class="hs-identifier hs-var">e1</span></a></span></span><span> </span><span id="local-6989586621679422169"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422169"><span class="hs-identifier hs-var">e2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Exp l -&gt; Exp l -&gt; QualStmt l
</span><a href="Language.Haskell.Exts.Syntax.html#GroupByUsing"><span class="hs-identifier hs-var">GroupByUsing</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422172"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422171"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422170"><span class="hs-identifier hs-var">e1</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422169"><span class="hs-identifier hs-var">e2</span></a></span><span>
</span><span id="line-1927"></span><span>
</span><span id="line-1928"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldUpdate"><span class="hs-identifier hs-type">FieldUpdate</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1929"></span><span>    </span><span id="local-6989586621679422163"><span class="annot"><span class="annottext">ann :: forall l. FieldUpdate l -&gt; l
</span><a href="#local-6989586621679422163"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldUpdate"><span class="hs-identifier hs-type">FieldUpdate</span></a></span><span> </span><span id="local-6989586621679422162"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422162"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422162"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1930"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldPun"><span class="hs-identifier hs-type">FieldPun</span></a></span><span> </span><span id="local-6989586621679422161"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422161"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422161"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1931"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldWildcard"><span class="hs-identifier hs-type">FieldWildcard</span></a></span><span> </span><span id="local-6989586621679422160"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422160"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422160"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1932"></span><span>    </span><span id="local-6989586621679422159"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; FieldUpdate l -&gt; FieldUpdate l
</span><a href="#local-6989586621679422159"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422158"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422158"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldUpdate"><span class="hs-identifier hs-type">FieldUpdate</span></a></span><span> </span><span id="local-6989586621679422157"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422157"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422156"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422156"><span class="hs-identifier hs-var">qn</span></a></span></span><span> </span><span id="local-6989586621679422155"><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422155"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; Exp l -&gt; FieldUpdate l
</span><a href="Language.Haskell.Exts.Syntax.html#FieldUpdate"><span class="hs-identifier hs-var">FieldUpdate</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422158"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422157"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422156"><span class="hs-identifier hs-var">qn</span></a></span><span> </span><span class="annot"><span class="annottext">Exp l
</span><a href="#local-6989586621679422155"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-1933"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422154"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422154"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldPun"><span class="hs-identifier hs-type">FieldPun</span></a></span><span> </span><span id="local-6989586621679422153"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422153"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422152"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422152"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; QName l -&gt; FieldUpdate l
</span><a href="Language.Haskell.Exts.Syntax.html#FieldPun"><span class="hs-identifier hs-var">FieldPun</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422154"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422153"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422152"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1934"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422151"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422151"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#FieldWildcard"><span class="hs-identifier hs-type">FieldWildcard</span></a></span><span> </span><span id="local-6989586621679422150"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422150"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; FieldUpdate l
</span><a href="Language.Haskell.Exts.Syntax.html#FieldWildcard"><span class="hs-identifier hs-var">FieldWildcard</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422151"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422150"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1935"></span><span>
</span><span id="line-1936"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Alt"><span class="hs-identifier hs-type">Alt</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1937"></span><span>    </span><span id="local-6989586621679422144"><span class="annot"><span class="annottext">ann :: forall l. Alt l -&gt; l
</span><a href="#local-6989586621679422144"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Alt"><span class="hs-identifier hs-type">Alt</span></a></span><span> </span><span id="local-6989586621679422143"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422143"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Rhs l
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Binds l)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422143"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1938"></span><span>    </span><span id="local-6989586621679422142"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Alt l -&gt; Alt l
</span><a href="#local-6989586621679422142"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422141"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422141"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Alt"><span class="hs-identifier hs-type">Alt</span></a></span><span> </span><span id="local-6989586621679422140"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422140"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422139"><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422139"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679422138"><span class="annot"><span class="annottext">Rhs l
</span><a href="#local-6989586621679422138"><span class="hs-identifier hs-var">gs</span></a></span></span><span> </span><span id="local-6989586621679422137"><span class="annot"><span class="annottext">Maybe (Binds l)
</span><a href="#local-6989586621679422137"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Pat l -&gt; Rhs l -&gt; Maybe (Binds l) -&gt; Alt l
</span><a href="Language.Haskell.Exts.Syntax.html#Alt"><span class="hs-identifier hs-var">Alt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422141"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422140"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Pat l
</span><a href="#local-6989586621679422139"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Rhs l
</span><a href="#local-6989586621679422138"><span class="hs-identifier hs-var">gs</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Binds l)
</span><a href="#local-6989586621679422137"><span class="hs-identifier hs-var">bs</span></a></span><span>
</span><span id="line-1939"></span><span>
</span><span id="line-1940"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Annotated"><span class="hs-identifier hs-type">Annotated</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#Promoted"><span class="hs-identifier hs-type">Promoted</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1941"></span><span>    </span><span id="local-6989586621679422131"><span class="annot"><span class="annottext">ann :: forall l. Promoted l -&gt; l
</span><a href="#local-6989586621679422131"><span class="hs-identifier hs-var hs-var hs-var hs-var">ann</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedInteger"><span class="hs-identifier hs-type">PromotedInteger</span></a></span><span> </span><span id="local-6989586621679422130"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422130"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Integer
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422130"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1942"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedString"><span class="hs-identifier hs-type">PromotedString</span></a></span><span> </span><span id="local-6989586621679422129"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422129"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422129"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1943"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedCon"><span class="hs-identifier hs-type">PromotedCon</span></a></span><span> </span><span id="local-6989586621679422128"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422128"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">QName l
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422128"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1944"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedList"><span class="hs-identifier hs-type">PromotedList</span></a></span><span> </span><span id="local-6989586621679422127"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422127"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422127"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1945"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedTuple"><span class="hs-identifier hs-type">PromotedTuple</span></a></span><span> </span><span id="local-6989586621679422126"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422126"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422126"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1946"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedUnit"><span class="hs-identifier hs-type">PromotedUnit</span></a></span><span> </span><span id="local-6989586621679422125"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422125"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422125"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1947"></span><span>    </span><span id="local-6989586621679422124"><span class="annot"><span class="annottext">amap :: forall l. (l -&gt; l) -&gt; Promoted l -&gt; Promoted l
</span><a href="#local-6989586621679422124"><span class="hs-identifier hs-var hs-var hs-var hs-var">amap</span></a></span></span><span> </span><span id="local-6989586621679422123"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422123"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedInteger"><span class="hs-identifier hs-type">PromotedInteger</span></a></span><span> </span><span id="local-6989586621679422122"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422122"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422121"><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679422121"><span class="hs-identifier hs-var">int</span></a></span></span><span> </span><span id="local-6989586621679422120"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422120"><span class="hs-identifier hs-var">raw</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Integer -&gt; String -&gt; Promoted l
</span><a href="Language.Haskell.Exts.Syntax.html#PromotedInteger"><span class="hs-identifier hs-var">PromotedInteger</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422123"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422122"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Integer
</span><a href="#local-6989586621679422121"><span class="hs-identifier hs-var">int</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422120"><span class="hs-identifier hs-var">raw</span></a></span><span>
</span><span id="line-1948"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422119"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422119"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedString"><span class="hs-identifier hs-type">PromotedString</span></a></span><span> </span><span id="local-6989586621679422118"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422118"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422117"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422117"><span class="hs-identifier hs-var">str</span></a></span></span><span> </span><span id="local-6989586621679422116"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422116"><span class="hs-identifier hs-var">raw</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; String -&gt; String -&gt; Promoted l
</span><a href="Language.Haskell.Exts.Syntax.html#PromotedString"><span class="hs-identifier hs-var">PromotedString</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422119"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422118"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422117"><span class="hs-identifier hs-var">str</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679422116"><span class="hs-identifier hs-var">raw</span></a></span><span>
</span><span id="line-1949"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422115"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422115"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedCon"><span class="hs-identifier hs-type">PromotedCon</span></a></span><span> </span><span id="local-6989586621679422114"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422114"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422113"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679422113"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679422112"><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422112"><span class="hs-identifier hs-var">qn</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Bool -&gt; QName l -&gt; Promoted l
</span><a href="Language.Haskell.Exts.Syntax.html#PromotedCon"><span class="hs-identifier hs-var">PromotedCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422115"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422114"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679422113"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">QName l
</span><a href="#local-6989586621679422112"><span class="hs-identifier hs-var">qn</span></a></span><span>
</span><span id="line-1950"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422111"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422111"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedList"><span class="hs-identifier hs-type">PromotedList</span></a></span><span> </span><span id="local-6989586621679422110"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422110"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422109"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679422109"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679422108"><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679422108"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Bool -&gt; [Type l] -&gt; Promoted l
</span><a href="Language.Haskell.Exts.Syntax.html#PromotedList"><span class="hs-identifier hs-var">PromotedList</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422111"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422110"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679422109"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679422108"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-1951"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422107"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422107"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedTuple"><span class="hs-identifier hs-type">PromotedTuple</span></a></span><span> </span><span id="local-6989586621679422106"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422106"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679422105"><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679422105"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; [Type l] -&gt; Promoted l
</span><a href="Language.Haskell.Exts.Syntax.html#PromotedTuple"><span class="hs-identifier hs-var">PromotedTuple</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422107"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422106"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type l]
</span><a href="#local-6989586621679422105"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-1952"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#amap"><span class="hs-identifier hs-var">amap</span></a></span><span> </span><span id="local-6989586621679422104"><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422104"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Syntax.html#PromotedUnit"><span class="hs-identifier hs-type">PromotedUnit</span></a></span><span> </span><span id="local-6989586621679422103"><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422103"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l. l -&gt; Promoted l
</span><a href="Language.Haskell.Exts.Syntax.html#PromotedUnit"><span class="hs-identifier hs-var">PromotedUnit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">l -&gt; l
</span><a href="#local-6989586621679422104"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">l
</span><a href="#local-6989586621679422103"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1953"></span></pre></body></html>
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-share-api
@version 0.0.0

module Unison.Server.Doc.Markdown.Types

-- | Custom type for converting Docs into Markdown. I tried using the
--   existing cmark-gfm library for this, but we have too many edge-cases
--   for it to work well.
data Markdown

-- | E.g. '---'
ThematicBreak :: Markdown
Paragraph :: [Markdown] -> Markdown
BlockQuote :: [Markdown] -> Markdown
CodeBlock :: Text -> Text -> Markdown
Heading :: Int -> [Markdown] -> Markdown
OrderedList :: Int -> [[Markdown]] -> Markdown
UnorderedList :: [[Markdown]] -> Markdown
Txt :: Text -> Markdown
Linebreak :: Markdown
InlineCode :: Text -> Markdown
Italics :: [Markdown] -> Markdown
Strong :: [Markdown] -> Markdown
Strikethrough :: [Markdown] -> Markdown
Link :: [Markdown] -> Text -> Markdown
Image :: [Markdown] -> Text -> Markdown
Table :: Maybe [[Markdown]] -> [[[Markdown]]] -> Markdown

-- | Render the markdown datatype to markdown text
toText :: [Markdown] -> Text
instance GHC.Show.Show Unison.Server.Doc.Markdown.Types.Markdown

module Unison.Server.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON U.Codebase.HashTags.CausalHash
instance Data.Aeson.Types.FromJSON.FromJSON U.Codebase.HashTags.CausalHash
instance Data.Binary.Class.Binary Unison.Hash.Hash
instance Data.Binary.Class.Binary U.Codebase.HashTags.CausalHash
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Codebase.ShortCausalHash.ShortCausalHash
instance (Data.OpenApi.Internal.Schema.ToSchema b, Data.OpenApi.Internal.Schema.ToSchema a) => Data.OpenApi.Internal.Schema.ToSchema (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Codebase.ShortCausalHash.ShortCausalHash
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Util.Pretty.Width
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Util.Pretty.Width
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Util.Pretty.Width
instance Data.OpenApi.Internal.Schema.ToSchema Unison.NameSegment.NameSegment
instance Data.OpenApi.Internal.Schema.ToSchema n => Data.OpenApi.Internal.Schema.ToSchema (Unison.HashQualified.HashQualified n)
instance Data.OpenApi.Internal.Schema.ToSchema n => Data.OpenApi.Internal.Schema.ToSchema (Unison.HashQualified'.HashQualified n)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Hash.Hash
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Hash.Hash
instance Data.Aeson.Types.ToJSON.ToJSON Unison.ShortHash.ShortHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Unison.ShortHash.ShortHash
instance Data.Aeson.Types.FromJSON.FromJSON Unison.ShortHash.ShortHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Unison.ShortHash.ShortHash
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Codebase.ShortCausalHash.ShortCausalHash
instance Web.Internal.HttpApiData.ToHttpApiData Unison.ShortHash.ShortHash
instance Web.Internal.HttpApiData.FromHttpApiData Unison.ShortHash.ShortHash
instance Data.OpenApi.Internal.Schema.ToSchema Unison.ShortHash.ShortHash
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Reference.Reference
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Referent.Referent
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Reference.Reference
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Referent.Referent
instance Data.OpenApi.Internal.Schema.ToSchema Data.OpenApi.Internal.Reference
instance (Data.Aeson.Types.ToJSON.ToJSON b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Name.Internal.Name
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Name.Internal.Name
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.ShortHash.ShortHash
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Reference.Reference
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Referent.Referent
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Name.Internal.Name
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Codebase.Path.Path
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Codebase.Path.Relative
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "name" Unison.Name.Internal.Name)
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Name.Internal.Name
instance Data.Aeson.Types.ToJSON.ToJSON Unison.ConstructorType.ConstructorType
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Codebase.Path.Relative
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Codebase.Path.Relative
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Codebase.Path.Absolute
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Codebase.Path.Absolute
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Codebase.Path.Path'
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Codebase.Path.Path'
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Codebase.Path.Path
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "hash" Unison.ShortHash.ShortHash)
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "hash" Unison.Reference.Reference)
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "hash" Unison.Referent.Referent)
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "fqn" Unison.Name.Internal.Name)
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "namespace" Unison.Codebase.Path.Path)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Codebase.Path.Path
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Codebase.Path.Path
instance Data.Aeson.Types.ToJSON.ToJSON (Unison.HashQualified.HashQualified Unison.Name.Internal.Name)
instance Data.Aeson.Types.ToJSON.ToJSON (Unison.HashQualified.HashQualified Unison.NameSegment.NameSegment)
instance Data.Aeson.Types.ToJSON.ToJSON (Unison.HashQualified'.HashQualified Unison.Name.Internal.Name)
instance Data.Aeson.Types.ToJSON.ToJSON (Unison.HashQualified'.HashQualified Unison.NameSegment.NameSegment)
instance Data.Aeson.Types.FromJSON.FromJSON (Unison.HashQualified'.HashQualified Unison.Name.Internal.Name)
instance Data.Aeson.Types.FromJSON.FromJSON (Unison.HashQualified.HashQualified Unison.Name.Internal.Name)
instance Data.Aeson.Types.FromJSON.FromJSON (Unison.HashQualified'.HashQualified Unison.NameSegment.NameSegment)
instance Data.Aeson.Types.FromJSON.FromJSON (Unison.HashQualified.HashQualified Unison.NameSegment.NameSegment)
instance Web.Internal.HttpApiData.FromHttpApiData (Unison.HashQualified.HashQualified Unison.Name.Internal.Name)
instance Web.Internal.HttpApiData.FromHttpApiData (Unison.HashQualified'.HashQualified Unison.Name.Internal.Name)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema (Unison.HashQualified.HashQualified n)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema (Unison.HashQualified'.HashQualified n)
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Name.Internal.Name

module Unison.Server.SearchResult
data SearchResult
Tp :: TypeResult -> SearchResult
Tm :: TermResult -> SearchResult
data TermResult
TermResult :: HashQualified Name -> Referent -> Set (HashQualified Name) -> TermResult
[$sel:termName:TermResult] :: TermResult -> HashQualified Name
[$sel:referent:TermResult] :: TermResult -> Referent
[$sel:termAliases:TermResult] :: TermResult -> Set (HashQualified Name)
data TypeResult
TypeResult :: HashQualified Name -> Reference -> Set (HashQualified Name) -> TypeResult
[$sel:typeName:TypeResult] :: TypeResult -> HashQualified Name
[$sel:reference:TypeResult] :: TypeResult -> Reference
[$sel:typeAliases:TypeResult] :: TypeResult -> Set (HashQualified Name)
pattern Tm' :: HashQualified Name -> Referent -> Set (HashQualified Name) -> SearchResult
pattern Tp' :: HashQualified Name -> Reference -> Set (HashQualified Name) -> SearchResult

-- | Construct a term search result from a primary name, referent, and set
--   of aliases.
termResult :: HashQualified Name -> Referent -> Set (HashQualified Name) -> SearchResult
termSearchResult :: Names -> Name -> Referent -> SearchResult

-- | Construct a type search result from a primary name, reference, and set
--   of aliases.
typeResult :: HashQualified Name -> Reference -> Set (HashQualified Name) -> SearchResult
typeSearchResult :: Names -> Name -> Reference -> SearchResult
name :: SearchResult -> HashQualified Name
aliases :: SearchResult -> Set (HashQualified Name)

-- | TypeResults yield a <a>Ref</a>
toReferent :: SearchResult -> Referent
truncateAliases :: Int -> SearchResult -> SearchResult

-- | You may want to sort this list differently afterward.
fromNames :: Names -> [SearchResult]
_fromNames :: Names -> [SearchResult]

-- | Sort a list of search results by name. If names are equal, fall back
--   to comparing by reference (putting types before terms).
compareByName :: SearchResult -> SearchResult -> Ordering
instance GHC.Show.Show Unison.Server.SearchResult.TermResult
instance GHC.Classes.Ord Unison.Server.SearchResult.TermResult
instance GHC.Classes.Eq Unison.Server.SearchResult.TermResult
instance GHC.Show.Show Unison.Server.SearchResult.TypeResult
instance GHC.Classes.Ord Unison.Server.SearchResult.TypeResult
instance GHC.Classes.Eq Unison.Server.SearchResult.TypeResult
instance GHC.Show.Show Unison.Server.SearchResult.SearchResult
instance GHC.Classes.Ord Unison.Server.SearchResult.SearchResult
instance GHC.Classes.Eq Unison.Server.SearchResult.SearchResult

module Unison.Server.QueryResult
data QueryResult
QueryResult :: [HashQualified Name] -> [SearchResult] -> QueryResult
[$sel:misses:QueryResult] :: QueryResult -> [HashQualified Name]
[$sel:hits:QueryResult] :: QueryResult -> [SearchResult]

module Unison.Server.SearchResult'
data SearchResult' v a
Tm' :: TermResult' v a -> SearchResult' v a
Tp' :: TypeResult' v a -> SearchResult' v a
data TermResult' v a
TermResult' :: HashQualified Name -> Maybe (Type v a) -> Referent -> Set (HashQualified Name) -> TermResult' v a
data TypeResult' v a
TypeResult' :: HashQualified Name -> DisplayObject () (Decl v a) -> Reference -> Set (HashQualified Name) -> TypeResult' v a
pattern Tm :: HashQualified Name -> Maybe (Type v a) -> Referent -> Set (HashQualified Name) -> SearchResult' v a
pattern Tp :: HashQualified Name -> DisplayObject () (Decl v a) -> Reference -> Set (HashQualified Name) -> SearchResult' v a
tmReferent :: SearchResult' v a -> Maybe Referent
tpReference :: SearchResult' v a -> Maybe Reference
foldResult' :: (TermResult' v a -> b) -> (TypeResult' v a -> b) -> SearchResult' v a -> b
labeledDependencies :: Ord v => SearchResult' v a -> Set LabeledDependency
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.SearchResult'.TermResult' v a)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.SearchResult'.TermResult' v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.Server.SearchResult'.TypeResult' v a)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Server.SearchResult'.TypeResult' v a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Server.SearchResult'.SearchResult' v a)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Server.SearchResult'.SearchResult' v a)


-- | Duplicate of the Unison.Util.SyntaxText module, but we expect these to
--   evolve separately. This is the version which is outward facing to the
--   server frontend.
module Unison.Server.Syntax
type SyntaxText = AnnotatedText Element
type SyntaxSegment = Segment Element
convertElement :: Element Reference -> Element
type UnisonHash = Text
type HashQualifiedName = Text

-- | The elements of the Unison grammar, for syntax highlighting purposes
data Element
NumericLiteral :: Element
TextLiteral :: Element
BytesLiteral :: Element
CharLiteral :: Element
BooleanLiteral :: Element
Blank :: Element
Var :: Element
TypeReference :: UnisonHash -> Element
DataConstructorReference :: UnisonHash -> Element
AbilityConstructorReference :: UnisonHash -> Element
TermReference :: UnisonHash -> Element
Op :: SeqOp -> Element

-- | Constructor Are these even used? | Request
AbilityBraces :: Element
ControlKeyword :: Element
TypeOperator :: Element
BindingEquals :: Element
TypeAscriptionColon :: Element
DataTypeKeyword :: Element
DataTypeParams :: Element
Unit :: Element
DataTypeModifier :: Element
UseKeyword :: Element
UsePrefix :: Element
UseSuffix :: Element
HashQualifier :: HashQualifiedName -> Element
DelayForceChar :: Element
DelimiterChar :: Element
Parenthesis :: Element
LinkKeyword :: Element
DocDelimiter :: Element
DocKeyword :: Element
syntax :: Element -> SyntaxText -> SyntaxText
firstReference :: SyntaxText -> Maybe UnisonHash
reference :: SyntaxSegment -> Maybe UnisonHash

-- | Convert a <a>SyntaxText</a> to a <a>String</a>, ignoring syntax markup
toPlain :: SyntaxText -> String
toPlainText :: SyntaxText -> Text
toHtml :: SyntaxText -> Html ()
nameToHtml :: Name -> Html ()
segmentToHtml :: SyntaxSegment -> Html ()
elementToClassName :: Element -> Text
instance GHC.Generics.Generic Unison.Server.Syntax.Element
instance GHC.Show.Show Unison.Server.Syntax.Element
instance GHC.Classes.Ord Unison.Server.Syntax.Element
instance GHC.Classes.Eq Unison.Server.Syntax.Element
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Syntax.Element
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Unison.Util.AnnotatedText.Segment a)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Pattern.SeqOp
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Syntax.SyntaxText
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Syntax.SyntaxText
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Syntax.SyntaxText
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Syntax.Element
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Syntax.Element
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Unison.Util.AnnotatedText.Segment a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Unison.Util.AnnotatedText.Segment a)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Pattern.SeqOp
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Pattern.SeqOp
instance Data.OpenApi.Internal.Schema.ToSchema r => Data.OpenApi.Internal.Schema.ToSchema (Data.Sequence.Internal.Seq r)

module Unison.Server.Doc
type Nat = Word64
type SSyntaxText = SyntaxText' Reference

-- | A doc rendered down to SyntaxText.
type Doc = DocG RenderedSpecialForm

-- | A doc which has been evaluated and includes all information necessary
--   to be rendered.
type EvaluatedDoc v = DocG (EvaluatedSpecialForm v)
type SrcRefs = Ref (UnisonHash, DisplayObject SyntaxText Src)

-- | A doc parameterized by its special forms.
data DocG specialForm
Word :: Text -> DocG specialForm
Code :: DocG specialForm -> DocG specialForm
CodeBlock :: Text -> DocG specialForm -> DocG specialForm
Bold :: DocG specialForm -> DocG specialForm
Italic :: DocG specialForm -> DocG specialForm
Strikethrough :: DocG specialForm -> DocG specialForm
Style :: Text -> DocG specialForm -> DocG specialForm
Anchor :: Text -> DocG specialForm -> DocG specialForm
Blockquote :: DocG specialForm -> DocG specialForm
Blankline :: DocG specialForm
Linebreak :: DocG specialForm
SectionBreak :: DocG specialForm
Tooltip :: DocG specialForm -> DocG specialForm -> DocG specialForm
Aside :: DocG specialForm -> DocG specialForm
Callout :: Maybe (DocG specialForm) -> DocG specialForm -> DocG specialForm
Table :: [[DocG specialForm]] -> DocG specialForm
Folded :: Bool -> DocG specialForm -> DocG specialForm -> DocG specialForm
Paragraph :: [DocG specialForm] -> DocG specialForm
BulletedList :: [DocG specialForm] -> DocG specialForm
NumberedList :: Nat -> [DocG specialForm] -> DocG specialForm
Section :: DocG specialForm -> [DocG specialForm] -> DocG specialForm
NamedLink :: DocG specialForm -> DocG specialForm -> DocG specialForm
Image :: DocG specialForm -> DocG specialForm -> Maybe (DocG specialForm) -> DocG specialForm
Special :: specialForm -> DocG specialForm
Join :: [DocG specialForm] -> DocG specialForm
UntitledSection :: [DocG specialForm] -> DocG specialForm
Column :: [DocG specialForm] -> DocG specialForm
Group :: DocG specialForm -> DocG specialForm
type UnisonHash = Text
data Ref a
Term :: a -> Ref a
Type :: a -> Ref a
data MediaSource
MediaSource :: Text -> Maybe Text -> MediaSource
[$sel:mediaSourceUrl:MediaSource] :: MediaSource -> Text
[$sel:mediaSourceMimeType:MediaSource] :: MediaSource -> Maybe Text
data RenderedSpecialForm
Source :: [SrcRefs] -> RenderedSpecialForm
FoldedSource :: [SrcRefs] -> RenderedSpecialForm
Example :: SyntaxText -> RenderedSpecialForm
ExampleBlock :: SyntaxText -> RenderedSpecialForm
Link :: SyntaxText -> RenderedSpecialForm
Signature :: [SyntaxText] -> RenderedSpecialForm
SignatureInline :: SyntaxText -> RenderedSpecialForm
Eval :: SyntaxText -> SyntaxText -> RenderedSpecialForm
EvalInline :: SyntaxText -> SyntaxText -> RenderedSpecialForm
Embed :: SyntaxText -> RenderedSpecialForm
EmbedInline :: SyntaxText -> RenderedSpecialForm
Video :: [MediaSource] -> Map Text Text -> RenderedSpecialForm
FrontMatter :: Map Text [Text] -> RenderedSpecialForm
LaTeXInline :: Text -> RenderedSpecialForm
Svg :: Text -> RenderedSpecialForm
RenderError :: RenderError SyntaxText -> RenderedSpecialForm
data EvaluatedSpecialForm v
ESource :: [EvaluatedSrc v] -> EvaluatedSpecialForm v
EFoldedSource :: [EvaluatedSrc v] -> EvaluatedSpecialForm v
EExample :: Term v () -> EvaluatedSpecialForm v
EExampleBlock :: Term v () -> EvaluatedSpecialForm v
ELink :: Either (Term v ()) LabeledDependency -> EvaluatedSpecialForm v
ESignature :: [(Referent, Type v ())] -> EvaluatedSpecialForm v
ESignatureInline :: (Referent, Type v ()) -> EvaluatedSpecialForm v
EEval :: Term v () -> Maybe (Term v ()) -> EvaluatedSpecialForm v
EEvalInline :: Term v () -> Maybe (Term v ()) -> EvaluatedSpecialForm v
EEmbed :: Term v () -> EvaluatedSpecialForm v
EEmbedInline :: Term v () -> EvaluatedSpecialForm v
EVideo :: [MediaSource] -> Map Text Text -> EvaluatedSpecialForm v
EFrontMatter :: Map Text [Text] -> EvaluatedSpecialForm v
ELaTeXInline :: Text -> EvaluatedSpecialForm v
ESvg :: Text -> EvaluatedSpecialForm v
ERenderError :: RenderError (Term v ()) -> EvaluatedSpecialForm v
data Src
Src :: SyntaxText -> SyntaxText -> Src

-- | Evaluate the doc, then render it.
evalAndRenderDoc :: forall v m. (Var v, Monad m) => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term v ()))) -> (Referent -> m (Maybe (Type v ()))) -> (Term v () -> m (Maybe (Term v ()))) -> (Reference -> m (Maybe (Decl v ()))) -> Term v () -> m Doc

-- | Renders the given doc, which must have been evaluated using
--   <a>evalDoc</a>
renderDoc :: forall v. Var v => PrettyPrintEnvDecl -> EvaluatedDoc v -> Doc

-- | Evaluates the given doc, expanding transclusions, expressions, etc.
evalDoc :: forall v m. (Var v, Monad m) => (Reference -> m (Maybe (Term v ()))) -> (Referent -> m (Maybe (Type v ()))) -> (Term v () -> m (Maybe (Term v ()))) -> (Reference -> m (Maybe (Decl v ()))) -> Term v () -> m (EvaluatedDoc v)
data RenderError trm
InvalidTerm :: trm -> RenderError trm
data EvaluatedSrc v
EvaluatedSrcDecl :: EvaluatedDecl v -> EvaluatedSrc v
EvaluatedSrcTerm :: EvaluatedTerm v -> EvaluatedSrc v
data EvaluatedDecl v
MissingDecl :: Reference -> EvaluatedDecl v
BuiltinDecl :: Reference -> EvaluatedDecl v
FoundDecl :: Reference -> Decl v () -> EvaluatedDecl v
data EvaluatedTerm v
MissingTerm :: Reference -> EvaluatedTerm v
BuiltinTypeSig :: Reference -> Type v () -> EvaluatedTerm v
MissingBuiltinTypeSig :: Reference -> EvaluatedTerm v
FoundTerm :: Reference -> Type v () -> Term v () -> EvaluatedTerm v
dependencies :: Ord v => EvaluatedDoc v -> Set LabeledDependency

-- | Determines all dependencies of a special form
dependenciesSpecial :: forall v. Ord v => EvaluatedSpecialForm v -> Set LabeledDependency
instance Data.Aeson.Types.ToJSON.ToJSON specialForm => Data.Aeson.Types.ToJSON.ToJSON (Unison.Server.Doc.DocG specialForm)
instance Data.Traversable.Traversable Unison.Server.Doc.DocG
instance Data.Foldable.Foldable Unison.Server.Doc.DocG
instance GHC.Base.Functor Unison.Server.Doc.DocG
instance GHC.Generics.Generic (Unison.Server.Doc.DocG specialForm)
instance GHC.Show.Show specialForm => GHC.Show.Show (Unison.Server.Doc.DocG specialForm)
instance GHC.Classes.Eq specialForm => GHC.Classes.Eq (Unison.Server.Doc.DocG specialForm)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Unison.Server.Doc.Ref a)
instance Data.Traversable.Traversable Unison.Server.Doc.Ref
instance Data.Foldable.Foldable Unison.Server.Doc.Ref
instance GHC.Base.Functor Unison.Server.Doc.Ref
instance GHC.Generics.Generic (Unison.Server.Doc.Ref a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Server.Doc.Ref a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Server.Doc.Ref a)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Doc.MediaSource
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Doc.MediaSource
instance GHC.Generics.Generic Unison.Server.Doc.MediaSource
instance GHC.Show.Show Unison.Server.Doc.MediaSource
instance GHC.Classes.Eq Unison.Server.Doc.MediaSource
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Doc.Src
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Doc.Src
instance GHC.Generics.Generic Unison.Server.Doc.Src
instance GHC.Show.Show Unison.Server.Doc.Src
instance GHC.Classes.Eq Unison.Server.Doc.Src
instance Data.Aeson.Types.ToJSON.ToJSON trm => Data.Aeson.Types.ToJSON.ToJSON (Unison.Server.Doc.RenderError trm)
instance GHC.Generics.Generic (Unison.Server.Doc.RenderError trm)
instance GHC.Show.Show trm => GHC.Show.Show (Unison.Server.Doc.RenderError trm)
instance GHC.Classes.Eq trm => GHC.Classes.Eq (Unison.Server.Doc.RenderError trm)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Doc.RenderedSpecialForm
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Doc.RenderedSpecialForm
instance GHC.Generics.Generic Unison.Server.Doc.RenderedSpecialForm
instance GHC.Show.Show Unison.Server.Doc.RenderedSpecialForm
instance GHC.Classes.Eq Unison.Server.Doc.RenderedSpecialForm
instance GHC.Generics.Generic (Unison.Server.Doc.EvaluatedDecl v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Doc.EvaluatedDecl v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Doc.EvaluatedDecl v)
instance GHC.Generics.Generic (Unison.Server.Doc.EvaluatedTerm v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Doc.EvaluatedTerm v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Doc.EvaluatedTerm v)
instance GHC.Generics.Generic (Unison.Server.Doc.EvaluatedSrc v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Doc.EvaluatedSrc v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Doc.EvaluatedSrc v)
instance GHC.Generics.Generic (Unison.Server.Doc.EvaluatedSpecialForm v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Doc.EvaluatedSpecialForm v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Doc.EvaluatedSpecialForm v)
instance Data.OpenApi.Internal.Schema.ToSchema specialForm => Data.OpenApi.Internal.Schema.ToSchema (Unison.Server.Doc.DocG specialForm)
instance Data.OpenApi.Internal.Schema.ToSchema trm => Data.OpenApi.Internal.Schema.ToSchema (Unison.Server.Doc.RenderError trm)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Unison.Server.Doc.Ref a)


-- | Render Unison.Server.Doc as plain markdown, used in the LSP
module Unison.Server.Doc.Markdown.Render

-- | Renders a Doc to a list of Markdown blocks
toMarkdown :: Doc -> [Markdown]


-- | Render Unison.Server.Doc and embedded source to Html
module Unison.Server.Doc.AsHtml
data NamedLinkHref
Href :: Text -> NamedLinkHref
DocLinkHref :: Name -> NamedLinkHref
ReferenceHref :: Text -> NamedLinkHref
InvalidHref :: NamedLinkHref
data EmbeddedSource
EmbeddedSource :: SyntaxText -> SyntaxText -> EmbeddedSource
Builtin :: SyntaxText -> EmbeddedSource
embeddedSource :: Ref (UnisonHash, DisplayObject SyntaxText Src) -> Maybe EmbeddedSource
inlineCode :: [Text] -> Html () -> Html ()
codeBlock :: [Attribute] -> Html () -> Html ()
normalizeHref :: Map Referent Name -> Doc -> NamedLinkHref
data IsFolded
IsFolded :: Bool -> [Html ()] -> [Html ()] -> IsFolded
Disabled :: Html () -> IsFolded
foldedToHtml :: [Attribute] -> IsFolded -> Html ()
foldedToHtmlSource :: Bool -> EmbeddedSource -> Html ()

-- | Merge adjacent Word elements in a list to 1 element with a string of
--   words separated by space— useful for rendering to the dom without
--   creating dom elements for each and every word in the doc, but instead
--   rely on textNodes
mergeWords :: Text -> [Doc] -> [Doc]

-- | Merge down Doc to Text by merging Paragraphs and Words. Used for
--   things like extract an src of an image. I.e something that has to be a
--   Text and not a Doc
toText :: Text -> Doc -> Text
data SideContent
FrontMatterContent :: Map Text [Text] -> SideContent
TooltipContent :: Html () -> SideContent
newtype FrontMatterData
FrontMatterData :: Map Text [Text] -> FrontMatterData
toHtml :: Map Referent Name -> Doc -> (FrontMatterData, Html ())

-- | Unison Doc allows endlessly deep section nesting with titles, but HTML
--   only supports to h1-h6, so we clamp the sectionLevel when converting
h :: Nat -> Text -> Html () -> Html ()
badge :: Html () -> Html ()
textToClass :: Text -> Text

module Unison.Server.Types
type APIHeaders x = Headers '[Header "Cache-Control" String] x
type APIGet c = Get '[JSON] (APIHeaders c)
type HashQualifiedName = Text
type NamespaceFQN = Text
type Size = Int
type UnisonName = Text
type UnisonHash = Text

-- | A hash qualified name, unlike HashQualified, the hash is required
data ExactName name ref
ExactName :: name -> ref -> ExactName name ref
[$sel:name:ExactName] :: ExactName name ref -> name
[$sel:ref:ExactName] :: ExactName name ref -> ref
exactToHQ :: ExactName name ShortHash -> HashQualified name
exactToHQ' :: ExactName name ShortHash -> HashQualified name
newtype Suffixify
Suffixify :: Bool -> Suffixify
[$sel:suffixified:Suffixify] :: Suffixify -> Bool
data TermDefinition
TermDefinition :: [HashQualifiedName] -> HashQualifiedName -> TermTag -> DisplayObject SyntaxText SyntaxText -> SyntaxText -> [(HashQualifiedName, UnisonHash, Doc)] -> TermDefinition
[$sel:termNames:TermDefinition] :: TermDefinition -> [HashQualifiedName]
[$sel:bestTermName:TermDefinition] :: TermDefinition -> HashQualifiedName
[$sel:defnTermTag:TermDefinition] :: TermDefinition -> TermTag
[$sel:termDefinition:TermDefinition] :: TermDefinition -> DisplayObject SyntaxText SyntaxText
[$sel:signature:TermDefinition] :: TermDefinition -> SyntaxText
[$sel:termDocs:TermDefinition] :: TermDefinition -> [(HashQualifiedName, UnisonHash, Doc)]
data TypeDefinition
TypeDefinition :: [HashQualifiedName] -> HashQualifiedName -> TypeTag -> DisplayObject SyntaxText SyntaxText -> [(HashQualifiedName, UnisonHash, Doc)] -> TypeDefinition
[$sel:typeNames:TypeDefinition] :: TypeDefinition -> [HashQualifiedName]
[$sel:bestTypeName:TypeDefinition] :: TypeDefinition -> HashQualifiedName
[$sel:defnTypeTag:TypeDefinition] :: TypeDefinition -> TypeTag
[$sel:typeDefinition:TypeDefinition] :: TypeDefinition -> DisplayObject SyntaxText SyntaxText
[$sel:typeDocs:TypeDefinition] :: TypeDefinition -> [(HashQualifiedName, UnisonHash, Doc)]
data DefinitionDisplayResults
DefinitionDisplayResults :: Map UnisonHash TermDefinition -> Map UnisonHash TypeDefinition -> [HashQualifiedName] -> DefinitionDisplayResults
[$sel:termDefinitions:DefinitionDisplayResults] :: DefinitionDisplayResults -> Map UnisonHash TermDefinition
[$sel:typeDefinitions:DefinitionDisplayResults] :: DefinitionDisplayResults -> Map UnisonHash TypeDefinition
[$sel:missingDefinitions:DefinitionDisplayResults] :: DefinitionDisplayResults -> [HashQualifiedName]
data TermTag
Doc :: TermTag
Test :: TermTag
Plain :: TermTag
Constructor :: TypeTag -> TermTag
data TypeTag
Ability :: TypeTag
Data :: TypeTag
data UnisonRef
TypeRef :: UnisonHash -> UnisonRef
TermRef :: UnisonHash -> UnisonRef
data FoundEntry
FoundTerm :: NamedTerm -> FoundEntry
FoundType :: NamedType -> FoundEntry
unisonRefToText :: UnisonRef -> Text
data NamedTerm
NamedTerm :: HashQualified NameSegment -> ShortHash -> Maybe SyntaxText -> TermTag -> NamedTerm
[$sel:termName:NamedTerm] :: NamedTerm -> HashQualified NameSegment
[$sel:termHash:NamedTerm] :: NamedTerm -> ShortHash
[$sel:termType:NamedTerm] :: NamedTerm -> Maybe SyntaxText
[$sel:termTag:NamedTerm] :: NamedTerm -> TermTag
data NamedType
NamedType :: HashQualified NameSegment -> ShortHash -> TypeTag -> NamedType
[$sel:typeName:NamedType] :: NamedType -> HashQualified NameSegment
[$sel:typeHash:NamedType] :: NamedType -> ShortHash
[$sel:typeTag:NamedType] :: NamedType -> TypeTag
munge :: Text -> ByteString
mungeShow :: Show s => s -> ByteString
mungeString :: String -> ByteString
defaultWidth :: Width
discard :: Applicative m => a -> m ()
mayDefaultWidth :: Maybe Width -> Width
setCacheControl :: v -> APIHeaders v
branchToUnisonHash :: Branch m -> UnisonHash
v2CausalBranchToUnisonHash :: CausalBranch m -> UnisonHash
instance (GHC.Classes.Ord name, GHC.Classes.Ord ref) => GHC.Classes.Ord (Unison.Server.Types.ExactName name ref)
instance (GHC.Classes.Eq name, GHC.Classes.Eq ref) => GHC.Classes.Eq (Unison.Server.Types.ExactName name ref)
instance (GHC.Show.Show name, GHC.Show.Show ref) => GHC.Show.Show (Unison.Server.Types.ExactName name ref)
instance GHC.Generics.Generic Unison.Server.Types.Suffixify
instance GHC.Show.Show Unison.Server.Types.Suffixify
instance GHC.Classes.Ord Unison.Server.Types.Suffixify
instance GHC.Classes.Eq Unison.Server.Types.Suffixify
instance GHC.Generics.Generic Unison.Server.Types.TypeTag
instance GHC.Show.Show Unison.Server.Types.TypeTag
instance GHC.Classes.Ord Unison.Server.Types.TypeTag
instance GHC.Classes.Eq Unison.Server.Types.TypeTag
instance GHC.Generics.Generic Unison.Server.Types.TermTag
instance GHC.Show.Show Unison.Server.Types.TermTag
instance GHC.Classes.Ord Unison.Server.Types.TermTag
instance GHC.Classes.Eq Unison.Server.Types.TermTag
instance GHC.Generics.Generic Unison.Server.Types.TermDefinition
instance GHC.Show.Show Unison.Server.Types.TermDefinition
instance GHC.Classes.Eq Unison.Server.Types.TermDefinition
instance GHC.Generics.Generic Unison.Server.Types.TypeDefinition
instance GHC.Show.Show Unison.Server.Types.TypeDefinition
instance GHC.Classes.Eq Unison.Server.Types.TypeDefinition
instance GHC.Generics.Generic Unison.Server.Types.DefinitionDisplayResults
instance GHC.Show.Show Unison.Server.Types.DefinitionDisplayResults
instance GHC.Classes.Eq Unison.Server.Types.DefinitionDisplayResults
instance GHC.Generics.Generic Unison.Server.Types.UnisonRef
instance GHC.Show.Show Unison.Server.Types.UnisonRef
instance GHC.Classes.Ord Unison.Server.Types.UnisonRef
instance GHC.Classes.Eq Unison.Server.Types.UnisonRef
instance GHC.Show.Show Unison.Server.Types.NamedTerm
instance GHC.Generics.Generic Unison.Server.Types.NamedTerm
instance GHC.Classes.Eq Unison.Server.Types.NamedTerm
instance GHC.Show.Show Unison.Server.Types.NamedType
instance GHC.Generics.Generic Unison.Server.Types.NamedType
instance GHC.Classes.Eq Unison.Server.Types.NamedType
instance GHC.Generics.Generic Unison.Server.Types.FoundEntry
instance GHC.Show.Show Unison.Server.Types.FoundEntry
instance GHC.Classes.Eq Unison.Server.Types.FoundEntry
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Server.Types.Suffixify
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Server.Types.Suffixify
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TypeDefinition
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TermDefinition
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.DefinitionDisplayResults
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.FoundEntry
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.NamedTerm
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.NamedType
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TermTag
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TypeTag
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.FoundEntry
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.NamedType
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Types.NamedType
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.NamedTerm
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Types.NamedTerm
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.DefinitionDisplayResults
instance GHC.Base.Semigroup Unison.Server.Types.DefinitionDisplayResults
instance GHC.Base.Monoid Unison.Server.Types.DefinitionDisplayResults
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TermDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TermTag
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Types.TermTag
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TypeTag
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Types.TypeTag
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema (Unison.Server.Types.ExactName Unison.Name.Internal.Name Unison.ShortHash.ShortHash)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "exact-name" (Unison.Server.Types.ExactName Unison.Name.Internal.Name Unison.ShortHash.ShortHash))
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "fqn" (Unison.Server.Types.ExactName Unison.Name.Internal.Name Unison.ShortHash.ShortHash))
instance Data.Bifunctor.Bifunctor Unison.Server.Types.ExactName
instance Data.Bifoldable.Bifoldable Unison.Server.Types.ExactName
instance Data.Bitraversable.Bitraversable Unison.Server.Types.ExactName
instance Web.Internal.HttpApiData.FromHttpApiData (Unison.Server.Types.ExactName Unison.Name.Internal.Name Unison.ShortHash.ShortHash)

module Unison.Server.Backend
type SyntaxText = SyntaxText' Reference
data ShallowListEntry v a
ShallowTermEntry :: TermEntry v a -> ShallowListEntry v a
ShallowTypeEntry :: TypeEntry -> ShallowListEntry v a
ShallowBranchEntry :: NameSegment -> CausalHash -> NamespaceStats -> ShallowListEntry v a
ShallowPatchEntry :: NameSegment -> ShallowListEntry v a
listEntryName :: ShallowListEntry v a -> Text
data BackendError
NoSuchNamespace :: Absolute -> BackendError
BadNamespace :: String -> String -> BackendError
CouldntExpandBranchHash :: ShortCausalHash -> BackendError
AmbiguousBranchHash :: ShortCausalHash -> Set ShortCausalHash -> BackendError
AmbiguousHashForDefinition :: ShortHash -> BackendError
NoBranchForHash :: CausalHash -> BackendError
CouldntLoadBranch :: CausalHash -> BackendError
MissingSignatureForTerm :: Reference -> BackendError
NoSuchDefinition :: HashQualified Name -> BackendError
newtype BackendEnv
BackendEnv :: Bool -> BackendEnv

-- | Whether to use the sqlite name-lookup table to generate Names objects
--   rather than building Names from the root branch.
[$sel:useNamesIndex:BackendEnv] :: BackendEnv -> Bool
newtype Backend m a
Backend :: ReaderT BackendEnv (ExceptT BackendError m) a -> Backend m a
[$sel:runBackend:Backend] :: Backend m a -> ReaderT BackendEnv (ExceptT BackendError m) a
hoistBackend :: (forall x. m x -> n x) -> Backend m a -> Backend n a
suffixifyNames :: Int -> Names -> PrettyPrintEnv
namesForBranch :: Branch m -> NameScoping -> (Names, Names, Names)
basicSuffixifiedNames :: Int -> Branch m -> NameScoping -> PrettyPrintEnv
parseNamesForBranch :: Branch m -> NameScoping -> Names
prettyNamesForBranch :: Branch m -> NameScoping -> Names
shallowPPE :: MonadIO m => Codebase m v a -> Branch m -> m PrettyPrintEnv

-- | A <a>Names</a> which only includes mappings for things _directly_
--   accessible from the branch.
--   
--   I.e. names in nested children are omitted. This should probably live
--   elsewhere, but the package dependency graph makes it hard to find a
--   good place.
shallowNames :: forall m v a. Monad m => Codebase m v a -> Branch m -> Transaction Names
loadReferentType :: Codebase m Symbol Ann -> Referent -> Transaction (Maybe (Type Symbol Ann))
data TermEntry v a
TermEntry :: Referent -> ShortHash -> NameSegment -> Bool -> Maybe (Type v a) -> TermTag -> TermEntry v a
[$sel:termEntryReferent:TermEntry] :: TermEntry v a -> Referent
[$sel:termEntryHash:TermEntry] :: TermEntry v a -> ShortHash
[$sel:termEntryName:TermEntry] :: TermEntry v a -> NameSegment
[$sel:termEntryConflicted:TermEntry] :: TermEntry v a -> Bool
[$sel:termEntryType:TermEntry] :: TermEntry v a -> Maybe (Type v a)
[$sel:termEntryTag:TermEntry] :: TermEntry v a -> TermTag
termEntryDisplayName :: TermEntry v a -> Text
termEntryHQName :: TermEntry v a -> HashQualified NameSegment
data TypeEntry
TypeEntry :: Reference -> ShortHash -> NameSegment -> Bool -> TypeTag -> TypeEntry
[$sel:typeEntryReference:TypeEntry] :: TypeEntry -> Reference
[$sel:typeEntryHash:TypeEntry] :: TypeEntry -> ShortHash
[$sel:typeEntryName:TypeEntry] :: TypeEntry -> NameSegment
[$sel:typeEntryConflicted:TypeEntry] :: TypeEntry -> Bool
[$sel:typeEntryTag:TypeEntry] :: TypeEntry -> TypeTag
typeEntryDisplayName :: TypeEntry -> Text
typeEntryHQName :: TypeEntry -> HashQualified NameSegment
data FoundRef
FoundTermRef :: Referent -> FoundRef
FoundTypeRef :: Reference -> FoundRef
fuzzyFind :: Names -> String -> [(Alignment, UnisonName, [FoundRef])]
lsAtPath :: MonadIO m => Codebase m Symbol Ann -> Maybe (Branch Transaction) -> Absolute -> m [ShallowListEntry Symbol Ann]
findShallowReadmeInBranchAndRender :: Width -> Runtime Symbol -> Codebase IO Symbol Ann -> PrettyPrintEnvDecl -> Branch m -> Backend IO (Maybe Doc)
isDoc :: Codebase m Symbol Ann -> Referent -> Transaction Bool
isDoc' :: (Var v, Monoid loc) => Maybe (Type v loc) -> Bool
doc1Type :: (Ord v, Monoid a) => Type v a
doc2Type :: (Ord v, Monoid a) => Type v a
isTestResultList :: forall v a. (Var v, Monoid a) => Maybe (Type v a) -> Bool
resultListType :: (Ord v, Monoid a) => Type v a
termListEntry :: MonadIO m => Codebase m Symbol Ann -> Branch n -> ExactName NameSegment Referent -> m (TermEntry Symbol Ann)
getTermTag :: (Var v, MonadIO m) => Codebase m v a -> Referent -> Maybe (Type v Ann) -> m TermTag
getTypeTag :: Var v => Codebase m v Ann -> Reference -> Transaction TypeTag
typeListEntry :: Var v => Codebase m v Ann -> Branch n -> ExactName NameSegment Reference -> Transaction TypeEntry
typeDeclHeader :: forall v m. Var v => Codebase m v Ann -> PrettyPrintEnv -> Reference -> Transaction (DisplayObject SyntaxText SyntaxText)
formatTypeName :: PrettyPrintEnv -> Reference -> SyntaxText
formatTypeName' :: PrettyPrintEnv -> Reference -> SyntaxText
termEntryToNamedTerm :: Var v => PrettyPrintEnv -> Maybe Width -> TermEntry v a -> NamedTerm
typeEntryToNamedType :: TypeEntry -> NamedType

-- | Find all definitions and children reachable from the given
--   <a>Branch</a>,
lsBranch :: MonadIO m => Codebase m Symbol Ann -> Branch n -> m [ShallowListEntry Symbol Ann]

-- | Look up types in the codebase by short hash, and include builtins.
typeReferencesByShortHash :: ShortHash -> Transaction (Set Reference)
termReferencesByShortHash :: ShortHash -> Transaction (Set Reference)

-- | Look up terms in the codebase by short hash, and include builtins.
termReferentsByShortHash :: Codebase m v a -> ShortHash -> Transaction (Set Referent)

-- | Configure how names will be constructed and filtered. this is
--   typically used when fetching names for printing source code or when
--   finding definitions by name.
data NameScoping

-- | Find all names, making any names which are children of this path,
--   otherwise leave them absolute.
AllNames :: Path -> NameScoping

-- | Filter returned names to only include names within this path.
Within :: Path -> NameScoping
toAllNames :: NameScoping -> NameScoping
getCurrentPrettyNames :: Int -> NameScoping -> Branch m -> PrettyPrintEnvDecl
getCurrentParseNames :: NameScoping -> Branch m -> NamesWithHistory
fixupNamesRelative :: Absolute -> Names -> Names

-- | A <tt>Search r</tt> is a small bag of functions that is used to power
--   a search for <tt>r</tt>s.
--   
--   Construct a <a>Search</a> with <a>makeTypeSearch</a> or
--   <a>makeTermSearch</a>, and eliminate it with <a>applySearch</a>.
data Search r
Search :: (r -> Set (HashQualified Name)) -> (HashQualified Name -> Set r) -> (HashQualified Name -> r -> Set (HashQualified Name) -> SearchResult) -> (Name -> r -> HashQualified Name -> Bool) -> Search r
[$sel:lookupNames:Search] :: Search r -> r -> Set (HashQualified Name)
[$sel:lookupRelativeHQRefs':Search] :: Search r -> HashQualified Name -> Set r
[$sel:makeResult:Search] :: Search r -> HashQualified Name -> r -> Set (HashQualified Name) -> SearchResult
[$sel:matchesNamedRef:Search] :: Search r -> Name -> r -> HashQualified Name -> Bool
data NameSearch
NameSearch :: Search Reference -> Search Referent -> NameSearch
[$sel:typeSearch:NameSearch] :: NameSearch -> Search Reference
[$sel:termSearch:NameSearch] :: NameSearch -> Search Referent

-- | Make a type search, given a short hash length and names to search in.
makeTypeSearch :: Int -> NamesWithHistory -> Search Reference

-- | Make a term search, given a short hash length and names to search in.
makeTermSearch :: Int -> NamesWithHistory -> Search Referent
makeNameSearch :: Int -> NamesWithHistory -> NameSearch

-- | Interpret a <a>Search</a> as a function from name to search results.
applySearch :: Show r => Search r -> HashQualified Name -> [SearchResult]
hqNameQuery :: Codebase m v Ann -> NameSearch -> [HashQualified Name] -> Transaction QueryResult
data DefinitionResults
DefinitionResults :: Map Reference (DisplayObject (Type Symbol Ann) (Term Symbol Ann)) -> Map Reference (DisplayObject () (Decl Symbol Ann)) -> [HashQualified Name] -> DefinitionResults
[$sel:termResults:DefinitionResults] :: DefinitionResults -> Map Reference (DisplayObject (Type Symbol Ann) (Term Symbol Ann))
[$sel:typeResults:DefinitionResults] :: DefinitionResults -> Map Reference (DisplayObject () (Decl Symbol Ann))
[$sel:noResults:DefinitionResults] :: DefinitionResults -> [HashQualified Name]
expandShortCausalHash :: ShortCausalHash -> Backend Transaction CausalHash

-- | Efficiently resolve a root hash and path to a shallow branch's causal.
getShallowCausalAtPathFromRootHash :: Maybe CausalHash -> Path -> Transaction (CausalBranch Transaction)
formatType' :: Var v => PrettyPrintEnv -> Width -> Type v a -> SyntaxText
formatType :: Var v => PrettyPrintEnv -> Width -> Type v a -> SyntaxText
formatSuffixedType :: Var v => PrettyPrintEnvDecl -> Width -> Type v Ann -> SyntaxText
mungeSyntaxText :: Functor g => g (Element Reference) -> g Element

-- | Renders a definition for the given name or hash alongside its
--   documentation.
prettyDefinitionsForHQName :: Path -> Maybe CausalHash -> Maybe Width -> Suffixify -> Runtime Symbol -> Codebase IO Symbol Ann -> HashQualified Name -> Backend IO DefinitionDisplayResults

-- | Fetch the docs associated with the given name. Returns all references
--   with a Doc type which are at the name provided, or at
--   '<a>name</a>.doc'.
docsForDefinitionName :: Codebase IO Symbol Ann -> NameSearch -> Name -> IO [TermReference]
renderDoc :: PrettyPrintEnvDecl -> Width -> Runtime Symbol -> Codebase IO Symbol Ann -> TermReference -> IO (HashQualifiedName, UnisonHash, Doc)
docsInBranchToHtmlFiles :: Runtime Symbol -> Codebase IO Symbol Ann -> Branch IO -> Path -> FilePath -> IO ()
bestNameForTerm :: forall v. Var v => PrettyPrintEnv -> Width -> Referent -> Text
bestNameForType :: forall v. Var v => PrettyPrintEnv -> Width -> Reference -> Text

-- | Returns (parse, pretty, local, ppe) where:
--   
--   <ul>
--   <li><tt>parse</tt> includes ALL fully qualified names from the root,
--   and ALSO all names from within the provided path, relative to that
--   path.</li>
--   <li><tt>pretty</tt> includes names within the provided path, relative
--   to that path, and also all globally scoped names _outside_ of the
--   path</li>
--   <li><a>local</a> includes ONLY the names within the provided path</li>
--   <li><tt>ppe</tt> is a ppe which searches for a name within the path
--   first, but falls back to a global name search. The
--   <a>$sel:suffixified:Suffixify</a> component of this ppe will search
--   for the shortest unambiguous suffix within the scope in which the name
--   is found (local, falling back to global)</li>
--   </ul>
scopedNamesForBranchHash :: forall m n v a. MonadIO m => Codebase m v a -> Maybe (CausalBranch n) -> Path -> Backend m (Names, PrettyPrintEnvDecl)
resolveCausalHash :: Monad m => Maybe CausalHash -> Codebase m v a -> Backend m (Branch m)
resolveCausalHashV2 :: Maybe CausalHash -> Transaction (CausalBranch Transaction)
resolveRootBranchHash :: MonadIO m => Maybe ShortCausalHash -> Codebase m v a -> Backend m (Branch m)
resolveRootBranchHashV2 :: Maybe ShortCausalHash -> Backend Transaction (CausalBranch Transaction)

-- | Determines whether we include full cycles in the results, (e.g. if I
--   search for <tt>isEven</tt>, will I find <tt>isOdd</tt> too?)
--   
--   This was once used for both term and decl components, but now is only
--   used for decl components, because <tt>update</tt> does The Right Thing
--   for terms (i.e. propagates changes to all dependents, including
--   component-mates, which are de facto dependents).
--   
--   Ticket of interest:
--   <a>https://github.com/unisonweb/unison/issues/3445</a>
data IncludeCycles
IncludeCycles :: IncludeCycles
DontIncludeCycles :: IncludeCycles
definitionsBySuffixes :: Codebase m Symbol Ann -> NameSearch -> IncludeCycles -> [HashQualified Name] -> Transaction DefinitionResults
displayTerm :: Codebase m Symbol Ann -> Reference -> Transaction (DisplayObject (Type Symbol Ann) (Term Symbol Ann))
displayType :: Codebase m Symbol Ann -> Reference -> Transaction (DisplayObject () (Decl Symbol Ann))
termsToSyntax :: Var v => Ord a => Suffixify -> Width -> PrettyPrintEnvDecl -> Map Reference (DisplayObject (Type v a) (Term v a)) -> Map Reference (DisplayObject SyntaxText SyntaxText)
typesToSyntax :: Var v => Ord a => Suffixify -> Width -> PrettyPrintEnvDecl -> Map Reference (DisplayObject () (Decl v a)) -> Map Reference (DisplayObject SyntaxText SyntaxText)

-- | Renders a type to its decl header, e.g.
--   
--   Effect:
--   
--   unique ability Stream s
--   
--   Data:
--   
--   structural type Maybe a
typeToSyntaxHeader :: Width -> HashQualified Name -> DisplayObject () (Decl Symbol Ann) -> DisplayObject SyntaxText SyntaxText
loadSearchResults :: Codebase m Symbol Ann -> [SearchResult] -> Transaction [SearchResult' Symbol Ann]
loadTypeDisplayObject :: Codebase m v Ann -> Reference -> Transaction (DisplayObject () (Decl v Ann))
instance GHC.Show.Show Unison.Server.Backend.BackendError
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError Unison.Server.Backend.BackendError (Unison.Server.Backend.Backend m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Unison.Server.Backend.BackendEnv (Unison.Server.Backend.Backend m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Unison.Server.Backend.Backend m)
instance GHC.Base.Monad m => GHC.Base.Monad (Unison.Server.Backend.Backend m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Unison.Server.Backend.Backend m)
instance GHC.Base.Functor m => GHC.Base.Functor (Unison.Server.Backend.Backend m)
instance GHC.Generics.Generic (Unison.Server.Backend.TermEntry v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Backend.TermEntry v a)
instance U.Core.ABT.Var.Var v => GHC.Classes.Ord (Unison.Server.Backend.TermEntry v a)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Backend.TermEntry v a)
instance GHC.Generics.Generic Unison.Server.Backend.TypeEntry
instance GHC.Show.Show Unison.Server.Backend.TypeEntry
instance GHC.Classes.Ord Unison.Server.Backend.TypeEntry
instance GHC.Classes.Eq Unison.Server.Backend.TypeEntry
instance GHC.Generics.Generic (Unison.Server.Backend.ShallowListEntry v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Backend.ShallowListEntry v a)
instance U.Core.ABT.Var.Var v => GHC.Classes.Ord (Unison.Server.Backend.ShallowListEntry v a)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Backend.ShallowListEntry v a)
instance GHC.Generics.Generic Unison.Server.Backend.FoundRef
instance GHC.Show.Show Unison.Server.Backend.FoundRef
instance GHC.Classes.Ord Unison.Server.Backend.FoundRef
instance GHC.Classes.Eq Unison.Server.Backend.FoundRef
instance Control.Monad.Trans.Class.MonadTrans Unison.Server.Backend.Backend

module Unison.Server.Errors
badHQN :: HashQualifiedName -> ServerError
backendError :: BackendError -> ServerError
badNamespace :: String -> String -> ServerError
noSuchNamespace :: HashQualifiedName -> ServerError
couldntLoadBranch :: CausalHash -> ServerError
ambiguousNamespace :: HashQualifiedName -> Set HashQualifiedName -> ServerError
missingSigForTerm :: HashQualifiedName -> ServerError
noSuchDefinition :: HashQualified Name -> ServerError
ambiguousHashForDefinition :: ShortHash -> ServerError

module Unison.Server.Endpoints.Projects
type ProjectsAPI = "projects" :> QueryParam "rootBranch" ShortCausalHash :> QueryParam "owner" ProjectOwner :> APIGet [ProjectListing]
newtype ProjectOwner
ProjectOwner :: Text -> ProjectOwner
projectOwnerFromText :: Text -> Either Text ProjectOwner
data ProjectListing
ProjectListing :: ProjectOwner -> Text -> UnisonHash -> ProjectListing
[$sel:owner:ProjectListing] :: ProjectListing -> ProjectOwner
[$sel:name:ProjectListing] :: ProjectListing -> Text
[$sel:hash:ProjectListing] :: ProjectListing -> UnisonHash
backendListEntryToProjectListing :: ProjectOwner -> ShallowListEntry Symbol a -> Maybe ProjectListing
entryToOwner :: ShallowListEntry Symbol a -> Maybe ProjectOwner
serve :: forall m. MonadIO m => Codebase m Symbol Ann -> Maybe ShortCausalHash -> Maybe ProjectOwner -> Backend m [ProjectListing]
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.Projects.ProjectOwner
instance GHC.Show.Show Unison.Server.Endpoints.Projects.ProjectOwner
instance GHC.Generics.Generic Unison.Server.Endpoints.Projects.ProjectOwner
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.Projects.ProjectListing
instance GHC.Show.Show Unison.Server.Endpoints.Projects.ProjectListing
instance GHC.Generics.Generic Unison.Server.Endpoints.Projects.ProjectListing
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Server.Endpoints.Projects.ProjectOwner
instance Servant.Docs.Internal.ToSample Unison.Server.Endpoints.Projects.ProjectListing
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.Projects.ProjectListing
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "owner" Unison.Server.Endpoints.Projects.ProjectOwner)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.Projects.ProjectOwner
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Server.Endpoints.Projects.ProjectOwner

module Unison.Server.Endpoints.NamespaceListing
serve :: Codebase IO Symbol Ann -> Maybe ShortCausalHash -> Maybe Path -> Maybe Path -> Backend IO NamespaceListing
type NamespaceListingAPI = "list" :> QueryParam "rootBranch" ShortCausalHash :> QueryParam "relativeTo" Path :> QueryParam "namespace" Path :> APIGet NamespaceListing
data NamespaceListing
NamespaceListing :: UnisonName -> UnisonHash -> [NamespaceObject] -> NamespaceListing
[$sel:namespaceListingFQN:NamespaceListing] :: NamespaceListing -> UnisonName
[$sel:namespaceListingHash:NamespaceListing] :: NamespaceListing -> UnisonHash
[$sel:namespaceListingChildren:NamespaceListing] :: NamespaceListing -> [NamespaceObject]
data NamespaceObject
Subnamespace :: NamedNamespace -> NamespaceObject
TermObject :: NamedTerm -> NamespaceObject
TypeObject :: NamedType -> NamespaceObject
PatchObject :: NamedPatch -> NamespaceObject
data NamedNamespace
NamedNamespace :: UnisonName -> UnisonHash -> Int -> NamedNamespace
[$sel:namespaceName:NamedNamespace] :: NamedNamespace -> UnisonName
[$sel:namespaceHash:NamedNamespace] :: NamedNamespace -> UnisonHash
[$sel:namespaceSize:NamedNamespace] :: NamedNamespace -> Int
newtype NamedPatch
NamedPatch :: HashQualifiedName -> NamedPatch
[$sel:patchName:NamedPatch] :: NamedPatch -> HashQualifiedName
newtype KindExpression
KindExpression :: Text -> KindExpression
[$sel:kindExpressionText:KindExpression] :: KindExpression -> Text
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceListing.NamedNamespace
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceListing.NamedNamespace
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceListing.NamedPatch
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceListing.NamedPatch
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceListing.NamedPatch
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceListing.NamespaceObject
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceListing.NamespaceObject
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceListing.NamespaceListing
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceListing.NamespaceListing
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceListing.KindExpression
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceListing.KindExpression
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceListing.KindExpression
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceListing.NamespaceListing
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceListing.NamespaceObject
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceListing.NamedNamespace
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceListing.KindExpression
instance Servant.Docs.Internal.ToSample Unison.Server.Endpoints.NamespaceListing.NamespaceListing
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceListing.NamespaceListing
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Endpoints.NamespaceListing.NamespaceListing
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceListing.NamespaceObject
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Endpoints.NamespaceListing.NamespaceObject
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceListing.NamedPatch
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Endpoints.NamespaceListing.NamedPatch
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceListing.NamedNamespace
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Endpoints.NamespaceListing.NamedNamespace
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "namespace" Data.Text.Internal.Text)

module Unison.Server.Endpoints.NamespaceDetails
type NamespaceDetailsAPI = "namespaces" :> Capture "namespace" Path :> QueryParam "rootBranch" ShortCausalHash :> QueryParam "renderWidth" Width :> APIGet NamespaceDetails
data NamespaceDetails
NamespaceDetails :: Path -> UnisonHash -> Maybe Doc -> NamespaceDetails
[$sel:fqn:NamespaceDetails] :: NamespaceDetails -> Path
[$sel:hash:NamespaceDetails] :: NamespaceDetails -> UnisonHash
[$sel:readme:NamespaceDetails] :: NamespaceDetails -> Maybe Doc
namespaceDetails :: Runtime Symbol -> Codebase IO Symbol Ann -> Path -> Maybe ShortCausalHash -> Maybe Width -> Backend IO NamespaceDetails
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceDetails.NamespaceDetails
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceDetails.NamespaceDetails
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceDetails.NamespaceDetails
instance Servant.Docs.Internal.ToSample Unison.Server.Endpoints.NamespaceDetails.NamespaceDetails
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceDetails.NamespaceDetails
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "namespace" Data.Text.Internal.Text)

module Unison.Server.Endpoints.GetDefinitions
type DefinitionsAPI = "getDefinition" :> QueryParam "rootBranch" ShortCausalHash :> QueryParam "relativeTo" Path :> QueryParams "names" (HashQualified Name) :> QueryParam "renderWidth" Width :> QueryParam "suffixifyBindings" Suffixify :> APIGet DefinitionDisplayResults
serveDefinitions :: Runtime Symbol -> Codebase IO Symbol Ann -> Maybe ShortCausalHash -> Maybe Path -> [HashQualified Name] -> Maybe Width -> Maybe Suffixify -> Backend IO DefinitionDisplayResults
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "renderWidth" Unison.Util.Pretty.Width)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "suffixifyBindings" Unison.Server.Types.Suffixify)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "relativeTo" Unison.Codebase.Path.Path)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "namespace" Unison.Codebase.Path.Path)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "rootBranch" Unison.Codebase.ShortCausalHash.ShortCausalHash)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParams "names" (Unison.HashQualified.HashQualified Unison.Name.Internal.Name))
instance Servant.Docs.Internal.ToSample Unison.Server.Types.DefinitionDisplayResults

module Unison.Server.Endpoints.FuzzyFind
type FuzzyFindAPI = "find" :> QueryParam "rootBranch" ShortCausalHash :> QueryParam "relativeTo" Path :> QueryParam "limit" Int :> QueryParam "renderWidth" Width :> QueryParam "query" String :> APIGet [(Alignment, FoundResult)]
data FoundTerm
FoundTerm :: HashQualifiedName -> NamedTerm -> FoundTerm
[$sel:bestFoundTermName:FoundTerm] :: FoundTerm -> HashQualifiedName
[$sel:namedTerm:FoundTerm] :: FoundTerm -> NamedTerm
data FoundType
FoundType :: HashQualifiedName -> DisplayObject SyntaxText SyntaxText -> NamedType -> FoundType
[$sel:bestFoundTypeName:FoundType] :: FoundType -> HashQualifiedName
[$sel:typeDef:FoundType] :: FoundType -> DisplayObject SyntaxText SyntaxText
[$sel:namedType:FoundType] :: FoundType -> NamedType
data FoundResult
FoundTermResult :: FoundTerm -> FoundResult
FoundTypeResult :: FoundType -> FoundResult
serveFuzzyFind :: forall m. MonadIO m => Codebase m Symbol Ann -> Maybe ShortCausalHash -> Maybe Path -> Maybe Int -> Maybe Width -> Maybe String -> Backend m [(Alignment, FoundResult)]
instance GHC.Show.Show Unison.Server.Endpoints.FuzzyFind.FoundTerm
instance GHC.Generics.Generic Unison.Server.Endpoints.FuzzyFind.FoundTerm
instance GHC.Show.Show Unison.Server.Endpoints.FuzzyFind.FoundType
instance GHC.Generics.Generic Unison.Server.Endpoints.FuzzyFind.FoundType
instance GHC.Show.Show Unison.Server.Endpoints.FuzzyFind.FoundResult
instance GHC.Generics.Generic Unison.Server.Endpoints.FuzzyFind.FoundResult
instance Data.OpenApi.Internal.Schema.ToSchema Text.FuzzyFind.Alignment
instance Data.OpenApi.Internal.Schema.ToSchema Text.FuzzyFind.Result
instance Data.OpenApi.Internal.Schema.ToSchema Text.FuzzyFind.ResultSegment
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.FuzzyFind.FoundType
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.FuzzyFind.FoundTerm
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.FuzzyFind.FoundResult
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.FuzzyFind.FoundResult
instance Servant.Docs.Internal.ToSample Unison.Server.Endpoints.FuzzyFind.FoundResult
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.FuzzyFind.FoundType
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.FuzzyFind.FoundTerm
instance Servant.Docs.Internal.ToSample Text.FuzzyFind.Alignment
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "limit" GHC.Types.Int)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "query" GHC.Base.String)
instance Data.Aeson.Types.ToJSON.ToJSON Text.FuzzyFind.Alignment
instance Data.Aeson.Types.ToJSON.ToJSON Text.FuzzyFind.Result
instance Data.Aeson.Types.ToJSON.ToJSON Text.FuzzyFind.ResultSegment

module Unison.Server.Endpoints.DefinitionSummary
type TermSummaryAPI = "definitions" :> "terms" :> "by-hash" :> Capture "hash" Referent :> "summary" :> QueryParam "name" Name :> QueryParam "rootBranch" ShortCausalHash :> QueryParam "relativeTo" Path :> QueryParam "renderWidth" Width :> APIGet TermSummary
serveTermSummary :: Codebase IO Symbol Ann -> Referent -> Maybe Name -> Maybe ShortCausalHash -> Maybe Path -> Maybe Width -> Backend IO TermSummary
data TermSummary
TermSummary :: HashQualified Name -> ShortHash -> DisplayObject SyntaxText SyntaxText -> TermTag -> TermSummary
[$sel:displayName:TermSummary] :: TermSummary -> HashQualified Name
[$sel:hash:TermSummary] :: TermSummary -> ShortHash
[$sel:summary:TermSummary] :: TermSummary -> DisplayObject SyntaxText SyntaxText
[$sel:tag:TermSummary] :: TermSummary -> TermTag
type TypeSummaryAPI = "definitions" :> "types" :> "by-hash" :> Capture "hash" Reference :> "summary" :> QueryParam "name" Name :> QueryParam "rootBranch" ShortCausalHash :> QueryParam "relativeTo" Path :> QueryParam "renderWidth" Width :> APIGet TypeSummary
serveTypeSummary :: Codebase IO Symbol Ann -> Reference -> Maybe Name -> Maybe ShortCausalHash -> Maybe Path -> Maybe Width -> Backend IO TypeSummary
data TypeSummary
TypeSummary :: HashQualified Name -> ShortHash -> DisplayObject SyntaxText SyntaxText -> TypeTag -> TypeSummary
[$sel:displayName:TypeSummary] :: TypeSummary -> HashQualified Name
[$sel:hash:TypeSummary] :: TypeSummary -> ShortHash
[$sel:summary:TypeSummary] :: TypeSummary -> DisplayObject SyntaxText SyntaxText
[$sel:tag:TypeSummary] :: TypeSummary -> TypeTag
instance GHC.Show.Show Unison.Server.Endpoints.DefinitionSummary.TermSummary
instance GHC.Generics.Generic Unison.Server.Endpoints.DefinitionSummary.TermSummary
instance GHC.Show.Show Unison.Server.Endpoints.DefinitionSummary.TypeSummary
instance GHC.Generics.Generic Unison.Server.Endpoints.DefinitionSummary.TypeSummary
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.DefinitionSummary.TermSummary
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.DefinitionSummary.TypeSummary
instance Servant.Docs.Internal.ToSample Unison.Server.Endpoints.DefinitionSummary.TypeSummary
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.DefinitionSummary.TypeSummary
instance Servant.Docs.Internal.ToSample Unison.Server.Endpoints.DefinitionSummary.TermSummary
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.DefinitionSummary.TermSummary

module Unison.Server.CodebaseServer
data HTML
HTML :: HTML
newtype RawHtml
RawHtml :: ByteString -> RawHtml
[$sel:unRaw:RawHtml] :: RawHtml -> ByteString
type OpenApiJSON = "openapi.json" :> Get '[JSON] OpenApi
type UnisonAndDocsAPI = UnisonAPI :<|> OpenApiJSON :<|> Raw
type UnisonAPI = NamespaceListingAPI :<|> NamespaceDetailsAPI :<|> ProjectsAPI :<|> DefinitionsAPI :<|> FuzzyFindAPI :<|> TermSummaryAPI :<|> TypeSummaryAPI
type WebUI = CaptureAll "route" Text :> Get '[HTML] RawHtml
type ServerAPI = ("ui" :> WebUI) :<|> ("api" :> UnisonAndDocsAPI)
type StaticAPI = "static" :> Raw
type Authed api = (Capture "token" Text :> api)
type AppAPI = StaticAPI :<|> Authed ServerAPI
data BaseUrl
BaseUrl :: String -> ByteString -> Port -> BaseUrl
[$sel:urlHost:BaseUrl] :: BaseUrl -> String
[$sel:urlToken:BaseUrl] :: BaseUrl -> ByteString
[$sel:urlPort:BaseUrl] :: BaseUrl -> Port
data BaseUrlPath
UI :: BaseUrlPath
Api :: BaseUrlPath
urlFor :: BaseUrlPath -> BaseUrl -> String
handleAuth :: ByteString -> Text -> Handler ()
openAPI :: OpenApi
infoObject :: Info
docsBS :: ByteString
unisonAndDocsAPI :: Proxy UnisonAndDocsAPI
api :: Proxy UnisonAPI
serverAPI :: Proxy ServerAPI
appAPI :: Proxy AppAPI
app :: BackendEnv -> Runtime Symbol -> Codebase IO Symbol Ann -> FilePath -> ByteString -> Maybe String -> Application

-- | The Token is used to help prevent multiple users on a machine gain
--   access to each others codebases.
genToken :: IO ByteString
data Waiter a
Waiter :: (a -> IO ()) -> IO a -> Waiter a
[$sel:notify:Waiter] :: Waiter a -> a -> IO ()
[$sel:waitFor:Waiter] :: Waiter a -> IO a
mkWaiter :: IO (Waiter a)
ucmUIVar :: String
ucmPortVar :: String
ucmHostVar :: String
ucmAllowCorsHost :: String
ucmTokenVar :: String
data CodebaseServerOpts
CodebaseServerOpts :: Maybe String -> Maybe String -> Maybe Int -> Maybe String -> Maybe FilePath -> CodebaseServerOpts
[$sel:token:CodebaseServerOpts] :: CodebaseServerOpts -> Maybe String
[$sel:host:CodebaseServerOpts] :: CodebaseServerOpts -> Maybe String
[$sel:port:CodebaseServerOpts] :: CodebaseServerOpts -> Maybe Int
[$sel:allowCorsHost:CodebaseServerOpts] :: CodebaseServerOpts -> Maybe String
[$sel:codebaseUIPath:CodebaseServerOpts] :: CodebaseServerOpts -> Maybe FilePath
defaultCodebaseServerOpts :: CodebaseServerOpts
startServer :: BackendEnv -> CodebaseServerOpts -> Runtime Symbol -> Codebase IO Symbol Ann -> (BaseUrl -> IO a) -> IO a
serveIndex :: FilePath -> Handler RawHtml
serveUI :: FilePath -> Server WebUI
corsPolicy :: Maybe String -> Middleware
server :: BackendEnv -> Runtime Symbol -> Codebase IO Symbol Ann -> FilePath -> ByteString -> Server AppAPI
serveUnisonAndDocs :: BackendEnv -> Runtime Symbol -> Codebase IO Symbol Ann -> Server UnisonAndDocsAPI
serveDocs :: Application
serveOpenAPI :: Handler OpenApi
hoistWithAuth :: forall api. HasServer api '[] => Proxy api -> ByteString -> ServerT api Handler -> ServerT (Authed api) Handler
serveUnison :: BackendEnv -> Codebase IO Symbol Ann -> Runtime Symbol -> Server UnisonAPI
backendHandler :: BackendEnv -> Backend IO a -> Handler a
instance GHC.Classes.Eq Unison.Server.CodebaseServer.CodebaseServerOpts
instance GHC.Show.Show Unison.Server.CodebaseServer.CodebaseServerOpts
instance GHC.Show.Show Unison.Server.CodebaseServer.BaseUrl
instance Servant.API.ContentTypes.MimeRender Unison.Server.CodebaseServer.HTML Unison.Server.CodebaseServer.RawHtml
instance Servant.API.ContentTypes.Accept Unison.Server.CodebaseServer.HTML
instance Servant.Docs.Internal.ToSample GHC.Types.Char

module Unison.Sync.Types

-- | A newtype for JSON encoding binary data.
newtype Base64Bytes
Base64Bytes :: ByteString -> Base64Bytes
newtype RepoName
RepoName :: Text -> RepoName
[$sel:unRepoName:RepoName] :: RepoName -> Text
data Path
Path :: NonEmpty Text -> Path
[$sel:pathSegments:Path] :: Path -> NonEmpty Text
pathRepoName :: Path -> RepoName
pathCodebasePath :: Path -> [Text]
newtype HashJWT
HashJWT :: Text -> HashJWT
[$sel:unHashJWT:HashJWT] :: HashJWT -> Text

-- | Grab the hash out of a hash JWT.
--   
--   This decodes the whole JWT, then throws away the claims; use it if you
--   really only need the hash!
hashJWTHash :: HashJWT -> Hash32
data HashJWTClaims
HashJWTClaims :: Hash32 -> Maybe Text -> HashJWTClaims
[$sel:hash:HashJWTClaims] :: HashJWTClaims -> Hash32
[$sel:userId:HashJWTClaims] :: HashJWTClaims -> Maybe Text

-- | A decoded hash JWT that retains the original encoded JWT.
data DecodedHashJWT
DecodedHashJWT :: HashJWTClaims -> HashJWT -> DecodedHashJWT
[$sel:claims:DecodedHashJWT] :: DecodedHashJWT -> HashJWTClaims
[$sel:hashJWT:DecodedHashJWT] :: DecodedHashJWT -> HashJWT

-- | Decode a hash JWT.
decodeHashJWT :: HashJWT -> DecodedHashJWT

-- | Decode the claims out of a hash JWT.
decodeHashJWTClaims :: HashJWT -> HashJWTClaims

-- | Grab the hash out of a decoded hash JWT.
decodedHashJWTHash :: DecodedHashJWT -> Hash32
data Entity text noSyncHash hash
TC :: TermComponent text hash -> Entity text noSyncHash hash
DC :: DeclComponent text hash -> Entity text noSyncHash hash
P :: Patch text noSyncHash hash -> Entity text noSyncHash hash
PD :: PatchDiff text noSyncHash hash -> Entity text noSyncHash hash
N :: Namespace text hash -> Entity text noSyncHash hash
ND :: NamespaceDiff text hash -> Entity text noSyncHash hash
C :: Causal hash -> Entity text noSyncHash hash
data TermComponent text hash
TermComponent :: [(LocalIds text hash, ByteString)] -> TermComponent text hash
data DeclComponent text hash
DeclComponent :: [(LocalIds text hash, ByteString)] -> DeclComponent text hash
data Patch text oldHash newHash
Patch :: [text] -> [oldHash] -> [newHash] -> ByteString -> Patch text oldHash newHash
[$sel:textLookup:Patch] :: Patch text oldHash newHash -> [text]
[$sel:oldHashLookup:Patch] :: Patch text oldHash newHash -> [oldHash]
[$sel:newHashLookup:Patch] :: Patch text oldHash newHash -> [newHash]
[$sel:bytes:Patch] :: Patch text oldHash newHash -> ByteString
data PatchDiff text oldHash hash
PatchDiff :: hash -> [text] -> [oldHash] -> [hash] -> ByteString -> PatchDiff text oldHash hash
[$sel:parent:PatchDiff] :: PatchDiff text oldHash hash -> hash
[$sel:textLookup:PatchDiff] :: PatchDiff text oldHash hash -> [text]
[$sel:oldHashLookup:PatchDiff] :: PatchDiff text oldHash hash -> [oldHash]
[$sel:newHashLookup:PatchDiff] :: PatchDiff text oldHash hash -> [hash]
[$sel:bytes:PatchDiff] :: PatchDiff text oldHash hash -> ByteString
data Namespace text hash
Namespace :: [text] -> [hash] -> [hash] -> [(hash, hash)] -> ByteString -> Namespace text hash
[$sel:textLookup:Namespace] :: Namespace text hash -> [text]
[$sel:defnLookup:Namespace] :: Namespace text hash -> [hash]
[$sel:patchLookup:Namespace] :: Namespace text hash -> [hash]
[$sel:childLookup:Namespace] :: Namespace text hash -> [(hash, hash)]
[$sel:bytes:Namespace] :: Namespace text hash -> ByteString
data NamespaceDiff text hash
NamespaceDiff :: hash -> [text] -> [hash] -> [hash] -> [(hash, hash)] -> ByteString -> NamespaceDiff text hash
[$sel:parent:NamespaceDiff] :: NamespaceDiff text hash -> hash
[$sel:textLookup:NamespaceDiff] :: NamespaceDiff text hash -> [text]
[$sel:defnLookup:NamespaceDiff] :: NamespaceDiff text hash -> [hash]
[$sel:patchLookup:NamespaceDiff] :: NamespaceDiff text hash -> [hash]
[$sel:childLookup:NamespaceDiff] :: NamespaceDiff text hash -> [(hash, hash)]
[$sel:bytes:NamespaceDiff] :: NamespaceDiff text hash -> ByteString
data Causal hash
Causal :: hash -> Set hash -> Causal hash
[$sel:namespaceHash:Causal] :: Causal hash -> hash
[$sel:parents:Causal] :: Causal hash -> Set hash
data LocalIds text hash
LocalIds :: [text] -> [hash] -> LocalIds text hash
[$sel:texts:LocalIds] :: LocalIds text hash -> [text]
[$sel:hashes:LocalIds] :: LocalIds text hash -> [hash]

-- | Get the direct dependencies of an entity (which are actually sync'd).
--   
--   FIXME use generic-lens here? (typed @hash)
entityDependencies :: Ord hash => Entity text noSyncHash hash -> Set hash
data EntityType
TermComponentType :: EntityType
DeclComponentType :: EntityType
PatchType :: EntityType
PatchDiffType :: EntityType
NamespaceType :: EntityType
NamespaceDiffType :: EntityType
CausalType :: EntityType
entityHashes_ :: (Applicative m, Ord hash') => (hash -> m hash') -> Entity text noSyncHash hash -> m (Entity text noSyncHash hash')
patchHashes_ :: Applicative m => (hash -> m hash') -> Patch text noSyncHash hash -> m (Patch text noSyncHash hash')
patchDiffHashes_ :: Applicative m => (hash -> m hash') -> PatchDiff text noSyncHash hash -> m (PatchDiff text noSyncHash hash')
namespaceDiffHashes_ :: Applicative m => (hash -> m hash') -> NamespaceDiff text hash -> m (NamespaceDiff text hash')
causalHashes_ :: (Applicative m, Ord hash') => (hash -> m hash') -> Causal hash -> m (Causal hash')
newtype GetCausalHashByPathRequest
GetCausalHashByPathRequest :: Path -> GetCausalHashByPathRequest
[$sel:path:GetCausalHashByPathRequest] :: GetCausalHashByPathRequest -> Path
data GetCausalHashByPathResponse
GetCausalHashByPathSuccess :: Maybe HashJWT -> GetCausalHashByPathResponse
GetCausalHashByPathNoReadPermission :: Path -> GetCausalHashByPathResponse
data DownloadEntitiesRequest
DownloadEntitiesRequest :: RepoName -> NESet HashJWT -> DownloadEntitiesRequest
[$sel:repoName:DownloadEntitiesRequest] :: DownloadEntitiesRequest -> RepoName
[$sel:hashes:DownloadEntitiesRequest] :: DownloadEntitiesRequest -> NESet HashJWT
data DownloadEntitiesResponse
DownloadEntitiesSuccess :: NEMap Hash32 (Entity Text Hash32 HashJWT) -> DownloadEntitiesResponse
DownloadEntitiesNoReadPermission :: RepoName -> DownloadEntitiesResponse
data UploadEntitiesRequest
UploadEntitiesRequest :: RepoName -> NEMap Hash32 (Entity Text Hash32 Hash32) -> UploadEntitiesRequest
[$sel:repoName:UploadEntitiesRequest] :: UploadEntitiesRequest -> RepoName
[$sel:entities:UploadEntitiesRequest] :: UploadEntitiesRequest -> NEMap Hash32 (Entity Text Hash32 Hash32)
data UploadEntitiesResponse
UploadEntitiesSuccess :: UploadEntitiesResponse
UploadEntitiesNeedDependencies :: NeedDependencies Hash32 -> UploadEntitiesResponse
UploadEntitiesNoWritePermission :: RepoName -> UploadEntitiesResponse
UploadEntitiesHashMismatchForEntity :: HashMismatchForEntity -> UploadEntitiesResponse

-- | A non-empty list of causal hashes, latest first, that show the lineage
--   from wherever the client wants to fast-forward to back to wherever the
--   (client believes the) server is (including the server head, in a
--   separate field).
--   
--   For example, if the client wants to update
--   
--   <pre>
--   A -&gt; B -&gt; C
--   </pre>
--   
--   to
--   
--   <pre>
--   A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F
--   </pre>
--   
--   then it would send hashes
--   
--   <pre>
--   expectedHash = C
--   hashes = [D, E, F]
--   </pre>
--   
--   Note that if the client wants to begin a history at a new path on the
--   server, it would use the "update path" endpoint instead.
data FastForwardPathRequest
FastForwardPathRequest :: Hash32 -> NonEmpty Hash32 -> Path -> FastForwardPathRequest

-- | The causal that the client believes exists at
--   <a>$sel:path:GetCausalHashByPathRequest</a>
[$sel:expectedHash:FastForwardPathRequest] :: FastForwardPathRequest -> Hash32

-- | The sequence of causals to fast-forward with, starting from the oldest
--   new causal to the newest new causal
[$sel:hashes:FastForwardPathRequest] :: FastForwardPathRequest -> NonEmpty Hash32

-- | The path to fast-forward
[$sel:path:FastForwardPathRequest] :: FastForwardPathRequest -> Path
data FastForwardPathResponse
FastForwardPathSuccess :: FastForwardPathResponse
FastForwardPathMissingDependencies :: NeedDependencies Hash32 -> FastForwardPathResponse
FastForwardPathNoWritePermission :: Path -> FastForwardPathResponse

-- | This wasn't a fast-forward. Here's a JWT to download the causal head,
--   if you want it.
FastForwardPathNotFastForward :: HashJWT -> FastForwardPathResponse

-- | There was no history at this path; the client should use the "update
--   path" endpoint instead.
FastForwardPathNoHistory :: FastForwardPathResponse

-- | This wasn't a fast-forward. You said the first hash was a parent of
--   the second hash, but I disagree.
FastForwardPathInvalidParentage :: InvalidParentage -> FastForwardPathResponse
data UpdatePathRequest
UpdatePathRequest :: Path -> Maybe Hash32 -> Hash32 -> UpdatePathRequest
[$sel:path:UpdatePathRequest] :: UpdatePathRequest -> Path
[$sel:expectedHash:UpdatePathRequest] :: UpdatePathRequest -> Maybe Hash32
[$sel:newHash:UpdatePathRequest] :: UpdatePathRequest -> Hash32
data UpdatePathResponse
UpdatePathSuccess :: UpdatePathResponse
UpdatePathHashMismatch :: HashMismatch -> UpdatePathResponse
UpdatePathMissingDependencies :: NeedDependencies Hash32 -> UpdatePathResponse
UpdatePathNoWritePermission :: Path -> UpdatePathResponse
data HashMismatch
HashMismatch :: Path -> Maybe Hash32 -> Maybe Hash32 -> HashMismatch
[$sel:path:HashMismatch] :: HashMismatch -> Path
[$sel:expectedHash:HashMismatch] :: HashMismatch -> Maybe Hash32
[$sel:actualHash:HashMismatch] :: HashMismatch -> Maybe Hash32
data HashMismatchForEntity
HashMismatchForEntity :: Hash32 -> Hash32 -> HashMismatchForEntity
[$sel:supplied:HashMismatchForEntity] :: HashMismatchForEntity -> Hash32
[$sel:computed:HashMismatchForEntity] :: HashMismatchForEntity -> Hash32
data InvalidParentage
InvalidParentage :: Hash32 -> Hash32 -> InvalidParentage
[$sel:parent:InvalidParentage] :: InvalidParentage -> Hash32
[$sel:child:InvalidParentage] :: InvalidParentage -> Hash32
data NeedDependencies hash
NeedDependencies :: NESet hash -> NeedDependencies hash
[$sel:missingDependencies:NeedDependencies] :: NeedDependencies hash -> NESet hash
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.RepoName
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.RepoName
instance GHC.Classes.Ord Unison.Sync.Types.RepoName
instance GHC.Classes.Eq Unison.Sync.Types.RepoName
instance GHC.Show.Show Unison.Sync.Types.RepoName
instance GHC.Classes.Ord Unison.Sync.Types.Path
instance GHC.Classes.Eq Unison.Sync.Types.Path
instance GHC.Show.Show Unison.Sync.Types.Path
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.HashJWT
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.HashJWT
instance GHC.Classes.Ord Unison.Sync.Types.HashJWT
instance GHC.Classes.Eq Unison.Sync.Types.HashJWT
instance GHC.Show.Show Unison.Sync.Types.HashJWT
instance GHC.Classes.Ord Unison.Sync.Types.HashJWTClaims
instance GHC.Classes.Eq Unison.Sync.Types.HashJWTClaims
instance GHC.Show.Show Unison.Sync.Types.HashJWTClaims
instance GHC.Show.Show Unison.Sync.Types.DecodedHashJWT
instance GHC.Classes.Ord Unison.Sync.Types.DecodedHashJWT
instance GHC.Classes.Eq Unison.Sync.Types.DecodedHashJWT
instance (GHC.Classes.Ord text, GHC.Classes.Ord hash) => GHC.Classes.Ord (Unison.Sync.Types.LocalIds text hash)
instance (GHC.Classes.Eq text, GHC.Classes.Eq hash) => GHC.Classes.Eq (Unison.Sync.Types.LocalIds text hash)
instance (GHC.Show.Show text, GHC.Show.Show hash) => GHC.Show.Show (Unison.Sync.Types.LocalIds text hash)
instance (GHC.Classes.Ord text, GHC.Classes.Ord hash) => GHC.Classes.Ord (Unison.Sync.Types.DeclComponent text hash)
instance (GHC.Classes.Eq text, GHC.Classes.Eq hash) => GHC.Classes.Eq (Unison.Sync.Types.DeclComponent text hash)
instance (GHC.Show.Show text, GHC.Show.Show hash) => GHC.Show.Show (Unison.Sync.Types.DeclComponent text hash)
instance (GHC.Classes.Ord text, GHC.Classes.Ord hash) => GHC.Classes.Ord (Unison.Sync.Types.TermComponent text hash)
instance (GHC.Classes.Eq text, GHC.Classes.Eq hash) => GHC.Classes.Eq (Unison.Sync.Types.TermComponent text hash)
instance (GHC.Show.Show text, GHC.Show.Show hash) => GHC.Show.Show (Unison.Sync.Types.TermComponent text hash)
instance (GHC.Classes.Ord text, GHC.Classes.Ord oldHash, GHC.Classes.Ord newHash) => GHC.Classes.Ord (Unison.Sync.Types.Patch text oldHash newHash)
instance (GHC.Classes.Eq text, GHC.Classes.Eq oldHash, GHC.Classes.Eq newHash) => GHC.Classes.Eq (Unison.Sync.Types.Patch text oldHash newHash)
instance (GHC.Show.Show text, GHC.Show.Show oldHash, GHC.Show.Show newHash) => GHC.Show.Show (Unison.Sync.Types.Patch text oldHash newHash)
instance (GHC.Show.Show hash, GHC.Show.Show text, GHC.Show.Show oldHash) => GHC.Show.Show (Unison.Sync.Types.PatchDiff text oldHash hash)
instance (GHC.Classes.Ord hash, GHC.Classes.Ord text, GHC.Classes.Ord oldHash) => GHC.Classes.Ord (Unison.Sync.Types.PatchDiff text oldHash hash)
instance (GHC.Classes.Eq hash, GHC.Classes.Eq text, GHC.Classes.Eq oldHash) => GHC.Classes.Eq (Unison.Sync.Types.PatchDiff text oldHash hash)
instance (GHC.Show.Show text, GHC.Show.Show hash) => GHC.Show.Show (Unison.Sync.Types.Namespace text hash)
instance (GHC.Classes.Ord text, GHC.Classes.Ord hash) => GHC.Classes.Ord (Unison.Sync.Types.Namespace text hash)
instance (GHC.Classes.Eq text, GHC.Classes.Eq hash) => GHC.Classes.Eq (Unison.Sync.Types.Namespace text hash)
instance (GHC.Show.Show hash, GHC.Show.Show text) => GHC.Show.Show (Unison.Sync.Types.NamespaceDiff text hash)
instance (GHC.Classes.Ord hash, GHC.Classes.Ord text) => GHC.Classes.Ord (Unison.Sync.Types.NamespaceDiff text hash)
instance (GHC.Classes.Eq hash, GHC.Classes.Eq text) => GHC.Classes.Eq (Unison.Sync.Types.NamespaceDiff text hash)
instance GHC.Show.Show hash => GHC.Show.Show (Unison.Sync.Types.Causal hash)
instance GHC.Classes.Ord hash => GHC.Classes.Ord (Unison.Sync.Types.Causal hash)
instance GHC.Classes.Eq hash => GHC.Classes.Eq (Unison.Sync.Types.Causal hash)
instance (GHC.Classes.Ord text, GHC.Classes.Ord noSyncHash, GHC.Classes.Ord hash) => GHC.Classes.Ord (Unison.Sync.Types.Entity text noSyncHash hash)
instance (GHC.Classes.Eq text, GHC.Classes.Eq noSyncHash, GHC.Classes.Eq hash) => GHC.Classes.Eq (Unison.Sync.Types.Entity text noSyncHash hash)
instance (GHC.Show.Show text, GHC.Show.Show noSyncHash, GHC.Show.Show hash) => GHC.Show.Show (Unison.Sync.Types.Entity text noSyncHash hash)
instance GHC.Show.Show Unison.Sync.Types.EntityType
instance GHC.Classes.Ord Unison.Sync.Types.EntityType
instance GHC.Classes.Eq Unison.Sync.Types.EntityType
instance GHC.Classes.Ord Unison.Sync.Types.GetCausalHashByPathRequest
instance GHC.Classes.Eq Unison.Sync.Types.GetCausalHashByPathRequest
instance GHC.Show.Show Unison.Sync.Types.GetCausalHashByPathRequest
instance GHC.Classes.Ord Unison.Sync.Types.GetCausalHashByPathResponse
instance GHC.Classes.Eq Unison.Sync.Types.GetCausalHashByPathResponse
instance GHC.Show.Show Unison.Sync.Types.GetCausalHashByPathResponse
instance GHC.Classes.Ord Unison.Sync.Types.DownloadEntitiesRequest
instance GHC.Classes.Eq Unison.Sync.Types.DownloadEntitiesRequest
instance GHC.Show.Show Unison.Sync.Types.DownloadEntitiesRequest
instance GHC.Classes.Ord Unison.Sync.Types.UploadEntitiesRequest
instance GHC.Classes.Eq Unison.Sync.Types.UploadEntitiesRequest
instance GHC.Show.Show Unison.Sync.Types.UploadEntitiesRequest
instance GHC.Classes.Ord Unison.Sync.Types.HashMismatchForEntity
instance GHC.Classes.Eq Unison.Sync.Types.HashMismatchForEntity
instance GHC.Show.Show Unison.Sync.Types.HashMismatchForEntity
instance GHC.Show.Show Unison.Sync.Types.FastForwardPathRequest
instance GHC.Show.Show Unison.Sync.Types.InvalidParentage
instance GHC.Classes.Ord Unison.Sync.Types.UpdatePathRequest
instance GHC.Classes.Eq Unison.Sync.Types.UpdatePathRequest
instance GHC.Show.Show Unison.Sync.Types.UpdatePathRequest
instance GHC.Classes.Ord Unison.Sync.Types.HashMismatch
instance GHC.Classes.Eq Unison.Sync.Types.HashMismatch
instance GHC.Show.Show Unison.Sync.Types.HashMismatch
instance GHC.Classes.Ord hash => GHC.Classes.Ord (Unison.Sync.Types.NeedDependencies hash)
instance GHC.Classes.Eq hash => GHC.Classes.Eq (Unison.Sync.Types.NeedDependencies hash)
instance GHC.Show.Show hash => GHC.Show.Show (Unison.Sync.Types.NeedDependencies hash)
instance GHC.Classes.Ord Unison.Sync.Types.UpdatePathResponse
instance GHC.Classes.Eq Unison.Sync.Types.UpdatePathResponse
instance GHC.Show.Show Unison.Sync.Types.UpdatePathResponse
instance GHC.Show.Show Unison.Sync.Types.FastForwardPathResponse
instance GHC.Classes.Ord Unison.Sync.Types.UploadEntitiesResponse
instance GHC.Classes.Eq Unison.Sync.Types.UploadEntitiesResponse
instance GHC.Show.Show Unison.Sync.Types.UploadEntitiesResponse
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.UploadEntitiesResponse
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.UploadEntitiesResponse
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.FastForwardPathResponse
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.FastForwardPathResponse
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.UpdatePathResponse
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.UpdatePathResponse
instance Data.Aeson.Types.ToJSON.ToJSON hash => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.NeedDependencies hash)
instance (Data.Aeson.Types.FromJSON.FromJSON hash, GHC.Classes.Ord hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.NeedDependencies hash)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.HashMismatch
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.HashMismatch
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.UpdatePathRequest
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.UpdatePathRequest
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.InvalidParentage
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.InvalidParentage
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.FastForwardPathRequest
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.FastForwardPathRequest
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.HashMismatchForEntity
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.HashMismatchForEntity
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.UploadEntitiesRequest
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.UploadEntitiesRequest
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.DownloadEntitiesResponse
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.DownloadEntitiesResponse
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.DownloadEntitiesRequest
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.DownloadEntitiesRequest
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.GetCausalHashByPathResponse
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.GetCausalHashByPathResponse
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.GetCausalHashByPathRequest
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.GetCausalHashByPathRequest
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON noSyncHash, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.Entity text noSyncHash hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON noSyncHash, Data.Aeson.Types.FromJSON.FromJSON hash, GHC.Classes.Ord hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.Entity text noSyncHash hash)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.EntityType
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.EntityType
instance Data.Aeson.Types.ToJSON.ToJSON hash => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.Causal hash)
instance (Data.Aeson.Types.FromJSON.FromJSON hash, GHC.Classes.Ord hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.Causal hash)
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.NamespaceDiff text hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.NamespaceDiff text hash)
instance Data.Bifoldable.Bifoldable Unison.Sync.Types.Namespace
instance Data.Bifunctor.Bifunctor Unison.Sync.Types.Namespace
instance Data.Bitraversable.Bitraversable Unison.Sync.Types.Namespace
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.Namespace text hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.Namespace text hash)
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON oldHash, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.PatchDiff text oldHash hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON oldHash, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.PatchDiff text oldHash hash)
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON oldHash, Data.Aeson.Types.ToJSON.ToJSON newHash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.Patch text oldHash newHash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON oldHash, Data.Aeson.Types.FromJSON.FromJSON newHash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.Patch text oldHash newHash)
instance Data.Bifoldable.Bifoldable Unison.Sync.Types.TermComponent
instance Data.Bifunctor.Bifunctor Unison.Sync.Types.TermComponent
instance Data.Bitraversable.Bitraversable Unison.Sync.Types.TermComponent
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.TermComponent text hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.TermComponent text hash)
instance Data.Bifoldable.Bifoldable Unison.Sync.Types.DeclComponent
instance Data.Bifunctor.Bifunctor Unison.Sync.Types.DeclComponent
instance Data.Bitraversable.Bitraversable Unison.Sync.Types.DeclComponent
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.DeclComponent text hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.DeclComponent text hash)
instance Data.Bifoldable.Bifoldable Unison.Sync.Types.LocalIds
instance Data.Bifunctor.Bifunctor Unison.Sync.Types.LocalIds
instance Data.Bitraversable.Bitraversable Unison.Sync.Types.LocalIds
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.LocalIds text hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.LocalIds text hash)
instance Servant.Auth.JWT.ToJWT Unison.Sync.Types.HashJWTClaims
instance Servant.Auth.JWT.FromJWT Unison.Sync.Types.HashJWTClaims
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.HashJWTClaims
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.HashJWTClaims
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.Path
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.Path
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.Base64Bytes
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.Base64Bytes


-- | Combinators or utilities shared by sync server AND client
module Unison.Sync.Common

-- | Read an entity out of the database that we know is in main storage.
expectEntity :: Hash32 -> Transaction (Entity Text Hash32 Hash32)
causalHashToHash32 :: CausalHash -> Hash32
hash32ToCausalHash :: Hash32 -> CausalHash

-- | Convert an entity that came over the wire from Unison Share into an
--   equivalent type that we can store in the <tt>temp_entity</tt> table.
entityToTempEntity :: forall hash. (hash -> Hash32) -> Entity Text Hash32 hash -> TempEntity
tempEntityToEntity :: TempEntity -> Entity Text Hash32 Hash32

module Unison.Sync.API
type API = "path" :> "get" :> GetCausalHashByPathEndpoint :<|> "path" :> "fast-forward" :> FastForwardPathEndpoint :<|> "path" :> "update" :> UpdatePathEndpoint :<|> "entities" :> "download" :> DownloadEntitiesEndpoint :<|> "entities" :> "upload" :> UploadEntitiesEndpoint
api :: Proxy API

module Unison.Util.Find
fuzzyFinder :: forall a. String -> [a] -> (a -> String) -> [(a, Pretty ColorText)]
simpleFuzzyFinder :: forall a. String -> [a] -> (a -> String) -> [(a, Pretty ColorText)]
simpleFuzzyScore :: String -> String -> Maybe Int
fuzzyFindInBranch :: HasCallStack => Names -> HashQualified Name -> [(SearchResult, Pretty ColorText)]
fuzzyFindMatchArray :: forall a. String -> [a] -> (a -> String) -> [(MatchArray, (a, Pretty ColorText))]
prefixFindInBranch :: Names -> HashQualified Name -> [(SearchResult, Pretty ColorText)]

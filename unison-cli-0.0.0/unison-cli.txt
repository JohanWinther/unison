-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-cli
@version 0.0.0

module Compat
onWindows :: Bool

-- | Constructs a default interrupt handler which builds an interrupt
--   handler which throws a UserInterrupt exception to the thread in which
--   the setup was initially called.
defaultInterruptHandler :: IO (IO ())

-- | Replaces any existing interrupt handlers with the provided IO action
--   while the provided action is running, restoring any existing handlers
--   afterwards.
withInterruptHandler :: IO () -> IO a -> IO a

module Unison.Auth.Types
data DiscoveryDoc
DiscoveryDoc :: URI -> URI -> URI -> URI -> DiscoveryDoc
[$sel:issuer:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:authorizationEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:tokenEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:userInfoEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
data Tokens
Tokens :: AccessToken -> Maybe IDToken -> Maybe RefreshToken -> TokenType -> NominalDiffTime -> Scopes -> Tokens
[$sel:accessToken:Tokens] :: Tokens -> AccessToken
[$sel:idToken:Tokens] :: Tokens -> Maybe IDToken
[$sel:refreshToken:Tokens] :: Tokens -> Maybe RefreshToken
[$sel:tokenType:Tokens] :: Tokens -> TokenType
[$sel:expiresIn:Tokens] :: Tokens -> NominalDiffTime
[$sel:scopes:Tokens] :: Tokens -> Scopes
data Credentials
Credentials :: Map ProfileName (Map CodeserverId CodeserverCredentials) -> ProfileName -> Credentials
[$sel:credentials:Credentials] :: Credentials -> Map ProfileName (Map CodeserverId CodeserverCredentials)
[$sel:activeProfile:Credentials] :: Credentials -> ProfileName
type Code = Text
type AccessToken = Text
type RefreshToken = Text
type IDToken = Text
type OAuthState = ByteString
type PKCEVerifier = ByteString
type PKCEChallenge = ByteString
type ProfileName = Text
data CredentialFailure
ReauthRequired :: CodeserverId -> CredentialFailure
CredentialParseFailure :: FilePath -> Text -> CredentialFailure
InvalidDiscoveryDocument :: URI -> Text -> CredentialFailure
InvalidJWT :: Text -> CredentialFailure
RefreshFailure :: Text -> CredentialFailure
InvalidTokenResponse :: URI -> Text -> CredentialFailure
InvalidHost :: CodeserverURI -> CredentialFailure
FailedToFetchUserInfo :: URI -> Text -> CredentialFailure

-- | Credentials for a specific codeserver
data CodeserverCredentials
CodeserverCredentials :: Tokens -> URI -> UserInfo -> CodeserverCredentials
[$sel:tokens:CodeserverCredentials] :: CodeserverCredentials -> Tokens
[$sel:discoveryURI:CodeserverCredentials] :: CodeserverCredentials -> URI
[$sel:userInfo:CodeserverCredentials] :: CodeserverCredentials -> UserInfo
data UserInfo
UserInfo :: Text -> Maybe Text -> Text -> UserInfo
[$sel:userId:UserInfo] :: UserInfo -> Text
[$sel:name:UserInfo] :: UserInfo -> Maybe Text
[$sel:handle:UserInfo] :: UserInfo -> Text
getCodeserverCredentials :: CodeserverId -> Credentials -> Either CredentialFailure CodeserverCredentials
setCodeserverCredentials :: CodeserverId -> CodeserverCredentials -> Credentials -> Credentials
codeserverCredentials :: URI -> Tokens -> UserInfo -> CodeserverCredentials
emptyCredentials :: Credentials
instance GHC.Exception.Type.Exception Unison.Auth.Types.CredentialFailure
instance GHC.Classes.Eq Unison.Auth.Types.CredentialFailure
instance GHC.Show.Show Unison.Auth.Types.CredentialFailure
instance GHC.Classes.Ord Unison.Auth.Types.Scopes
instance GHC.Classes.Eq Unison.Auth.Types.Scopes
instance GHC.Show.Show Unison.Auth.Types.Scopes
instance GHC.Show.Show Unison.Auth.Types.DiscoveryDoc
instance GHC.Show.Show Unison.Auth.Types.Tokens
instance GHC.Classes.Eq Unison.Auth.Types.Tokens
instance GHC.Generics.Generic Unison.Auth.Types.UserInfo
instance GHC.Classes.Eq Unison.Auth.Types.UserInfo
instance GHC.Show.Show Unison.Auth.Types.UserInfo
instance GHC.Classes.Eq Unison.Auth.Types.CodeserverCredentials
instance GHC.Classes.Eq Unison.Auth.Types.Credentials
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Credentials
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Credentials
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.CodeserverCredentials
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.CodeserverCredentials
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.UserInfo
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.UserInfo
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.URIParam
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.DiscoveryDoc
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Tokens
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Tokens
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Scopes
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Scopes

module Unison.Auth.Discovery
discoveryURIForCodeserver :: CodeserverURI -> URI
fetchDiscoveryDoc :: MonadIO m => URI -> m (Either CredentialFailure DiscoveryDoc)

module Unison.Auth.CredentialFile

-- | Atomically update the credential storage file. Creates an empty file
--   automatically if one doesn't exist.
atomicallyModifyCredentialsFile :: MonadIO m => (Credentials -> Credentials) -> m Credentials

module Unison.Auth.CredentialManager

-- | Saves credentials to the active profile.
saveCredentials :: MonadUnliftIO m => CredentialManager -> CodeserverId -> CodeserverCredentials -> m ()

-- | A <a>CredentialManager</a> knows how to load, save, and cache
--   credentials. It's thread-safe and safe for use across multiple UCM
--   clients. Note: Currently the in-memory cache is _not_ updated if a
--   different UCM updates the credentials file, however this shouldn't
--   pose any problems, since auth will still be refreshed if we encounter
--   any auth failures on requests.
data CredentialManager
newCredentialManager :: MonadIO m => m CredentialManager
getCredentials :: MonadIO m => CredentialManager -> CodeserverId -> m (Either CredentialFailure CodeserverCredentials)

module Unison.Auth.UserInfo

-- | Get user info for an authenticated user.
getUserInfo :: MonadIO m => DiscoveryDoc -> AccessToken -> m (Either CredentialFailure UserInfo)
decodeUserInfo :: ByteString -> Either String UserInfo

module Unison.Auth.Tokens

-- | Checks whether a JWT access token is expired.
isExpired :: MonadIO m => AccessToken -> m Bool

-- | Given a <a>CodeserverId</a>, provide a valid <a>AccessToken</a> for
--   the associated host. The TokenProvider may automatically refresh
--   access tokens if we have a refresh token.
type TokenProvider = CodeserverId -> IO (Either CredentialFailure AccessToken)

-- | Creates a <a>TokenProvider</a> using the given
--   <a>CredentialManager</a>
newTokenProvider :: CredentialManager -> TokenProvider

-- | Don't yet support automatically refreshing tokens.
--   
--   Specification:
--   <a>https://datatracker.ietf.org/doc/html/rfc6749#section-6</a>
performTokenRefresh :: MonadIO m => DiscoveryDoc -> Tokens -> m (Either CredentialFailure Tokens)


-- | Types of <a>Unison.Cli.Share.Projects</a>, put in their own module to
--   avoid cyclic dependencies.
--   
--   Refer to that module's documentation, and use it instead if you can.
--   It re-exports these types.
module Unison.Cli.Share.Projects.Types

-- | A remote project.
data RemoteProject
RemoteProject :: RemoteProjectId -> ProjectName -> RemoteProject
[$sel:projectId:RemoteProject] :: RemoteProject -> RemoteProjectId
[$sel:projectName:RemoteProject] :: RemoteProject -> ProjectName

-- | A remote project branch.
data RemoteProjectBranch
RemoteProjectBranch :: RemoteProjectId -> ProjectName -> RemoteProjectBranchId -> ProjectBranchName -> HashJWT -> RemoteProjectBranch
[$sel:projectId:RemoteProjectBranch] :: RemoteProjectBranch -> RemoteProjectId
[$sel:projectName:RemoteProjectBranch] :: RemoteProjectBranch -> ProjectName
[$sel:branchId:RemoteProjectBranch] :: RemoteProjectBranch -> RemoteProjectBranchId
[$sel:branchName:RemoteProjectBranch] :: RemoteProjectBranch -> ProjectBranchName
[$sel:branchHead:RemoteProjectBranch] :: RemoteProjectBranch -> HashJWT
instance GHC.Show.Show Unison.Cli.Share.Projects.Types.RemoteProject
instance GHC.Generics.Generic Unison.Cli.Share.Projects.Types.RemoteProject
instance GHC.Classes.Eq Unison.Cli.Share.Projects.Types.RemoteProject
instance GHC.Generics.Generic Unison.Cli.Share.Projects.Types.RemoteProjectBranch
instance GHC.Show.Show Unison.Cli.Share.Projects.Types.RemoteProjectBranch
instance GHC.Classes.Eq Unison.Cli.Share.Projects.Types.RemoteProjectBranch

module Unison.Codebase.Editor.AuthorInfo
data AuthorInfo v a
AuthorInfo :: (Id, Term v a, Type v a) -> AuthorInfo v a
[$sel:guid:AuthorInfo, $sel:author:AuthorInfo, $sel:copyrightHolder:AuthorInfo] :: AuthorInfo v a -> (Id, Term v a, Type v a)
createAuthorInfo :: forall m v a. MonadIO m => Var v => a -> Text -> m (AuthorInfo v a)

module Unison.Codebase.Editor.HandleInput.NamespaceDependencies

-- | Check the dependencies of all types, terms, and metadata in the
--   current namespace, returns a map of dependencies which do not have a
--   name within the current namespace, alongside the names of all of that
--   thing's dependents.
--   
--   This is non-transitive, i.e. only the first layer of external
--   dependencies is returned.
--   
--   So if my namespace depends on .base.Bag.map; which depends on
--   base.Map.mapKeys, only .base.Bag.map is returned unless some other
--   definition inside my namespace depends on base.Map.mapKeys directly.
--   
--   Returns a Set of names rather than using the PPE since we already have
--   the correct names in scope on this branch, and also want to list ALL
--   names of dependents, including aliases.
namespaceDependencies :: Codebase m Symbol a -> Branch0 m -> Transaction (Map LabeledDependency (Set Name))

module Unison.Codebase.Editor.Input
data Input
ForkLocalBranchI :: Either ShortCausalHash Path' -> Path' -> Input
MergeLocalBranchI :: Path' -> Path' -> MergeMode -> Input
PreviewMergeLocalBranchI :: Path' -> Path' -> Input
DiffNamespaceI :: BranchId -> BranchId -> Input
PullRemoteBranchI :: PullSourceTarget -> SyncMode -> PullMode -> Verbosity -> Input
PushRemoteBranchI :: PushRemoteBranchInput -> Input
ResetRootI :: Either ShortCausalHash Path' -> Input
CreateMessage :: Pretty ColorText -> Input
SwitchBranchI :: Maybe Path' -> Input
UpI :: Input
PopBranchI :: Input
NamesI :: IsGlobal -> HashQualified Name -> Input
AliasTermI :: HashOrHQSplit' -> Split' -> Input
AliasTypeI :: HashOrHQSplit' -> Split' -> Input
AliasManyI :: [HQSplit] -> Path' -> Input
MoveTermI :: HQSplit' -> Split' -> Input
MoveTypeI :: HQSplit' -> Split' -> Input
MoveBranchI :: Path' -> Path' -> Input
MovePatchI :: Split' -> Split' -> Input
CopyPatchI :: Split' -> Split' -> Input
DeleteI :: DeleteTarget -> Input
ResolveTermNameI :: HQSplit' -> Input
ResolveTypeNameI :: HQSplit' -> Input
LoadI :: Maybe FilePath -> Input
ClearI :: Input
AddI :: Set Name -> Input
PreviewAddI :: Set Name -> Input
UpdateI :: OptionalPatch -> Set Name -> Input
PreviewUpdateI :: Set Name -> Input
TodoI :: Maybe PatchPath -> Path' -> Input
PropagatePatchI :: PatchPath -> Path' -> Input
ListEditsI :: Maybe PatchPath -> Input
DeprecateTermI :: PatchPath -> HQSplit' -> Input
DeprecateTypeI :: PatchPath -> HQSplit' -> Input
ReplaceI :: HashQualified Name -> HashQualified Name -> Maybe PatchPath -> Input
RemoveTermReplacementI :: HashQualified Name -> Maybe PatchPath -> Input
RemoveTypeReplacementI :: HashQualified Name -> Maybe PatchPath -> Input
UndoI :: Input
HistoryI :: Maybe Int -> Maybe Int -> BranchId -> Input
ExecuteI :: String -> [String] -> Input
SaveExecuteResultI :: Name -> Input
IOTestI :: HashQualified Name -> Input
MakeStandaloneI :: String -> HashQualified Name -> Input
ExecuteSchemeI :: HashQualified Name -> [String] -> Input
CompileSchemeI :: String -> HashQualified Name -> Input
GenSchemeLibsI :: Input
FetchSchemeCompilerI :: String -> Input
TestI :: TestInput -> Input
LinkI :: HashQualified Name -> [HQSplit'] -> Input
UnlinkI :: HashQualified Name -> [HQSplit'] -> Input
LinksI :: HQSplit' -> Maybe String -> Input
CreateAuthorI :: NameSegment -> Text -> Input
DisplayI :: OutputLocation -> [HashQualified Name] -> Input
DocsI :: [HQSplit'] -> Input
FindI :: Bool -> FindScope -> [String] -> Input
FindShallowI :: Path' -> Input
FindPatchI :: Input
ShowDefinitionI :: OutputLocation -> ShowDefinitionScope -> [HashQualified Name] -> Input
ShowDefinitionByPrefixI :: OutputLocation -> [HashQualified Name] -> Input
ShowReflogI :: Input
UpdateBuiltinsI :: Input
MergeBuiltinsI :: Input
MergeIOBuiltinsI :: Input
ListDependenciesI :: HashQualified Name -> Input
ListDependentsI :: HashQualified Name -> Input

-- | List all external dependencies of a given namespace, or the current
--   namespace if no path is provided.
NamespaceDependenciesI :: Maybe Path' -> Input
DebugTabCompletionI :: [String] -> Input
DebugNumberedArgsI :: Input
DebugTypecheckedUnisonFileI :: Input
DebugDumpNamespacesI :: Input
DebugDumpNamespaceSimpleI :: Input
DebugClearWatchI :: Input
DebugDoctorI :: Input
DebugNameDiffI :: ShortCausalHash -> ShortCausalHash -> Input
QuitI :: Input
ApiI :: Input
UiI :: Input
DocToMarkdownI :: Name -> Input
DocsToHtmlI :: Path' -> FilePath -> Input
GistI :: GistInput -> Input
AuthLoginI :: Input
VersionI :: Input
DiffNamespaceToPatchI :: DiffNamespaceToPatchInput -> Input
ProjectCloneI :: These ProjectName ProjectBranchName -> Input
ProjectCreateI :: ProjectName -> Input
ProjectSwitchI :: These ProjectName ProjectBranchName -> Input
ProjectsI :: Input
BranchesI :: Input
data DiffNamespaceToPatchInput
DiffNamespaceToPatchInput :: BranchId -> BranchId -> Split' -> DiffNamespaceToPatchInput
[$sel:branchId1:DiffNamespaceToPatchInput] :: DiffNamespaceToPatchInput -> BranchId
[$sel:branchId2:DiffNamespaceToPatchInput] :: DiffNamespaceToPatchInput -> BranchId
[$sel:patch:DiffNamespaceToPatchInput] :: DiffNamespaceToPatchInput -> Split'

-- | <tt>"push.gist repo"</tt> pushes the contents of the current namespace
--   to <tt>repo</tt>.
data GistInput
GistInput :: WriteGitRepo -> GistInput
[$sel:repo:GistInput] :: GistInput -> WriteGitRepo

-- | Pull source and target: either neither is specified, or only a source,
--   or both.
data PullSourceTarget
PullSourceTarget0 :: PullSourceTarget
PullSourceTarget1 :: ReadRemoteNamespace (These ProjectName ProjectBranchName) -> PullSourceTarget
PullSourceTarget2 :: ReadRemoteNamespace (These ProjectName ProjectBranchName) -> PullTarget (These ProjectName ProjectBranchName) -> PullSourceTarget

-- | Where are we pulling into?
data PullTarget a
PullTargetLooseCode :: Path' -> PullTarget a
PullTargetProject :: a -> PullTarget a
data PushRemoteBranchInput
PushRemoteBranchInput :: PushSourceTarget -> PushBehavior -> SyncMode -> PushRemoteBranchInput
[$sel:sourceTarget:PushRemoteBranchInput] :: PushRemoteBranchInput -> PushSourceTarget
[$sel:pushBehavior:PushRemoteBranchInput] :: PushRemoteBranchInput -> PushBehavior
[$sel:syncMode:PushRemoteBranchInput] :: PushRemoteBranchInput -> SyncMode

-- | Push source and target: either neither is specified, or only a target,
--   or both.
data PushSourceTarget
PushSourceTarget0 :: PushSourceTarget
PushSourceTarget1 :: WriteRemoteNamespace (These ProjectName ProjectBranchName) -> PushSourceTarget
PushSourceTarget2 :: PushSource -> WriteRemoteNamespace (These ProjectName ProjectBranchName) -> PushSourceTarget
data PushSource
PathySource :: Path' -> PushSource
ProjySource :: These ProjectName ProjectBranchName -> PushSource
data TestInput
TestInput :: Bool -> Bool -> Bool -> TestInput

-- | Should we run tests in the <tt>lib</tt> namespace?
[$sel:includeLibNamespace:TestInput] :: TestInput -> Bool
[$sel:showFailures:TestInput] :: TestInput -> Bool
[$sel:showSuccesses:TestInput] :: TestInput -> Bool
data Event
UnisonFileChanged :: SourceName -> Source -> Event
IncomingRootBranch :: Set CausalHash -> Event
data OutputLocation
ConsoleLocation :: OutputLocation
LatestFileLocation :: OutputLocation
FileLocation :: FilePath -> OutputLocation
type PatchPath = Split'
type BranchId = Either ShortCausalHash Path'
type AbsBranchId = Either ShortCausalHash Absolute
parseBranchId :: String -> Either String BranchId
parseShortCausalHash :: String -> Either String ShortCausalHash
type HashOrHQSplit' = Either ShortHash HQSplit'

-- | Should we force the operation or not?
data Insistence
Force :: Insistence
Try :: Insistence
data PullMode
PullWithHistory :: PullMode
PullWithoutHistory :: PullMode
data OptionalPatch
NoPatch :: OptionalPatch
DefaultPatch :: OptionalPatch
UsePatch :: PatchPath -> OptionalPatch
data FindScope
FindLocal :: FindScope
FindLocalAndDeps :: FindScope
FindGlobal :: FindScope
data ShowDefinitionScope
ShowDefinitionLocal :: ShowDefinitionScope
ShowDefinitionGlobal :: ShowDefinitionScope
type IsGlobal = Bool
data DeleteOutput
DeleteOutput'Diff :: DeleteOutput
DeleteOutput'NoDiff :: DeleteOutput
data DeleteTarget
DeleteTarget'TermOrType :: DeleteOutput -> [HQSplit'] -> DeleteTarget
DeleteTarget'Term :: DeleteOutput -> [HQSplit'] -> DeleteTarget
DeleteTarget'Type :: DeleteOutput -> [HQSplit'] -> DeleteTarget
DeleteTarget'Branch :: Insistence -> Maybe Split' -> DeleteTarget
DeleteTarget'Patch :: Split' -> DeleteTarget
instance GHC.Show.Show Unison.Codebase.Editor.Input.OptionalPatch
instance GHC.Classes.Ord Unison.Codebase.Editor.Input.OptionalPatch
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.OptionalPatch
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.Insistence
instance GHC.Show.Show Unison.Codebase.Editor.Input.Insistence
instance GHC.Show.Show Unison.Codebase.Editor.Input.PullMode
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PullMode
instance GHC.Show.Show Unison.Codebase.Editor.Input.DiffNamespaceToPatchInput
instance GHC.Generics.Generic Unison.Codebase.Editor.Input.DiffNamespaceToPatchInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.DiffNamespaceToPatchInput
instance GHC.Show.Show Unison.Codebase.Editor.Input.GistInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.GistInput
instance GHC.Generics.Generic (Unison.Codebase.Editor.Input.PullTarget a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.Editor.Input.PullTarget a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.Editor.Input.PullTarget a)
instance GHC.Show.Show Unison.Codebase.Editor.Input.PullSourceTarget
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PullSourceTarget
instance GHC.Show.Show Unison.Codebase.Editor.Input.PushSource
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PushSource
instance GHC.Show.Show Unison.Codebase.Editor.Input.PushSourceTarget
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PushSourceTarget
instance GHC.Show.Show Unison.Codebase.Editor.Input.PushRemoteBranchInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PushRemoteBranchInput
instance GHC.Show.Show Unison.Codebase.Editor.Input.TestInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.TestInput
instance GHC.Show.Show Unison.Codebase.Editor.Input.OutputLocation
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.OutputLocation
instance GHC.Show.Show Unison.Codebase.Editor.Input.FindScope
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.FindScope
instance GHC.Show.Show Unison.Codebase.Editor.Input.ShowDefinitionScope
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.ShowDefinitionScope
instance GHC.Show.Show Unison.Codebase.Editor.Input.DeleteOutput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.DeleteOutput
instance GHC.Show.Show Unison.Codebase.Editor.Input.DeleteTarget
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.DeleteTarget
instance GHC.Show.Show Unison.Codebase.Editor.Input.Input
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.Input

module Unison.Codebase.Editor.Output.BranchDiff
data MetadataDiff tm
MetadataDiff :: [tm] -> [tm] -> MetadataDiff tm
[$sel:addedMetadata:MetadataDiff] :: MetadataDiff tm -> [tm]
[$sel:removedMetadata:MetadataDiff] :: MetadataDiff tm -> [tm]
data BranchDiffOutput v a
BranchDiffOutput :: [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> Int -> [PatchDisplay] -> [AddedTypeDisplay v a] -> [AddedTermDisplay v a] -> [PatchDisplay] -> [RemovedTypeDisplay v a] -> [RemovedTermDisplay v a] -> [PatchDisplay] -> [RenameTypeDisplay v a] -> [RenameTermDisplay v a] -> BranchDiffOutput v a
[$sel:updatedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:updatedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:newTypeConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:newTermConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:resolvedTypeConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:resolvedTermConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:propagatedUpdates:BranchDiffOutput] :: BranchDiffOutput v a -> Int
[$sel:updatedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:addedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [AddedTypeDisplay v a]
[$sel:addedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [AddedTermDisplay v a]
[$sel:addedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:removedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [RemovedTypeDisplay v a]
[$sel:removedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [RemovedTermDisplay v a]
[$sel:removedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:renamedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [RenameTypeDisplay v a]
[$sel:renamedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [RenameTermDisplay v a]
isEmpty :: BranchDiffOutput v a -> Bool
data TermDisplay v a
TermDisplay :: HashQualified Name -> Referent -> Maybe (Type v a) -> MetadataDiff (MetadataDisplay v a) -> TermDisplay v a
[$sel:name:TermDisplay] :: TermDisplay v a -> HashQualified Name
[$sel:ref:TermDisplay] :: TermDisplay v a -> Referent
[$sel:type_:TermDisplay] :: TermDisplay v a -> Maybe (Type v a)
[$sel:metadata:TermDisplay] :: TermDisplay v a -> MetadataDiff (MetadataDisplay v a)
data TypeDisplay v a
TypeDisplay :: HashQualified Name -> Reference -> Maybe (DeclOrBuiltin v a) -> MetadataDiff (MetadataDisplay v a) -> TypeDisplay v a
[$sel:name:TypeDisplay] :: TypeDisplay v a -> HashQualified Name
[$sel:ref:TypeDisplay] :: TypeDisplay v a -> Reference
[$sel:decl:TypeDisplay] :: TypeDisplay v a -> Maybe (DeclOrBuiltin v a)
[$sel:metadata:TypeDisplay] :: TypeDisplay v a -> MetadataDiff (MetadataDisplay v a)
type AddedTermDisplay v a = ([(HashQualified Name, [MetadataDisplay v a])], Referent, Maybe (Type v a))
type AddedTypeDisplay v a = ([(HashQualified Name, [MetadataDisplay v a])], Reference, Maybe (DeclOrBuiltin v a))
type RemovedTermDisplay v a = ([HashQualified Name], Referent, Maybe (Type v a))
type RemovedTypeDisplay v a = ([HashQualified Name], Reference, Maybe (DeclOrBuiltin v a))
type SimpleTermDisplay v a = (HashQualified Name, Referent, Maybe (Type v a))
type SimpleTypeDisplay v a = (HashQualified Name, Reference, Maybe (DeclOrBuiltin v a))
data UpdateTermDisplay v a
UpdateTermDisplay :: Maybe [SimpleTermDisplay v a] -> [TermDisplay v a] -> UpdateTermDisplay v a
[$sel:old:UpdateTermDisplay] :: UpdateTermDisplay v a -> Maybe [SimpleTermDisplay v a]
[$sel:new:UpdateTermDisplay] :: UpdateTermDisplay v a -> [TermDisplay v a]
data UpdateTypeDisplay v a
UpdateTypeDisplay :: Maybe [SimpleTypeDisplay v a] -> [TypeDisplay v a] -> UpdateTypeDisplay v a
[$sel:old:UpdateTypeDisplay] :: UpdateTypeDisplay v a -> Maybe [SimpleTypeDisplay v a]
[$sel:new:UpdateTypeDisplay] :: UpdateTypeDisplay v a -> [TypeDisplay v a]
type MetadataDisplay v a = (HashQualified Name, Referent, Maybe (Type v a))
type RenameTermDisplay v a = (Referent, Maybe (Type v a), Set (HashQualified Name), Set (HashQualified Name))
type RenameTypeDisplay v a = (Reference, Maybe (DeclOrBuiltin v a), Set (HashQualified Name), Set (HashQualified Name))
type PatchDisplay = (Name, PatchDiff)
toOutput :: forall m v a. Monad m => (Referent -> m (Maybe (Type v a))) -> (Reference -> m (Maybe (DeclOrBuiltin v a))) -> Int -> Names -> Names -> PrettyPrintEnv -> BranchDiff -> m (BranchDiffOutput v a)
instance GHC.Show.Show tm => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance Data.Traversable.Traversable Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff
instance Data.Foldable.Foldable Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff
instance GHC.Base.Functor Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff
instance GHC.Classes.Eq tm => GHC.Classes.Eq (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance GHC.Classes.Ord tm => GHC.Classes.Ord (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.TypeDisplay v a)
instance GHC.Generics.Generic (Unison.Codebase.Editor.Output.BranchDiff.TypeDisplay v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.UpdateTypeDisplay v a)
instance GHC.Generics.Generic (Unison.Codebase.Editor.Output.BranchDiff.UpdateTypeDisplay v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.TermDisplay v a)
instance GHC.Generics.Generic (Unison.Codebase.Editor.Output.BranchDiff.TermDisplay v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.UpdateTermDisplay v a)
instance GHC.Generics.Generic (Unison.Codebase.Editor.Output.BranchDiff.UpdateTermDisplay v a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.BranchDiffOutput v a)
instance GHC.Classes.Eq (Unison.Codebase.Editor.Output.BranchDiff.UpdateTermDisplay v a)
instance GHC.Classes.Ord (Unison.Codebase.Editor.Output.BranchDiff.UpdateTermDisplay v a)
instance GHC.Classes.Eq (Unison.Codebase.Editor.Output.BranchDiff.TermDisplay v a)
instance GHC.Classes.Ord (Unison.Codebase.Editor.Output.BranchDiff.TermDisplay v a)
instance GHC.Classes.Eq (Unison.Codebase.Editor.Output.BranchDiff.UpdateTypeDisplay v a)
instance GHC.Classes.Ord (Unison.Codebase.Editor.Output.BranchDiff.UpdateTypeDisplay v a)
instance GHC.Classes.Eq (Unison.Codebase.Editor.Output.BranchDiff.TypeDisplay v a)
instance GHC.Classes.Ord (Unison.Codebase.Editor.Output.BranchDiff.TypeDisplay v a)
instance GHC.Base.Semigroup (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance GHC.Base.Monoid (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)

module Unison.Codebase.Editor.Output.DumpNamespace
data DumpNamespace
DumpNamespace :: Map Referent (Set NameSegment, Set Reference) -> Map Reference (Set NameSegment, Set Reference) -> Map NameSegment PatchHash -> Map NameSegment CausalHash -> Set CausalHash -> DumpNamespace
[$sel:terms:DumpNamespace] :: DumpNamespace -> Map Referent (Set NameSegment, Set Reference)
[$sel:types:DumpNamespace] :: DumpNamespace -> Map Reference (Set NameSegment, Set Reference)
[$sel:patches:DumpNamespace] :: DumpNamespace -> Map NameSegment PatchHash
[$sel:children:DumpNamespace] :: DumpNamespace -> Map NameSegment CausalHash
[$sel:causalParents:DumpNamespace] :: DumpNamespace -> Set CausalHash
instance GHC.Show.Show Unison.Codebase.Editor.Output.DumpNamespace.DumpNamespace

module Unison.Codebase.Editor.Output.PushPull
data PushPull
Push :: PushPull
Pull :: PushPull
fold :: a -> a -> PushPull -> a
instance GHC.Show.Show Unison.Codebase.Editor.Output.PushPull.PushPull
instance GHC.Classes.Ord Unison.Codebase.Editor.Output.PushPull.PushPull
instance GHC.Classes.Eq Unison.Codebase.Editor.Output.PushPull.PushPull

module Unison.Codebase.Editor.SlurpComponent
data SlurpComponent
SlurpComponent :: Set Symbol -> Set Symbol -> Set Symbol -> SlurpComponent
[$sel:types:SlurpComponent] :: SlurpComponent -> Set Symbol
[$sel:terms:SlurpComponent] :: SlurpComponent -> Set Symbol
[$sel:ctors:SlurpComponent] :: SlurpComponent -> Set Symbol
empty :: SlurpComponent
fromTerms :: Set Symbol -> SlurpComponent
fromTypes :: Set Symbol -> SlurpComponent
fromCtors :: Set Symbol -> SlurpComponent
isEmpty :: SlurpComponent -> Bool
difference :: SlurpComponent -> SlurpComponent -> SlurpComponent
intersection :: SlurpComponent -> SlurpComponent -> SlurpComponent
closeWithDependencies :: forall a. TypecheckedUnisonFile Symbol a -> SlurpComponent -> SlurpComponent
instance GHC.Show.Show Unison.Codebase.Editor.SlurpComponent.SlurpComponent
instance GHC.Classes.Ord Unison.Codebase.Editor.SlurpComponent.SlurpComponent
instance GHC.Classes.Eq Unison.Codebase.Editor.SlurpComponent.SlurpComponent
instance GHC.Base.Semigroup Unison.Codebase.Editor.SlurpComponent.SlurpComponent
instance GHC.Base.Monoid Unison.Codebase.Editor.SlurpComponent.SlurpComponent

module Unison.Codebase.Editor.SlurpResult
data SlurpResult
SlurpResult :: TypecheckedUnisonFile Symbol Ann -> SlurpComponent -> SlurpComponent -> SlurpComponent -> SlurpComponent -> SlurpComponent -> Set Symbol -> Set Symbol -> Map Symbol Aliases -> Map Symbol Aliases -> SlurpComponent -> SlurpResult
[$sel:originalFile:SlurpResult] :: SlurpResult -> TypecheckedUnisonFile Symbol Ann
[$sel:extraDefinitions:SlurpResult] :: SlurpResult -> SlurpComponent
[$sel:adds:SlurpResult] :: SlurpResult -> SlurpComponent
[$sel:duplicates:SlurpResult] :: SlurpResult -> SlurpComponent
[$sel:collisions:SlurpResult] :: SlurpResult -> SlurpComponent
[$sel:updates:SlurpResult] :: SlurpResult -> SlurpComponent
[$sel:termExistingConstructorCollisions:SlurpResult] :: SlurpResult -> Set Symbol
[$sel:constructorExistingTermCollisions:SlurpResult] :: SlurpResult -> Set Symbol
[$sel:termAlias:SlurpResult] :: SlurpResult -> Map Symbol Aliases
[$sel:typeAlias:SlurpResult] :: SlurpResult -> Map Symbol Aliases
[$sel:defsWithBlockedDependencies:SlurpResult] :: SlurpResult -> SlurpComponent
data Aliases
AddAliases :: Set Name -> Aliases
UpdateAliases :: Set Name -> Set Name -> Aliases
[$sel:oldRefNames:AddAliases] :: Aliases -> Set Name
[$sel:newRefNames:AddAliases] :: Aliases -> Set Name
isOk :: SlurpResult -> Bool
isAllDuplicates :: SlurpResult -> Bool
hasAddsOrUpdates :: SlurpResult -> Bool
filterUnisonFile :: SlurpResult -> TypecheckedUnisonFile Symbol Ann -> TypecheckedUnisonFile Symbol Ann
pretty :: IsPastTense -> PrettyPrintEnv -> SlurpResult -> Pretty ColorText
data Status
Add :: Status
Update :: Status
Duplicate :: Status
Collision :: Status
TermExistingConstructorCollision :: Status
ConstructorExistingTermCollision :: Status
ExtraDefinition :: Status
BlockedDependency :: Status
prettyStatus :: Status -> Pretty ColorText
instance GHC.Classes.Ord Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Classes.Eq Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Show.Show Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Show.Show Unison.Codebase.Editor.SlurpResult.SlurpResult
instance GHC.Show.Show Unison.Codebase.Editor.SlurpResult.Status
instance GHC.Classes.Eq Unison.Codebase.Editor.SlurpResult.Status
instance GHC.Classes.Ord Unison.Codebase.Editor.SlurpResult.Status

module Unison.Codebase.Editor.Slurp

-- | The operation which is being performed or checked.
data SlurpOp
AddOp :: SlurpOp
UpdateOp :: SlurpOp
CheckOp :: SlurpOp

-- | Analyze a file and determine the status of all of its definitions with
--   respect to a set of vars to analyze and an operation you wish to
--   perform.
slurpFile :: TypecheckedUnisonFile Symbol Ann -> Set Symbol -> SlurpOp -> Names -> SlurpResult
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.SlurpOp
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.SlurpOp
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.TaggedVar
instance GHC.Classes.Ord Unison.Codebase.Editor.Slurp.TaggedVar
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.TaggedVar
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Classes.Ord Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.DepStatus
instance GHC.Classes.Ord Unison.Codebase.Editor.Slurp.DepStatus
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.DepStatus
instance GHC.Base.Semigroup Unison.Codebase.Editor.Slurp.SlurpingSummary
instance GHC.Base.Monoid Unison.Codebase.Editor.Slurp.SlurpingSummary

module Unison.Codebase.Editor.TodoOutput
type Score = Int
data TodoOutput v a
TodoOutput :: Score -> ([(Reference, Maybe (Type v a))], [(Reference, DisplayObject () (Decl v a))]) -> ([(Score, Reference, Maybe (Type v a))], [(Score, Reference, DisplayObject () (Decl v a))]) -> Names -> Patch -> TodoOutput v a
[$sel:todoScore:TodoOutput] :: TodoOutput v a -> Score
[$sel:todoFrontier:TodoOutput] :: TodoOutput v a -> ([(Reference, Maybe (Type v a))], [(Reference, DisplayObject () (Decl v a))])
[$sel:todoFrontierDependents:TodoOutput] :: TodoOutput v a -> ([(Score, Reference, Maybe (Type v a))], [(Score, Reference, DisplayObject () (Decl v a))])
[$sel:nameConflicts:TodoOutput] :: TodoOutput v a -> Names
[$sel:editConflicts:TodoOutput] :: TodoOutput v a -> Patch
labeledDependencies :: Ord v => TodoOutput v a -> Set LabeledDependency
noConflicts :: TodoOutput v a -> Bool
noEdits :: TodoOutput v a -> Bool

module Unison.Codebase.Editor.UCMVersion
type UCMVersion = Text

module Unison.Codebase.Editor.UriParser
repoPath :: P (ReadRemoteNamespace (These ProjectName ProjectBranchName))
writeGitRepo :: P WriteGitRepo

-- | A parser for the deprecated format of git URLs, which may still exist
--   in old GitURL unisonConfigs.
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "/srv/git/project.git:.namespace"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "/srv/git/project.git:branch:.namespace"
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "/srv/git/project.git", branch = Nothing}, path = namespace})
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "/srv/git/project.git", branch = Just "branch"}, path = namespace})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "file:///srv/git/project.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "file:///srv/git/project.git:branch"
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "file:///srv/git/project.git", branch = Nothing}, path = })
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "file:///srv/git/project.git", branch = Just "branch"}, path = })
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "https://example.com/gitproject.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "https://example.com/gitproject.git:base"
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "https://example.com/gitproject.git", branch = Nothing}, path = })
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "https://example.com/gitproject.git", branch = Just "base"}, path = })
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "ssh://user@server/project.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "ssh://user@server/project.git:branch"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "ssh://server/project.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "ssh://server/project.git:branch"
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "ssh://user@server/project.git", branch = Nothing}, path = })
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "ssh://user@server/project.git", branch = Just "branch"}, path = })
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "ssh://server/project.git", branch = Nothing}, path = })
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "ssh://server/project.git", branch = Just "branch"}, path = })
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "server:project"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemoteNamespace "user@server:project.git:branch"
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "server:project", branch = Nothing}, path = })
--   Just (WriteGitRemoteNamespace {repo = WriteGitRepo {url = "user@server:project.git", branch = Just "branch"}, path = })
--   </pre>
deprecatedWriteGitRemoteNamespace :: P WriteGitRemoteNamespace
writeRemoteNamespace :: P (WriteRemoteNamespace (These ProjectName ProjectBranchName))
writeRemoteNamespaceWith :: P a -> P (WriteRemoteNamespace a)
parseReadRemoteNamespace :: String -> String -> Either (Pretty ColorText) (ReadRemoteNamespace (These ProjectName ProjectBranchName))
parseReadShareLooseCode :: String -> String -> Either (Pretty ColorText) ReadShareLooseCode
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.User
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.User
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.User
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.HostInfo
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.HostInfo
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.HostInfo
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.GitProtocol
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.GitProtocol
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.GitProtocol

module Unison.Codebase.Editor.VersionParser

-- | Parse git version strings into valid unison namespaces.
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe defaultBaseLib "release/M4"
--   
--   &gt;&gt;&gt; parseMaybe defaultBaseLib "release/M4b"
--   
--   &gt;&gt;&gt; parseMaybe defaultBaseLib "release/M4c.2"
--   Just (ReadShareLooseCode {server = DefaultCodeserver, repo = "unison", path = public.base.releases.M4})
--   Just (ReadShareLooseCode {server = DefaultCodeserver, repo = "unison", path = public.base.releases.M4b})
--   Just (ReadShareLooseCode {server = DefaultCodeserver, repo = "unison", path = public.base.releases.M4c_2})
--   </pre>
defaultBaseLib :: Parsec Void Text ReadShareLooseCode


-- | Command-line fuzzy selection of arbitrary values. Shells out to fzf
--   for the actual selection.
module Unison.CommandLine.FuzzySelect

-- | Allows prompting the user to interactively fuzzy-select a result from
--   a list of options, currently shells out to <tt>fzf</tt> under the
--   hood. If fzf is missing, or an error (other than ctrl-c) occurred,
--   returns Nothing.
fuzzySelect :: forall a. Options -> (a -> Text) -> [a] -> IO (Maybe [a])

-- | Fuzzy Selection options
data Options
Options :: Bool -> Options
[$sel:allowMultiSelect:Options] :: Options -> Bool

-- | Default <a>Options</a>
defaultOptions :: Options


-- | Provides Globbing for selecting types, terms and namespaces using
--   wildcards.
module Unison.CommandLine.Globbing

-- | Expand a single glob pattern into all matching targets of the
--   specified types.
expandGlobs :: forall m. Set TargetType -> Branch0 m -> Absolute -> String -> Maybe [String]
containsGlob :: String -> Bool

-- | Possible targets which a glob may select.
data TargetType
Type :: TargetType
Term :: TargetType
Namespace :: TargetType
instance GHC.Show.Show Unison.CommandLine.Globbing.TargetType
instance GHC.Classes.Ord Unison.CommandLine.Globbing.TargetType
instance GHC.Classes.Eq Unison.CommandLine.Globbing.TargetType
instance GHC.Show.Show Unison.CommandLine.Globbing.GlobArg

module Unison.CommandLine.Types
data ShouldWatchFiles
ShouldWatchFiles :: ShouldWatchFiles
ShouldNotWatchFiles :: ShouldWatchFiles
instance GHC.Classes.Eq Unison.CommandLine.Types.ShouldWatchFiles
instance GHC.Show.Show Unison.CommandLine.Types.ShouldWatchFiles

module Unison.CommandLine.Welcome
data Welcome
Welcome :: Onboarding -> DownloadBase -> FilePath -> Text -> ShouldWatchFiles -> Welcome
[$sel:onboarding:Welcome] :: Welcome -> Onboarding
[$sel:downloadBase:Welcome] :: Welcome -> DownloadBase
[$sel:watchDir:Welcome] :: Welcome -> FilePath
[$sel:unisonVersion:Welcome] :: Welcome -> Text
[$sel:shouldWatchFiles:Welcome] :: Welcome -> ShouldWatchFiles
data DownloadBase
DownloadBase :: ReadShareLooseCode -> DownloadBase
DontDownloadBase :: DownloadBase
data CodebaseInitStatus
NewlyCreatedCodebase :: CodebaseInitStatus
PreviouslyCreatedCodebase :: CodebaseInitStatus
data Onboarding
Init :: CodebaseInitStatus -> Onboarding
DownloadingBase :: ReadShareLooseCode -> Onboarding
Author :: Onboarding
Finished :: Onboarding
PreviouslyOnboarded :: Onboarding
welcome :: CodebaseInitStatus -> DownloadBase -> FilePath -> Text -> ShouldWatchFiles -> Welcome
pullBase :: ReadShareLooseCode -> Either Event Input
run :: Codebase IO v a -> Welcome -> IO [Either Event Input]
toInput :: Pretty ColorText -> Either Event Input
determineFirstStep :: DownloadBase -> Codebase IO v a -> IO Onboarding
asciiartUnison :: Pretty ColorText
downloading :: Path -> Pretty ColorText
header :: Text -> Pretty ColorText
authorSuggestion :: Pretty ColorText
getStarted :: ShouldWatchFiles -> FilePath -> IO (Pretty ColorText)
instance GHC.Classes.Eq Unison.CommandLine.Welcome.DownloadBase
instance GHC.Show.Show Unison.CommandLine.Welcome.DownloadBase
instance GHC.Classes.Eq Unison.CommandLine.Welcome.CodebaseInitStatus
instance GHC.Show.Show Unison.CommandLine.Welcome.CodebaseInitStatus
instance GHC.Classes.Eq Unison.CommandLine.Welcome.Onboarding
instance GHC.Show.Show Unison.CommandLine.Welcome.Onboarding


-- | Instances for LSP types which are strangely missing.
module Unison.LSP.Orphans
instance GHC.Classes.Ord Language.LSP.Types.TextDocument.TextDocumentIdentifier
instance Language.LSP.Types.Lens.HasTextDocument Language.LSP.Types.TextDocument.TextDocumentIdentifier Language.LSP.Types.TextDocument.TextDocumentIdentifier
instance Language.LSP.Types.Lens.HasTextDocument Language.LSP.Types.TextDocument.VersionedTextDocumentIdentifier Language.LSP.Types.TextDocument.VersionedTextDocumentIdentifier
instance Language.LSP.Types.Lens.HasUri Language.LSP.Types.Uri.NormalizedUri Language.LSP.Types.Uri.Uri

module Unison.LSP.Conversions
rangeToInterval :: Range -> Interval Position
annToInterval :: Ann -> Maybe (Interval Position)
uToLspPos :: Pos -> Position
lspToUPos :: Position -> Pos
uToLspRange :: Range -> Range
annToRange :: Ann -> Maybe Range

module Unison.LSP.Types

-- | A custom LSP monad wrapper so we can provide our own environment.
newtype Lsp a
Lsp :: ReaderT Env (LspM Config) a -> Lsp a
[$sel:runLspM:Lsp] :: Lsp a -> ReaderT Env (LspM Config) a

-- | Log an info message to the client's LSP log.
logInfo :: Text -> Lsp ()

-- | Log an error message to the client's LSP log, this will be shown to
--   the user in most LSP implementations.
logError :: Text -> Lsp ()

-- | Environment for the Lsp monad.
data Env
Env :: LanguageContextEnv Config -> Codebase IO Symbol Ann -> IO NamesWithHistory -> IO PrettyPrintEnvDecl -> IO (NameSearch Transaction) -> IO Absolute -> MVar VFS -> Runtime Symbol -> TVar (Map Uri FileAnalysis) -> TVar (Set Uri) -> TVar (Map SomeLspId (IO ())) -> TVar CompletionTree -> Scope -> Env
[$sel:lspContext:Env] :: Env -> LanguageContextEnv Config
[$sel:codebase:Env] :: Env -> Codebase IO Symbol Ann
[$sel:parseNamesCache:Env] :: Env -> IO NamesWithHistory
[$sel:ppedCache:Env] :: Env -> IO PrettyPrintEnvDecl
[$sel:nameSearchCache:Env] :: Env -> IO (NameSearch Transaction)
[$sel:currentPathCache:Env] :: Env -> IO Absolute
[$sel:vfsVar:Env] :: Env -> MVar VFS
[$sel:runtime:Env] :: Env -> Runtime Symbol
[$sel:checkedFilesVar:Env] :: Env -> TVar (Map Uri FileAnalysis)
[$sel:dirtyFilesVar:Env] :: Env -> TVar (Set Uri)
[$sel:cancellationMapVar:Env] :: Env -> TVar (Map SomeLspId (IO ()))
[$sel:completionsVar:Env] :: Env -> TVar CompletionTree
[$sel:scope:Env] :: Env -> Scope

-- | A suffix tree over path segments of name completions. see
--   <tt>namesToCompletionTree</tt> for more on how this is built and the
--   invariants it should have.
newtype CompletionTree
CompletionTree :: Cofree (Map NameSegment) (Set (Name, LabeledDependency)) -> CompletionTree
[$sel:unCompletionTree:CompletionTree] :: CompletionTree -> Cofree (Map NameSegment) (Set (Name, LabeledDependency))

-- | A monotonically increasing file version tracked by the lsp client.
type FileVersion = Int32
type LexedSource = (Text, [Token Lexeme])
data FileAnalysis
FileAnalysis :: Uri -> FileVersion -> LexedSource -> IntervalMap Position Lexeme -> Maybe (UnisonFile Symbol Ann) -> Maybe (TypecheckedUnisonFile Symbol Ann) -> Seq (Note Symbol Ann) -> IntervalMap Position [Diagnostic] -> IntervalMap Position [CodeAction] -> Maybe FileSummary -> FileAnalysis
[$sel:fileUri:FileAnalysis] :: FileAnalysis -> Uri
[$sel:fileVersion:FileAnalysis] :: FileAnalysis -> FileVersion
[$sel:lexedSource:FileAnalysis] :: FileAnalysis -> LexedSource
[$sel:tokenMap:FileAnalysis] :: FileAnalysis -> IntervalMap Position Lexeme
[$sel:parsedFile:FileAnalysis] :: FileAnalysis -> Maybe (UnisonFile Symbol Ann)
[$sel:typecheckedFile:FileAnalysis] :: FileAnalysis -> Maybe (TypecheckedUnisonFile Symbol Ann)
[$sel:notes:FileAnalysis] :: FileAnalysis -> Seq (Note Symbol Ann)
[$sel:diagnostics:FileAnalysis] :: FileAnalysis -> IntervalMap Position [Diagnostic]
[$sel:codeActions:FileAnalysis] :: FileAnalysis -> IntervalMap Position [CodeAction]
[$sel:fileSummary:FileAnalysis] :: FileAnalysis -> Maybe FileSummary

-- | A file that parses might not always type-check, but often we just want
--   to get as much information as we have available. This provides a type
--   where we can summarize the information available in a Unison file.
--   
--   If the file typechecked then all the Ref Ids and types will be filled
--   in, otherwise they will be Nothing.
data FileSummary
FileSummary :: Map Symbol (Id, DataDeclaration Symbol Ann) -> Map Id (Map Symbol (DataDeclaration Symbol Ann)) -> Map Symbol (Id, EffectDeclaration Symbol Ann) -> Map Id (Map Symbol (EffectDeclaration Symbol Ann)) -> Map Symbol (Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann)) -> Map (Maybe Id) (Map Symbol (Term Symbol Ann, Maybe (Type Symbol Ann))) -> [(Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann))] -> [(Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann))] -> Names -> FileSummary
[$sel:dataDeclsBySymbol:FileSummary] :: FileSummary -> Map Symbol (Id, DataDeclaration Symbol Ann)
[$sel:dataDeclsByReference:FileSummary] :: FileSummary -> Map Id (Map Symbol (DataDeclaration Symbol Ann))
[$sel:effectDeclsBySymbol:FileSummary] :: FileSummary -> Map Symbol (Id, EffectDeclaration Symbol Ann)
[$sel:effectDeclsByReference:FileSummary] :: FileSummary -> Map Id (Map Symbol (EffectDeclaration Symbol Ann))
[$sel:termsBySymbol:FileSummary] :: FileSummary -> Map Symbol (Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann))
[$sel:termsByReference:FileSummary] :: FileSummary -> Map (Maybe Id) (Map Symbol (Term Symbol Ann, Maybe (Type Symbol Ann)))
[$sel:testWatchSummary:FileSummary] :: FileSummary -> [(Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann))]
[$sel:exprWatchSummary:FileSummary] :: FileSummary -> [(Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann))]
[$sel:fileNames:FileSummary] :: FileSummary -> Names
getCurrentPath :: Lsp Absolute
getCodebaseCompletions :: Lsp CompletionTree
globalPPED :: Lsp PrettyPrintEnvDecl
getNameSearch :: Lsp (NameSearch Transaction)
getParseNames :: Lsp NamesWithHistory
data Config
Config :: Maybe Int -> Config
[$sel:maxCompletions:Config] :: Config -> Maybe Int
defaultLSPConfig :: Config

-- | Lift a backend computation into the Lsp monad.
lspBackend :: Backend IO a -> Lsp (Either BackendError a)
sendNotification :: forall (m :: Method 'FromServer 'Notification). Message m ~ NotificationMessage m => NotificationMessage m -> Lsp ()
data RangedCodeAction
RangedCodeAction :: [Range] -> CodeAction -> RangedCodeAction
[$sel:_codeActionRanges:RangedCodeAction] :: RangedCodeAction -> [Range]
[$sel:_codeAction:RangedCodeAction] :: RangedCodeAction -> CodeAction
rangedCodeAction :: Text -> [Diagnostic] -> [Range] -> RangedCodeAction

-- | Provided ranges must not intersect.
includeEdits :: Uri -> Text -> [Range] -> RangedCodeAction -> RangedCodeAction
getConfig :: Lsp Config
setConfig :: Config -> Lsp ()
instance GHC.Show.Show Unison.LSP.Types.CompletionTree
instance GHC.Show.Show Unison.LSP.Types.FileSummary
instance GHC.Show.Show Unison.LSP.Types.FileAnalysis
instance GHC.Show.Show Unison.LSP.Types.Config
instance Language.LSP.Server.Core.MonadLsp Unison.LSP.Types.Config Unison.LSP.Types.Lsp
instance Control.Monad.Reader.Class.MonadReader Unison.LSP.Types.Env Unison.LSP.Types.Lsp
instance Control.Monad.IO.Unlift.MonadUnliftIO Unison.LSP.Types.Lsp
instance Control.Monad.IO.Class.MonadIO Unison.LSP.Types.Lsp
instance GHC.Base.Monad Unison.LSP.Types.Lsp
instance GHC.Base.Applicative Unison.LSP.Types.Lsp
instance GHC.Base.Functor Unison.LSP.Types.Lsp
instance GHC.Show.Show Unison.LSP.Types.RangedCodeAction
instance GHC.Classes.Eq Unison.LSP.Types.RangedCodeAction
instance Language.LSP.Types.Lens.HasCodeAction Unison.LSP.Types.RangedCodeAction Language.LSP.Types.CodeAction.CodeAction
instance Data.Aeson.Types.FromJSON.FromJSON Unison.LSP.Types.Config
instance Data.Aeson.Types.ToJSON.ToJSON Unison.LSP.Types.Config
instance GHC.Base.Semigroup Unison.LSP.Types.CompletionTree
instance GHC.Base.Monoid Unison.LSP.Types.CompletionTree

module Unison.LSP.NotificationHandlers
initializedHandler :: NotificationMessage 'Initialized -> Lsp ()
withDebugging :: Show m => (m -> Lsp ()) -> m -> Lsp ()

module Unison.LSP.HandlerUtils

-- | Cancels an in-flight request
cancelRequest :: SomeLspId -> Lsp ()
withDebugging :: (Show (RequestMessage message), Show (ResponseResult message)) => (RequestMessage message -> (Either ResponseError (ResponseResult message) -> Lsp ()) -> Lsp ()) -> RequestMessage message -> (Either ResponseError (ResponseResult message) -> Lsp ()) -> Lsp ()

-- | Handler middleware to add the ability for the client to cancel
--   long-running in-flight requests.
withCancellation :: forall message. Maybe Int -> (RequestMessage message -> (Either ResponseError (ResponseResult message) -> Lsp ()) -> Lsp ()) -> RequestMessage message -> (Either ResponseError (ResponseResult message) -> Lsp ()) -> Lsp ()

module Unison.LSP.Diagnostics
annToRange :: Ann -> Maybe Range
uToLspPos :: Pos -> Position
uToLspRange :: Range -> Range
reportDiagnostics :: Foldable f => Uri -> Maybe FileVersion -> f Diagnostic -> Lsp ()
mkDiagnostic :: Uri -> Range -> DiagnosticSeverity -> Text -> [(Text, Range)] -> Diagnostic

module Unison.LSP.Configuration

-- | Handle configuration changes
updateConfig :: Config -> Value -> Either Text Config

-- | We could use this notification to cancel/update work-in-progress, but
--   we don't actually need to update the config here, that's handled by
--   the lsp library automatically.
workspaceConfigurationChanged :: NotificationMessage 'WorkspaceDidChangeConfiguration -> Lsp ()

module Unison.LSP.CancelRequest

-- | Allows a client to cancel work from a previous request.
cancelRequestHandler :: NotificationMessage 'CancelRequest -> Lsp ()

module Unison.LSP.VFS

-- | Some VFS combinators require Monad State, this provides it in a
--   transactionally safe manner so we're sure we don't edit the same file
--   in two different actions at the same time.
usingVFS :: forall a. StateT VFS Lsp a -> Lsp a
getVirtualFile :: Uri -> MaybeT Lsp VirtualFile
getFileContents :: Uri -> MaybeT Lsp (FileVersion, Text)
vfsLogger :: LogAction (StateT VFS Lsp) (WithSeverity VfsLog)

-- | Mark some files as needing to be checked.
markFilesDirty :: (Foldable f, HasUri doc Uri) => f doc -> Lsp ()

-- | Mark all files for re-checking.
--   
--   We may want to do this when our names or perspective change.
markAllFilesDirty :: Lsp ()

-- | Returns the name or symbol which the provided position is contained
--   in.
identifierAtPosition :: Uri -> Position -> MaybeT Lsp Text

-- | Returns the prefix and suffix of the symbol which the provided
--   position is contained in.
identifierSplitAtPosition :: Uri -> Position -> MaybeT Lsp (Text, Text)

-- | Returns the prefix of the symbol at the provided location, and the
--   range that prefix spans.
completionPrefix :: Uri -> Position -> MaybeT Lsp (Range, Text)
lspOpenFile :: NotificationMessage 'TextDocumentDidOpen -> Lsp ()
lspCloseFile :: NotificationMessage 'TextDocumentDidClose -> Lsp ()
lspChangeFile :: NotificationMessage 'TextDocumentDidChange -> Lsp ()

module Unison.Share.Codeserver

-- | This is the URI where the share API is based.
defaultCodeserver :: CodeserverURI
resolveCodeserver :: ShareCodeserver -> CodeserverURI


-- | Types used by the UCM client during sync.
module Unison.Share.Sync.Types

-- | Error used by the client when pushing code to Unison Share.
data CheckAndSetPushError
CheckAndSetPushError'UpdatePath :: RepoInfo -> UpdatePathError -> CheckAndSetPushError
CheckAndSetPushError'UploadEntities :: UploadEntitiesError -> CheckAndSetPushError

-- | Generic Codeserver transport errors
data CodeserverTransportError
DecodeFailure :: Text -> Response -> CodeserverTransportError
PermissionDenied :: Text -> CodeserverTransportError
RateLimitExceeded :: CodeserverTransportError
Timeout :: CodeserverTransportError
Unauthenticated :: BaseUrl -> CodeserverTransportError
UnexpectedResponse :: Response -> CodeserverTransportError
UnreachableCodeserver :: BaseUrl -> CodeserverTransportError

-- | An error occurred while fast-forward pushing code to Unison Share.
data FastForwardPushError
FastForwardPushError'FastForwardPath :: Path -> FastForwardPathError -> FastForwardPushError
FastForwardPushError'GetCausalHash :: GetCausalHashByPathError -> FastForwardPushError
FastForwardPushError'NotFastForward :: Path -> FastForwardPushError
FastForwardPushError'UploadEntities :: UploadEntitiesError -> FastForwardPushError

-- | An error occurred when getting causal hash by path.
data GetCausalHashByPathError

-- | The user does not have permission to read this path.
GetCausalHashByPathErrorNoReadPermission :: Path -> GetCausalHashByPathError

-- | The repo info was invalid. (err, repoInfo)
GetCausalHashByPathErrorInvalidRepoInfo :: Text -> RepoInfo -> GetCausalHashByPathError

-- | The user was not found.
GetCausalHashByPathErrorUserNotFound :: RepoInfo -> GetCausalHashByPathError

-- | An error occurred while pulling code from Unison Share.
data PullError
PullError'DownloadEntities :: DownloadEntitiesError -> PullError
PullError'GetCausalHash :: GetCausalHashByPathError -> PullError
PullError'NoHistoryAtPath :: Path -> PullError
data SyncError e
TransportError :: CodeserverTransportError -> SyncError e
SyncError :: e -> SyncError e
instance GHC.Show.Show Unison.Share.Sync.Types.CheckAndSetPushError
instance GHC.Show.Show Unison.Share.Sync.Types.GetCausalHashByPathError
instance GHC.Show.Show Unison.Share.Sync.Types.PullError
instance GHC.Show.Show Unison.Share.Sync.Types.FastForwardPushError
instance GHC.Exception.Type.Exception Unison.Share.Sync.Types.CodeserverTransportError
instance GHC.Show.Show Unison.Share.Sync.Types.CodeserverTransportError
instance GHC.Show.Show e => GHC.Show.Show (Unison.Share.Sync.Types.SyncError e)
instance GHC.Base.Functor Unison.Share.Sync.Types.SyncError

module Unison.Util.HTTP
addRequestMiddleware :: (Request -> IO Request) -> ManagerSettings -> ManagerSettings
setUserAgent :: Text -> ManagerSettings -> ManagerSettings
ucmUserAgent :: UCMVersion -> Text

module Unison.Auth.HTTPClient

-- | Returns a new http manager which applies the appropriate Authorization
--   header to any hosts our UCM is authenticated with.
newAuthenticatedHTTPClient :: MonadIO m => TokenProvider -> UCMVersion -> m AuthenticatedHttpClient

-- | Newtype to delineate HTTP Managers with access-token logic.
newtype AuthenticatedHttpClient
AuthenticatedHttpClient :: Manager -> AuthenticatedHttpClient

module Unison.CommandLine.InputPattern
data InputPattern
InputPattern :: String -> [String] -> Visibility -> [(IsOptional, ArgumentType)] -> Pretty ColorText -> ([String] -> Either (Pretty ColorText) Input) -> InputPattern
[$sel:patternName:InputPattern] :: InputPattern -> String
[$sel:aliases:InputPattern] :: InputPattern -> [String]
[$sel:visibility:InputPattern] :: InputPattern -> Visibility
[$sel:argTypes:InputPattern] :: InputPattern -> [(IsOptional, ArgumentType)]
[$sel:help:InputPattern] :: InputPattern -> Pretty ColorText
[$sel:parse:InputPattern] :: InputPattern -> [String] -> Either (Pretty ColorText) Input
data ArgumentType
ArgumentType :: String -> (forall m v a. MonadIO m => String -> Codebase m v a -> AuthenticatedHttpClient -> Absolute -> m [Completion]) -> Set TargetType -> ArgumentType
[$sel:typeName:ArgumentType] :: ArgumentType -> String

-- | Generate completion suggestions for this argument type
[$sel:suggestions:ArgumentType] :: ArgumentType -> forall m v a. MonadIO m => String -> Codebase m v a -> AuthenticatedHttpClient -> Absolute -> m [Completion]

-- | Select which targets glob patterns may expand into for this argument.
--   An empty set disables globbing.
[$sel:globTargets:ArgumentType] :: ArgumentType -> Set TargetType
argType :: InputPattern -> Int -> Maybe ArgumentType
data IsOptional
Required :: IsOptional
Optional :: IsOptional
ZeroPlus :: IsOptional
OnePlus :: IsOptional
data Visibility
Hidden :: Visibility
Visible :: Visibility
minArgs :: InputPattern -> Int
maxArgs :: InputPattern -> Maybe Int
instance GHC.Classes.Eq Unison.CommandLine.InputPattern.IsOptional
instance GHC.Show.Show Unison.CommandLine.InputPattern.IsOptional
instance GHC.Classes.Ord Unison.CommandLine.InputPattern.Visibility
instance GHC.Classes.Eq Unison.CommandLine.InputPattern.Visibility
instance GHC.Show.Show Unison.CommandLine.InputPattern.Visibility
instance GHC.Show.Show Unison.CommandLine.InputPattern.ArgumentType

module Unison.CommandLine
allow :: FilePath -> Bool
backtick :: IsString s => Pretty s -> Pretty s
aside :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
bigproblem :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
note :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
nothingTodo :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
plural :: Foldable f => f a -> b -> b -> b
plural' :: Integral a => a -> b -> b -> b
problem :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
tip :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
warn :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
warnNote :: String -> String
parseInput :: IO (Branch0 m) -> Absolute -> [String] -> Map String InputPattern -> [String] -> IO (Either (Pretty ColorText) Input)
prompt :: String
watchConfig :: FilePath -> IO (Config, IO ())
watchFileSystem :: TQueue Event -> FilePath -> IO (IO ())

module Unison.Codebase.Editor.Output
data Output
Success :: Output
NoUnisonFile :: Output
PrintMessage :: Pretty ColorText -> Output
InvalidSourceName :: String -> Output
SourceLoadFailed :: String -> Output
NoMainFunction :: String -> PrettyPrintEnv -> [Type Symbol Ann] -> Output

-- | Function found, but has improper type Note: the constructor name is
--   misleading here; we weren't necessarily looking for a "main".
BadMainFunction :: String -> String -> Type Symbol Ann -> PrettyPrintEnv -> [Type Symbol Ann] -> Output
BranchEmpty :: WhichBranchEmpty -> Output
LoadPullRequest :: ReadRemoteNamespace Void -> ReadRemoteNamespace Void -> Path' -> Path' -> Path' -> Path' -> Output
CreatedNewBranch :: Absolute -> Output
BranchAlreadyExists :: Path' -> Output
FindNoLocalMatches :: Output
PatchAlreadyExists :: Split' -> Output
NoExactTypeMatches :: Output
TypeAlreadyExists :: Split' -> Set Reference -> Output
TypeParseError :: String -> Err Symbol -> Output
ParseResolutionFailures :: String -> [ResolutionFailure Symbol Ann] -> Output
TypeHasFreeVars :: Type Symbol Ann -> Output
TermAlreadyExists :: Split' -> Set Referent -> Output
LabeledReferenceAmbiguous :: Int -> HashQualified Name -> Set LabeledDependency -> Output
LabeledReferenceNotFound :: HashQualified Name -> Output
DeleteNameAmbiguous :: Int -> HQSplit' -> Set Referent -> Set Reference -> Output
TermAmbiguous :: HashQualified Name -> Set Referent -> Output
HashAmbiguous :: ShortHash -> Set Referent -> Output
BranchHashAmbiguous :: ShortCausalHash -> Set ShortCausalHash -> Output
BadNamespace :: String -> String -> Output
BranchNotFound :: Path' -> Output
EmptyLooseCodePush :: Path' -> Output
EmptyProjectBranchPush :: ProjectAndBranch ProjectName ProjectBranchName -> Output
NameNotFound :: HQSplit' -> Output
NamesNotFound :: [Name] -> Output
PatchNotFound :: Split' -> Output
TypeNotFound :: HQSplit' -> Output
TermNotFound :: HQSplit' -> Output
TypeNotFound' :: ShortHash -> Output
TermNotFound' :: ShortHash -> Output
TypeTermMismatch :: HashQualified Name -> HashQualified Name -> Output
NoLastRunResult :: Output
SaveTermNameConflict :: Name -> Output
SearchTermsNotFound :: [HashQualified Name] -> Output
SearchTermsNotFoundDetailed :: Bool -> [HashQualified Name] -> [HashQualified Name] -> Output
DeleteBranchConfirmation :: [(Path', (Names, [SearchResult' Symbol Ann]))] -> Output
DeleteEverythingConfirmation :: Output
MoveRootBranchConfirmation :: Output
MovedOverExistingBranch :: Path' -> Output
DeletedEverything :: Output
ListNames :: IsGlobal -> Int -> [(Reference, [HashQualified Name])] -> [(Referent, [HashQualified Name])] -> Output
ListOfDefinitions :: FindScope -> PrettyPrintEnv -> ListDetailed -> [SearchResult' Symbol Ann] -> Output
ListOfLinks :: PrettyPrintEnv -> [(HashQualified Name, Reference, Maybe (Type Symbol Ann))] -> Output
ListShallow :: IO PrettyPrintEnv -> [ShallowListEntry Symbol Ann] -> Output
ListOfPatches :: Set Name -> Output
SlurpOutput :: Input -> PrettyPrintEnv -> SlurpResult -> Output
ParseErrors :: Text -> [Err Symbol] -> Output
TypeErrors :: Absolute -> Text -> PrettyPrintEnv -> [ErrorNote Symbol Ann] -> Output
CompilerBugs :: Text -> PrettyPrintEnv -> [CompilerBug Symbol Ann] -> Output
DisplayConflicts :: Relation Name Referent -> Relation Name Reference -> Output
EvaluationFailure :: Error -> Output
Evaluated :: SourceFileContents -> PrettyPrintEnv -> [(Symbol, Term Symbol ())] -> Map Symbol (Ann, WatchKind, Term Symbol (), IsCacheHit) -> Output
RunResult :: PrettyPrintEnv -> Term Symbol () -> Output
Typechecked :: SourceName -> PrettyPrintEnv -> SlurpResult -> TypecheckedUnisonFile Symbol Ann -> Output
DisplayRendered :: Maybe FilePath -> Pretty ColorText -> Output
DisplayDefinitions :: DisplayDefinitionsOutput -> Output
TestIncrementalOutputStart :: PrettyPrintEnv -> (Int, Int) -> Reference -> Term Symbol Ann -> Output
TestIncrementalOutputEnd :: PrettyPrintEnv -> (Int, Int) -> Reference -> Term Symbol Ann -> Output
TestResults :: TestReportStats -> PrettyPrintEnv -> ShowSuccesses -> ShowFailures -> [(Reference, Text)] -> [(Reference, Text)] -> Output
CantUndo :: UndoFailureReason -> Output
BustedBuiltins :: Set Reference -> Set Reference -> Output
GitError :: GitError -> Output
ShareError :: ShareError -> Output
ViewOnShare :: WriteShareRemoteNamespace -> Output
ConfiguredMetadataParseError :: Path' -> String -> Pretty ColorText -> Output
NoConfiguredRemoteMapping :: PushPull -> Absolute -> Output
ConfiguredRemoteMappingParseError :: PushPull -> Absolute -> Text -> String -> Output
MetadataMissingType :: PrettyPrintEnv -> Referent -> Output
TermMissingType :: Reference -> Output
MetadataAmbiguous :: HashQualified Name -> PrettyPrintEnv -> [Referent] -> Output
NothingToPatch :: PatchPath -> Path' -> Output
PatchNeedsToBeConflictFree :: Output
PatchInvolvesExternalDependents :: PrettyPrintEnv -> Set Reference -> Output
WarnIncomingRootBranch :: ShortCausalHash -> Set ShortCausalHash -> Output
StartOfCurrentPathHistory :: Output
ShowReflog :: [(Maybe UTCTime, ShortCausalHash, Text)] -> Output
PullAlreadyUpToDate :: ReadRemoteNamespace RemoteProjectBranch -> PullTarget (ProjectAndBranch Project ProjectBranch) -> Output
PullSuccessful :: ReadRemoteNamespace RemoteProjectBranch -> PullTarget (ProjectAndBranch Project ProjectBranch) -> Output

-- | Indicates a trivial merge where the destination was empty and was just
--   replaced.
MergeOverEmpty :: PullTarget (ProjectAndBranch Project ProjectBranch) -> Output
MergeAlreadyUpToDate :: Path' -> Path' -> Output
PreviewMergeAlreadyUpToDate :: Path' -> Path' -> Output

-- | No conflicts or edits remain for the current patch.
NoConflictsOrEdits :: Output
NotImplemented :: Output
NoBranchWithHash :: ShortCausalHash -> Output
ListDependencies :: Int -> LabeledDependency -> [(Name, Reference)] -> Set Reference -> Output

-- | List dependents of a type or term.
ListDependents :: Int -> LabeledDependency -> [(Reference, Maybe Name)] -> Output

-- | List all direct dependencies which don't have any names in the current
--   branch
ListNamespaceDependencies :: PrettyPrintEnv -> Absolute -> Map LabeledDependency (Set Name) -> Output
DumpNumberedArgs :: NumberedArgs -> Output
DumpBitBooster :: CausalHash -> Map CausalHash [CausalHash] -> Output
DumpUnisonFileHashes :: Int -> [(Name, Id)] -> [(Name, Id)] -> [(Name, Id)] -> Output
BadName :: String -> Output
DefaultMetadataNotification :: Output
CouldntLoadBranch :: CausalHash -> Output
HelpMessage :: InputPattern -> Output
NamespaceEmpty :: NonEmpty AbsBranchId -> Output
NoOp :: Output
RefusedToPush :: PushBehavior -> WriteRemoteNamespace Void -> Output

-- | <tt>GistCreated repo</tt> means a causal was just published to
--   <tt>repo</tt>.
GistCreated :: ReadRemoteNamespace Void -> Output

-- | Directs the user to URI to begin an authorization flow.
InitiateAuthFlow :: URI -> Output
UnknownCodeServer :: Text -> Output
CredentialFailureMsg :: CredentialFailure -> Output
PrintVersion :: Text -> Output
IntegrityCheck :: IntegrityResult -> Output
DisplayDebugNameDiff :: NameChanges -> Output
DisplayDebugCompletions :: [Completion] -> Output
ClearScreen :: Output
PulledEmptyBranch :: ReadRemoteNamespace RemoteProjectBranch -> Output
CreatedProject :: ProjectName -> ProjectBranchName -> Output
CreatedProjectBranch :: ProjectBranchName -> ProjectBranchName -> Output
CreatedRemoteProject :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
CreatedRemoteProjectBranch :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
RemoteProjectBranchIsUpToDate :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
InvalidProjectName :: Text -> Output
InvalidProjectBranchName :: Text -> Output
RefusedToCreateProjectBranch :: ProjectAndBranch ProjectName ProjectBranchName -> Output
ProjectNameAlreadyExists :: ProjectName -> Output
ProjectNameRequiresUserSlug :: ProjectName -> Output
ProjectAndBranchNameAlreadyExists :: ProjectAndBranch ProjectName ProjectBranchName -> Output
NotOnProjectBranch :: Output
NoAssociatedRemoteProject :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
NoAssociatedRemoteProjectBranch :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
LocalProjectBranchDoesntExist :: ProjectAndBranch ProjectName ProjectBranchName -> Output
RemoteProjectDoesntExist :: URI -> ProjectName -> Output
RemoteProjectBranchDoesntExist :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
RemoteProjectBranchHeadMismatch :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
Unauthorized :: Text -> Output
ServantClientError :: ClientError -> Output
MarkdownOut :: Text -> Output
DownloadedEntities :: Int -> Output
UploadedEntities :: Int -> Output
NotImplementedYet :: Text -> Output
data DisplayDefinitionsOutput
DisplayDefinitionsOutput :: (TermReference -> Bool) -> Maybe FilePath -> PrettyPrintEnvDecl -> Map Reference (DisplayObject (Type Symbol Ann) (Term Symbol Ann)) -> Map Reference (DisplayObject () (Decl Symbol Ann)) -> DisplayDefinitionsOutput
[$sel:isTest:DisplayDefinitionsOutput] :: DisplayDefinitionsOutput -> TermReference -> Bool
[$sel:outputFile:DisplayDefinitionsOutput] :: DisplayDefinitionsOutput -> Maybe FilePath
[$sel:prettyPrintEnv:DisplayDefinitionsOutput] :: DisplayDefinitionsOutput -> PrettyPrintEnvDecl
[$sel:terms:DisplayDefinitionsOutput] :: DisplayDefinitionsOutput -> Map Reference (DisplayObject (Type Symbol Ann) (Term Symbol Ann))
[$sel:types:DisplayDefinitionsOutput] :: DisplayDefinitionsOutput -> Map Reference (DisplayObject () (Decl Symbol Ann))

-- | A branch was empty. But how do we refer to that branch?
data WhichBranchEmpty
WhichBranchEmptyHash :: ShortCausalHash -> WhichBranchEmpty
WhichBranchEmptyPath :: Path' -> WhichBranchEmpty
data NumberedOutput
ShowDiffNamespace :: AbsBranchId -> AbsBranchId -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterUndo :: PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterDeleteDefinitions :: PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterDeleteBranch :: Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterModifyBranch :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterMerge :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterMergePropagate :: Path' -> Absolute -> Path' -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterMergePreview :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterPull :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterCreateAuthor :: NameSegment -> Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput

-- | Invariant: there's at least one conflict or edit in the TodoOutput.
TodoOutput :: PrettyPrintEnvDecl -> TodoOutput Symbol Ann -> NumberedOutput

-- | CantDeleteDefinitions ppe couldntDelete becauseTheseStillReferenceThem
CantDeleteDefinitions :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput

-- | CantDeleteNamespace ppe couldntDelete becauseTheseStillReferenceThem
CantDeleteNamespace :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput

-- | DeletedDespiteDependents ppe deletedThings
--   thingsWhichNowHaveUnnamedReferences
DeletedDespiteDependents :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput

-- | size limit, history , how the history ends
History :: Maybe Int -> HashLength -> [(CausalHash, Diff)] -> HistoryTail -> NumberedOutput
ListEdits :: Patch -> PrettyPrintEnv -> NumberedOutput
ListProjects :: [Project] -> NumberedOutput
ListBranches :: ProjectName -> [(ProjectBranchName, [(URI, ProjectName, ProjectBranchName)])] -> NumberedOutput
type NumberedArgs = [String]
type ListDetailed = Bool
data HistoryTail
EndOfLog :: CausalHash -> HistoryTail
MergeTail :: CausalHash -> [CausalHash] -> HistoryTail
PageEnd :: CausalHash -> Int -> HistoryTail
data TestReportStats
CachedTests :: TotalCount -> CachedCount -> TestReportStats
NewlyComputed :: TestReportStats
data UndoFailureReason
CantUndoPastStart :: UndoFailureReason
CantUndoPastMerge :: UndoFailureReason
data ShareError
ShareErrorCheckAndSetPush :: CheckAndSetPushError -> ShareError
ShareErrorDownloadEntities :: DownloadEntitiesError -> ShareError
ShareErrorFastForwardPush :: FastForwardPushError -> ShareError
ShareErrorGetCausalHashByPath :: GetCausalHashByPathError -> ShareError
ShareErrorPull :: PullError -> ShareError
ShareErrorTransport :: CodeserverTransportError -> ShareError
ShareErrorUploadEntities :: UploadEntitiesError -> ShareError
isFailure :: Output -> Bool
isNumberedFailure :: NumberedOutput -> Bool
instance GHC.Show.Show Unison.Codebase.Editor.Output.HistoryTail
instance GHC.Show.Show Unison.Codebase.Editor.Output.TestReportStats
instance GHC.Show.Show Unison.Codebase.Editor.Output.UndoFailureReason

module Unison.CommandLine.Completion

-- | Constructs a list of <a>Completion</a>s from a query and completion
--   options by filtering them for prefix matches. A completion will be
--   selected if it's an exact match for a provided option.
exactComplete :: String -> [String] -> [Completion]

-- | Completes a term or type argument by prefix-matching against the
--   query.
prefixCompleteTermOrType :: String -> Absolute -> Transaction [Completion]

-- | Completes a term argument by prefix-matching against the query.
prefixCompleteTerm :: String -> Absolute -> Transaction [Completion]

-- | Completes a term or type argument by prefix-matching against the
--   query.
prefixCompleteType :: String -> Absolute -> Transaction [Completion]

-- | Completes a patch argument by prefix-matching against the query.
prefixCompletePatch :: String -> Absolute -> Transaction [Completion]

-- | The empty completor.
noCompletions :: MonadIO m => String -> Codebase m v a -> AuthenticatedHttpClient -> Absolute -> m [Completion]

-- | Completes a namespace argument by prefix-matching against the query.
prefixCompleteNamespace :: String -> Absolute -> Transaction [Completion]
prettyCompletion :: Bool -> (String, Pretty ColorText) -> Completion
fixupCompletion :: String -> [Completion] -> [Completion]

-- | A completion func for use with Haskeline
haskelineTabComplete :: MonadIO m => Map String InputPattern -> Codebase m v a -> AuthenticatedHttpClient -> Absolute -> CompletionFunc m
sharePathCompletion :: MonadIO m => AuthenticatedHttpClient -> String -> m [Completion]
instance GHC.Classes.Ord Unison.CommandLine.Completion.CompletionType
instance GHC.Classes.Eq Unison.CommandLine.Completion.CompletionType
instance GHC.Show.Show Unison.CommandLine.Completion.CompletionType
instance GHC.Show.Show Unison.CommandLine.Completion.SearchResult
instance Data.Aeson.Types.FromJSON.FromJSON Unison.CommandLine.Completion.SearchResult

module Unison.CommandLine.InputPatterns
showPatternHelp :: InputPattern -> Pretty ColorText
patternName :: InputPattern -> Pretty ColorText
makeExample :: InputPattern -> [Pretty ColorText] -> Pretty ColorText
makeExampleNoBackticks :: InputPattern -> [Pretty ColorText] -> Pretty ColorText
makeExample' :: InputPattern -> Pretty ColorText
makeExampleEOS :: InputPattern -> [Pretty ColorText] -> Pretty ColorText
helpFor :: InputPattern -> Either (Pretty ColorText) Input
mergeBuiltins :: InputPattern
mergeIOBuiltins :: InputPattern
updateBuiltins :: InputPattern
todo :: InputPattern
load :: InputPattern
clear :: InputPattern
add :: InputPattern
previewAdd :: InputPattern
updateNoPatch :: InputPattern
update :: InputPattern
previewUpdate :: InputPattern
patch :: InputPattern
view :: InputPattern
viewGlobal :: InputPattern
display :: InputPattern
displayTo :: InputPattern
docs :: InputPattern
api :: InputPattern
ui :: InputPattern
undo :: InputPattern
viewByPrefix :: InputPattern
find :: InputPattern
findAll :: InputPattern
findGlobal :: InputPattern
find' :: String -> FindScope -> InputPattern
findShallow :: InputPattern
findVerbose :: InputPattern
findVerboseAll :: InputPattern
findPatch :: InputPattern
renameTerm :: InputPattern
renameType :: InputPattern
deleteGen :: Maybe String -> String -> ([HQSplit'] -> DeleteTarget) -> InputPattern
delete :: InputPattern
deleteVerbose :: InputPattern
deleteTerm :: InputPattern
deleteTermVerbose :: InputPattern
deleteType :: InputPattern
deleteTypeVerbose :: InputPattern
deleteTermReplacementCommand :: String
deleteTypeReplacementCommand :: String
deleteReplacement :: Bool -> InputPattern
deleteTermReplacement :: InputPattern
deleteTypeReplacement :: InputPattern
aliasTerm :: InputPattern
aliasType :: InputPattern
aliasMany :: InputPattern
up :: InputPattern
cd :: InputPattern
back :: InputPattern
deleteNamespace :: InputPattern
deleteNamespaceForce :: InputPattern
deleteNamespaceParser :: Pretty ColorText -> Insistence -> [String] -> Either (Pretty ColorText) Input
deletePatch :: InputPattern
movePatch :: String -> String -> Either (Pretty ColorText) Input
copyPatch' :: String -> String -> Either (Pretty ColorText) Input
copyPatch :: InputPattern
renamePatch :: InputPattern
renameBranch :: InputPattern
history :: InputPattern
forkLocal :: InputPattern
resetRoot :: InputPattern
pull :: InputPattern
pullVerbose :: InputPattern
pullWithoutHistory :: InputPattern
pullImpl :: String -> [String] -> Verbosity -> PullMode -> Pretty ColorText -> InputPattern
pullExhaustive :: InputPattern
debugTabCompletion :: InputPattern
push :: InputPattern
pushCreate :: InputPattern
pushForce :: InputPattern
pushExhaustive :: InputPattern
squashMerge :: InputPattern
mergeLocal :: InputPattern
diffNamespace :: InputPattern
previewMergeLocal :: InputPattern
replaceEdit :: (HashQualified Name -> HashQualified Name -> Maybe PatchPath -> Input) -> InputPattern
replace :: InputPattern
viewReflog :: InputPattern
edit :: InputPattern
topicNameArg :: ArgumentType
codebaseServerNameArg :: ArgumentType
helpTopics :: InputPattern
helpTopicsMap :: Map String (Pretty ColorText)
help :: InputPattern
quit :: InputPattern
viewPatch :: InputPattern
link :: InputPattern
links :: InputPattern
unlink :: InputPattern
names :: IsGlobal -> InputPattern
dependents :: InputPattern
dependencies :: InputPattern
namespaceDependencies :: InputPattern
debugNumberedArgs :: InputPattern
debugFileHashes :: InputPattern
debugDumpNamespace :: InputPattern
debugDumpNamespaceSimple :: InputPattern
debugClearWatchCache :: InputPattern
debugDoctor :: InputPattern
debugNameDiff :: InputPattern
test :: InputPattern
testAll :: InputPattern
docsToHtml :: InputPattern
docToMarkdown :: InputPattern
execute :: InputPattern
saveExecuteResult :: InputPattern
ioTest :: InputPattern
makeStandalone :: InputPattern
runScheme :: InputPattern
compileScheme :: InputPattern
schemeLibgen :: InputPattern
fetchScheme :: InputPattern
createAuthor :: InputPattern
gist :: InputPattern
authLogin :: InputPattern
printVersion :: InputPattern
diffNamespaceToPatch :: InputPattern
projectClone :: InputPattern
projectCreate :: InputPattern
projectSwitch :: InputPattern
projects :: InputPattern
branches :: InputPattern
validInputs :: [InputPattern]

-- | A map of all command patterns by pattern name or alias.
patternMap :: Map String InputPattern
visibleInputs :: [InputPattern]
commandNames :: [String]
commandNameArg :: ArgumentType
exactDefinitionArg :: ArgumentType
fuzzyDefinitionQueryArg :: ArgumentType
definitionQueryArg :: ArgumentType
exactDefinitionTypeQueryArg :: ArgumentType
exactDefinitionTermQueryArg :: ArgumentType
patchArg :: ArgumentType
namespaceArg :: ArgumentType

-- | Names of child branches of the branch, only gives options for one
--   <tt>layer</tt> deeper at a time.
childNamespaceNames :: Branch0 m -> [Text]
newNameArg :: ArgumentType
noCompletionsArg :: ArgumentType
gitUrlArg :: ArgumentType

-- | Refers to a namespace on some remote code host.
remoteNamespaceArg :: ArgumentType

-- | A project name and optional branch name, separated by a colon.
projectAndBranchNamesArg :: ArgumentType

-- | A project branch name.
projectBranchNameArg :: ArgumentType

-- | A project name.
projectNameArg :: ArgumentType
parseProjectName :: Text -> Either (Pretty ColorText) ProjectName
parseProjectBranchName :: Text -> Either (Pretty ColorText) ProjectBranchName
parsePullTarget :: String -> Either (Pretty ColorText) (PullTarget (These ProjectName ProjectBranchName))

-- | Parse a <a>PushSource</a>.
parsePushSource :: String -> Either (Pretty ColorText) PushSource

-- | Parse a push target.
parsePushTarget :: String -> Either (Pretty ColorText) (WriteRemoteNamespace (These ProjectName ProjectBranchName))
parseHashQualifiedName :: String -> Either (Pretty ColorText) (HashQualified Name)
parseWriteGitRepo :: String -> String -> Either (Pretty ColorText) WriteGitRepo
collectNothings :: (a -> Maybe b) -> [a] -> [a]
explainRemote :: PushPull -> Pretty ColorText
showErrorFancy :: ShowErrorComponent e => ErrorFancy e -> String
showErrorItem :: ErrorItem (Token Text) -> String


-- | The main CLI monad.
module Unison.Cli.Monad

-- | The main command-line app monad.
--   
--   <ul>
--   <li>It is a reader monad of <a>Env</a>.</li>
--   <li>It is a state monad of <a>LoopState</a>.</li>
--   <li>It is a short-circuiting monad: a <tt>Cli</tt> computation can
--   short-circuit with success or failure in a delimited scope.</li>
--   <li>It is a resource monad: resources can be acquired in
--   callback-style.</li>
--   <li>It is an IO monad: you can do IO things, but throwing synchronous
--   exceptions is discouraged. Use the built-in short-circuiting mechanism
--   instead.</li>
--   </ul>
data Cli a

-- | What a Cli action returns: a value, an instruction to continue
--   processing input, or an instruction to stop processing input.
data ReturnType a
Success :: a -> ReturnType a
Continue :: ReturnType a
HaltRepl :: ReturnType a

-- | Run a <tt>Cli</tt> action down to <tt>IO</tt>.
runCli :: Env -> LoopState -> Cli a -> IO (ReturnType a, LoopState)

-- | The command-line app monad environment.
--   
--   Get the environment with <a>ask</a>.
data Env
Env :: AuthenticatedHttpClient -> Codebase IO Symbol Ann -> Config -> CredentialManager -> IO UniqueName -> (Text -> IO LoadSourceResult) -> (Output -> IO ()) -> (NumberedOutput -> IO NumberedArgs) -> Runtime Symbol -> Runtime Symbol -> Maybe BaseUrl -> UCMVersion -> Env
[$sel:authHTTPClient:Env] :: Env -> AuthenticatedHttpClient
[$sel:codebase:Env] :: Env -> Codebase IO Symbol Ann
[$sel:config:Env] :: Env -> Config
[$sel:credentialManager:Env] :: Env -> CredentialManager

-- | Generate a unique name.
[$sel:generateUniqueName:Env] :: Env -> IO UniqueName

-- | How to load source code.
[$sel:loadSource:Env] :: Env -> Text -> IO LoadSourceResult

-- | What to do with output for the user.
[$sel:notify:Env] :: Env -> Output -> IO ()

-- | What to do with numbered output for the user.
[$sel:notifyNumbered:Env] :: Env -> NumberedOutput -> IO NumberedArgs
[$sel:runtime:Env] :: Env -> Runtime Symbol
[$sel:sandboxedRuntime:Env] :: Env -> Runtime Symbol
[$sel:serverBaseUrl:Env] :: Env -> Maybe BaseUrl
[$sel:ucmVersion:Env] :: Env -> UCMVersion

-- | The command-line app monad mutable state.
--   
--   There's an additional pseudo <tt>"currentPath"</tt> field lens, for
--   convenience.
data LoopState
LoopState :: TMVar (Branch IO) -> CausalHash -> NonEmpty Absolute -> Maybe (FilePath, Bool) -> Maybe (TypecheckedUnisonFile Symbol Ann) -> Maybe Input -> NumberedArgs -> Maybe (Term Symbol Ann, Type Symbol Ann, TypecheckedUnisonFile Symbol Ann) -> LoopState
[$sel:root:LoopState] :: LoopState -> TMVar (Branch IO)
[$sel:lastSavedRootHash:LoopState] :: LoopState -> CausalHash
[$sel:currentPathStack:LoopState] :: LoopState -> NonEmpty Absolute
[$sel:latestFile:LoopState] :: LoopState -> Maybe (FilePath, Bool)
[$sel:latestTypecheckedFile:LoopState] :: LoopState -> Maybe (TypecheckedUnisonFile Symbol Ann)
[$sel:lastInput:LoopState] :: LoopState -> Maybe Input
[$sel:numberedArgs:LoopState] :: LoopState -> NumberedArgs
[$sel:lastRunResult:LoopState] :: LoopState -> Maybe (Term Symbol Ann, Type Symbol Ann, TypecheckedUnisonFile Symbol Ann)

-- | Create an initial loop state given a root branch and the current path.
loopState0 :: CausalHash -> TMVar (Branch IO) -> Absolute -> LoopState

-- | Lift an action of type <tt>IO (Either e a)</tt>, given a continuation
--   for <tt>e</tt>.
ioE :: IO (Either e a) -> (e -> Cli a) -> Cli a

-- | Wrap a continuation with <a>Cli</a>.
--   
--   Useful for resource acquisition:
--   
--   <pre>
--   with (bracket create destroy) \resource -&gt;
--     ...
--   </pre>
with :: (forall x. (a -> IO x) -> IO x) -> (a -> Cli b) -> Cli b

-- | A variant of <a>with</a> for actions that don't acquire a resource
--   (like <a>bracket_</a>).
with_ :: (forall x. IO x -> IO x) -> Cli a -> Cli a

-- | A variant of <a>with</a> for the variant of bracketing function that
--   may return a Left rather than call the provided continuation.
withE :: (forall x. (a -> IO x) -> IO (Either e x)) -> (Either e a -> Cli b) -> Cli b

-- | Create a label that can be jumped to.
--   
--   <pre>
--   x &lt;- label \j0 -&gt; do
--     ...
--     label \j1 -&gt; do
--       ...
--       j0 someValue
--       ... -- We don't get here
--     ... -- We don't get here
--   -- x is bound to someValue
--   </pre>
label :: forall a. ((forall void. a -> Cli void) -> Cli a) -> Cli a

-- | Short-circuit the processing of the current input.
returnEarly :: Output -> Cli a

-- | Variant of <a>returnEarly</a> that doesn't take a final output
--   message.
returnEarlyWithoutOutput :: Cli a

-- | Stop processing inputs from the user.
haltRepl :: Cli a
cd :: Absolute -> Cli ()
respond :: Output -> Cli ()
respondNumbered :: NumberedOutput -> Cli ()

-- | Time an action.
time :: String -> Cli a -> Cli a
runTransaction :: Transaction a -> Cli a

-- | Return early if a transaction returns Left.
runEitherTransaction :: Transaction (Either Output a) -> Cli a

-- | The result of calling <a>$sel:loadSource:Env</a>.
data LoadSourceResult
InvalidSourceNameError :: LoadSourceResult
LoadError :: LoadSourceResult
LoadSuccess :: Text -> LoadSourceResult
instance GHC.Show.Show a => GHC.Show.Show (Unison.Cli.Monad.ReturnType a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Cli.Monad.ReturnType a)
instance GHC.Generics.Generic Unison.Cli.Monad.LoopState
instance GHC.Generics.Generic Unison.Cli.Monad.Env
instance GHC.Base.Functor Unison.Cli.Monad.Cli
instance GHC.Exception.Type.Exception Unison.Cli.Monad.X
instance GHC.Show.Show Unison.Cli.Monad.X
instance GHC.Base.Applicative Unison.Cli.Monad.Cli
instance GHC.Base.Monad Unison.Cli.Monad.Cli
instance Control.Monad.IO.Class.MonadIO Unison.Cli.Monad.Cli
instance Control.Monad.Reader.Class.MonadReader Unison.Cli.Monad.Env Unison.Cli.Monad.Cli
instance Control.Monad.State.Class.MonadState Unison.Cli.Monad.LoopState Unison.Cli.Monad.Cli
instance GHC.Base.Functor f => GHC.OverloadedLabels.IsLabel "currentPath" ((Unison.Codebase.Path.Absolute -> f Unison.Codebase.Path.Absolute) -> Unison.Cli.Monad.LoopState -> f Unison.Cli.Monad.LoopState)

module Unison.Share.Sync

-- | Get the causal hash of a path hosted on Unison Share.
getCausalHashByPath :: BaseUrl -> Path -> Cli (Either (SyncError GetCausalHashByPathError) (Maybe HashJWT))

-- | An error occurred when getting causal hash by path.
data GetCausalHashByPathError

-- | The user does not have permission to read this path.
GetCausalHashByPathErrorNoReadPermission :: Path -> GetCausalHashByPathError

-- | The repo info was invalid. (err, repoInfo)
GetCausalHashByPathErrorInvalidRepoInfo :: Text -> RepoInfo -> GetCausalHashByPathError

-- | The user was not found.
GetCausalHashByPathErrorUserNotFound :: RepoInfo -> GetCausalHashByPathError

-- | Perform a check-and-set push (initially of just a causal hash, but
--   ultimately all of its dependencies that the server is missing, too) to
--   Unison Share.
--   
--   This flavor of push takes the expected state of the server, and the
--   desired state we want to set; if our expectation is off, we won't
--   proceed with the push.
checkAndSetPush :: BaseUrl -> Path -> Maybe Hash32 -> CausalHash -> (Int -> IO ()) -> Cli (Either (SyncError CheckAndSetPushError) ())

-- | Error used by the client when pushing code to Unison Share.
data CheckAndSetPushError
CheckAndSetPushError'UpdatePath :: RepoInfo -> UpdatePathError -> CheckAndSetPushError
CheckAndSetPushError'UploadEntities :: UploadEntitiesError -> CheckAndSetPushError

-- | Perform a fast-forward push (initially of just a causal hash, but
--   ultimately all of its dependencies that the server is missing, too) to
--   Unison Share.
--   
--   This flavor of push provides the server with a chain of causal hashes
--   leading from its current state to our desired state.
fastForwardPush :: BaseUrl -> Path -> CausalHash -> (Int -> IO ()) -> Cli (Either (SyncError FastForwardPushError) ())

-- | An error occurred while fast-forward pushing code to Unison Share.
data FastForwardPushError
FastForwardPushError'FastForwardPath :: Path -> FastForwardPathError -> FastForwardPushError
FastForwardPushError'GetCausalHash :: GetCausalHashByPathError -> FastForwardPushError
FastForwardPushError'NotFastForward :: Path -> FastForwardPushError
FastForwardPushError'UploadEntities :: UploadEntitiesError -> FastForwardPushError

-- | Upload a set of entities to Unison Share. If the server responds that
--   it cannot yet store any hash(es) due to missing dependencies, send
--   those dependencies too, and on and on, until the server stops
--   responding that it's missing anything.
--   
--   Returns true on success, false on failure (because the user does not
--   have write permission).
uploadEntities :: BaseUrl -> RepoInfo -> NESet Hash32 -> (Int -> IO ()) -> Cli (Either (SyncError UploadEntitiesError) ())
pull :: BaseUrl -> Path -> (Int -> IO ()) -> Cli (Either (SyncError PullError) CausalHash)

-- | An error occurred while pulling code from Unison Share.
data PullError
PullError'DownloadEntities :: DownloadEntitiesError -> PullError
PullError'GetCausalHash :: GetCausalHashByPathError -> PullError
PullError'NoHistoryAtPath :: Path -> PullError
downloadEntities :: BaseUrl -> RepoInfo -> HashJWT -> (Int -> IO ()) -> Cli (Either (SyncError DownloadEntitiesError) ())

module Unison.CommandLine.OutputMessages
type Pretty = Pretty ColorText
shortenDirectory :: FilePath -> IO FilePath
renderFileName :: FilePath -> IO Pretty
notifyNumbered :: NumberedOutput -> (Pretty, NumberedArgs)
undoTip :: Pretty ColorText
showListEdits :: Patch -> PrettyPrintEnv -> (Pretty ColorText, NumberedArgs)
prettyURI :: URI -> Pretty
prettyReadRemoteNamespace :: ReadRemoteNamespace RemoteProjectBranch -> Pretty
prettyReadRemoteNamespaceWith :: (a -> Text) -> ReadRemoteNamespace a -> Pretty
prettyWriteRemoteNamespace :: WriteRemoteNamespace (ProjectAndBranch ProjectName ProjectBranchName) -> Pretty
notifyUser :: FilePath -> Output -> IO Pretty
expectedEmptyPushDest :: WriteRemoteNamespace Void -> Pretty
expectedNonEmptyPushDest :: WriteRemoteNamespace Void -> Pretty
prettyShareError :: ShareError -> Pretty
prettyCheckAndSetPushError :: CheckAndSetPushError -> Pretty
prettyDownloadEntitiesError :: DownloadEntitiesError -> Pretty
prettyFastForwardPathError :: Path -> FastForwardPathError -> Pretty
prettyFastForwardPushError :: FastForwardPushError -> Pretty
prettyGetCausalHashByPathError :: GetCausalHashByPathError -> Pretty
prettyPullError :: PullError -> Pretty
prettyUpdatePathError :: RepoInfo -> UpdatePathError -> Pretty
prettyUploadEntitiesError :: UploadEntitiesError -> Pretty
prettyTransportError :: CodeserverTransportError -> Pretty
invalidRepoInfo :: Text -> RepoInfo -> Pretty
pushPublicNote :: InputPattern -> Text -> [Text] -> Pretty
needDependencies :: NeedDependencies Hash32 -> Pretty
noReadPermissionForPath :: Path -> Pretty
noReadPermissionForRepo :: RepoInfo -> Pretty
noWritePermissionForPath :: Path -> Pretty
noWritePermissionForRepo :: RepoInfo -> Pretty
notFastForward :: Path -> Pretty
shareProjectNotFound :: Text -> Pretty
shareUserNotFound :: RepoInfo -> Pretty
sharePathToWriteRemotePathShare :: Path -> WriteRemoteNamespace void
shareOrigin :: Text
prettyRepoInfo :: RepoInfo -> Pretty
prettyShareLink :: WriteShareRemoteNamespace -> Pretty
prettySharePath :: Path -> Pretty
prettyFilePath :: FilePath -> Pretty
prettyPath' :: Path' -> Pretty
prettyPullTarget :: PullTarget (ProjectAndBranch Project ProjectBranch) -> Pretty
prettyBranchId :: AbsBranchId -> Pretty
prettyRelative :: Relative -> Pretty
prettyAbsolute :: Absolute -> Pretty
prettySCH :: IsString s => ShortCausalHash -> Pretty s
prettyCausalHash :: IsString s => CausalHash -> Pretty s
prettyBase32Hex :: IsString s => Base32Hex -> Pretty s
prettyBase32Hex# :: IsString s => Base32Hex -> Pretty s
prettyHash :: IsString s => Hash -> Pretty s
prettyHash32 :: IsString s => Hash32 -> Pretty s
prettyProjectName :: ProjectName -> Pretty
prettyProjectBranchName :: ProjectBranchName -> Pretty
prettyProjectAndBranchName :: ProjectAndBranch ProjectName ProjectBranchName -> Pretty
formatMissingStuff :: (Show tm, Show typ) => [(HashQualified Name, tm)] -> [(HashQualified Name, typ)] -> Pretty
displayDefinitions' :: Var v => Ord a1 => PrettyPrintEnvDecl -> Map Reference (DisplayObject () (Decl v a1)) -> Map Reference (DisplayObject (Type v a1) (Term v a1)) -> Pretty
displayRendered :: Maybe FilePath -> Pretty -> IO Pretty
displayDefinitions :: DisplayDefinitionsOutput -> IO Pretty
displayTestResults :: Bool -> PrettyPrintEnv -> [(Reference, Text)] -> [(Reference, Text)] -> Pretty
unsafePrettyTermResultSig' :: Var v => PrettyPrintEnv -> TermResult' v a -> Pretty
unsafePrettyTermResultSigFull' :: Var v => PrettyPrintEnv -> TermResult' v a -> Pretty
prettyTypeResultHeader' :: Var v => TypeResult' v a -> Pretty
prettyTypeResultHeaderFull' :: Var v => TypeResult' v a -> Pretty
prettyDeclTriple :: Var v => (HashQualified Name, Reference, DisplayObject () (Decl v a)) -> Pretty
prettyDeclPair :: Var v => PrettyPrintEnv -> (Reference, DisplayObject () (Decl v a)) -> Pretty
renderNameConflicts :: PrettyPrintEnv -> Names -> Numbered Pretty
renderEditConflicts :: PrettyPrintEnv -> Patch -> Numbered Pretty
type Numbered = State (Int, Seq String)
addNumberedArg :: String -> Numbered Int
formatNum :: Int -> Pretty
runNumbered :: Numbered a -> (a, NumberedArgs)
todoOutput :: Var v => PrettyPrintEnvDecl -> TodoOutput v a -> (Pretty, NumberedArgs)
listOfDefinitions :: Var v => FindScope -> PrettyPrintEnv -> ListDetailed -> [SearchResult' v a] -> IO Pretty
listOfLinks :: Var v => PrettyPrintEnv -> [(HashQualified Name, Maybe (Type v a))] -> IO Pretty
data ShowNumbers
ShowNumbers :: ShowNumbers
HideNumbers :: ShowNumbers

-- | <tt>ppe</tt> is just for rendering type signatures `oldPath, newPath
--   :: Path.Absolute` are just for producing fully-qualified numbered args
showDiffNamespace :: forall v. Var v => ShowNumbers -> PrettyPrintEnv -> AbsBranchId -> AbsBranchId -> BranchDiffOutput v Ann -> (Pretty, NumberedArgs)
noResults :: FindScope -> Pretty
listOfDefinitions' :: Var v => FindScope -> PrettyPrintEnv -> ListDetailed -> [SearchResult' v a] -> Pretty
watchPrinter :: Var v => Text -> PrettyPrintEnv -> Ann -> WatchKind -> Term v () -> IsCacheHit -> Pretty
filestatusTip :: Pretty
prettyDiff :: Diff -> Pretty
prettyTermName :: PrettyPrintEnv -> Referent -> Pretty
prettyTypeName :: PrettyPrintEnv -> Reference -> Pretty
prettyReadGitRepo :: ReadGitRepo -> Pretty
prettyWriteGitRepo :: WriteGitRepo -> Pretty

-- | Pretty-print a <a>WhichBranchEmpty</a>.
prettyWhichBranchEmpty :: WhichBranchEmpty -> Pretty
isTestOk :: Term v Ann -> Bool

-- | Get the list of numbered args corresponding to an endangerment map,
--   which is used by a few outputs. See <a>endangeredDependentsTable</a>.
numberedArgsForEndangerments :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedArgs

-- | Format and render all dependents which are endangered by references
--   going extinct.
endangeredDependentsTable :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> Pretty ColorText

-- | Displays a full, non-truncated Branch.CausalHash to a string, e.g.
--   #abcdef
displayBranchHash :: CausalHash -> String
prettyHumanReadableTime :: UTCTime -> UTCTime -> Pretty

module Unison.CommandLine.DisplayValues
type Pretty = Pretty ColorText
displayTerm :: Monad m => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
type ElideUnit = Bool
displayTerm' :: Monad m => ElideUnit -> PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
displayPretty :: forall m. Monad m => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
displayDoc :: forall v m. (Var v, Monad m) => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term v ()))) -> (Referent -> m (Maybe (Type v ()))) -> (Term v () -> m (Maybe (Term v ()))) -> (Reference -> m (Maybe (Decl v ()))) -> Term v () -> m Pretty
termName :: PrettyPrintEnv -> Referent -> Pretty
typeName :: PrettyPrintEnv -> Reference -> Pretty


-- | <tt>projects</tt> input handler
module Unison.Codebase.Editor.HandleInput.Projects
handleProjects :: Cli ()

module Unison.Codebase.Editor.HandleInput.AuthLogin

-- | Direct the user through an authentication flow with the given server
--   and store the credentials in the provided credential manager.
authLogin :: CodeserverURI -> Cli UserInfo

-- | Checks if the user has valid auth for the given codeserver, and runs
--   through an authentication flow if not.
ensureAuthenticatedWithCodeserver :: CodeserverURI -> Cli UserInfo

module Unison.Cli.TypeCheck
typecheck :: [Type Symbol Ann] -> NamesWithHistory -> Text -> (Text, [Token Lexeme]) -> Cli (Result (Seq (Note Symbol Ann)) (Either (UnisonFile Symbol Ann) (TypecheckedUnisonFile Symbol Ann)))
typecheckHelper :: MonadIO m => Codebase IO Symbol Ann -> IO UniqueName -> [Type Symbol Ann] -> NamesWithHistory -> Text -> (Text, [Token Lexeme]) -> m (Result (Seq (Note Symbol Ann)) (Either (UnisonFile Symbol Ann) (TypecheckedUnisonFile Symbol Ann)))
typecheckFile :: Codebase m Symbol Ann -> [Type Symbol Ann] -> UnisonFile Symbol Ann -> Transaction (Result (Seq (Note Symbol Ann)) (Either Names (TypecheckedUnisonFile Symbol Ann)))
typecheckTerm :: Term Symbol Ann -> Cli (Result (Seq (Note Symbol Ann)) (Type Symbol Ann))

module Unison.LSP.FileAnalysis

-- | Lex, parse, and typecheck a file.
checkFile :: HasUri d Uri => d -> Lsp (Maybe FileAnalysis)

-- | If a symbol is a <tt>User</tt> symbol, return (Just sym), otherwise
--   return Nothing.
assertUserSym :: Symbol -> Maybe Symbol

-- | Summarize the information available to us from the current state of
--   the file. See <a>FileSummary</a> for more information.
mkFileSummary :: Maybe (UnisonFile Symbol Ann) -> Maybe (TypecheckedUnisonFile Symbol Ann) -> Maybe FileSummary
fileAnalysisWorker :: Lsp ()
analyseFile :: Foldable f => Uri -> Text -> f (Note Symbol Ann) -> Lsp ([Diagnostic], [RangedCodeAction])
getTokenMap :: [Token Lexeme] -> IntervalMap Position Lexeme
analyseNotes :: Foldable f => Uri -> PrettyPrintEnv -> String -> f (Note Symbol Ann) -> Lsp ([Diagnostic], [RangedCodeAction])
toRangeMap :: Foldable f => f (Range, a) -> IntervalMap Position [a]
getFileAnalysis :: Uri -> Lsp (Maybe FileAnalysis)
getFileSummary :: Uri -> MaybeT Lsp FileSummary
ppedForFile :: Uri -> Lsp PrettyPrintEnvDecl
ppedForFileHelper :: Maybe (UnisonFile Symbol a) -> Maybe (TypecheckedUnisonFile Symbol a) -> Lsp PrettyPrintEnvDecl


-- | Rewrites of some codebase queries, but which check the scratch file
--   for info first.
module Unison.LSP.Queries

-- | Renders all docs for a given FQN to markdown.
markdownDocsForFQN :: Uri -> HashQualified Name -> Lsp [Text]

-- | Gets the type of a reference from either the parsed file or the
--   codebase.
getTypeOfReferent :: Uri -> Referent -> MaybeT Lsp (Type Symbol Ann)

-- | Gets a decl from either the parsed file or the codebase.
getTypeDeclaration :: Uri -> Id -> MaybeT Lsp (Decl Symbol Ann)

-- | Returns a reference to whatever the symbol at the given position
--   refers to.
refAtPosition :: Uri -> Position -> MaybeT Lsp LabeledDependency

-- | Returns the ABT node at the provided position. Does not return Decl
--   nodes.
nodeAtPosition :: Uri -> Position -> MaybeT Lsp (SourceNode Ann)

-- | Returns the reference a given term node refers to, if any.
refInTerm :: Term v a -> Maybe LabeledDependency
refInType :: Type v a -> Maybe TypeReference

-- | Find the the node in a term which contains the specified position, but
--   none of its children contain that position.
findSmallestEnclosingNode :: Pos -> Term Symbol Ann -> Maybe (SourceNode Ann)

-- | Find the the node in a type which contains the specified position, but
--   none of its children contain that position. This is helpful for
--   finding the specific type reference of a given argument within a type
--   arrow that a position references.
findSmallestEnclosingType :: Pos -> Type Symbol Ann -> Maybe (Type Symbol Ann)

-- | Returns the type reference the given position applies to within a
--   Decl, if any.
--   
--   I.e. if the cursor is over a type reference within a constructor
--   signature or ability request signature, that type reference will be
--   returned.
refInDecl :: Pos -> Decl Symbol Ann -> Maybe TypeReference
data SourceNode a
TermNode :: Term Symbol a -> SourceNode a
TypeNode :: Type Symbol a -> SourceNode a
PatternNode :: Pattern a -> SourceNode a
instance GHC.Show.Show (Unison.LSP.Queries.SourceNode a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.LSP.Queries.SourceNode a)
instance GHC.Base.Functor Unison.LSP.Queries.SourceNode

module Unison.LSP.Hover

-- | Hover help handler
--   
--   TODO: * Add docs * Resolve fqn on hover
hoverHandler :: RequestMessage 'TextDocumentHover -> (Either ResponseError (ResponseResult 'TextDocumentHover) -> Lsp ()) -> Lsp ()
hoverInfo :: Uri -> Position -> MaybeT Lsp Text

-- | Get the type for term literals.
builtinTypeForTermLiterals :: Term Symbol Ann -> Maybe Text
builtinTypeForPatternLiterals :: Pattern Ann -> Maybe Text

module Unison.LSP.FoldingRange
foldingRangeRequest :: RequestMessage 'TextDocumentFoldingRange -> (Either ResponseError (ResponseResult 'TextDocumentFoldingRange) -> Lsp ()) -> Lsp ()

-- | Return a folding range for each top-level definition
foldingRangesForFile :: Uri -> Lsp [FoldingRange]

module Unison.LSP.Completion
completionHandler :: RequestMessage 'TextDocumentCompletion -> (Either ResponseError (ResponseResult 'TextDocumentCompletion) -> Lsp ()) -> Lsp ()
mkDefCompletionItem :: Uri -> Range -> Name -> Name -> Text -> Text -> LabeledDependency -> CompletionItem

-- | Generate a completion tree from a set of names. A completion tree is a
--   suffix tree over the path segments of each name it contains. The goal
--   is to allow fast completion of names by any partial path suffix.
--   
--   The tree is generated by building a trie where all possible suffixes
--   of a name are reachable from the root of the trie, with sharing over
--   subtrees to improve memory residency.
--   
--   Currently we don't "summarize" all of the children of a node in the
--   node itself, and instead you have to crawl all the children to get the
--   actual completions.
--   
--   TODO: Would it be worthwhile to perform compression or include child
--   summaries on the suffix tree? I suspect most namespace trees won't
--   actually compress very well since each node is likely to have
--   terms/types at it.
--   
--   E.g. From the names: * alpha.beta.Nat * alpha.Text * foxtrot.Text
--   
--   It will generate a tree like the following, where each bullet is a
--   possible completion:
--   
--   . ├── foxtrot │ └── Text │ └── * foxtrot.Text (##Text) ├── beta │ └──
--   Nat │ └── * alpha.beta.Nat (##Nat) ├── alpha │ ├── beta │ │ └── Nat │
--   │ └── * alpha.beta.Nat (##Nat) │ └── Text │ └── * alpha.Text (##Text)
--   ├── Text │ ├── * foxtrot.Text (##Text) │ └── * alpha.Text (##Text) └──
--   Nat └── * alpha.beta.Nat (##Nat)
namesToCompletionTree :: Names -> CompletionTree
nameToCompletionTree :: Name -> LabeledDependency -> CompletionTree

-- | Crawl the completion tree and return all valid prefix-based
--   completions alongside their Path from the provided prefix, and their
--   full name.
--   
--   E.g. if the term "alpha.beta.gamma.map (#abc)" exists in the
--   completion map, and the query is "beta" the result would be:
--   
--   @<tt> [(["beta", "gamma", "map"], "alpha.beta.gamma.map", TermReferent
--   #abc)] </tt>@
matchCompletions :: CompletionTree -> Text -> [(Path, Name, LabeledDependency)]

-- | Called to resolve additional details for a completion item that the
--   user is considering.
completionItemResolveHandler :: RequestMessage 'CompletionItemResolve -> (Either ResponseError CompletionItem -> Lsp ()) -> Lsp ()

-- | Data which will be provided back to us in the completion resolve
--   handler when the user considers this completion.
data CompletionItemDetails
CompletionItemDetails :: LabeledDependency -> Name -> Name -> Uri -> CompletionItemDetails
[$sel:dep:CompletionItemDetails] :: CompletionItemDetails -> LabeledDependency
[$sel:relativeName:CompletionItemDetails] :: CompletionItemDetails -> Name
[$sel:fullyQualifiedName:CompletionItemDetails] :: CompletionItemDetails -> Name
[$sel:fileUri:CompletionItemDetails] :: CompletionItemDetails -> Uri
instance Data.Aeson.Types.ToJSON.ToJSON Unison.LSP.Completion.CompletionItemDetails
instance Data.Aeson.Types.FromJSON.FromJSON Unison.LSP.Completion.CompletionItemDetails

module Unison.LSP.UCMWorker

-- | Watches for state changes in UCM and updates cached LSP state
--   accordingly
ucmWorker :: TVar PrettyPrintEnvDecl -> TVar NamesWithHistory -> TVar (NameSearch Transaction) -> STM (Branch IO) -> STM Absolute -> Lsp ()

module Unison.LSP.CodeAction

-- | Computes code actions for a document.
codeActionHandler :: RequestMessage 'TextDocumentCodeAction -> (Either ResponseError (ResponseResult 'TextDocumentCodeAction) -> Lsp ()) -> Lsp ()

module Unison.LSP
getLspPort :: IO String

-- | Spawn an LSP server on the configured port.
spawnLsp :: Codebase IO Symbol Ann -> Runtime Symbol -> STM (Branch IO) -> STM Absolute -> IO ()
serverDefinition :: MVar VFS -> Codebase IO Symbol Ann -> Runtime Symbol -> Scope -> STM (Branch IO) -> STM Absolute -> ServerDefinition Config

-- | Initialize any context needed by the LSP server
lspDoInitialize :: MVar VFS -> Codebase IO Symbol Ann -> Runtime Symbol -> Scope -> STM (Branch IO) -> STM Absolute -> LanguageContextEnv Config -> Message 'Initialize -> IO (Either ResponseError Env)

-- | LSP request handlers that don't register/unregister dynamically
lspStaticHandlers :: Handlers Lsp

-- | LSP request handlers
lspRequestHandlers :: SMethodMap (ClientMessageHandler Lsp 'Request)

-- | LSP notification handlers
lspNotificationHandlers :: SMethodMap (ClientMessageHandler Lsp 'Notification)

-- | A natural transformation into IO, required by the LSP lib.
lspInterpretHandler :: Env -> Lsp <~> IO
lspOptions :: Options


-- | This module contains Share API calls related to projects, wrapped in
--   the Cli monad.
--   
--   Here, we also validate inputs from Share that the API itself does not.
--   For example, in the API, a project name is just a Text. But because
--   our client requires a richer structure for project names, we try
--   parsing them into a ProjectName, and fail right away if parsing fails.
module Unison.Cli.Share.Projects

-- | A remote project.
data RemoteProject
RemoteProject :: RemoteProjectId -> ProjectName -> RemoteProject
[$sel:projectId:RemoteProject] :: RemoteProject -> RemoteProjectId
[$sel:projectName:RemoteProject] :: RemoteProject -> ProjectName

-- | A remote project branch.
data RemoteProjectBranch
RemoteProjectBranch :: RemoteProjectId -> ProjectName -> RemoteProjectBranchId -> ProjectBranchName -> HashJWT -> RemoteProjectBranch
[$sel:projectId:RemoteProjectBranch] :: RemoteProjectBranch -> RemoteProjectId
[$sel:projectName:RemoteProjectBranch] :: RemoteProjectBranch -> ProjectName
[$sel:branchId:RemoteProjectBranch] :: RemoteProjectBranch -> RemoteProjectBranchId
[$sel:branchName:RemoteProjectBranch] :: RemoteProjectBranch -> ProjectBranchName
[$sel:branchHead:RemoteProjectBranch] :: RemoteProjectBranch -> HashJWT

-- | Get a project by id.
--   
--   On success, update the <tt>remote_project</tt> table.
getProjectById :: RemoteProjectId -> Cli (Maybe RemoteProject)

-- | Get a project by name.
--   
--   On success, update the <tt>remote_project</tt> table.
getProjectByName :: ProjectName -> Cli (Maybe RemoteProject)

-- | Create a new project. Kinda weird: returns <a>Nothing</a> if the user
--   handle part of the project doesn't exist.
--   
--   On success, update the <tt>remote_project</tt> table.
createProject :: ProjectName -> Cli (Maybe RemoteProject)
data GetProjectBranchResponse
GetProjectBranchResponseBranchNotFound :: GetProjectBranchResponse
GetProjectBranchResponseProjectNotFound :: GetProjectBranchResponse
GetProjectBranchResponseSuccess :: !RemoteProjectBranch -> GetProjectBranchResponse

-- | Get a project branch by id.
--   
--   On success, update the <tt>remote_project_branch</tt> table.
getProjectBranchById :: ProjectAndBranch RemoteProjectId RemoteProjectBranchId -> Cli GetProjectBranchResponse

-- | Get a project branch by name.
--   
--   On success, update the <tt>remote_project_branch</tt> table.
getProjectBranchByName :: ProjectAndBranch RemoteProjectId ProjectBranchName -> Cli GetProjectBranchResponse

-- | Create a new project branch.
--   
--   On success, update the <tt>remote_project_branch</tt> table.
createProjectBranch :: CreateProjectBranchRequest -> Cli (Maybe RemoteProjectBranch)
data SetProjectBranchHeadResponse
SetProjectBranchHeadResponseNotFound :: SetProjectBranchHeadResponse

-- | (expected, actual)
SetProjectBranchHeadResponseExpectedCausalHashMismatch :: !Hash32 -> !Hash32 -> SetProjectBranchHeadResponse
SetProjectBranchHeadResponseSuccess :: SetProjectBranchHeadResponse

-- | Set a project branch head (can be a fast-forward or force-push).
setProjectBranchHead :: SetProjectBranchHeadRequest -> Cli SetProjectBranchHeadResponse
hardCodedBaseUrl :: BaseUrl
hardCodedUri :: URI
instance GHC.Generics.Generic Unison.Cli.Share.Projects.SetProjectBranchHeadResponse
instance GHC.Show.Show Unison.Cli.Share.Projects.SetProjectBranchHeadResponse
instance GHC.Classes.Eq Unison.Cli.Share.Projects.SetProjectBranchHeadResponse


-- | This module contains miscellaneous helper utils for rote actions in
--   the Cli monad, like resolving a relative path to an absolute path, per
--   the current path.
module Unison.Cli.MonadUtils

-- | Lookup a config value by key.
getConfig :: Configured a => Text -> Cli (Maybe a)

-- | Get the current path.
getCurrentPath :: Cli Absolute

-- | Resolve a <tt>Path'</tt> to a <tt>Path.Absolute</tt>, per the current
--   path.
resolvePath' :: Path' -> Cli Absolute

-- | Resolve a path split, per the current path.
resolveSplit' :: (Path', a) -> Cli (Absolute, a)

-- | Resolve an <tt>AbsBranchId</tt> to the corresponding <tt>Branch
--   IO</tt>, or fail if no such branch hash is found. (Non-existent
--   branches by path are OK - the empty branch will be returned).
resolveAbsBranchId :: AbsBranchId -> Cli (Branch IO)

-- | V2 version of <tt>resolveAbsBranchId2</tt>.
resolveAbsBranchIdV2 :: AbsBranchId -> Transaction (Either Output (Branch Transaction))

-- | Resolve a <tt>BranchId</tt> to the corresponding <tt>Branch IO</tt>,
--   or fail if no such branch hash is found. (Non-existent branches by
--   path are OK - the empty branch will be returned).
resolveBranchId :: BranchId -> Cli (Branch IO)

-- | Resolve a <tt>BranchId</tt> to an <tt>AbsBranchId</tt>.
resolveBranchIdToAbsBranchId :: BranchId -> Cli AbsBranchId

-- | Resolve a <tt>ShortCausalHash</tt> to the corresponding <tt>Branch
--   IO</tt>, or fail if no such branch hash is found.
resolveShortCausalHash :: ShortCausalHash -> Cli (Branch IO)

-- | Get the root branch.
getRootBranch :: Cli (Branch IO)

-- | Set a new root branch.
--   
--   Note: This does _not_ update the codebase, the caller is responsible
--   for that.
setRootBranch :: Branch IO -> Cli ()

-- | Modify the root branch.
--   
--   Note: This does _not_ update the codebase, the caller is responsible
--   for that.
modifyRootBranch :: (Branch IO -> Branch IO) -> Cli (Branch IO)

-- | Get the root branch0.
getRootBranch0 :: Cli (Branch0 IO)

-- | Get the current branch.
getCurrentBranch :: Cli (Branch IO)

-- | Get the current branch0.
getCurrentBranch0 :: Cli (Branch0 IO)

-- | Get the branch at an absolute path.
getBranchAt :: Absolute -> Cli (Branch IO)

-- | Get the branch0 at an absolute path.
getBranch0At :: Absolute -> Cli (Branch0 IO)

-- | Get the last saved root hash.
getLastSavedRootHash :: Cli CausalHash

-- | Set a new root branch. Note: This does _not_ update the codebase, the
--   caller is responsible for that.
setLastSavedRootHash :: CausalHash -> Cli ()

-- | Get the maybe-branch at an absolute path.
getMaybeBranchAt :: Absolute -> Cli (Maybe (Branch IO))

-- | Get the branch at an absolute or relative path, or return early if
--   there's no such branch.
expectBranchAtPath' :: Path' -> Cli (Branch IO)

-- | Assert that there's "no branch" at an absolute or relative path, or
--   return early if there is one, where "no branch" means either there's
--   actually no branch, or there is a branch whose head is empty (i.e. it
--   may have a history, but no current terms/types etc).
assertNoBranchAtPath' :: Path' -> Cli ()

-- | Check if there's a branch at an absolute or relative path
--   
--   "no branch" means either there's actually no branch, or there is a
--   branch whose head is empty (i.e. it may have a history, but no current
--   terms/types etc).
branchExistsAtPath' :: Path' -> Cli Bool
stepAt' :: Text -> (Path, Branch0 IO -> Cli (Branch0 IO)) -> Cli Bool
stepAt :: Text -> (Path, Branch0 IO -> Branch0 IO) -> Cli ()
stepAtM :: Text -> (Path, Branch0 IO -> IO (Branch0 IO)) -> Cli ()
stepAtNoSync' :: (Path, Branch0 IO -> Cli (Branch0 IO)) -> Cli Bool
stepAtNoSync :: (Path, Branch0 IO -> Branch0 IO) -> Cli ()
stepManyAt :: Foldable f => Text -> f (Path, Branch0 IO -> Branch0 IO) -> Cli ()
stepManyAtMNoSync :: Foldable f => f (Path, Branch0 IO -> IO (Branch0 IO)) -> Cli ()
stepManyAtNoSync :: Foldable f => f (Path, Branch0 IO -> Branch0 IO) -> Cli ()

-- | Sync the in-memory root branch.
syncRoot :: Text -> Cli ()
updateRoot :: Branch IO -> Text -> Cli ()

-- | Update a branch at the given path, returning <a>True</a> if an update
--   occurred and false otherwise
updateAtM :: Text -> Absolute -> (Branch IO -> Cli (Branch IO)) -> Cli Bool

-- | Update a branch at the given path, returning <a>True</a> if an update
--   occurred and false otherwise
updateAt :: Text -> Absolute -> (Branch IO -> Branch IO) -> Cli Bool
getTermsAt :: (Absolute, HQSegment) -> Cli (Set Referent)
getTypesAt :: (Absolute, HQSegment) -> Cli (Set TypeReference)
defaultPatchNameSegment :: NameSegment

-- | The default patch path.
defaultPatchPath :: Split'

-- | Get the patch at a path, or the empty patch if there's no such patch.
getPatchAt :: Split' -> Cli Patch

-- | Get the patch at a path.
getMaybePatchAt :: Split' -> Cli (Maybe Patch)

-- | Get the patch at a path, or return early if there's no such patch.
expectPatchAt :: Split' -> Cli Patch

-- | Assert that there's no patch at a path, or return early if there is
--   one.
assertNoPatchAt :: Split' -> Cli ()
getLatestFile :: Cli (Maybe (FilePath, Bool))
expectLatestFile :: Cli (FilePath, Bool)

-- | Get the latest typechecked unison file.
getLatestTypecheckedFile :: Cli (Maybe (TypecheckedUnisonFile Symbol Ann))

-- | Get the latest typechecked unison file, or return early if there isn't
--   one.
expectLatestTypecheckedFile :: Cli (TypecheckedUnisonFile Symbol Ann)

module Unison.Codebase.Editor.Propagate
propagateAndApply :: Patch -> Branch0 IO -> Cli (Branch0 IO)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.Propagate.Edits v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Codebase.Editor.Propagate.Edits v)

module Unison.Codebase.Editor.HandleInput.MoveBranch

-- | Moves a branch and its history from one location to another, and saves
--   the new root branch.
doMoveBranch :: Text -> Bool -> Path' -> Path' -> Cli ()


-- | <tt>.unisonConfig</tt> file utilities
module Unison.Cli.UnisonConfigUtils
defaultMetadataKey :: Absolute -> Text
gitUrlKey :: Absolute -> Text
remoteMappingKey :: Absolute -> Text
resolveConfiguredUrl :: PushPull -> Path' -> Cli (WriteRemoteNamespace Void)


-- | Project-related utilities.
module Unison.Cli.ProjectUtils

-- | Get the current project that a user is on.
getCurrentProject :: Cli (Maybe Project)

-- | Like <a>getCurrentProject</a>, but fails with a message if the user is
--   not on a project branch.
expectCurrentProject :: Cli Project

-- | Get the current project+branch that a user is on.
--   
--   Note that if a user has (somehow) cd'd into a namespace *within* a
--   branch, this function will return Nothing; that is, it only returns
--   Just if the user's current namespace is the root of a branch, and no
--   deeper.
--   
--   This should be fine: we don't want users to be able to cd around
--   willy-nilly within projects (right?...)
getCurrentProjectBranch :: Cli (Maybe (ProjectAndBranch Project ProjectBranch))

-- | Like <a>getCurrentProjectBranch</a>, but fails with a message if the
--   user is not on a project branch.
expectCurrentProjectBranch :: Cli (ProjectAndBranch Project ProjectBranch)

-- | Get the path that a project is stored at. Users aren't supposed to go
--   here.
--   
--   <pre>
--   &gt;&gt;&gt; projectPath "ABCD"
--   .__projects._ABCD
--   </pre>
projectPath :: ProjectId -> Absolute

-- | Get the path that a branch is stored at. Users aren't supposed to go
--   here.
--   
--   <pre>
--   &gt;&gt;&gt; projectBranchPath ProjectAndBranch { project = "ABCD", branch = "DEFG" }
--   .__projects._ABCD.branches._DEFG
--   </pre>
projectBranchPath :: ProjectAndBranch ProjectId ProjectBranchId -> Absolute

-- | The prism between paths like
--   
--   <pre>
--   .__projects._XX_XX.branches._YY_YY
--   </pre>
--   
--   and the <tt>(project id, branch id)</tt> pair
--   
--   <pre>
--   (XX-XX, YY-YY)
--   </pre>
projectBranchPathPrism :: Prism' Absolute (ProjectAndBranch ProjectId ProjectBranchId)
hydrateNames :: These ProjectName ProjectBranchName -> Cli (ProjectAndBranch ProjectName ProjectBranchName)
expectProjectAndBranchByIds :: ProjectAndBranch ProjectId ProjectBranchId -> Transaction (ProjectAndBranch Project ProjectBranch)
expectProjectAndBranchByTheseNames :: These ProjectName ProjectBranchName -> Cli (ProjectAndBranch Project ProjectBranch)
expectRemoteProjectByName :: ProjectName -> Cli RemoteProject
expectRemoteProjectBranchById :: ProjectAndBranch (RemoteProjectId, ProjectName) (RemoteProjectBranchId, ProjectBranchName) -> Cli RemoteProjectBranch
expectRemoteProjectBranchByName :: ProjectAndBranch (RemoteProjectId, ProjectName) ProjectBranchName -> Cli RemoteProjectBranch
expectRemoteProjectBranchByTheseNames :: These ProjectName ProjectBranchName -> Cli RemoteProjectBranch


-- | <tt>push</tt> input handler
module Unison.Codebase.Editor.HandleInput.Push

-- | Handle a <tt>gist</tt> command.
handleGist :: GistInput -> Cli ()

-- | Handle a <tt>push</tt> command.
handlePushRemoteBranch :: PushRemoteBranchInput -> Cli ()


-- | <tt>project.switch</tt> input handler
module Unison.Codebase.Editor.HandleInput.ProjectSwitch

-- | Switch to (or create) a project or project branch.
projectSwitch :: These ProjectName ProjectBranchName -> Cli ()


-- | <tt>project.create</tt> input handler
module Unison.Codebase.Editor.HandleInput.ProjectCreate

-- | Create a new project.
--   
--   <ol>
--   <li>If a project already exists with the given name, bail.</li>
--   <li>Otherwise, create a scaffold out a new project with a "main"
--   branch, and add it to the namespace (at a magic location that the user
--   isn't supposed to look at).</li>
--   </ol>
--   
--   Big danger: we first commit the project identity and metadata (like
--   its name) to the codebase, then manipulate our in-memory namespace and
--   flush its contents out in a separate transaction. This means that if
--   lightning strikes at the wrong time, we'll be in an inconsistent
--   state.
--   
--   This could be fixed in a few different ways:
--   
--   <ol>
--   <li>Make a better <tt>stepAt</tt> helper that can mutate the namespace
--   in a transaction.</li>
--   <li>Add more code to detect the inconsistency and work around it. For
--   example, if we ever see that a project id exists in the codebase but
--   not at its corresponding place in the namespace, we could consider it
--   garbage and delete it. Then, any user who tried to create a project
--   called "foo" shortly before getting hit by lightning could simply try
--   creating "foo" again later.</li>
--   <li>Don't store projects in the root namespace at all. We don't even
--   want them there, it's just a little too convenient because *not*
--   storing them in the root namespace would require a lot of reworking
--   and rewriting. We'd rather hit some shorter-term project milestones
--   and clean our mess up Later (TM).</li>
--   </ol>
--   
--   For now, it doesn't seem worth it to do (1) or (2), since we want to
--   do (3) eventually, and we'd rather not waste too much time getting
--   everything perfectly correct before we get there.
projectCreate :: ProjectName -> Cli ()


-- | <tt>branches</tt> input handler
module Unison.Codebase.Editor.HandleInput.Branches
handleBranches :: Cli ()


-- | Utilities that have to do with constructing pretty-print environments,
--   given stateful information in the Cli monad state/environment, such as
--   the current path.
module Unison.Cli.PrettyPrintUtils
prettyPrintEnvDecl :: NamesWithHistory -> Cli PrettyPrintEnvDecl

-- | Get a pretty print env decl for the current names at the current path.
currentPrettyPrintEnvDecl :: (Path -> NameScoping) -> Cli PrettyPrintEnvDecl


-- | Helpers/utils that have to do with namespace diffs.
module Unison.Codebase.Editor.HandleInput.NamespaceDiffUtils
diffHelper :: Branch0 IO -> Branch0 IO -> Cli (PrettyPrintEnv, BranchDiffOutput Symbol Ann)


-- | <tt>pull</tt> input handler
module Unison.Codebase.Editor.HandleInput.Pull
doPullRemoteBranch :: PullSourceTarget -> SyncMode -> PullMode -> Verbosity -> Text -> Cli ()
loadShareLooseCodeIntoMemory :: ReadShareLooseCode -> Cli (Branch IO)
loadPropagateDiffDefaultPatch :: Text -> Maybe Path' -> Absolute -> Cli ()

-- | supply <tt>dest0</tt> if you want to print diff messages supply
--   unchangedMessage if you want to display it if merge had no effect
mergeBranchAndPropagateDefaultPatch :: MergeMode -> Text -> Maybe Output -> Branch IO -> Maybe Path' -> Absolute -> Cli ()
propagatePatch :: Text -> Patch -> Absolute -> Cli Bool
withEntitiesDownloadedProgressCallback :: ((Int -> IO (), IO Int) -> IO a) -> IO a


-- | <tt>project.clone</tt> input handler
module Unison.Codebase.Editor.HandleInput.ProjectClone

-- | Clone a remote project or remote project branch.
projectClone :: These ProjectName ProjectBranchName -> Cli ()


-- | Helpers<i>utils that have to do with term</i>type metadata.
module Unison.Codebase.Editor.HandleInput.MetadataUtils
addDefaultMetadata :: SlurpComponent -> Cli ()

-- | Add/remove links between definitions and metadata. <tt>silent</tt>
--   controls whether this produces any output to the user. <tt>srcs</tt>
--   is (names of the) definitions to pass to <a>op</a> <tt>mdValues</tt>
--   is (names of the) metadata to pass to <a>op</a> <a>op</a> is the
--   operation to add<i>remove</i>alter metadata mappings. e.g.
--   <a>insert</a> is passed to add metadata links.
manageLinks :: Bool -> [HQSplit'] -> [HashQualified Name] -> (forall r. Ord r => (r, Type, Value) -> Star r NameSegment -> Star r NameSegment) -> Cli ()


-- | Utilities that have to do with constructing names objects.
module Unison.Cli.NamesUtils
basicParseNames :: Cli Names
basicPrettyPrintNamesA :: Cli Names

-- | Produce a <a>Names</a> needed to display all the hashes used in the
--   given file.
displayNames :: Var v => TypecheckedUnisonFile v a -> Cli NamesWithHistory
findHistoricalHQs :: Set (HashQualified Name) -> Cli Names
getBasicPrettyPrintNames :: Cli Names
makeHistoricalParsingNames :: Set (HashQualified Name) -> Cli NamesWithHistory
makePrintNamesFromLabeled' :: Set LabeledDependency -> Cli NamesWithHistory
makeShadowedPrintNamesFromHQ :: Set (HashQualified Name) -> Names -> Cli NamesWithHistory

module Unison.Codebase.Editor.HandleInput.Update

-- | Handle an <tt>update</tt> command.
handleUpdate :: Input -> OptionalPatch -> Set Name -> Cli ()
doSlurpAdds :: forall m. Monad m => SlurpComponent -> TypecheckedUnisonFile Symbol Ann -> Branch0 m -> Branch0 m

module Unison.Codebase.Editor.HandleInput.TermResolution
lookupTermRefs :: HashQualified Name -> Names -> ([Reference], [Referent])
lookupTermRefWithType :: Codebase IO Symbol Ann -> HashQualified Name -> Cli [(Reference, Type Symbol Ann)]
resolveCon :: HashQualified Name -> Cli ConstructorReference
resolveTerm :: HashQualified Name -> Cli Referent
resolveTermRef :: HashQualified Name -> Cli Reference
resolveMainRef :: HashQualified Name -> Cli (Reference, PrettyPrintEnv)

module Unison.Codebase.Editor.HandleInput
loop :: Either Event Input -> Cli ()

module Unison.CommandLine.Main
main :: FilePath -> Welcome -> Absolute -> Config -> [Either Event Input] -> Runtime Symbol -> Runtime Symbol -> Codebase IO Symbol Ann -> Maybe BaseUrl -> UCMVersion -> (Branch IO -> STM ()) -> (Absolute -> STM ()) -> ShouldWatchFiles -> IO ()

module Unison.Codebase.TranscriptParser
data Stanza
Ucm :: Hidden -> ExpectingError -> [UcmLine] -> Stanza
Unison :: Hidden -> ExpectingError -> Maybe ScratchFileName -> Text -> Stanza
API :: [APIRequest] -> Stanza
UnprocessedFence :: FenceType -> Text -> Stanza
Unfenced :: Text -> Stanza
type FenceType = Text
type ExpectingError = Bool
data Hidden
data TranscriptError
TranscriptRunFailure :: Text -> TranscriptError
TranscriptParseError :: Text -> TranscriptError
data UcmLine
UcmCommand :: UcmContext -> Text -> UcmLine
UcmComment :: Text -> UcmLine
withTranscriptRunner :: forall m r. MonadUnliftIO m => UCMVersion -> Maybe FilePath -> (TranscriptRunner -> m r) -> m r
parse :: String -> Text -> Either TranscriptError [Stanza]
parseFile :: FilePath -> IO (Either TranscriptError [Stanza])
instance GHC.Show.Show Unison.Codebase.TranscriptParser.Hidden
instance GHC.Classes.Eq Unison.Codebase.TranscriptParser.Hidden
instance GHC.Exception.Type.Exception Unison.Codebase.TranscriptParser.TranscriptError
instance GHC.Show.Show Unison.Codebase.TranscriptParser.TranscriptError
instance GHC.Show.Show Unison.Codebase.TranscriptParser.Stanza
instance GHC.Show.Show Unison.Codebase.TranscriptParser.APIRequest
instance GHC.Show.Show Unison.Codebase.TranscriptParser.UcmLine
